-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | GraphQL API over Postgres
--   
--   GraphQL API over Postgres
@package graphql-engine
@version 1.0.0


-- | Knot-tying monad transformer for recursive graph building.
--   
--   Some operations, such as building a graph, are inherently
--   self-recursive; consider the following graph:
--   
--   <pre>
--   a -&gt; b
--   b -&gt; a
--   </pre>
--   
--   To construct in Haskell, we might want to use the following type:
--   
--   <pre>
--   data Node = Node
--     { nodeName :: Text
--     , nodeNeighbours :: [Node]
--     }
--   </pre>
--   
--   To construct our trivial graph, we need <tt>a</tt> to know about
--   <tt>b</tt> and <tt>b</tt> to know about <tt>a</tt>: this is fine as
--   long as we can build them both at the same time:
--   
--   <pre>
--   graph = [nodeA, nodeB]
--     where
--       nodeA = Node "a" [nodeB]
--       nodeB = Node "b" [nodeA]
--   </pre>
--   
--   But this falls apart as soon as building the nodes becomes more
--   complicated; for instance, if it becomes monadic. This causes an
--   infinite recursion:
--   
--   <pre>
--   graph = do
--     a &lt;- buildA
--     b &lt;- buildB
--     pure [a,b]
--     where
--       buildA = do
--         b &lt;- buildB
--         pure $ Node "a" [b]
--       buildB = do
--         a &lt;- buildA
--         pure $ Node "b" [a]
--   </pre>
--   
--   The reason why the non-monadic version works is laziness; and there is
--   a way to retrieve this laziness in a monadic context: it's what
--   <a>MonadFix</a> is for. (https:/<i>wiki.haskell.org</i>MonadFix)
--   
--   However, <a>MonadFix</a> is both powerful and unintuitive; the goal of
--   this module is to use its power, but to give it a more restricted
--   interface, to make it easier to use. Using <a>CircularT</a>, the graph
--   above can be built monadically like so:
--   
--   <pre>
--   graph = runCircularT do
--     a &lt;- buildA
--     b &lt;- buildB
--     pure [a,b]
--     where
--       buildA = withCircular "a" do
--         b &lt;- buildB
--         pure $ Node "a" [b]
--       buildB = withCircular "b" do
--         a &lt;- buildA
--         pure $ Node "b" [a]
--   </pre>
--   
--   It allows each part of a recursive process to be given a name (the
--   type of which is of the user's choosing), and it automatically breaks
--   cycles. The only caveat is that we cannot violate temporal causality:
--   if we attempt to make a cache-building decision based on the value
--   obtained from the cache, then no amount of laziness can save us:
--   
--   <pre>
--   broken = runCircularT go
--     where
--       go = withCircular () do
--         x &lt;- go
--         pure $ if odd x then 1 else 0
--   </pre>
--   
--   <a>CircularT</a> is somewhat similar to <tt>TardisT</tt> from
--   <tt>Control.Monad.Tardis</tt> and <tt>SchemaT</tt> from
--   <tt>Hasura.GraphQL.Parser.Monad</tt>, but simpler than both.
module Control.Monad.Circular

-- | CircularT is implemented as a state monad containing a lazy HashMap.
--   
--   We use this state to both determine wether we have already encountered
--   a given key and to track the associated result. We use laziness and
--   MonadFix to tie the knot for us (see <a>withCircular</a>).
--   
--   <ul>
--   <li>type <tt>k</tt> is the type of cache key, to which a given action
--   is associated.</li>
--   <li>type <tt>v</tt> is the values we wish to cache in our
--   process.</li>
--   <li>type <tt>m</tt> is the underlying monad on which this transformer
--   operates.</li>
--   <li>type <tt>a</tt> is the result of the computation</li>
--   </ul>
data CircularT k v (m :: Type -> Type) a

-- | Runs a computation in <a>CircularT</a>.
runCircularT :: (Hashable k, MonadFix m) => CircularT k v m a -> m a

-- | Cache a computation under a given key.
--   
--   For a given key <tt>k</tt>, and a computation in <a>CircularT</a> that
--   yields a value of type <tt>v</tt>, return an action that builds said
--   value <tt>v</tt> but that prevents cycles by looking into and
--   populating a stateful cache.
withCircular :: forall k (m :: Type -> Type) v. (Hashable k, MonadFix m) => k -> CircularT k v m v -> CircularT k v m v
instance GHC.Internal.Base.Monad m => GHC.Internal.Base.Applicative (Control.Monad.Circular.CircularT k v m)
instance GHC.Internal.Base.Functor m => GHC.Internal.Base.Functor (Control.Monad.Circular.CircularT k v m)
instance GHC.Internal.Base.Monad m => GHC.Internal.Base.Monad (Control.Monad.Circular.CircularT k v m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Control.Monad.Circular.CircularT k v m)
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (Control.Monad.Circular.CircularT k v m)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (Control.Monad.Circular.CircularT k v m)
instance Control.Monad.Trans.Class.MonadTrans (Control.Monad.Circular.CircularT k v)
instance Control.Monad.Writer.Class.MonadWriter w m => Control.Monad.Writer.Class.MonadWriter w (Control.Monad.Circular.CircularT k v m)

module Control.Monad.Memoize
class Monad m => MonadMemoize (m :: Type -> Type)

-- | Memoizes a parser constructor function for the extent of a single
--   schema construction process. This is mostly useful for recursive
--   parsers; see Note [Tying the knot] for more details.
--   
--   The generality of the type here allows us to use this with multiple
--   concrete parser types:
--   
--   <pre>
--   <a>memoizeOn</a> :: (<a>MonadMemoize</a> m, MonadParse n) =&gt; <a>Name</a> -&gt; a -&gt; m (Parser n b) -&gt; m (Parser n b)
--   <a>memoizeOn</a> :: (<a>MonadMemoize</a> m, MonadParse n) =&gt; <a>Name</a> -&gt; a -&gt; m (FieldParser n b) -&gt; m (FieldParser n b)
--   </pre>
memoizeOn :: (MonadMemoize m, Ord a, Typeable a, Typeable p) => Name -> a -> m p -> m p

-- | A wrapper around <a>memoizeOn</a> that memoizes a function by using
--   its argument as the key.
memoize :: (MonadMemoize m, Ord a, Typeable a, Typeable p) => Name -> (a -> m p) -> a -> m p
data MemoizeT (m :: Type -> Type) a
runMemoizeT :: Monad m => MemoizeT m a -> m a
instance GHC.Internal.Base.Monad m => GHC.Internal.Base.Applicative (Control.Monad.Memoize.MemoizeT m)
instance GHC.Internal.Base.Functor m => GHC.Internal.Base.Functor (Control.Monad.Memoize.MemoizeT m)
instance Data.GADT.Internal.GCompare Control.Monad.Memoize.MemoizationKey
instance Data.GADT.Internal.GEq Control.Monad.Memoize.MemoizationKey
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Control.Monad.Memoize.MemoizeT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.Memoize.MonadMemoize (Control.Monad.Memoize.MemoizeT m)
instance Control.Monad.Memoize.MonadMemoize m => Control.Monad.Memoize.MonadMemoize (Control.Monad.Trans.Reader.ReaderT a m)
instance GHC.Internal.Base.Monad m => GHC.Internal.Base.Monad (Control.Monad.Memoize.MemoizeT m)
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (Control.Monad.Memoize.MemoizeT m)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (Control.Monad.Memoize.MemoizeT m)
instance Control.Monad.Trans.Class.MonadTrans Control.Monad.Memoize.MemoizeT

module Control.Monad.Stateless
class (MonadBaseControl b m, forall a. () => StatelessProof m a) => MonadStateless (b :: Type -> Type) (m :: Type -> Type) | m -> b
liftWithStateless :: MonadStateless b m => ((forall a. () => m a -> b a) -> b c) -> m c
instance (Control.Monad.Trans.Control.MonadBaseControl b m, forall a. Control.Monad.Stateless.StatelessProof m a) => Control.Monad.Stateless.MonadStateless b m
instance (Control.Monad.Trans.Control.StM m a GHC.Types.~ a) => Control.Monad.Stateless.StatelessProof m a

module Control.Monad.Trans.Extended

-- | Utility newtype that can be used to derive type class instances just
--   using <a>MonadTrans</a>.
--   
--   We often derive some <tt>MonadBlaBla</tt> instance for
--   <tt>ReaderT</tt> by using <a>lift</a> from <a>MonadTrans</a>. Which is
--   fine, but it gets laborious if you do the same for <tt>ExceptT</tt>,
--   <tt>StateT</tt> and <tt>WriterT</tt>, even though the method
--   implementations are exactly the same. <a>TransT</a> allows you to
--   write one <a>MonadTrans</a>-based instance, which can then be used
--   with <tt>DerivingVia</tt> to use that one implementation for all monad
--   transformers that use that same lifting implementation.
newtype TransT (t :: Type -> Type -> Type -> Type) (m :: Type -> Type) a
TransT :: t m a -> TransT (t :: (Type -> Type) -> Type -> Type) (m :: Type -> Type) a
instance GHC.Internal.Base.Applicative (t m) => GHC.Internal.Base.Applicative (Control.Monad.Trans.Extended.TransT t m)
instance GHC.Internal.Base.Functor (t m) => GHC.Internal.Base.Functor (Control.Monad.Trans.Extended.TransT t m)
instance Control.Monad.Morph.MFunctor t => Control.Monad.Morph.MFunctor (Control.Monad.Trans.Extended.TransT t)
instance Control.Monad.Morph.MMonad t => Control.Monad.Morph.MMonad (Control.Monad.Trans.Extended.TransT t)
instance GHC.Internal.Base.Monad (t m) => GHC.Internal.Base.Monad (Control.Monad.Trans.Extended.TransT t m)
instance Control.Monad.Trans.Class.MonadTrans t => Control.Monad.Trans.Class.MonadTrans (Control.Monad.Trans.Extended.TransT t)

module Control.Monad.Trans.Managed

-- | This type is like a transformer version of the <tt>Managed</tt> monad
--   from the <tt>managed</tt> library. It can be used to manage resources
--   by pairing together their allocation with their finalizers.
--   
--   The documentation for the <tt>managed</tt> library is an excellent
--   introduction to the idea here.
--   
--   We could use <a>Codensity</a> directly, but we'd have to define an
--   orphan instance for <a>MonadFix</a>. This also gives us the
--   opportunity to give it a slightly more friendly name.
--   
--   We could also have used <tt>ResourceT</tt>, but that would have
--   involved writing instances for <tt>MonadUnliftIO</tt>. That could
--   still be a good option to consider later, however.
newtype ManagedT (m :: Type -> Type) a
ManagedT :: (forall r. () => (a -> m r) -> m r) -> ManagedT (m :: Type -> Type) a
[runManagedT] :: ManagedT (m :: Type -> Type) a -> forall r. () => (a -> m r) -> m r

-- | Allocate a resource by providing setup and finalizer actions.
allocate :: MonadBaseControl IO m => m a -> (a -> m b) -> ManagedT m a

-- | Allocate a resource but do not return a reference to it.
allocate_ :: MonadBaseControl IO m => m a -> m b -> ManagedT m ()

-- | Run the provided computation by returning its result, and run any
--   finalizers. Watch out: this function might leak finalized resources.
lowerManagedT :: Monad m => ManagedT m a -> m a
hoistManagedTReaderT :: forall (m :: Type -> Type) r a. Monad m => r -> ManagedT (ReaderT r m) a -> ManagedT m a
instance GHC.Internal.Base.Applicative (Control.Monad.Trans.Managed.ManagedT m)
instance GHC.Internal.Base.Functor (Control.Monad.Trans.Managed.ManagedT m)
instance Control.Monad.IO.Class.MonadIO m => GHC.Internal.Control.Monad.Fix.MonadFix (Control.Monad.Trans.Managed.ManagedT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.Managed.ManagedT m)
instance GHC.Internal.Base.Monad (Control.Monad.Trans.Managed.ManagedT m)
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (Control.Monad.Trans.Managed.ManagedT m)
instance Control.Monad.Reader.Class.MonadReader s m => Control.Monad.State.Class.MonadState s (Control.Monad.Trans.Managed.ManagedT m)
instance Control.Monad.Trans.Class.MonadTrans Control.Monad.Trans.Managed.ManagedT


-- | MSSQL Connection Pooling
module Database.MSSQL.Pool

-- | ODBC connection string for MSSQL server
newtype ConnectionString
ConnectionString :: Text -> ConnectionString
[unConnectionString] :: ConnectionString -> Text
data ConnectionOptions
ConnectionOptionsPool :: PoolOptions -> ConnectionOptions
ConnectionOptionsNoPool :: ConnectionOptions

-- | ODBC connection pool
data MSSQLPool
MSSQLPool :: Pool Connection -> MSSQLPool
MSSQLNoPool :: IO Connection -> MSSQLPool
data PoolOptions
PoolOptions :: Int -> Int -> Int -> PoolOptions
[poConnections] :: PoolOptions -> Int
[poStripes] :: PoolOptions -> Int
[poIdleTime] :: PoolOptions -> Int

-- | Initialize an MSSQL pool with given connection configuration
initMSSQLPool :: ConnectionString -> ConnectionOptions -> IO MSSQLPool

-- | Destroy all pool resources
drainMSSQLPool :: MSSQLPool -> IO ()
withMSSQLPool :: MonadBaseControl IO m => MSSQLPool -> (Connection -> m a) -> m (Either ODBCException a)

-- | Resize a pool
resizePool :: MSSQLPool -> Int -> IO ()
getInUseConnections :: MSSQLPool -> IO Int
instance GHC.Classes.Eq Database.MSSQL.Pool.ConnectionOptions
instance GHC.Classes.Eq Database.MSSQL.Pool.ConnectionString
instance GHC.Classes.Eq Database.MSSQL.Pool.PoolOptions
instance Data.Aeson.Types.FromJSON.FromJSON Database.MSSQL.Pool.ConnectionString
instance GHC.Internal.Generics.Generic Database.MSSQL.Pool.ConnectionString
instance Autodocodec.Class.HasCodec Database.MSSQL.Pool.ConnectionString
instance GHC.Internal.Show.Show Database.MSSQL.Pool.ConnectionOptions
instance GHC.Internal.Show.Show Database.MSSQL.Pool.ConnectionString
instance GHC.Internal.Show.Show Database.MSSQL.Pool.PoolOptions
instance Data.Aeson.Types.ToJSON.ToJSON Database.MSSQL.Pool.ConnectionString

module Database.MSSQL.Transaction

-- | The transaction command to run, parameterised over: e - the exception
--   type (usually <a>MSSQLTxError</a>) m - some Monad, (usually some
--   <a>MonadIO</a>) a - the successful result type
newtype TxET e (m :: Type -> Type) a
TxET :: ReaderT Connection (ExceptT e m) a -> TxET e (m :: Type -> Type) a
[txHandler] :: TxET e (m :: Type -> Type) a -> ReaderT Connection (ExceptT e m) a

-- | Error type generally used in <a>TxET</a>.
data MSSQLTxError
MSSQLQueryError :: !Query -> !ODBCException -> MSSQLTxError
MSSQLConnError :: !ODBCException -> MSSQLTxError
MSSQLInternal :: !Text -> MSSQLTxError

-- | 
--   <a>https://learn.microsoft.com/en-us/sql/t-sql/statements/set-transaction-isolation-level-transact-sql</a>
data TxIsolation
ReadUncommitted :: TxIsolation
ReadCommitted :: TxIsolation
RepeatableRead :: TxIsolation
Snapshot :: TxIsolation
Serializable :: TxIsolation

-- | The transaction command to run, returning an MSSQLTxError or the
--   result.
type TxT (m :: Type -> Type) a = TxET MSSQLTxError m a
type TxE e a = TxET e IO a

-- | Run a command on the given connection wrapped in a transaction.
--   
--   See <a>runTxE</a> if you need to map the error type as well.
runTx :: forall (m :: Type -> Type) a. (MonadIO m, MonadBaseControl IO m) => TxIsolation -> TxT m a -> MSSQLPool -> ExceptT MSSQLTxError m a

-- | Run a command on the given connection wrapped in a transaction.
runTxE :: forall (m :: Type -> Type) e a. (MonadIO m, MonadBaseControl IO m) => (MSSQLTxError -> e) -> TxIsolation -> TxET e m a -> MSSQLPool -> ExceptT e m a

-- | Useful for building transactions which return no data.
--   
--   <pre>
--   insertId :: TxT m ()
--   insertId = unitQuery "INSERT INTO some_table VALUES (1, "hello")"
--   </pre>
--   
--   See <a>unitQueryE</a> if you need to map the error type as well.
unitQuery :: forall (m :: Type -> Type). MonadIO m => Query -> TxT m ()

-- | Useful for building transactions which return no data.
unitQueryE :: forall (m :: Type -> Type) e. MonadIO m => (MSSQLTxError -> e) -> Query -> TxET e m ()

-- | Useful for building query transactions which return a single one row.
--   
--   <pre>
--   returnOne :: TxT m Int
--   returnOne = singleRowQuery "SELECT 1"
--   </pre>
--   
--   See <a>singleRowQueryE</a> if you need to map the error type as well.
singleRowQuery :: forall a (m :: Type -> Type). (MonadIO m, FromRow a) => Query -> TxT m a

-- | Useful for building query transactions which return a single one row.
singleRowQueryE :: forall (m :: Type -> Type) a e. (MonadIO m, FromRow a) => (MSSQLTxError -> e) -> Query -> TxET e m a

-- | Useful for building query transactions which return multiple rows.
--   
--   <pre>
--   selectIds :: TxT m [Int]
--   selectIds = multiRowQuery "SELECT id FROM author"
--   </pre>
--   
--   See <a>multiRowQueryE</a> if you need to map the error type as well.
multiRowQuery :: forall a (m :: Type -> Type). (MonadIO m, FromRow a) => Query -> TxT m [a]

-- | Useful for building query transactions which return multiple rows.
multiRowQueryE :: forall (m :: Type -> Type) a e. (MonadIO m, FromRow a) => (MSSQLTxError -> e) -> Query -> TxET e m [a]

-- | MSSQL splits up results that have a <tt>SELECT .. FOR JSON</tt> at the
--   top-level into multiple rows with a single column, see
--   <a>https://docs.microsoft.com/en-us/sql/relational-databases/json/format-query-results-as-json-with-for-json-sql-server?view=sql-server-ver15#output-of-the-for-json-clause</a>
--   
--   This function simply concatenates each single-column row into one long
--   <a>Text</a> string.
forJsonQueryE :: forall (m :: Type -> Type) e. MonadIO m => (MSSQLTxError -> e) -> Query -> TxET e m Text

-- | Build a generic transaction out of an IO action.
buildGenericQueryTxE :: forall (m :: Type -> Type) e query a. MonadIO m => (MSSQLTxError -> e) -> query -> (query -> Query) -> (Connection -> query -> IO a) -> TxET e m a

-- | Map the error type for a <a>TxET</a>.
withTxET :: forall (m :: Type -> Type) e1 e2 a. Monad m => (e1 -> e2) -> TxET e1 m a -> TxET e2 m a
instance GHC.Internal.Base.Monad m => GHC.Internal.Base.Applicative (Database.MSSQL.Transaction.TxET e m)
instance GHC.Classes.Eq Database.MSSQL.Transaction.MSSQLResult
instance GHC.Classes.Eq Database.MSSQL.Transaction.MSSQLTxError
instance GHC.Classes.Eq Database.MSSQL.Transaction.TxIsolation
instance Data.Aeson.Types.FromJSON.FromJSON Database.MSSQL.Transaction.TxIsolation
instance GHC.Internal.Base.Functor m => GHC.Internal.Base.Functor (Database.MSSQL.Transaction.TxET e m)
instance GHC.Internal.Generics.Generic Database.MSSQL.Transaction.TxIsolation
instance Autodocodec.Class.HasCodec Database.MSSQL.Transaction.TxIsolation
instance Data.Hashable.Class.Hashable Database.MSSQL.Transaction.TxIsolation
instance Control.Monad.Morph.MFunctor (Database.MSSQL.Transaction.TxET e)
instance Control.Monad.Trans.Control.MonadBaseControl GHC.Types.IO m => Control.Monad.Trans.Control.MonadBaseControl GHC.Types.IO (Database.MSSQL.Transaction.TxET e m)
instance Control.Monad.Base.MonadBase GHC.Types.IO m => Control.Monad.Base.MonadBase GHC.Types.IO (Database.MSSQL.Transaction.TxET e m)
instance GHC.Internal.Base.Monad m => Control.Monad.Error.Class.MonadError e (Database.MSSQL.Transaction.TxET e m)
instance GHC.Internal.Control.Monad.Fix.MonadFix m => GHC.Internal.Control.Monad.Fix.MonadFix (Database.MSSQL.Transaction.TxET e m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Database.MSSQL.Transaction.TxET e m)
instance GHC.Internal.Base.Monad m => Control.Monad.Reader.Class.MonadReader Database.ODBC.Internal.Connection (Database.MSSQL.Transaction.TxET e m)
instance Control.Monad.Trans.Class.MonadTrans (Database.MSSQL.Transaction.TxET e)
instance GHC.Internal.Base.Monad m => GHC.Internal.Base.Monad (Database.MSSQL.Transaction.TxET e m)
instance Control.DeepSeq.NFData Database.MSSQL.Transaction.TxIsolation
instance GHC.Internal.Show.Show Database.MSSQL.Transaction.MSSQLResult
instance GHC.Internal.Show.Show Database.MSSQL.Transaction.MSSQLTxError
instance GHC.Internal.Show.Show Database.MSSQL.Transaction.TxIsolation
instance Data.Aeson.Types.ToJSON.ToJSON Database.MSSQL.Transaction.TxIsolation

module Hasura.Authentication.Headers
contentLengthHeader :: IsString a => a
gzipHeader :: Header
jsonHeader :: Header
requestIdHeader :: IsString a => a
sqlHeader :: Header
sensitiveHeaders :: HashSet HeaderName
commonClientHeadersIgnored :: IsString a => [a]

module Hasura.Authentication.Header
filterHeaders :: HashSet HeaderName -> [Header] -> [Header]
getRequestHeader :: HeaderName -> [Header] -> Maybe ByteString
mkSetCookieHeaders :: Response a -> ResponseHeaders
redactSensitiveHeader :: Header -> Header

module Hasura.Authentication.Role
newtype DropInheritedRole
DropInheritedRole :: RoleName -> DropInheritedRole
[_ddrRoleName] :: DropInheritedRole -> RoleName
type InheritedRole = Role
newtype ParentRoles
ParentRoles :: HashSet RoleName -> ParentRoles
[_unParentRoles] :: ParentRoles -> HashSet RoleName

-- | The <a>Role</a> type represents a role by containing its name and the
--   names of its parent roles. This type is used externally in the
--   <tt>add_inherited_role</tt> metadata API and is also used internally
--   in the permission building part of the schema cache building process
data Role
Role :: RoleName -> ParentRoles -> Role
[_rRoleName] :: Role -> RoleName

-- | set of the parent role names, in case of non-inherited roles it will
--   be an empty set
[_rParentRoles] :: Role -> ParentRoles
data RoleName
mkRoleName :: Text -> Maybe RoleName
mkRoleNameSafe :: NonEmptyText -> RoleName
adminRoleName :: RoleName
roleNameToTxt :: RoleName -> Text
instance GHC.Classes.Eq Hasura.Authentication.Role.DropInheritedRole
instance GHC.Classes.Eq Hasura.Authentication.Role.ParentRoles
instance GHC.Classes.Eq Hasura.Authentication.Role.Role
instance GHC.Classes.Eq Hasura.Authentication.Role.RoleName
instance Database.PG.Query.Class.FromCol Hasura.Authentication.Role.RoleName
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.Authentication.Role.RoleName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Authentication.Role.DropInheritedRole
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Authentication.Role.ParentRoles
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Authentication.Role.Role
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Authentication.Role.RoleName
instance GHC.Internal.Generics.Generic Hasura.Authentication.Role.DropInheritedRole
instance GHC.Internal.Generics.Generic Hasura.Authentication.Role.ParentRoles
instance GHC.Internal.Generics.Generic Hasura.Authentication.Role.Role
instance GHC.Internal.Generics.Generic Hasura.Authentication.Role.RoleName
instance Autodocodec.Class.HasCodec Hasura.Authentication.Role.ParentRoles
instance Autodocodec.Class.HasCodec Hasura.Authentication.Role.Role
instance Autodocodec.Class.HasCodec Hasura.Authentication.Role.RoleName
instance Data.Hashable.Class.Hashable Hasura.Authentication.Role.ParentRoles
instance Data.Hashable.Class.Hashable Hasura.Authentication.Role.Role
instance Data.Hashable.Class.Hashable Hasura.Authentication.Role.RoleName
instance Control.DeepSeq.NFData Hasura.Authentication.Role.RoleName
instance GHC.Classes.Ord Hasura.Authentication.Role.RoleName
instance GHC.Internal.Show.Show Hasura.Authentication.Role.DropInheritedRole
instance GHC.Internal.Show.Show Hasura.Authentication.Role.ParentRoles
instance GHC.Internal.Show.Show Hasura.Authentication.Role.Role
instance GHC.Internal.Show.Show Hasura.Authentication.Role.RoleName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Authentication.Role.RoleName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Authentication.Role.DropInheritedRole
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Authentication.Role.ParentRoles
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Authentication.Role.Role
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Authentication.Role.RoleName
instance Database.PG.Query.Class.ToPrepArg Hasura.Authentication.Role.RoleName
instance Data.Text.Extended.ToTxt Hasura.Authentication.Role.RoleName

module Hasura.Authentication.Session
adminSecretHeader :: SessionVariable
deprecatedAccessKeyHeader :: SessionVariable
useBackendOnlyPermissionsHeader :: SessionVariable
userIdHeader :: SessionVariable
userRoleHeader :: SessionVariable
data SessionVariable
type SessionVariableValue = Text
class ToSessionVariable a

-- | Tests the input to find out whether it is a valid session variable.
isSessionVariable :: ToSessionVariable a => a -> Bool

-- | Makes a session variable from the input. Returns <a>Nothing</a> on an
--   invalid input.
mkSessionVariable :: ToSessionVariable a => a -> Maybe SessionVariable

-- | Converts back to the input (lossily).
fromSessionVariable :: ToSessionVariable a => SessionVariable -> a

-- | Unsafely makes a session variable. Errors if the input is invalid.
unsafeMkSessionVariable :: ToSessionVariable a => a -> SessionVariable
parseSessionVariable :: Text -> Parser SessionVariable
sessionVariableToHeader :: SessionVariable -> SessionVariableValue -> Header

-- | Converts a <a>SessionVariable</a> value to a GraphQL name. This will
--   fail if the session variable contains characters that are not valid
--   for a graphql names. It is the caller's responsibility to decide what
--   to do in such a case.
sessionVariableToGraphQLName :: SessionVariable -> Maybe Name
data SessionVariables
singleSessionVariable :: SessionVariable -> SessionVariableValue -> SessionVariables
sessionVariablesFromMap :: HashMap Text Text -> SessionVariables
sessionVariablesWith :: SessionVariable -> SessionVariableValue -> SessionVariables -> SessionVariables
sessionVariablesWithout :: SessionVariable -> SessionVariables -> SessionVariables
filterSessionVariables :: (SessionVariable -> SessionVariableValue -> Bool) -> SessionVariables -> SessionVariables
sessionVariablesToHeaders :: SessionVariables -> [Header]
mkSessionVariablesHeaders :: [Header] -> SessionVariables
getSessionVariableValue :: SessionVariable -> SessionVariables -> Maybe SessionVariableValue
getSessionVariablesSet :: SessionVariables -> HashSet SessionVariable
getSessionVariables :: SessionVariables -> [Text]
maybeRoleFromSessionVariables :: SessionVariables -> Maybe RoleName
mkClientHeadersForward :: [Header] -> [Header]
instance GHC.Internal.Data.Data.Data Hasura.Authentication.Session.SessionVariable
instance GHC.Classes.Eq Hasura.Authentication.Session.SessionVariable
instance GHC.Classes.Eq Hasura.Authentication.Session.SessionVariables
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.Authentication.Session.SessionVariable
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Authentication.Session.SessionVariable
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Authentication.Session.SessionVariables
instance Data.Hashable.Class.Hashable Hasura.Authentication.Session.SessionVariable
instance Data.Hashable.Class.Hashable Hasura.Authentication.Session.SessionVariables
instance GHC.Internal.Base.Monoid Hasura.Authentication.Session.SessionVariables
instance Control.DeepSeq.NFData Hasura.Authentication.Session.SessionVariable
instance GHC.Classes.Ord Hasura.Authentication.Session.SessionVariable
instance GHC.Internal.Base.Semigroup Hasura.Authentication.Session.SessionVariables
instance GHC.Internal.Show.Show Hasura.Authentication.Session.SessionVariable
instance GHC.Internal.Show.Show Hasura.Authentication.Session.SessionVariables
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Authentication.Session.SessionVariable
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Authentication.Session.SessionVariable
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Authentication.Session.SessionVariables
instance Hasura.Authentication.Session.ToSessionVariable (Data.CaseInsensitive.Internal.CI Data.Text.Internal.Text)
instance Hasura.Authentication.Session.ToSessionVariable Network.HTTP.Types.Header.HeaderName
instance Hasura.Authentication.Session.ToSessionVariable Data.Aeson.Key.Key
instance Hasura.Authentication.Session.ToSessionVariable Data.Text.Internal.Text
instance Data.Text.Extended.ToTxt Hasura.Authentication.Session.SessionVariable


-- | Module of reusable functions for Kriti transforms.
--   
--   NOTE: This defines an alternative <a>runKritiWith</a> that includes
--   the basicFunctions by default. You should probably invoke Kriti
--   through this module rather than directly in order to make updating the
--   functions available only require touching this module.
--   
--   TODO: This should be added to the documentation and referenced in
--   (for-example) REST Connectors once the documentation refactor project
--   is complete.
module Data.Aeson.Kriti.Functions

-- | <a>runKriti</a> attaches the basicFunctions by default NOTE: The error
--   type is SerializedError due to KritiError not currently being exported
runKriti :: Text -> [(Text, Value)] -> Either SerializedError Value

-- | <a>runKritiWith</a> attaches the basicFunctions by default.
runKritiWith :: Text -> [(Text, Value)] -> HashMap Text KritiFunc -> Either SerializedError Value

-- | Re-Export of the Kriti <tt>stdlib</tt>
basicFunctions :: HashMap Text KritiFunc

-- | Functions that interact with environment variables
environmentFunctions :: Environment -> HashMap Text KritiFunc

-- | Functions that interact with HGE session during requests
sessionFunctions :: Maybe SessionVariables -> HashMap Text KritiFunc

module Hasura.Authentication.User

-- | Represent the admin secret state; whether the secret is sent in the
--   request or if actually authorization is not configured.
data UserAdminSecret
UAdminSecretSent :: UserAdminSecret
UAdminSecretNotSent :: UserAdminSecret
UAuthNotSet :: UserAdminSecret

-- | Represents the 'X-Hasura-Use-Backend-Only-Permissions' session
--   variable and request made with 'X-Hasura-Admin-Secret' if any auth
--   configured. For more details see Note [Backend only permissions]
data BackendOnlyFieldAccess
BOFAAllowed :: BackendOnlyFieldAccess
BOFADisallowed :: BackendOnlyFieldAccess
data UserInfo
UserInfo :: RoleName -> SessionVariables -> BackendOnlyFieldAccess -> UserInfo
[_uiRole] :: UserInfo -> RoleName
[_uiSession] :: UserInfo -> SessionVariables
[_uiBackendOnlyFieldAccess] :: UserInfo -> BackendOnlyFieldAccess
class Monad m => UserInfoM (m :: Type -> Type)
askUserInfo :: UserInfoM m => m UserInfo

-- | extra information used to identify a Hasura User
data ExtraUserInfo
ExtraUserInfo :: Maybe Text -> ExtraUserInfo
[_euiUserId] :: ExtraUserInfo -> Maybe Text

-- | Represents how to build a role from the session variables
data UserRoleBuild

-- | Look for `x-hasura-role` session variable value and absence will raise
--   an exception
URBFromSessionVariables :: UserRoleBuild

-- | Look for `x-hasura-role` session variable value, if absent fall back
--   to given role
URBFromSessionVariablesFallback :: !RoleName -> UserRoleBuild

-- | Use only the pre-determined role
URBPreDetermined :: !RoleName -> UserRoleBuild
askCurRole :: UserInfoM m => m RoleName
adminUserInfo :: UserInfo

-- | Build <tt><a>UserInfo</a> from </tt><a>SessionVariables</a>
mkUserInfo :: MonadError QErr m => UserRoleBuild -> UserAdminSecret -> SessionVariables -> m UserInfo
instance GHC.Classes.Eq Hasura.Authentication.User.BackendOnlyFieldAccess
instance GHC.Classes.Eq Hasura.Authentication.User.ExtraUserInfo
instance GHC.Classes.Eq Hasura.Authentication.User.UserAdminSecret
instance GHC.Classes.Eq Hasura.Authentication.User.UserInfo
instance GHC.Classes.Eq Hasura.Authentication.User.UserRoleBuild
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Authentication.User.BackendOnlyFieldAccess
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Authentication.User.UserInfo
instance GHC.Internal.Generics.Generic Hasura.Authentication.User.BackendOnlyFieldAccess
instance GHC.Internal.Generics.Generic Hasura.Authentication.User.ExtraUserInfo
instance GHC.Internal.Generics.Generic Hasura.Authentication.User.UserInfo
instance Data.Hashable.Class.Hashable Hasura.Authentication.User.BackendOnlyFieldAccess
instance Data.Hashable.Class.Hashable Hasura.Authentication.User.UserInfo
instance GHC.Internal.Show.Show Hasura.Authentication.User.BackendOnlyFieldAccess
instance GHC.Internal.Show.Show Hasura.Authentication.User.ExtraUserInfo
instance GHC.Internal.Show.Show Hasura.Authentication.User.UserAdminSecret
instance GHC.Internal.Show.Show Hasura.Authentication.User.UserInfo
instance GHC.Internal.Show.Show Hasura.Authentication.User.UserRoleBuild
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Authentication.User.BackendOnlyFieldAccess
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Authentication.User.UserInfo
instance Hasura.Authentication.User.UserInfoM m => Hasura.Authentication.User.UserInfoM (Control.Monad.Trans.Except.ExceptT r m)
instance Hasura.Authentication.User.UserInfoM m => Hasura.Authentication.User.UserInfoM (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.Authentication.User.UserInfoM m => Hasura.Authentication.User.UserInfoM (Control.Monad.Trans.State.Strict.StateT s m)

module Hasura.Backends.BigQuery.Name
_Bytes :: Name
_Date :: Name
_Datetime :: Name
_Geography :: Name
_Time :: Name
_Timestamp :: Name

module Hasura.Backends.BigQuery.Source
data BigQueryConnSourceConfig
BigQueryConnSourceConfig :: ConfigurationJSON ServiceAccount -> ConfigurationInputs -> ConfigurationInput -> Maybe ConfigurationInput -> Maybe ConfigurationInput -> Maybe ConfigurationInput -> BigQueryConnSourceConfig
[_cscServiceAccount] :: BigQueryConnSourceConfig -> ConfigurationJSON ServiceAccount
[_cscDatasets] :: BigQueryConnSourceConfig -> ConfigurationInputs
[_cscProjectId] :: BigQueryConnSourceConfig -> ConfigurationInput
[_cscGlobalSelectLimit] :: BigQueryConnSourceConfig -> Maybe ConfigurationInput
[_cscRetryBaseDelay] :: BigQueryConnSourceConfig -> Maybe ConfigurationInput
[_cscRetryLimit] :: BigQueryConnSourceConfig -> Maybe ConfigurationInput
data RetryOptions
RetryOptions :: Microseconds -> Int -> RetryOptions
[_retryBaseDelay] :: RetryOptions -> Microseconds
[_retryNumRetries] :: RetryOptions -> Int
newtype BigQueryProjectId
BigQueryProjectId :: Text -> BigQueryProjectId
[getBigQueryProjectId] :: BigQueryProjectId -> Text
newtype BigQueryDataset
BigQueryDataset :: Text -> BigQueryDataset
[getBigQueryDataset] :: BigQueryDataset -> Text
data BigQueryConnection
BigQueryConnection :: ServiceAccount -> BigQueryProjectId -> Maybe RetryOptions -> MVar (Maybe TokenResp) -> BigQueryConnection
[_bqServiceAccount] :: BigQueryConnection -> ServiceAccount
[_bqProjectId] :: BigQueryConnection -> BigQueryProjectId
[_bqRetryOptions] :: BigQueryConnection -> Maybe RetryOptions
[_bqAccessTokenMVar] :: BigQueryConnection -> MVar (Maybe TokenResp)
data BigQuerySourceConfig
BigQuerySourceConfig :: BigQueryConnection -> [BigQueryDataset] -> Int64 -> BigQuerySourceConfig
[_scConnection] :: BigQuerySourceConfig -> BigQueryConnection
[_scDatasets] :: BigQuerySourceConfig -> [BigQueryDataset]
[_scGlobalSelectLimit] :: BigQuerySourceConfig -> Int64

-- | Configuration input when the YAML value as well as the Env var have
--   singular values
data ConfigurationInput
FromYaml :: Text -> ConfigurationInput
FromEnv :: Text -> ConfigurationInput

-- | Configuration inputs when they are a YAML array or an Env var whose
--   value is a comma-separated string
data ConfigurationInputs
FromYamls :: [Text] -> ConfigurationInputs
FromEnvs :: Text -> ConfigurationInputs
data ConfigurationJSON a
FromEnvJSON :: Text -> ConfigurationJSON a
FromYamlJSON :: a -> ConfigurationJSON a
newtype GoogleAccessToken
GoogleAccessToken :: Text -> GoogleAccessToken
data PKey
data ServiceAccount
ServiceAccount :: Text -> PKey -> BigQueryProjectId -> ServiceAccount
[_saClientEmail] :: ServiceAccount -> Text
[_saPrivateKey] :: ServiceAccount -> PKey
[_saProjectId] :: ServiceAccount -> BigQueryProjectId
data TokenResp
TokenResp :: GoogleAccessToken -> Integer -> TokenResp
[_trAccessToken] :: TokenResp -> GoogleAccessToken
[_trExpiresAt] :: TokenResp -> Integer
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Source.BigQueryDataset
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Source.BigQueryProjectId
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Source.GoogleAccessToken
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Source.PKey
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Source.ServiceAccount
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Source.TokenResp
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Source.BigQueryConnSourceConfig
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Source.BigQueryConnection
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Source.BigQueryDataset
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Source.BigQueryProjectId
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Source.BigQuerySourceConfig
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Source.ConfigurationInput
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Source.ConfigurationInputs
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.Backends.BigQuery.Source.ConfigurationJSON a)
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Source.GoogleAccessToken
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Source.PKey
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Source.RetryOptions
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Source.ServiceAccount
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Source.TokenResp
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Source.BigQueryConnSourceConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Source.BigQueryDataset
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Source.BigQueryProjectId
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Source.ConfigurationInput
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Source.ConfigurationInputs
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Backends.BigQuery.Source.ConfigurationJSON a)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Source.GoogleAccessToken
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Source.PKey
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Source.ServiceAccount
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Source.TokenResp
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Source.BigQueryConnSourceConfig
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Source.BigQueryDataset
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Source.BigQueryProjectId
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Source.ConfigurationInput
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Source.ConfigurationInputs
instance GHC.Internal.Generics.Generic (Hasura.Backends.BigQuery.Source.ConfigurationJSON a)
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Source.GoogleAccessToken
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Source.PKey
instance GHC.Internal.Generics.Generic Crypto.PubKey.RSA.Types.PrivateKey
instance GHC.Internal.Generics.Generic Crypto.PubKey.RSA.Types.PublicKey
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Source.ServiceAccount
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Source.TokenResp
instance Autodocodec.Class.HasCodec Hasura.Backends.BigQuery.Source.BigQueryConnSourceConfig
instance Autodocodec.Class.HasCodec Hasura.Backends.BigQuery.Source.BigQueryDataset
instance Autodocodec.Class.HasCodec Hasura.Backends.BigQuery.Source.BigQueryProjectId
instance Autodocodec.Class.HasCodec Hasura.Backends.BigQuery.Source.ConfigurationInput
instance Autodocodec.Class.HasCodec Hasura.Backends.BigQuery.Source.ConfigurationInputs
instance Autodocodec.Class.HasCodec a => Autodocodec.Class.HasCodec (Hasura.Backends.BigQuery.Source.ConfigurationJSON a)
instance Autodocodec.Class.HasCodec Hasura.Backends.BigQuery.Source.PKey
instance Autodocodec.Class.HasCodec Hasura.Backends.BigQuery.Source.ServiceAccount
instance Data.Has.Has () Hasura.Backends.BigQuery.Source.BigQuerySourceConfig
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Source.BigQueryConnSourceConfig
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Source.BigQueryDataset
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Source.BigQueryProjectId
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Source.ConfigurationInput
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Source.ConfigurationInputs
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.Backends.BigQuery.Source.ConfigurationJSON a)
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Source.GoogleAccessToken
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Source.PKey
instance Data.Hashable.Class.Hashable Crypto.PubKey.RSA.Types.PrivateKey
instance Data.Hashable.Class.Hashable Crypto.PubKey.RSA.Types.PublicKey
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Source.ServiceAccount
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Source.TokenResp
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Source.BigQueryConnSourceConfig
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Source.BigQueryDataset
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Source.BigQueryProjectId
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Source.ConfigurationInput
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Source.ConfigurationInputs
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.Backends.BigQuery.Source.ConfigurationJSON a)
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Source.GoogleAccessToken
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Source.PKey
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Source.ServiceAccount
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Source.TokenResp
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Source.BigQueryConnSourceConfig
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Source.BigQueryDataset
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Source.BigQueryProjectId
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Source.BigQuerySourceConfig
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Source.ConfigurationInput
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Source.ConfigurationInputs
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (Hasura.Backends.BigQuery.Source.ConfigurationJSON a)
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Source.GoogleAccessToken
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Source.PKey
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Source.ServiceAccount
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Source.TokenResp
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Source.BigQueryConnSourceConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Source.BigQueryDataset
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Source.BigQueryProjectId
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Source.BigQuerySourceConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Source.ConfigurationInput
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Source.ConfigurationInputs
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Backends.BigQuery.Source.ConfigurationJSON a)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Source.GoogleAccessToken
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Source.PKey
instance Data.Aeson.Types.ToJSON.ToJSON Crypto.PubKey.RSA.Types.PrivateKey
instance Data.Aeson.Types.ToJSON.ToJSON Crypto.PubKey.RSA.Types.PublicKey
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Source.ServiceAccount


-- | Functions and datatypes for interpreting MSSQL database errors.
module Hasura.Backends.MSSQL.SQL.Error

-- | The top-level error class. Errors in MSSQL are divided into different
--   <i>classes</i>, which are further subdivided into individual error
--   subclasses. It is useful to determine the class of database exception
--   and handle it appropriately.
data ErrorClass
DataException :: ErrorSubclass DataExceptionSubclass -> ErrorClass
IntegrityConstraintViolation :: ErrorClass
SyntaxErrorOrAccessViolation :: ErrorSubclass SyntaxErrorOrAccessViolationSubclass -> ErrorClass

-- | A default transaction error handler where all errors are unexpected.
defaultMSSQLTxErrorHandler :: MSSQLTxError -> QErr

-- | A transaction error handler to be used in constructing mutation
--   transactions, i.e INSERT, UPDATE and DELETE. We expect data exception
--   and integrity constraint violation.
mutationMSSQLTxErrorHandler :: MSSQLTxError -> QErr

-- | Constructs a transaction error handler given a predicate that
--   determines which error classes (and subclasses) are expected and
--   should be reported to the user. All other errors are considered
--   internal errors. Example:- Consider a insert mutation where we insert
--   some data into columns of a table. Except for the basic data type,
--   such as Boolean, String, Float, Int etc. we cannot invalidate data any
--   further, such as validating timestamp string format. In this case, a
--   @<a>DataException</a> is expected from the database and it is handled
--   and thrown with proper error message.
mkMSSQLTxErrorHandler :: (ErrorClass -> Bool) -> MSSQLTxError -> QErr
data ErrorSubclass a

-- | represents non-specific <tt>000</tt> subclass code
NoSubclass :: ErrorSubclass a

-- | represents known, more specific sub class
Subclass :: a -> ErrorSubclass a
data DataExceptionSubclass
StringDataRightTruncated :: DataExceptionSubclass
NumericValueOutOfRange :: DataExceptionSubclass
InvalidDatetimeFormat :: DataExceptionSubclass
DatetimeFieldOverflow :: DataExceptionSubclass
IntervalFieldOverflow :: DataExceptionSubclass
InvalidEscapeCharacter :: DataExceptionSubclass
InvalidEscapeSequence :: DataExceptionSubclass
data SyntaxErrorOrAccessViolationSubclass
TableOrViewAlreadyExists :: SyntaxErrorOrAccessViolationSubclass
TableOrViewNotFound :: SyntaxErrorOrAccessViolationSubclass
IndexAlreadyExists :: SyntaxErrorOrAccessViolationSubclass
IndexNotFound :: SyntaxErrorOrAccessViolationSubclass
ColumnAlreadyExists :: SyntaxErrorOrAccessViolationSubclass
ColumnNotFound :: SyntaxErrorOrAccessViolationSubclass

-- | Parsing error class and subclass information from a SQLSTATE code.
--   SQLSTATE provides detailed information about the cause of a warning or
--   error. A SQLSTATE consists of 5 chars. They are divided into two
--   parts: the first and second chars contain a class and the following
--   three a subclass.
parseErrorClass :: String -> Maybe ErrorClass
instance GHC.Classes.Eq Hasura.Backends.MSSQL.SQL.Error.DataExceptionSubclass
instance GHC.Classes.Eq Hasura.Backends.MSSQL.SQL.Error.ErrorClass
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.Backends.MSSQL.SQL.Error.ErrorSubclass a)
instance GHC.Classes.Eq Hasura.Backends.MSSQL.SQL.Error.SyntaxErrorOrAccessViolationSubclass
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.SQL.Error.DataExceptionSubclass
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.SQL.Error.ErrorClass
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.SQL.Error.SyntaxErrorOrAccessViolationSubclass


-- | Postgres SQL Error
--   
--   Functions and datatypes for interpreting Postgres errors.
module Hasura.Backends.Postgres.SQL.Error

-- | The top-level error code type. Errors in Postgres are divided into
--   different <i>classes</i>, which are further subdivided into individual
--   error codes. Even if a particular status code is not known to the
--   application, it’s possible to determine its class and handle it
--   appropriately.
data PGErrorType
PGDataException :: Maybe (PGErrorCode PGDataException) -> PGErrorType
PGIntegrityConstraintViolation :: Maybe (PGErrorCode PGIntegrityConstraintViolation) -> PGErrorType
PGSyntaxErrorOrAccessRuleViolation :: Maybe (PGErrorCode PGSyntaxErrorOrAccessRuleViolation) -> PGErrorType
PGTransactionRollback :: Maybe (PGErrorCode PGTransactionRollback) -> PGErrorType
_PGDataException :: Prism' PGErrorType (Maybe (PGErrorCode PGDataException))
_PGIntegrityConstraintViolation :: Prism' PGErrorType (Maybe (PGErrorCode PGIntegrityConstraintViolation))
_PGSyntaxErrorOrAccessRuleViolation :: Prism' PGErrorType (Maybe (PGErrorCode PGSyntaxErrorOrAccessRuleViolation))
_PGTransactionRollback :: Prism' PGErrorType (Maybe (PGErrorCode PGTransactionRollback))
pgErrorType :: PGStmtErrDetail -> Maybe PGErrorType
data PGErrorCode a

-- | represents errors that have the non-specific <tt>000</tt> status code
PGErrorGeneric :: PGErrorCode a

-- | represents errors with a known, more specific status code
PGErrorSpecific :: a -> PGErrorCode a
_PGErrorGeneric :: forall a p f. (Choice p, Applicative f) => p () (f ()) -> p (PGErrorCode a) (f (PGErrorCode a))
_PGErrorSpecific :: forall a1 a2 p f. (Choice p, Applicative f) => p a1 (f a2) -> p (PGErrorCode a1) (f (PGErrorCode a2))
data PGDataException
PGInvalidDatetimeFormat :: PGDataException
PGInvalidParameterValue :: PGDataException
PGInvalidEscapeSequence :: PGDataException
PGInvalidTextRepresentation :: PGDataException
data PGIntegrityConstraintViolation
PGRestrictViolation :: PGIntegrityConstraintViolation
PGNotNullViolation :: PGIntegrityConstraintViolation
PGForeignKeyViolation :: PGIntegrityConstraintViolation
PGUniqueViolation :: PGIntegrityConstraintViolation
PGCheckViolation :: PGIntegrityConstraintViolation
PGExclusionViolation :: PGIntegrityConstraintViolation
data PGSyntaxErrorOrAccessRuleViolation
PGUndefinedObject :: PGSyntaxErrorOrAccessRuleViolation
PGInvalidColumnReference :: PGSyntaxErrorOrAccessRuleViolation
data PGTransactionRollback
PGSerializationFailure :: PGTransactionRollback
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Error.PGDataException
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.Backends.Postgres.SQL.Error.PGErrorCode a)
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Error.PGErrorType
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Error.PGIntegrityConstraintViolation
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Error.PGSyntaxErrorOrAccessRuleViolation
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Error.PGTransactionRollback
instance GHC.Internal.Base.Functor Hasura.Backends.Postgres.SQL.Error.PGErrorCode
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.Error.PGDataException
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (Hasura.Backends.Postgres.SQL.Error.PGErrorCode a)
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.Error.PGErrorType
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.Error.PGIntegrityConstraintViolation
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.Error.PGSyntaxErrorOrAccessRuleViolation
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.Error.PGTransactionRollback


-- | graphql-engine used to have a query plan cache, which cached the
--   execution plan for a given graphql query (sans JSON variable values).
--   After the PDV refactor (see <a>hasura/graphql-engine#4111</a>), this
--   query plan cache was not needed anymore. For backwards compatibility
--   reasons, we still need to parse the configuration options from the
--   CLI, although the CLI option gets ignored.
--   
--   Eventually, we can decide to stop parsing the CLI option
--   --query-plan-cache-size, at which point this module can be removed.
module Hasura.Cache.Bounded
newtype CacheSize
CacheSize :: Word16 -> CacheSize
[unCacheSize] :: CacheSize -> Word16
parseCacheSize :: String -> Either String CacheSize
instance GHC.Internal.Enum.Bounded Hasura.Cache.Bounded.CacheSize
instance GHC.Internal.Enum.Enum Hasura.Cache.Bounded.CacheSize
instance GHC.Classes.Eq Hasura.Cache.Bounded.CacheSize
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Cache.Bounded.CacheSize
instance GHC.Internal.Real.Integral Hasura.Cache.Bounded.CacheSize
instance GHC.Internal.Num.Num Hasura.Cache.Bounded.CacheSize
instance GHC.Classes.Ord Hasura.Cache.Bounded.CacheSize
instance GHC.Internal.Read.Read Hasura.Cache.Bounded.CacheSize
instance GHC.Internal.Real.Real Hasura.Cache.Bounded.CacheSize
instance GHC.Internal.Show.Show Hasura.Cache.Bounded.CacheSize
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Cache.Bounded.CacheSize


-- | Interface for a service for maintaining short-lived credentials, such
--   as access tokens or JWTs.
module Hasura.CredentialCache
newtype CredentialCache cred
CredentialCache :: STM (cred, STM (STM ())) -> CredentialCache cred

-- | Get the stored credential. Also returns an STM action for requesting a
--   refresh of the credential, which, in turn, returns an STM action for
--   waiting on the arrival of the fresh credential.
[getCredential] :: CredentialCache cred -> STM (cred, STM (STM ()))
instance GHC.Internal.Base.Functor Hasura.CredentialCache.CredentialCache

module Hasura.GraphQL.Execute.Subscription.Options
data SubscriptionsOptions
SubscriptionsOptions :: !BatchSize -> !RefetchInterval -> SubscriptionsOptions
[_lqoBatchSize] :: SubscriptionsOptions -> !BatchSize
[_lqoRefetchInterval] :: SubscriptionsOptions -> !RefetchInterval
type LiveQueriesOptions = SubscriptionsOptions
type StreamQueriesOptions = SubscriptionsOptions
newtype BatchSize
BatchSize :: Refined NonNegative Int -> BatchSize
[unBatchSize] :: BatchSize -> Refined NonNegative Int
newtype RefetchInterval
RefetchInterval :: Refined NonNegative DiffTime -> RefetchInterval
[unRefetchInterval] :: RefetchInterval -> Refined NonNegative DiffTime
mkSubscriptionsOptions :: Maybe BatchSize -> Maybe RefetchInterval -> SubscriptionsOptions
mkBatchSize :: Int -> Maybe BatchSize
mkRefetchInterval :: DiffTime -> Maybe RefetchInterval
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Options.BatchSize
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Options.RefetchInterval
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Options.SubscriptionsOptions
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Execute.Subscription.Options.BatchSize
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Execute.Subscription.Options.RefetchInterval
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Execute.Subscription.Options.SubscriptionsOptions
instance GHC.Internal.Show.Show Hasura.GraphQL.Execute.Subscription.Options.BatchSize
instance GHC.Internal.Show.Show Hasura.GraphQL.Execute.Subscription.Options.RefetchInterval
instance GHC.Internal.Show.Show Hasura.GraphQL.Execute.Subscription.Options.SubscriptionsOptions
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Subscription.Options.BatchSize
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Subscription.Options.RefetchInterval
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Subscription.Options.SubscriptionsOptions

module Hasura.GraphQL.Execute.Subscription.TMap

-- | A coarse-grained transactional map implemented by simply wrapping a
--   <a>HashMap</a> in a <a>TVar</a>. Compared to <a>StmContainers.Map</a>,
--   this provides much faster iteration over the elements at the cost of
--   significantly increased contention on writes.
data TMap k v
new :: STM (TMap k v)
reset :: TMap k v -> STM ()
null :: TMap k v -> STM Bool
lookup :: Hashable k => k -> TMap k v -> STM (Maybe v)
insert :: Hashable k => v -> k -> TMap k v -> STM ()
delete :: Hashable k => k -> TMap k v -> STM ()
toList :: TMap k v -> STM [(k, v)]
replace :: TMap k v -> HashMap k v -> STM ()
union :: Hashable k => TMap k v -> TMap k v -> STM (TMap k v)
filterWithKey :: (k -> v -> Bool) -> TMap k v -> STM ()
getMap :: TMap k v -> STM (HashMap k v)
adjust :: Hashable k => (v -> v) -> k -> TMap k v -> STM ()

module Hasura.GraphQL.Execute.Types
data GraphQLQueryType
QueryHasura :: GraphQLQueryType
QueryRelay :: GraphQLQueryType
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Types.GraphQLQueryType
instance GHC.Internal.Generics.Generic Hasura.GraphQL.Execute.Types.GraphQLQueryType
instance Data.Hashable.Class.Hashable Hasura.GraphQL.Execute.Types.GraphQLQueryType
instance GHC.Classes.Ord Hasura.GraphQL.Execute.Types.GraphQLQueryType
instance GHC.Internal.Show.Show Hasura.GraphQL.Execute.Types.GraphQLQueryType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Types.GraphQLQueryType

module Hasura.GraphQL.Schema.Typename

-- | Type name customization
newtype MkTypename
MkTypename :: (Name -> Name) -> MkTypename
[runMkTypename] :: MkTypename -> Name -> Name

-- | Inject a new <tt>MkTypename</tt> customization function into the
--   environment. This can be used by schema-building code (with
--   <tt>MonadBuildSchema</tt> constraint) to ensure the correct type name
--   customizations are applied.
withTypenameCustomization :: forall m r a. (MonadReader r m, Has MkTypename r) => MkTypename -> m a -> m a
instance GHC.Internal.Base.Monoid Hasura.GraphQL.Schema.Typename.MkTypename
instance GHC.Internal.Base.Semigroup Hasura.GraphQL.Schema.Typename.MkTypename


-- | We are in the process of building DTO types incrementally. We use
--   placeholder types in positions in data structures that are not
--   fully-defined yet. For example <a>PlaceholderObject</a> represents
--   some unspecified JSON object, and <a>PlaceholderArray</a> represents
--   an array whose contents are not yet specified.
--   
--   We are transitioning from converting <a>Metadata</a> directly to JSON
--   to converting it to <a>MetadataDTO</a> instead. Serialization and
--   deserialization for placeholder values is delegated to the old JSON
--   serialization code.
module Hasura.Metadata.DTO.Placeholder

-- | Stands in for an array that we have not had time to fully specify yet.
--   Generated OpenAPI documentation for <a>PlaceholderArray</a> will
--   permit an array of values of any type, and a note will be appended to
--   the documentation string for the value explaining that this is a
--   temporary placeholder.
newtype PlaceholderArray
PlaceholderArray :: Array -> PlaceholderArray

-- | Stands in for an object that we have not had time to fully specify
--   yet. Generated OpenAPI documentation for <a>PlaceholderObject</a> will
--   permit an object with any keys with any types of values. A note will
--   be appended to the documentation string for the value explaining that
--   this is a temporary placeholder.
newtype PlaceholderObject
PlaceholderObject :: Object -> PlaceholderObject
class IsPlaceholder p a | a -> p

-- | Use this function to mark an Aeson type (Array or Object) as a
--   temporary placeholder in a larger data structure.
placeholder :: IsPlaceholder p a => a -> p

-- | This placeholder can be used in a codec to represent any type of data
--   that has <a>FromJSON</a> and <a>ToJSON</a> instances. Generated
--   OpenAPI specifications based on this codec will not show any
--   information about the internal structure of the type so ideally uses
--   of this placeholder should eventually be replaced with more
--   descriptive codecs.
placeholderCodecViaJSON :: (FromJSON a, ToJSON a) => JSONCodec a
instance GHC.Classes.Eq Hasura.Metadata.DTO.Placeholder.PlaceholderArray
instance GHC.Classes.Eq Hasura.Metadata.DTO.Placeholder.PlaceholderObject
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Metadata.DTO.Placeholder.PlaceholderArray
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Metadata.DTO.Placeholder.PlaceholderObject
instance GHC.Internal.Generics.Generic Hasura.Metadata.DTO.Placeholder.PlaceholderArray
instance GHC.Internal.Generics.Generic Hasura.Metadata.DTO.Placeholder.PlaceholderObject
instance Autodocodec.Class.HasCodec Hasura.Metadata.DTO.Placeholder.PlaceholderArray
instance Autodocodec.Class.HasCodec Hasura.Metadata.DTO.Placeholder.PlaceholderObject
instance Hasura.Metadata.DTO.Placeholder.IsPlaceholder Hasura.Metadata.DTO.Placeholder.PlaceholderArray Data.Aeson.Types.Internal.Array
instance Hasura.Metadata.DTO.Placeholder.IsPlaceholder Hasura.Metadata.DTO.Placeholder.PlaceholderArray Data.Aeson.Ordered.Array
instance Hasura.Metadata.DTO.Placeholder.IsPlaceholder Hasura.Metadata.DTO.Placeholder.PlaceholderObject Data.Aeson.Types.Internal.Object
instance Hasura.Metadata.DTO.Placeholder.IsPlaceholder Hasura.Metadata.DTO.Placeholder.PlaceholderObject Data.Aeson.Ordered.Object
instance GHC.Internal.Show.Show Hasura.Metadata.DTO.Placeholder.PlaceholderArray
instance GHC.Internal.Show.Show Hasura.Metadata.DTO.Placeholder.PlaceholderObject
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Metadata.DTO.Placeholder.PlaceholderArray
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Metadata.DTO.Placeholder.PlaceholderObject
instance Data.OpenApi.Internal.Schema.ToSchema Hasura.Metadata.DTO.Placeholder.PlaceholderArray
instance Data.OpenApi.Internal.Schema.ToSchema Hasura.Metadata.DTO.Placeholder.PlaceholderObject

module Hasura.Metadata.DTO.MetadataV2

-- | Revision 2 of the Metadata export format. Note that values of the
--   types, <a>PlaceholderArray</a> and <a>PlaceholderObject</a> are
--   placeholders that will eventually be expanded to represent more
--   detail.
data MetadataV2
MetadataV2 :: Maybe PlaceholderArray -> Maybe PlaceholderArray -> Maybe PlaceholderArray -> Maybe PlaceholderObject -> Maybe PlaceholderArray -> Maybe PlaceholderArray -> Maybe PlaceholderArray -> PlaceholderArray -> MetadataV2
[metaV2Actions] :: MetadataV2 -> Maybe PlaceholderArray
[metaV2Allowlist] :: MetadataV2 -> Maybe PlaceholderArray
[metaV2CronTriggers] :: MetadataV2 -> Maybe PlaceholderArray
[metaV2CustomTypes] :: MetadataV2 -> Maybe PlaceholderObject
[metaV2Functions] :: MetadataV2 -> Maybe PlaceholderArray
[metaV2QueryCollections] :: MetadataV2 -> Maybe PlaceholderArray
[metaV2RemoteSchemas] :: MetadataV2 -> Maybe PlaceholderArray
[metaV2Tables] :: MetadataV2 -> PlaceholderArray
instance GHC.Classes.Eq Hasura.Metadata.DTO.MetadataV2.MetadataV2
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Metadata.DTO.MetadataV2.MetadataV2
instance GHC.Internal.Generics.Generic Hasura.Metadata.DTO.MetadataV2.MetadataV2
instance Autodocodec.Class.HasCodec Hasura.Metadata.DTO.MetadataV2.MetadataV2
instance GHC.Internal.Show.Show Hasura.Metadata.DTO.MetadataV2.MetadataV2
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Metadata.DTO.MetadataV2.MetadataV2
instance Data.OpenApi.Internal.Schema.ToSchema Hasura.Metadata.DTO.MetadataV2.MetadataV2

module Hasura.Metadata.DTO.MetadataV1

-- | Revision 1 of the Metadata export format. Note that values of the
--   types, <a>PlaceholderArray</a> and <tt>PlaceholderObject</tt> are
--   placeholders that will eventually be expanded to represent more
--   detail.
data MetadataV1
MetadataV1 :: Maybe PlaceholderArray -> Maybe PlaceholderArray -> PlaceholderArray -> MetadataV1
[metaV1Functions] :: MetadataV1 -> Maybe PlaceholderArray
[metaV1RemoteSchemas] :: MetadataV1 -> Maybe PlaceholderArray
[metaV1Tables] :: MetadataV1 -> PlaceholderArray
instance GHC.Classes.Eq Hasura.Metadata.DTO.MetadataV1.MetadataV1
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Metadata.DTO.MetadataV1.MetadataV1
instance GHC.Internal.Generics.Generic Hasura.Metadata.DTO.MetadataV1.MetadataV1
instance Autodocodec.Class.HasCodec Hasura.Metadata.DTO.MetadataV1.MetadataV1
instance GHC.Internal.Show.Show Hasura.Metadata.DTO.MetadataV1.MetadataV1
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Metadata.DTO.MetadataV1.MetadataV1
instance Data.OpenApi.Internal.Schema.ToSchema Hasura.Metadata.DTO.MetadataV1.MetadataV1


-- | QuasiQuoted GraphQL constants used througout the codebase. By moving
--   all the Quasiquotes here we can eliminate extraneous rebuilds of
--   larger modules.
--   
--   See:
--   <a>https://www.parsonsmatt.org/2021/07/12/template_haskell_performance_tips.html#recompilation-avoidance</a>
module Hasura.Name
__ :: Name
_no_queries_available :: Name
__mutation_backend :: Name
__mutation_frontend :: Name
__query :: Name
__subscription :: Name
_preset :: Name
_static :: Name
_value :: Name
_Bool :: Name
_Double :: Name
_float8 :: Name
_Number :: Name
_numeric :: Name
_mutation_root :: Name
_query_root :: Name
_subscription_root :: Name
__enum :: Name
__scalar :: Name
_id :: Name
_session_variables :: Name
__remote_rel_ :: Name
__bool_exp :: Name
__comparison_exp :: Name
__BigQuery_comparison_exp :: Name
__MSSQL_comparison_exp :: Name
__cast :: Name
__cast_exp :: Name
__is_null :: Name
__eq :: Name
__neq :: Name
__in :: Name
__nin :: Name
__gt :: Name
__gte :: Name
__lt :: Name
__lte :: Name
__contains :: Name
__matches :: Name
__ancestor :: Name
__descendant :: Name
__like :: Name
__ilike :: Name
__nlike :: Name
__nilike :: Name
__similar :: Name
__nsimilar :: Name
__regex :: Name
__nregex :: Name
__niregex :: Name
__iregex :: Name
__and :: Name
__not :: Name
__or :: Name
_aggregate :: Name
_aggregate_bool_exp :: Name
_column :: Name
_columns :: Name
_nodes :: Name
_avg :: Name
_count :: Name
_stddev :: Name
_stddev_pop :: Name
_stddev_samp :: Name
_sum :: Name
_var_pop :: Name
_var_samp :: Name
_variance :: Name
__aggregate :: Name
__aggregate_fields :: Name
__fields :: Name
_group_by :: Name
_keys :: Name
_group_key :: Name
_path :: Name
_args :: Name
__args :: Name
_distinct :: Name
_distinct_on :: Name
__select_column :: Name
_where :: Name
_order_by :: Name
_ASC :: Name
_asc :: Name
_asc_nulls_first :: Name
_asc_nulls_last :: Name
_DESC :: Name
_desc :: Name
_desc_nulls_first :: Name
_desc_nulls_last :: Name
_first :: Name
_last :: Name
_before :: Name
_after :: Name
__aggregate_order_by :: Name
__order_by :: Name
_limit :: Name
_offset :: Name
_distance :: Name
_from :: Name
_geommin :: Name
_nband :: Name
_st_d_within_geography_input :: Name
_st_d_within_input :: Name
_st_intersects_geom_nband_input :: Name
_st_intersects_nband_geom_input :: Name
_st_dwithin_input :: Name
_use_spheroid :: Name
__st_3d_d_within :: Name
__st_3d_intersects :: Name
__st_contains :: Name
__st_crosses :: Name
__st_d_within :: Name
__st_equals :: Name
__st_intersects_geom_nband :: Name
__st_intersects_nband_geom :: Name
__st_intersects_rast :: Name
__st_intersects :: Name
__st_overlaps :: Name
__st_touches :: Name
__st_within :: Name
_constraint :: Name
_if_matched :: Name
_match_columns :: Name
_on_conflict :: Name
_update_columns :: Name
__constraint :: Name
__if_matched :: Name
__on_conflict :: Name
__update_column :: Name
__PLACEHOLDER :: Name
_insert :: Name
_update :: Name
_updates :: Name
_delete :: Name
_affected_rows :: Name
_data :: Name
_object :: Name
_objects :: Name
_one :: Name
_many :: Name
_returning :: Name
_transaction :: Name
__append :: Name
__arr_rel_insert_input :: Name
__delete_at_path :: Name
__delete_elem :: Name
__delete_key :: Name
__insert_input :: Name
__insert_match_column :: Name
__mutation_response :: Name
__prepend :: Name
__obj_rel_insert_input :: Name
_created_at :: Name
_errors :: Name
_output :: Name
_Connection :: Name
_Edge :: Name
_PageInfo :: Name
_batch_size :: Name
_connection :: Name
_cursor :: Name
_cursor_ordering :: Name
_edges :: Name
_initial_value :: Name
_node :: Name
_ordering :: Name
_pageInfo :: Name
_stream :: Name
_startCursor :: Name
_endCursor :: Name
_hasNextPage :: Name
_hasPreviousPage :: Name
__connection :: Name
__stream_cursor_input :: Name
__stream_cursor_value_input :: Name
_Node :: Name
___hasura_internal_typename :: Name
__service :: Name
_key :: Name
_fields :: Name
_representations :: Name
__Any :: Name
_sdl :: Name
__Service :: Name
__Entity :: Name
__entities :: Name
_arguments :: Name
_predicate :: Name
_filter :: Name
__array :: Name


-- | Tools to analyze the structure of a GraphQL request.
module Hasura.GraphQL.Analyse

-- | Overall structure of a given query. We extract the tree of fields in
--   the output, and the graph of input variables.
data Structure
Structure :: HashMap Name FieldInfo -> HashMap Name VariableInfo -> Structure
[_stSelection] :: Structure -> HashMap Name FieldInfo
[_stVariables] :: Structure -> HashMap Name VariableInfo

-- | Information about the type of an output field; whether the base type
--   is an object or a scalar, we store the correspoding <tt>GType</tt> to
--   keep track of the modifiers applied to it (list or non-nullability).
data FieldInfo
FieldObjectInfo :: GType -> ObjectInfo -> FieldInfo
FieldScalarInfo :: GType -> ScalarInfo -> FieldInfo
FieldEnumInfo :: GType -> EnumInfo -> FieldInfo

-- | Information about the type of an input field; whether the base type is
--   an object or a scalar, we store the correspoding <tt>GType</tt> to
--   keep track of the modifiers applied to it (list or non-nullability).
data InputFieldInfo
InputFieldScalarInfo :: ScalarInfo -> InputFieldInfo
InputFieldEnumInfo :: EnumInfo -> InputFieldInfo
InputFieldObjectInfo :: InputObjectInfo -> InputFieldInfo

-- | Information about a single variable of the query.
data VariableInfo
VariableInfo :: GType -> InputFieldInfo -> Maybe (Value Void) -> VariableInfo
[_viType] :: VariableInfo -> GType
[_viTypeInfo] :: VariableInfo -> InputFieldInfo
[_viDefaultValue] :: VariableInfo -> Maybe (Value Void)
data ScalarInfo
ScalarInfo :: ScalarTypeDefinition -> ScalarInfo
[_siTypeDefinition] :: ScalarInfo -> ScalarTypeDefinition
data EnumInfo
EnumInfo :: EnumTypeDefinition -> EnumInfo
[_eiTypeDefinition] :: EnumInfo -> EnumTypeDefinition
data ObjectInfo
ObjectInfo :: ObjectTypeDefinition InputValueDefinition -> HashMap Name FieldInfo -> ObjectInfo
[_oiTypeDefinition] :: ObjectInfo -> ObjectTypeDefinition InputValueDefinition
[_oiSelection] :: ObjectInfo -> HashMap Name FieldInfo
data InputObjectInfo
InputObjectInfo :: InputObjectTypeDefinition InputValueDefinition -> ~HashMap Name (GType, InputFieldInfo) -> InputObjectInfo
[_ioiTypeDefinition] :: InputObjectInfo -> InputObjectTypeDefinition InputValueDefinition

-- | lazy for knot-tying, as we build a graph
[_ioiFields] :: InputObjectInfo -> ~HashMap Name (GType, InputFieldInfo)

-- | Given the schema's definition, and a query, validate that the query is
--   consistent. We do this by running the analysis, but discarding the
--   result: we do not care about the structure, only about the validity of
--   the query.
--   
--   Returns <a>Nothing</a> if the query is valid, or a list of messages
--   otherwise.
diagnoseGraphQLQuery :: SchemaIntrospection -> TypedOperationDefinition NoFragments Name -> Maybe [Text]

-- | Given the schema's definition, and a query, run the analysis.
--   
--   We process all possible fields, and return a partially filled
--   structure if necessary. Given the following query:
--   
--   <pre>
--   query {
--     foo {
--       bar
--     }
--     does_not_exist {
--       ghsdflgh
--     }
--   }
--   </pre>
--   
--   We would return a structure containing:
--   
--   <pre>
--   foo: {
--     bar: {
--     }
--   }
--   </pre>
--   
--   AND an error about "does_not_exist" not existing.
--   
--   In some cases, however, we might not be able to produce a structure at
--   all, in which case we return <a>Nothing</a>. This either indicates
--   that something was fundamentally wrong with the structure of the query
--   (such as not finding an object at the top level), or that a
--   recoverable error was not caught properly (see
--   <a>withCatchAndRecord</a>).
analyzeGraphQLQuery :: SchemaIntrospection -> TypedOperationDefinition NoFragments Name -> (Maybe Structure, [Text])
instance GHC.Internal.Base.Applicative Hasura.GraphQL.Analyse.Analysis
instance GHC.Internal.Base.Functor Hasura.GraphQL.Analyse.Analysis
instance GHC.Internal.Base.Monad Hasura.GraphQL.Analyse.Analysis
instance Control.Monad.Error.Class.MonadError Hasura.GraphQL.Analyse.AnalysisError Hasura.GraphQL.Analyse.Analysis
instance GHC.Internal.Control.Monad.Fix.MonadFix Hasura.GraphQL.Analyse.Analysis
instance Control.Monad.Reader.Class.MonadReader (Hasura.GraphQL.Analyse.Path, Language.GraphQL.Draft.Syntax.SchemaIntrospection) Hasura.GraphQL.Analyse.Analysis
instance Control.Monad.Writer.Class.MonadWriter [Hasura.GraphQL.Analyse.AnalysisError] Hasura.GraphQL.Analyse.Analysis

module Hasura.QueryTags.Types

-- | QueryTagsConfig is the configuration created by the users to control
--   query tags
--   
--   This config let's hasura know about the following: 1. In what format
--   should the query tags be created 2. Should they be appended to the SQL
--   3. Should the request id be part of the query tags (which varies on
--   each request and will cause prepared statements to be re-prepared
--   every time)
--   
--   FWIW, <a>QueryTagsConfig</a> are coupled along with the Source
--   metadata. So you can also think <a>QueryTagsConfig</a> as the query
--   tags configuration for each source.
--   
--   The workflow is something like this:
--   
--   <ol>
--   <li>The <a>QueryTagsConfig</a> for a source is created from the
--   metadata we get from the user.</li>
--   <li>This configuration is packaged (for the lack of better word) along
--   with SourceConfigWith</li>
--   <li>These query tags configuration are extracted from the
--   <tt>SourceConfigWith</tt> in the <tt>mkDBQueryPlan</tt>,
--   <tt>mkDBMutationPlan</tt>, <tt>mkDBSubscriptionPlan</tt> functions and
--   are passed along to the point where the actual SQL generation takes
--   place</li>
--   </ol>
--   
--   Note that, it is important for <a>QueryTagsConfig</a> to be a part of
--   <tt>SourceConfigWith</tt> because that's the only sane way (that we
--   can think of) the `mkDB..Plan` functions can get the QueryTagsConfig.
data QueryTagsConfig
QueryTagsConfig :: !Bool -> !QueryTagsFormat -> !Bool -> QueryTagsConfig
[_qtcDisabled] :: QueryTagsConfig -> !Bool
[_qtcFormat] :: QueryTagsConfig -> !QueryTagsFormat
[_qtcOmitRequestId] :: QueryTagsConfig -> !Bool
data QueryTagsFormat
Standard :: QueryTagsFormat
SQLCommenter :: QueryTagsFormat
defaultQueryTagsConfig :: QueryTagsConfig
instance GHC.Classes.Eq Hasura.QueryTags.Types.QueryTagsConfig
instance GHC.Classes.Eq Hasura.QueryTags.Types.QueryTagsFormat
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.QueryTags.Types.QueryTagsConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.QueryTags.Types.QueryTagsFormat
instance GHC.Internal.Generics.Generic Hasura.QueryTags.Types.QueryTagsConfig
instance GHC.Internal.Generics.Generic Hasura.QueryTags.Types.QueryTagsFormat
instance Autodocodec.Class.HasCodec Hasura.QueryTags.Types.QueryTagsConfig
instance Autodocodec.Class.HasCodec Hasura.QueryTags.Types.QueryTagsFormat
instance Data.Hashable.Class.Hashable Hasura.QueryTags.Types.QueryTagsConfig
instance Data.Hashable.Class.Hashable Hasura.QueryTags.Types.QueryTagsFormat
instance Control.DeepSeq.NFData Hasura.QueryTags.Types.QueryTagsConfig
instance Control.DeepSeq.NFData Hasura.QueryTags.Types.QueryTagsFormat
instance GHC.Internal.Show.Show Hasura.QueryTags.Types.QueryTagsConfig
instance GHC.Internal.Show.Show Hasura.QueryTags.Types.QueryTagsFormat
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.QueryTags.Types.QueryTagsConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.QueryTags.Types.QueryTagsFormat

module Hasura.RQL.IR.BoolExp.RemoteRelationshipPredicate
data RemoteRelSessionVariableORLiteralValue
RemoteRelSessionVariable :: SessionVariable -> RemoteRelSessionVariableORLiteralValue
RemoteRelLiteralValue :: Text -> RemoteRelSessionVariableORLiteralValue
data RemoteRelRHSFetchWhereExp f
RemoteRelRHSFetchWhereExp :: f -> [RemoteRelSupportedOp RemoteRelSessionVariableORLiteralValue] -> RemoteRelRHSFetchWhereExp f
[rrrfweColumnFieldName] :: RemoteRelRHSFetchWhereExp f -> f
[rrrfweBoolExp] :: RemoteRelRHSFetchWhereExp f -> [RemoteRelSupportedOp RemoteRelSessionVariableORLiteralValue]
data RemoteRelSupportedOp field
RemoteRelEqOp :: field -> RemoteRelSupportedOp field
RemoteRelNeqOp :: field -> RemoteRelSupportedOp field
RemoteRelGtOp :: field -> RemoteRelSupportedOp field
RemoteRelLtOp :: field -> RemoteRelSupportedOp field
RemoteRelGteOp :: field -> RemoteRelSupportedOp field
RemoteRelLteOp :: field -> RemoteRelSupportedOp field
RemoteRelInOp :: [field] -> RemoteRelSupportedOp field
RemoteRelNinOp :: [field] -> RemoteRelSupportedOp field
RemoteRelLikeOp :: field -> RemoteRelSupportedOp field
RemoteRelNlikeOp :: field -> RemoteRelSupportedOp field
RemoteRelIsNullOp :: Bool -> RemoteRelSupportedOp field
instance Data.Aeson.Types.FromJSON.FromJSON f => Data.Aeson.Extended.FromJSONKeyValue (Hasura.RQL.IR.BoolExp.RemoteRelationshipPredicate.RemoteRelSupportedOp f)
instance Data.Aeson.Types.FromJSON.FromJSON f => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.IR.BoolExp.RemoteRelationshipPredicate.RemoteRelRHSFetchWhereExp f)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.IR.BoolExp.RemoteRelationshipPredicate.RemoteRelSessionVariableORLiteralValue

module Hasura.RQL.Types.ApiLimit
data ApiLimit
ApiLimit :: Maybe RateLimit -> Maybe DepthLimit -> Maybe NodeLimit -> Maybe TimeLimit -> Maybe BatchLimit -> Bool -> ApiLimit
[_alRateLimit] :: ApiLimit -> Maybe RateLimit
[_alDepthLimit] :: ApiLimit -> Maybe DepthLimit
[_alNodeLimit] :: ApiLimit -> Maybe NodeLimit
[_alTimeLimit] :: ApiLimit -> Maybe TimeLimit
[_alBatchLimit] :: ApiLimit -> Maybe BatchLimit
[_alDisabled] :: ApiLimit -> Bool
type DepthLimit = Limit MaxDepth
data Limit a
Limit :: a -> Map RoleName a -> Limit a
[_lGlobal] :: Limit a -> a
[_lPerRole] :: Limit a -> Map RoleName a
newtype MaxDepth
MaxDepth :: Int -> MaxDepth
[unMaxDepth] :: MaxDepth -> Int
newtype MaxNodes
MaxNodes :: Int -> MaxNodes
[unMaxNodes] :: MaxNodes -> Int
newtype MaxTime
MaxTime :: Seconds -> MaxTime
[unMaxTime] :: MaxTime -> Seconds
newtype MaxBatchSize
MaxBatchSize :: Int -> MaxBatchSize
[unMaxBatchSize] :: MaxBatchSize -> Int
type NodeLimit = Limit MaxNodes
type RateLimit = Limit RateLimitConfig
data RateLimitConfig
RateLimitConfig :: Int -> Maybe UniqueParamConfig -> RateLimitConfig
[_rlcMaxReqsPerMin] :: RateLimitConfig -> Int
[_rlcUniqueParams] :: RateLimitConfig -> Maybe UniqueParamConfig
type TimeLimit = Limit MaxTime
type BatchLimit = Limit MaxBatchSize

-- | The unique key using which an authenticated client can be identified
data UniqueParamConfig

-- | it can be a list of session variable (like session var in
--   <tt>UserInfo</tt>)
UPCSessionVar :: [Text] -> UniqueParamConfig

-- | or it can be an IP address
UPCIpAddress :: UniqueParamConfig
emptyApiLimit :: ApiLimit
instance GHC.Classes.Eq Hasura.RQL.Types.ApiLimit.ApiLimit
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.RQL.Types.ApiLimit.Limit a)
instance GHC.Classes.Eq Hasura.RQL.Types.ApiLimit.MaxBatchSize
instance GHC.Classes.Eq Hasura.RQL.Types.ApiLimit.MaxDepth
instance GHC.Classes.Eq Hasura.RQL.Types.ApiLimit.MaxNodes
instance GHC.Classes.Eq Hasura.RQL.Types.ApiLimit.MaxTime
instance GHC.Classes.Eq Hasura.RQL.Types.ApiLimit.RateLimitConfig
instance GHC.Classes.Eq Hasura.RQL.Types.ApiLimit.UniqueParamConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ApiLimit.ApiLimit
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.ApiLimit.Limit a)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ApiLimit.MaxBatchSize
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ApiLimit.MaxDepth
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ApiLimit.MaxNodes
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ApiLimit.MaxTime
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ApiLimit.RateLimitConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ApiLimit.UniqueParamConfig
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.ApiLimit.ApiLimit
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.ApiLimit.Limit a)
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.ApiLimit.MaxBatchSize
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.ApiLimit.MaxDepth
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.ApiLimit.MaxNodes
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.ApiLimit.MaxTime
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.ApiLimit.RateLimitConfig
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.ApiLimit.UniqueParamConfig
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.ApiLimit.ApiLimit
instance (Autodocodec.Class.HasCodec a, GHC.Internal.Data.Typeable.Internal.Typeable a) => Autodocodec.Class.HasCodec (Hasura.RQL.Types.ApiLimit.Limit a)
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.ApiLimit.MaxBatchSize
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.ApiLimit.MaxDepth
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.ApiLimit.MaxNodes
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.ApiLimit.MaxTime
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.ApiLimit.RateLimitConfig
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.ApiLimit.UniqueParamConfig
instance GHC.Classes.Ord Hasura.RQL.Types.ApiLimit.MaxBatchSize
instance GHC.Classes.Ord Hasura.RQL.Types.ApiLimit.MaxDepth
instance GHC.Classes.Ord Hasura.RQL.Types.ApiLimit.MaxNodes
instance GHC.Classes.Ord Hasura.RQL.Types.ApiLimit.MaxTime
instance GHC.Internal.Show.Show Hasura.RQL.Types.ApiLimit.ApiLimit
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (Hasura.RQL.Types.ApiLimit.Limit a)
instance GHC.Internal.Show.Show Hasura.RQL.Types.ApiLimit.MaxBatchSize
instance GHC.Internal.Show.Show Hasura.RQL.Types.ApiLimit.MaxDepth
instance GHC.Internal.Show.Show Hasura.RQL.Types.ApiLimit.MaxNodes
instance GHC.Internal.Show.Show Hasura.RQL.Types.ApiLimit.MaxTime
instance GHC.Internal.Show.Show Hasura.RQL.Types.ApiLimit.RateLimitConfig
instance GHC.Internal.Show.Show Hasura.RQL.Types.ApiLimit.UniqueParamConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ApiLimit.ApiLimit
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.ApiLimit.Limit a)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ApiLimit.MaxBatchSize
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ApiLimit.MaxDepth
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ApiLimit.MaxNodes
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ApiLimit.MaxTime
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ApiLimit.RateLimitConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ApiLimit.UniqueParamConfig
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.ApiLimit.MaxTime

module Hasura.RQL.Types.DataConnector

-- | Note: Currently you should not use underscores in this name. This
--   should be enforced in instances, and the <a>mkDataConnectorName</a>
--   smart constructor is available to assist.
data DataConnectorName
unDataConnectorName :: DataConnectorName -> Name
mkDataConnectorName :: Name -> Either String DataConnectorName
instance GHC.Classes.Eq Hasura.RQL.Types.DataConnector.DataConnectorName
instance Witch.From.From Hasura.RQL.Types.DataConnector.DataConnectorName Data.Text.NonEmpty.NonEmptyText
instance Witch.From.From Hasura.RQL.Types.DataConnector.DataConnectorName Data.Text.Internal.Text
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.DataConnector.DataConnectorName
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.RQL.Types.DataConnector.DataConnectorName
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.DataConnector.DataConnectorName
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.DataConnector.DataConnectorName
instance Control.DeepSeq.NFData Hasura.RQL.Types.DataConnector.DataConnectorName
instance GHC.Classes.Ord Hasura.RQL.Types.DataConnector.DataConnectorName
instance GHC.Internal.Show.Show Hasura.RQL.Types.DataConnector.DataConnectorName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.DataConnector.DataConnectorName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.Types.DataConnector.DataConnectorName
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.DataConnector.DataConnectorName

module Hasura.RQL.Types.BackendType

-- | Argument to Postgres; we represent backends which are variations on
--   Postgres as sub-types of Postgres. This value indicates which
--   "flavour" of Postgres a backend is.
data PostgresKind
Vanilla :: PostgresKind
Citus :: PostgresKind
Cockroach :: PostgresKind

-- | An enum that represents each backend we support.
data BackendType
Postgres :: PostgresKind -> BackendType
MSSQL :: BackendType
BigQuery :: BackendType
DataConnector :: BackendType

-- | Similar to <a>BackendType</a>, however, in the case of
--   <a>DataConnectorKind</a> we need to be able capture the name of the
--   data connector that should be used by the DataConnector backend. This
--   type correlates to the kind property of <tt>SourceMetadata</tt>, which
--   is usually just postgres, mssql, etc for static backends, but can be a
--   configurable value for DataConnector hence requiring
--   <a>DataConnectorName</a> for <a>DataConnectorKind</a>
--   
--   This type cannot entirely replace <a>BackendType</a> because
--   <a>BackendType</a> has a fixed number of possible values which can be
--   enumerated over at compile time, but <a>BackendSourceKind</a> does not
--   because DataConnector fundamentally is configured at runtime with
--   <a>DataConnectorName</a>.
data BackendSourceKind (b :: BackendType)
[PostgresVanillaKind] :: BackendSourceKind ('Postgres 'Vanilla)
[PostgresCitusKind] :: BackendSourceKind ('Postgres 'Citus)
[PostgresCockroachKind] :: BackendSourceKind ('Postgres 'Cockroach)
[MSSQLKind] :: BackendSourceKind 'MSSQL
[BigQueryKind] :: BackendSourceKind 'BigQuery
[DataConnectorKind] :: DataConnectorName -> BackendSourceKind 'DataConnector

-- | Some generated APIs use a shortened version of the backend's name
--   rather than its full name. This function returns the "short form" of a
--   backend, if any.
backendShortName :: BackendType -> Maybe Text
supportedBackends :: [BackendType]
backendTextNames :: BackendType -> [Text]

-- | This uses this lookup mechanism to avoid having to duplicate and
--   hardcode the backend string. We accept both the short form and the
--   long form of the backend's name.
backendTypeFromText :: Text -> Maybe BackendType
parseBackendTypeFromText :: Text -> Parser BackendType
backendTypeFromBackendSourceKind :: forall (b :: BackendType). BackendSourceKind b -> BackendType
instance GHC.Classes.Eq (Hasura.RQL.Types.BackendType.BackendSourceKind b)
instance GHC.Classes.Eq Hasura.RQL.Types.BackendType.BackendType
instance GHC.Classes.Eq Hasura.RQL.Types.BackendType.PostgresKind
instance Witch.From.From (Hasura.RQL.Types.BackendType.BackendSourceKind b) Data.Text.NonEmpty.NonEmptyText
instance Witch.From.From Hasura.RQL.Types.BackendType.BackendType Data.Text.NonEmpty.NonEmptyText
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.BackendType.BackendSourceKind ('Hasura.RQL.Types.BackendType.Postgres 'Hasura.RQL.Types.BackendType.Vanilla))
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.BackendType.BackendSourceKind ('Hasura.RQL.Types.BackendType.Postgres 'Hasura.RQL.Types.BackendType.Citus))
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.BackendType.BackendSourceKind ('Hasura.RQL.Types.BackendType.Postgres 'Hasura.RQL.Types.BackendType.Cockroach))
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.BackendType.BackendSourceKind 'Hasura.RQL.Types.BackendType.MSSQL)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.BackendType.BackendSourceKind 'Hasura.RQL.Types.BackendType.BigQuery)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.BackendType.BackendSourceKind 'Hasura.RQL.Types.BackendType.DataConnector)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.BackendType.BackendType
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.BackendType.BackendType
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.BackendType.PostgresKind
instance Autodocodec.Class.HasCodec (Hasura.RQL.Types.BackendType.BackendSourceKind ('Hasura.RQL.Types.BackendType.Postgres 'Hasura.RQL.Types.BackendType.Vanilla))
instance Autodocodec.Class.HasCodec (Hasura.RQL.Types.BackendType.BackendSourceKind ('Hasura.RQL.Types.BackendType.Postgres 'Hasura.RQL.Types.BackendType.Citus))
instance Autodocodec.Class.HasCodec (Hasura.RQL.Types.BackendType.BackendSourceKind ('Hasura.RQL.Types.BackendType.Postgres 'Hasura.RQL.Types.BackendType.Cockroach))
instance Autodocodec.Class.HasCodec (Hasura.RQL.Types.BackendType.BackendSourceKind 'Hasura.RQL.Types.BackendType.MSSQL)
instance Autodocodec.Class.HasCodec (Hasura.RQL.Types.BackendType.BackendSourceKind 'Hasura.RQL.Types.BackendType.BigQuery)
instance Autodocodec.Class.HasCodec (Hasura.RQL.Types.BackendType.BackendSourceKind 'Hasura.RQL.Types.BackendType.DataConnector)
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.BackendType.BackendType
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.BackendType.PostgresKind
instance GHC.Classes.Ord (Hasura.RQL.Types.BackendType.BackendSourceKind b)
instance GHC.Classes.Ord Hasura.RQL.Types.BackendType.BackendType
instance GHC.Classes.Ord Hasura.RQL.Types.BackendType.PostgresKind
instance GHC.Internal.Show.Show (Hasura.RQL.Types.BackendType.BackendSourceKind b)
instance GHC.Internal.Show.Show Hasura.RQL.Types.BackendType.BackendType
instance GHC.Internal.Show.Show Hasura.RQL.Types.BackendType.PostgresKind
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.BackendType.BackendSourceKind b)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.BackendType.BackendType
instance Data.Text.Extended.ToTxt (Hasura.RQL.Types.BackendType.BackendSourceKind b)
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.BackendType.BackendType

module Hasura.RQL.Types.BackendTag

-- | A singleton-like GADT that associates a tag to each backend.
data BackendTag (b :: BackendType)
[PostgresVanillaTag] :: BackendTag ('Postgres 'Vanilla)
[PostgresCitusTag] :: BackendTag ('Postgres 'Citus)
[PostgresCockroachTag] :: BackendTag ('Postgres 'Cockroach)
[MSSQLTag] :: BackendTag 'MSSQL
[BigQueryTag] :: BackendTag 'BigQuery
[DataConnectorTag] :: BackendTag 'DataConnector

-- | This class describes how to get a tag for a given type. We use it in
--   AnyBackend: `case backendTag @b of`...
class HasTag (b :: BackendType)
backendTag :: HasTag b => BackendTag b

-- | How to convert back from a tag to a runtime value.
reify :: forall (b :: BackendType). BackendTag b -> BackendType

-- | Provides a title-cased name for a database kind, inferring the
--   appropriate database kind from type context.
backendPrefix :: forall (b :: BackendType). HasTag b => Text
instance Data.GADT.Internal.GCompare Hasura.RQL.Types.BackendTag.BackendTag
instance Data.GADT.Internal.GEq Hasura.RQL.Types.BackendTag.BackendTag
instance Hasura.RQL.Types.BackendTag.HasTag 'Hasura.RQL.Types.BackendType.BigQuery
instance Hasura.RQL.Types.BackendTag.HasTag 'Hasura.RQL.Types.BackendType.DataConnector
instance Hasura.RQL.Types.BackendTag.HasTag 'Hasura.RQL.Types.BackendType.MSSQL
instance Hasura.RQL.Types.BackendTag.HasTag ('Hasura.RQL.Types.BackendType.Postgres 'Hasura.RQL.Types.BackendType.Vanilla)
instance Hasura.RQL.Types.BackendTag.HasTag ('Hasura.RQL.Types.BackendType.Postgres 'Hasura.RQL.Types.BackendType.Citus)
instance Hasura.RQL.Types.BackendTag.HasTag ('Hasura.RQL.Types.BackendType.Postgres 'Hasura.RQL.Types.BackendType.Cockroach)

module Hasura.RQL.Types.EECredentials
data EEClientCredentials
EEClientCredentials :: EEClientId -> Text -> EEClientCredentials
[eccClientId] :: EEClientCredentials -> EEClientId
[eccClientSecret] :: EEClientCredentials -> Text
newtype EEClientId
EEClientId :: Text -> EEClientId
[_getEEClientId] :: EEClientId -> Text
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.EECredentials.EEClientCredentials
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.EECredentials.EEClientId

module Hasura.RQL.Types.Endpoint.Trie

-- | Trie from <a>PathComponent</a>s to <tt>MultiMap</tt>s
type MultiMapPathTrie a k v = Trie PathComponent a MultiMap k v

-- | Result of matching a path <tt>[<a>PathComponent</a>] a</tt> and key
--   <tt>k</tt> in a <a>MultiMapPathTrie</a>.
--   
--   <a>MatchResult</a> is a lattice where <a>MatchNotFound</a> is the
--   bottom element and <a>MatchAmbiguous</a> is the top element:
--   
--   MatchAmbiguous / MatchFound v0 as0 MatchFound v1 as1 / MatchMissingKey
--   (ks0 &lt;&gt; ks1) / MatchMissingKey ks0 MatchMissingKey ks1 /
--   MatchNotFound
data MatchResult a k v

-- | Multiple results.
MatchAmbiguous :: MatchResult a k v

-- | A single unambiguous result. Returns the value found and a list of
--   parameter bindings.
MatchFound :: v -> [a] -> MatchResult a k v

-- | A path was found, but not a key. Returns a list of keys found.
MatchMissingKey :: NonEmpty k -> MatchResult a k v

-- | Path was not found in the <a>MultiMapPathTrie</a>.
MatchNotFound :: MatchResult a k v

-- | A component in a URL path: either a literal or a wildcard parameter
data PathComponent a
PathLiteral :: a -> PathComponent a
PathParam :: PathComponent a

-- | Match a key <tt>k</tt> and path <tt>[a]</tt> against a
--   <tt>MultiMapPathTrie a k v</tt>
matchPath :: (Hashable k, Hashable a) => k -> [a] -> MultiMapPathTrie a k v -> MatchResult a k v

-- | Detect and return all ambiguous paths in the <tt>MultiMapPathTrie</tt>
--   A path <tt>p</tt> is ambiguous if <tt>matchPath k p</tt> can return
--   <tt>MatchAmbiguous</tt> for some <tt>k</tt>.
ambiguousPaths :: (Hashable a, Hashable k, Ord v) => MultiMapPathTrie a k v -> [([PathComponent a], Set v)]

-- | A version of ambiguousPaths that attempts to group all ambiguous paths
--   that have overlapping endpoints
ambiguousPathsGrouped :: (Hashable a, Hashable k, Ord v, Ord a) => MultiMapPathTrie a k v -> [(Set [PathComponent a], Set v)]
instance (GHC.Classes.Eq v, GHC.Classes.Eq a, GHC.Classes.Eq k) => GHC.Classes.Eq (Hasura.RQL.Types.Endpoint.Trie.MatchResult a k v)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.RQL.Types.Endpoint.Trie.PathComponent a)
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Endpoint.Trie.PathComponent a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.RQL.Types.Endpoint.Trie.PathComponent a)
instance GHC.Internal.Base.Monoid (Hasura.RQL.Types.Endpoint.Trie.MatchResult a k v)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Hasura.RQL.Types.Endpoint.Trie.PathComponent a)
instance GHC.Internal.Base.Semigroup (Hasura.RQL.Types.Endpoint.Trie.MatchResult a k v)
instance (GHC.Internal.Show.Show v, GHC.Internal.Show.Show a, GHC.Internal.Show.Show k) => GHC.Internal.Show.Show (Hasura.RQL.Types.Endpoint.Trie.MatchResult a k v)
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (Hasura.RQL.Types.Endpoint.Trie.PathComponent a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSONKey (Hasura.RQL.Types.Endpoint.Trie.PathComponent a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Endpoint.Trie.PathComponent a)

module Hasura.RQL.Types.GraphqlSchemaIntrospection
newtype SetGraphqlIntrospectionOptions
SetGraphqlIntrospectionOptions :: HashSet RoleName -> SetGraphqlIntrospectionOptions
[_idrDisabledForRoles] :: SetGraphqlIntrospectionOptions -> HashSet RoleName
instance GHC.Classes.Eq Hasura.RQL.Types.GraphqlSchemaIntrospection.SetGraphqlIntrospectionOptions
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.GraphqlSchemaIntrospection.SetGraphqlIntrospectionOptions
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.GraphqlSchemaIntrospection.SetGraphqlIntrospectionOptions
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.GraphqlSchemaIntrospection.SetGraphqlIntrospectionOptions
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.GraphqlSchemaIntrospection.SetGraphqlIntrospectionOptions
instance GHC.Internal.Base.Monoid Hasura.RQL.Types.GraphqlSchemaIntrospection.SetGraphqlIntrospectionOptions
instance Control.DeepSeq.NFData Hasura.RQL.Types.GraphqlSchemaIntrospection.SetGraphqlIntrospectionOptions
instance GHC.Internal.Base.Semigroup Hasura.RQL.Types.GraphqlSchemaIntrospection.SetGraphqlIntrospectionOptions
instance GHC.Internal.Show.Show Hasura.RQL.Types.GraphqlSchemaIntrospection.SetGraphqlIntrospectionOptions
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.GraphqlSchemaIntrospection.SetGraphqlIntrospectionOptions

module Hasura.RQL.Types.Headers
data HeaderConf
HeaderConf :: HeaderName -> HeaderValue -> HeaderConf
data HeaderValue
HVValue :: Template -> HeaderValue
HVEnv :: Text -> HeaderValue
instance GHC.Classes.Eq Hasura.RQL.Types.Headers.HeaderConf
instance GHC.Classes.Eq Hasura.RQL.Types.Headers.HeaderValue
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Headers.HeaderConf
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Headers.HeaderConf
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Headers.HeaderValue
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Headers.HeaderConf
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Headers.HeaderConf
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Headers.HeaderValue
instance Control.DeepSeq.NFData Hasura.RQL.Types.Headers.HeaderConf
instance Control.DeepSeq.NFData Hasura.RQL.Types.Headers.HeaderValue
instance GHC.Internal.Show.Show Hasura.RQL.Types.Headers.HeaderConf
instance GHC.Internal.Show.Show Hasura.RQL.Types.Headers.HeaderValue
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Headers.HeaderConf


-- | This module contains types which are common to event triggers and
--   scheduled triggers.
module Hasura.RQL.Types.Eventing
newtype ClientError
ClientError :: SerializableBlob -> ClientError
[_ceMessage] :: ClientError -> SerializableBlob
newtype EventId
EventId :: Text -> EventId
[unEventId] :: EventId -> Text
data Invocation (a :: TriggerTypes)
Invocation :: EventId -> Maybe Int -> WebhookRequest -> Response a -> Invocation (a :: TriggerTypes)
[iEventId] :: Invocation (a :: TriggerTypes) -> EventId
[iStatus] :: Invocation (a :: TriggerTypes) -> Maybe Int
[iRequest] :: Invocation (a :: TriggerTypes) -> WebhookRequest
[iResponse] :: Invocation (a :: TriggerTypes) -> Response a
type InvocationVersion = Text

-- | PGTextArray is only used for PG array encoding
newtype PGTextArray
PGTextArray :: [Text] -> PGTextArray
[unPGTextArray] :: PGTextArray -> [Text]
data Response (a :: TriggerTypes)
ResponseHTTP :: WebhookResponse -> Response (a :: TriggerTypes)
ResponseError :: ClientError -> Response (a :: TriggerTypes)

-- | There are two types of events: EventType (for event triggers) and
--   ScheduledType (for scheduled triggers)
data TriggerTypes
EventType :: TriggerTypes
ScheduledType :: TriggerTypes
data WebhookRequest
WebhookRequest :: Value -> [HeaderConf] -> Text -> WebhookRequest
[_rqPayload] :: WebhookRequest -> Value
[_rqHeaders] :: WebhookRequest -> [HeaderConf]
[_rqVersion] :: WebhookRequest -> Text
data WebhookResponse
WebhookResponse :: SerializableBlob -> [HeaderConf] -> Int -> WebhookResponse
[_wrsBody] :: WebhookResponse -> SerializableBlob
[_wrsHeaders] :: WebhookResponse -> [HeaderConf]
[_wrsStatus] :: WebhookResponse -> Int

-- | Used to construct the payload of Event Trigger
--   
--   OLD: Depicts the old database row value for UPDATE/DELETE trigger
--   operations. This is used to construct the 'data.old' field of the
--   event trigger payload. The value of 'data.old' is null in INSERT
--   trigger operation.
--   
--   NEW: Depicts the new database row value for INSERT/UPDATE trigger
--   operations. This is used to construct the 'data.new' field of the
--   event trigger payload. The value of 'data.new' is null in DELETE
--   trigger operation.
data OpVar
OLD :: OpVar
NEW :: OpVar
invocationVersionET :: InvocationVersion
invocationVersionST :: InvocationVersion
instance GHC.Classes.Eq Hasura.RQL.Types.Eventing.EventId
instance GHC.Classes.Eq Hasura.RQL.Types.Eventing.PGTextArray
instance Database.PG.Query.Class.FromCol Hasura.RQL.Types.Eventing.EventId
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Eventing.EventId
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Eventing.ClientError
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Eventing.EventId
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Eventing.WebhookRequest
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Eventing.WebhookResponse
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Eventing.EventId
instance Control.DeepSeq.NFData Hasura.RQL.Types.Eventing.EventId
instance GHC.Classes.Ord Hasura.RQL.Types.Eventing.EventId
instance GHC.Internal.Show.Show Hasura.RQL.Types.Eventing.EventId
instance GHC.Internal.Show.Show Hasura.RQL.Types.Eventing.OpVar
instance GHC.Internal.Show.Show Hasura.RQL.Types.Eventing.PGTextArray
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.Types.Eventing.EventId
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Eventing.ClientError
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Eventing.EventId
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Eventing.Response 'Hasura.RQL.Types.Eventing.EventType)
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Eventing.Response 'Hasura.RQL.Types.Eventing.ScheduledType)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Eventing.WebhookRequest
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Eventing.WebhookResponse
instance Database.PG.Query.Class.ToPrepArg Hasura.RQL.Types.Eventing.EventId
instance Database.PG.Query.Class.ToPrepArg Hasura.RQL.Types.Eventing.PGTextArray
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.Eventing.EventId

module Hasura.RQL.DDL.Headers

-- | Resolve configuration headers
makeHeadersFromConf :: MonadError QErr m => Environment -> [HeaderConf] -> m [Header]

-- | Encode headers to HeaderConf
toHeadersConf :: [Header] -> [HeaderConf]


-- | Provides a data type that holds all of the required implementation
--   details for a backend that supports health checks.
module Hasura.RQL.Types.HealthCheckImplementation
data HealthCheckImplementation healthCheckTest
HealthCheckImplementation :: healthCheckTest -> JSONCodec healthCheckTest -> HealthCheckImplementation healthCheckTest
[_hciDefaultTest] :: HealthCheckImplementation healthCheckTest -> healthCheckTest
[_hciTestCodec] :: HealthCheckImplementation healthCheckTest -> JSONCodec healthCheckTest

module Hasura.RQL.Types.NamingCase

-- | Represents the different possible type cases for fields and types,
--   i.e. <tt>HasuraCase</tt> and <tt>GraphqlCase</tt> (<tt>CamelCase</tt>
--   fields and <tt>PascalCase</tt> types).
data NamingCase
HasuraCase :: NamingCase
GraphqlCase :: NamingCase
parseNamingConventionFromText :: Text -> Either String NamingCase
instance GHC.Classes.Eq Hasura.RQL.Types.NamingCase.NamingCase
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.NamingCase.NamingCase
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.NamingCase.NamingCase
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.NamingCase.NamingCase
instance GHC.Internal.Show.Show Hasura.RQL.Types.NamingCase.NamingCase
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.NamingCase.NamingCase

module Hasura.RQL.Types.QueryCollection
newtype CollectionName
CollectionName :: NonEmptyText -> CollectionName
[unCollectionName] :: CollectionName -> NonEmptyText
newtype CollectionDef
CollectionDef :: [ListedQuery] -> CollectionDef
[_cdQueries] :: CollectionDef -> [ListedQuery]
cdQueries :: Iso' CollectionDef [ListedQuery]
data CreateCollection
CreateCollection :: CollectionName -> CollectionDef -> Maybe Text -> CreateCollection
[_ccName] :: CreateCollection -> CollectionName
[_ccDefinition] :: CreateCollection -> CollectionDef
[_ccComment] :: CreateCollection -> Maybe Text
ccName :: Lens' CreateCollection CollectionName
ccDefinition :: Lens' CreateCollection CollectionDef
ccComment :: Lens' CreateCollection (Maybe Text)
data RenameCollection
RenameCollection :: CollectionName -> CollectionName -> RenameCollection
[_rcName] :: RenameCollection -> CollectionName
[_rcNewName] :: RenameCollection -> CollectionName
rcName :: Lens' RenameCollection CollectionName
rcNewName :: Lens' RenameCollection CollectionName
data AddQueryToCollection
AddQueryToCollection :: CollectionName -> QueryName -> GQLQueryWithText -> AddQueryToCollection
[_aqtcCollectionName] :: AddQueryToCollection -> CollectionName
[_aqtcQueryName] :: AddQueryToCollection -> QueryName
[_aqtcQuery] :: AddQueryToCollection -> GQLQueryWithText
data DropQueryFromCollection
DropQueryFromCollection :: CollectionName -> QueryName -> DropQueryFromCollection
[_dqfcCollectionName] :: DropQueryFromCollection -> CollectionName
[_dqfcQueryName] :: DropQueryFromCollection -> QueryName
data DropCollection
DropCollection :: CollectionName -> Bool -> DropCollection
[_dcCollection] :: DropCollection -> CollectionName
[_dcCascade] :: DropCollection -> Bool
newtype GQLQuery
GQLQuery :: ExecutableDocument Name -> GQLQuery
[unGQLQuery] :: GQLQuery -> ExecutableDocument Name
newtype GQLQueryWithText
GQLQueryWithText :: (Text, GQLQuery) -> GQLQueryWithText
newtype QueryName
QueryName :: NonEmptyText -> QueryName
[unQueryName] :: QueryName -> NonEmptyText
data ListedQuery
ListedQuery :: QueryName -> GQLQueryWithText -> ListedQuery
[_lqName] :: ListedQuery -> QueryName
[_lqQuery] :: ListedQuery -> GQLQueryWithText
getGQLQuery :: GQLQueryWithText -> GQLQuery
getGQLQueryText :: GQLQueryWithText -> Text
type QueryCollections = InsOrdHashMap CollectionName CreateCollection
collectionQueries :: CreateCollection -> [ExecutableDocument Name]
instance GHC.Classes.Eq Hasura.RQL.Types.QueryCollection.AddQueryToCollection
instance GHC.Classes.Eq Hasura.RQL.Types.QueryCollection.CollectionDef
instance GHC.Classes.Eq Hasura.RQL.Types.QueryCollection.CollectionName
instance GHC.Classes.Eq Hasura.RQL.Types.QueryCollection.CreateCollection
instance GHC.Classes.Eq Hasura.RQL.Types.QueryCollection.DropCollection
instance GHC.Classes.Eq Hasura.RQL.Types.QueryCollection.DropQueryFromCollection
instance GHC.Classes.Eq Hasura.RQL.Types.QueryCollection.GQLQuery
instance GHC.Classes.Eq Hasura.RQL.Types.QueryCollection.GQLQueryWithText
instance GHC.Classes.Eq Hasura.RQL.Types.QueryCollection.ListedQuery
instance GHC.Classes.Eq Hasura.RQL.Types.QueryCollection.QueryName
instance GHC.Classes.Eq Hasura.RQL.Types.QueryCollection.RenameCollection
instance Database.PG.Query.Class.FromCol Hasura.RQL.Types.QueryCollection.CollectionName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.QueryCollection.AddQueryToCollection
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.QueryCollection.CollectionDef
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.QueryCollection.CollectionName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.QueryCollection.CreateCollection
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.QueryCollection.DropCollection
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.QueryCollection.DropQueryFromCollection
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.QueryCollection.GQLQuery
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.QueryCollection.GQLQueryWithText
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.QueryCollection.ListedQuery
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.QueryCollection.QueryName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.QueryCollection.RenameCollection
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.QueryCollection.AddQueryToCollection
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.QueryCollection.CollectionDef
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.QueryCollection.CollectionName
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.QueryCollection.CreateCollection
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.QueryCollection.DropCollection
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.QueryCollection.DropQueryFromCollection
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.QueryCollection.GQLQueryWithText
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.QueryCollection.ListedQuery
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.QueryCollection.QueryName
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.QueryCollection.RenameCollection
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.QueryCollection.CollectionDef
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.QueryCollection.CollectionName
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.QueryCollection.CreateCollection
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.QueryCollection.GQLQuery
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.QueryCollection.GQLQueryWithText
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.QueryCollection.ListedQuery
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.QueryCollection.QueryName
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.QueryCollection.CollectionName
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.QueryCollection.GQLQuery
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.QueryCollection.GQLQueryWithText
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.QueryCollection.ListedQuery
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.QueryCollection.QueryName
instance Control.DeepSeq.NFData Hasura.RQL.Types.QueryCollection.CollectionDef
instance Control.DeepSeq.NFData Hasura.RQL.Types.QueryCollection.GQLQuery
instance Control.DeepSeq.NFData Hasura.RQL.Types.QueryCollection.GQLQueryWithText
instance Control.DeepSeq.NFData Hasura.RQL.Types.QueryCollection.ListedQuery
instance Control.DeepSeq.NFData Hasura.RQL.Types.QueryCollection.QueryName
instance GHC.Classes.Ord Hasura.RQL.Types.QueryCollection.CollectionName
instance GHC.Classes.Ord Hasura.RQL.Types.QueryCollection.GQLQuery
instance GHC.Classes.Ord Hasura.RQL.Types.QueryCollection.GQLQueryWithText
instance GHC.Classes.Ord Hasura.RQL.Types.QueryCollection.ListedQuery
instance GHC.Classes.Ord Hasura.RQL.Types.QueryCollection.QueryName
instance GHC.Internal.Show.Show Hasura.RQL.Types.QueryCollection.AddQueryToCollection
instance GHC.Internal.Show.Show Hasura.RQL.Types.QueryCollection.CollectionDef
instance GHC.Internal.Show.Show Hasura.RQL.Types.QueryCollection.CollectionName
instance GHC.Internal.Show.Show Hasura.RQL.Types.QueryCollection.CreateCollection
instance GHC.Internal.Show.Show Hasura.RQL.Types.QueryCollection.DropCollection
instance GHC.Internal.Show.Show Hasura.RQL.Types.QueryCollection.DropQueryFromCollection
instance GHC.Internal.Show.Show Hasura.RQL.Types.QueryCollection.GQLQuery
instance GHC.Internal.Show.Show Hasura.RQL.Types.QueryCollection.GQLQueryWithText
instance GHC.Internal.Show.Show Hasura.RQL.Types.QueryCollection.ListedQuery
instance GHC.Internal.Show.Show Hasura.RQL.Types.QueryCollection.QueryName
instance GHC.Internal.Show.Show Hasura.RQL.Types.QueryCollection.RenameCollection
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.Types.QueryCollection.CollectionName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.Types.QueryCollection.QueryName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.QueryCollection.AddQueryToCollection
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.QueryCollection.CollectionDef
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.QueryCollection.CollectionName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.QueryCollection.CreateCollection
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.QueryCollection.DropCollection
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.QueryCollection.DropQueryFromCollection
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.QueryCollection.GQLQuery
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.QueryCollection.GQLQueryWithText
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.QueryCollection.ListedQuery
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.QueryCollection.QueryName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.QueryCollection.RenameCollection
instance Database.PG.Query.Class.ToPrepArg Hasura.RQL.Types.QueryCollection.CollectionName
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.QueryCollection.CollectionName
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.QueryCollection.QueryName

module Hasura.RQL.Types.Endpoint
newtype EndpointName
EndpointName :: NonEmptyText -> EndpointName
[unEndpointName] :: EndpointName -> NonEmptyText
data EndpointMethod
GET :: EndpointMethod
POST :: EndpointMethod
PUT :: EndpointMethod
DELETE :: EndpointMethod
PATCH :: EndpointMethod
data EndpointUrl
type CreateEndpoint = EndpointMetadata QueryReference
data EndpointDef query
EndpointDef :: query -> EndpointDef query
[_edQuery] :: EndpointDef query -> query
data QueryReference
QueryReference :: CollectionName -> QueryName -> QueryReference
[_qrCollectionName] :: QueryReference -> CollectionName
[_qrQueryName] :: QueryReference -> QueryName
data EndpointMetadata query
EndpointMetadata :: EndpointName -> EndpointUrl -> NonEmpty EndpointMethod -> EndpointDef query -> Maybe Text -> EndpointMetadata query
[_ceName] :: EndpointMetadata query -> EndpointName
[_ceUrl] :: EndpointMetadata query -> EndpointUrl
[_ceMethods] :: EndpointMetadata query -> NonEmpty EndpointMethod
[_ceDefinition] :: EndpointMetadata query -> EndpointDef query
[_ceComment] :: EndpointMetadata query -> Maybe Text
data DropEndpoint
DropEndpoint :: EndpointName -> DropEndpoint
[_deName] :: DropEndpoint -> EndpointName
type EndpointTrie query = MultiMapPathTrie Text EndpointMethod EndpointMetadata query
buildEndpointsTrie :: Ord query => [EndpointMetadata query] -> EndpointTrie query
qrCollectionName :: Lens' QueryReference CollectionName
qrQueryName :: Lens' QueryReference QueryName
edQuery :: forall query1 query2 p f. (Profunctor p, Functor f) => p query1 (f query2) -> p (EndpointDef query1) (f (EndpointDef query2))
ceComment :: forall query f. Functor f => (Maybe Text -> f (Maybe Text)) -> EndpointMetadata query -> f (EndpointMetadata query)
ceDefinition :: forall query1 query2 f. Functor f => (EndpointDef query1 -> f (EndpointDef query2)) -> EndpointMetadata query1 -> f (EndpointMetadata query2)
ceMethods :: forall query f. Functor f => (NonEmpty EndpointMethod -> f (NonEmpty EndpointMethod)) -> EndpointMetadata query -> f (EndpointMetadata query)
ceName :: forall query f. Functor f => (EndpointName -> f EndpointName) -> EndpointMetadata query -> f (EndpointMetadata query)
ceUrl :: forall query f. Functor f => (EndpointUrl -> f EndpointUrl) -> EndpointMetadata query -> f (EndpointMetadata query)
deName :: Iso' DropEndpoint EndpointName

-- | Split a path and construct PathSegments based on callbacks for
--   variables and literals Var callback is passed the ":" prefix as part
--   of the text.
splitPath :: (Text -> a) -> (Text -> a) -> EndpointUrl -> [a]
mkEndpointUrl :: ToTxt a => a -> Maybe EndpointUrl
unEndpointUrl :: EndpointUrl -> NonEmptyText
instance GHC.Internal.Enum.Bounded Hasura.RQL.Types.Endpoint.EndpointMethod
instance GHC.Internal.Enum.Enum Hasura.RQL.Types.Endpoint.EndpointMethod
instance GHC.Classes.Eq Hasura.RQL.Types.Endpoint.DropEndpoint
instance GHC.Classes.Eq query => GHC.Classes.Eq (Hasura.RQL.Types.Endpoint.EndpointDef query)
instance GHC.Classes.Eq query => GHC.Classes.Eq (Hasura.RQL.Types.Endpoint.EndpointMetadata query)
instance GHC.Classes.Eq Hasura.RQL.Types.Endpoint.EndpointMethod
instance GHC.Classes.Eq Hasura.RQL.Types.Endpoint.EndpointName
instance GHC.Classes.Eq Hasura.RQL.Types.Endpoint.EndpointUrl
instance GHC.Classes.Eq Hasura.RQL.Types.Endpoint.QueryReference
instance GHC.Internal.Data.Foldable.Foldable Hasura.RQL.Types.Endpoint.EndpointDef
instance GHC.Internal.Data.Foldable.Foldable Hasura.RQL.Types.Endpoint.EndpointMetadata
instance Web.Internal.HttpApiData.FromHttpApiData Hasura.RQL.Types.Endpoint.EndpointUrl
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Endpoint.DropEndpoint
instance Data.Aeson.Types.FromJSON.FromJSON query => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Endpoint.EndpointDef query)
instance Data.Aeson.Types.FromJSON.FromJSON query => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Endpoint.EndpointMetadata query)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Endpoint.EndpointMethod
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Endpoint.EndpointName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Endpoint.EndpointUrl
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Endpoint.QueryReference
instance GHC.Internal.Base.Functor Hasura.RQL.Types.Endpoint.EndpointDef
instance GHC.Internal.Base.Functor Hasura.RQL.Types.Endpoint.EndpointMetadata
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Endpoint.DropEndpoint
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Endpoint.EndpointDef query)
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Endpoint.EndpointMetadata query)
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Endpoint.EndpointMethod
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Endpoint.QueryReference
instance (Autodocodec.Class.HasCodec query, GHC.Internal.Data.Typeable.Internal.Typeable query) => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Endpoint.EndpointDef query)
instance (Autodocodec.Class.HasCodec query, GHC.Internal.Data.Typeable.Internal.Typeable query) => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Endpoint.EndpointMetadata query)
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Endpoint.EndpointMethod
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Endpoint.EndpointName
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Endpoint.EndpointUrl
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Endpoint.QueryReference
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Endpoint.EndpointMethod
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Endpoint.EndpointName
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Endpoint.EndpointUrl
instance GHC.Classes.Ord query => GHC.Classes.Ord (Hasura.RQL.Types.Endpoint.EndpointDef query)
instance GHC.Classes.Ord query => GHC.Classes.Ord (Hasura.RQL.Types.Endpoint.EndpointMetadata query)
instance GHC.Classes.Ord Hasura.RQL.Types.Endpoint.EndpointMethod
instance GHC.Classes.Ord Hasura.RQL.Types.Endpoint.EndpointName
instance GHC.Classes.Ord Hasura.RQL.Types.Endpoint.EndpointUrl
instance GHC.Internal.Show.Show Hasura.RQL.Types.Endpoint.DropEndpoint
instance GHC.Internal.Show.Show query => GHC.Internal.Show.Show (Hasura.RQL.Types.Endpoint.EndpointDef query)
instance GHC.Internal.Show.Show query => GHC.Internal.Show.Show (Hasura.RQL.Types.Endpoint.EndpointMetadata query)
instance GHC.Internal.Show.Show Hasura.RQL.Types.Endpoint.EndpointMethod
instance GHC.Internal.Show.Show Hasura.RQL.Types.Endpoint.EndpointName
instance GHC.Internal.Show.Show Hasura.RQL.Types.Endpoint.EndpointUrl
instance GHC.Internal.Show.Show Hasura.RQL.Types.Endpoint.QueryReference
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.Types.Endpoint.EndpointMethod
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Endpoint.DropEndpoint
instance Data.Aeson.Types.ToJSON.ToJSON query => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Endpoint.EndpointDef query)
instance Data.Aeson.Types.ToJSON.ToJSON query => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Endpoint.EndpointMetadata query)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Endpoint.EndpointMethod
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Endpoint.EndpointName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Endpoint.EndpointUrl
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Endpoint.QueryReference
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.Endpoint.EndpointMethod
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.Endpoint.EndpointName
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.Endpoint.EndpointUrl
instance GHC.Internal.Data.Traversable.Traversable Hasura.RQL.Types.Endpoint.EndpointDef
instance GHC.Internal.Data.Traversable.Traversable Hasura.RQL.Types.Endpoint.EndpointMetadata

module Hasura.RQL.Types.Allowlist

-- | InlinedAllowlist is the data type with which the allowlist is
--   represented in the schema cache, it contains a global and a per role
--   allowlist and when allowlist is enabled in the graphql-engine, the
--   incoming query for a non-admin role should either be in the global
--   allowlist or in the given role's role based allowlist.
--   
--   Essentially, it's a memoization of <a>allowlistAllowsQuery</a>
--   implemented in terms of <a>MetadataAllowlist</a>.
data InlinedAllowlist
InlinedAllowlist :: HashSet NormalizedQuery -> HashMap RoleName (HashSet NormalizedQuery) -> InlinedAllowlist
[iaGlobal] :: InlinedAllowlist -> HashSet NormalizedQuery
[iaPerRole] :: InlinedAllowlist -> HashMap RoleName (HashSet NormalizedQuery)
inlineAllowlist :: QueryCollections -> MetadataAllowlist -> InlinedAllowlist

-- | The mode in which the allowlist functions. In global mode, collections
--   with non-global scope are ignored.
data AllowlistMode
AllowlistModeGlobalOnly :: AllowlistMode
AllowlistModeFull :: AllowlistMode
allowlistAllowsQuery :: InlinedAllowlist -> AllowlistMode -> RoleName -> ExecutableDocument Name -> Bool
data AllowlistEntry
AllowlistEntry :: CollectionName -> AllowlistScope -> AllowlistEntry
[aeCollection] :: AllowlistEntry -> CollectionName
[aeScope] :: AllowlistEntry -> AllowlistScope

-- | Wrap <a>AllowlistEntry</a> with a FromJSON instance that requires
--   <tt>scope</tt> to be set.
newtype UpdateScopeOfCollectionInAllowlist
UpdateScopeOfCollectionInAllowlist :: AllowlistEntry -> UpdateScopeOfCollectionInAllowlist
type MetadataAllowlist = InsOrdHashMap CollectionName AllowlistEntry
newtype DropCollectionFromAllowlist
DropCollectionFromAllowlist :: CollectionName -> DropCollectionFromAllowlist
[_dcfaCollection] :: DropCollectionFromAllowlist -> CollectionName
data AllowlistScope
AllowlistScopeGlobal :: AllowlistScope
AllowlistScopeRoles :: NonEmpty RoleName -> AllowlistScope
metadataAllowlistInsert :: AllowlistEntry -> MetadataAllowlist -> Either Text MetadataAllowlist
metadataAllowlistUpdateScope :: AllowlistEntry -> MetadataAllowlist -> Either Text MetadataAllowlist

-- | Produce a list of all collections in the allowlist. This is used in
--   <tt>runDropCollection</tt> to function to ensure that we don't delete
--   any collections which are referred to in the allowlist.
metadataAllowlistAllCollections :: MetadataAllowlist -> [CollectionName]

-- | A query stripped of typenames. A query is allowed if it occurs in an
--   allowed query collection after normalization.
--   
--   Compare docs<i>graphql</i>core<i>deployment</i>allow-list.rst.
newtype NormalizedQuery
NormalizedQuery :: ExecutableDocument Name -> NormalizedQuery
[unNormalizedQuery] :: NormalizedQuery -> ExecutableDocument Name
instance GHC.Classes.Eq Hasura.RQL.Types.Allowlist.AllowlistEntry
instance GHC.Classes.Eq Hasura.RQL.Types.Allowlist.AllowlistScope
instance GHC.Classes.Eq Hasura.RQL.Types.Allowlist.DropCollectionFromAllowlist
instance GHC.Classes.Eq Hasura.RQL.Types.Allowlist.InlinedAllowlist
instance GHC.Classes.Eq Hasura.RQL.Types.Allowlist.NormalizedQuery
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Allowlist.AllowlistEntry
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Allowlist.AllowlistScope
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Allowlist.DropCollectionFromAllowlist
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Allowlist.UpdateScopeOfCollectionInAllowlist
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Allowlist.AllowlistEntry
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Allowlist.AllowlistScope
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Allowlist.DropCollectionFromAllowlist
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Allowlist.InlinedAllowlist
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Allowlist.AllowlistEntry
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Allowlist.AllowlistScope
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Allowlist.NormalizedQuery
instance GHC.Internal.Show.Show Hasura.RQL.Types.Allowlist.AllowlistEntry
instance GHC.Internal.Show.Show Hasura.RQL.Types.Allowlist.AllowlistScope
instance GHC.Internal.Show.Show Hasura.RQL.Types.Allowlist.DropCollectionFromAllowlist
instance GHC.Internal.Show.Show Hasura.RQL.Types.Allowlist.InlinedAllowlist
instance GHC.Internal.Show.Show Hasura.RQL.Types.Allowlist.NormalizedQuery
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Allowlist.AllowlistEntry
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Allowlist.AllowlistScope
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Allowlist.DropCollectionFromAllowlist
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Allowlist.InlinedAllowlist
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Allowlist.NormalizedQuery


-- | Types related to resizing a connection pool
--   
--   Resize connection pools, on-demand, based on underlying server
--   replicas
--   
--   See @<tt>resizeSourcePools</tt> in Hasura.RQL.Types.Backend
module Hasura.RQL.Types.ResizePool

-- | Number of server instances. A wrapper over <tt><a>Word</a> type, a
--   non-negative integer with the same size as </tt><a>Int</a>. Useful for
--   resize a connection pool.
data ServerReplicas

-- | A strategy for resizing a pool
data ResizePoolStrategy

-- | Never resize the pool
NeverResizePool :: ResizePoolStrategy

-- | Resize the pool by using provided total maximum connections
ResizePool :: Int -> ResizePoolStrategy

-- | Get server replic count in @<a>Int</a>
getServerReplicasInt :: ServerReplicas -> Int

-- | Safely build <tt><a>ServerReplicas</a> from non-negative and non-zero
--   </tt><a>Int</a> value.
safeServerReplicas :: Int -> Either Text ServerReplicas

-- | Summary of a source's pools resize. Predominantly used to log.
data SourceResizePoolSummary
SourceResizePoolSummary :: Bool -> Bool -> [Text] -> SourceResizePoolSummary
[_srpsPrimaryResized] :: SourceResizePoolSummary -> Bool
[_srpsReadReplicasResized] :: SourceResizePoolSummary -> Bool
[_srpsConnectionSet] :: SourceResizePoolSummary -> [Text]
noPoolsResizedSummary :: SourceResizePoolSummary
unsafeServerReplicas :: Word -> ServerReplicas
oneServerReplica :: ServerReplicas
instance GHC.Classes.Eq Hasura.RQL.Types.ResizePool.ServerReplicas
instance GHC.Classes.Eq Hasura.RQL.Types.ResizePool.SourceResizePoolSummary
instance GHC.Internal.Show.Show Hasura.RQL.Types.ResizePool.ServerReplicas
instance GHC.Internal.Show.Show Hasura.RQL.Types.ResizePool.SourceResizePoolSummary


-- | MSSQL Connection
--   
--   This module handles the connection against an MS SQL Server. It
--   defines the connection string, connection pool, default settings, and
--   conversion functions between MSSQL and graphql-engine.
module Hasura.Backends.MSSQL.Connection
data MSSQLConnConfiguration
MSSQLConnConfiguration :: MSSQLConnectionInfo -> Maybe (NonEmpty MSSQLConnectionInfo) -> MSSQLConnConfiguration
data MSSQLSourceConfig
MSSQLSourceConfig :: ConnectionString -> MSSQLExecCtx -> Int -> MSSQLSourceConfig
data MSSQLConnectionInfo
MSSQLConnectionInfo :: InputConnectionString -> MSSQLPoolSettings -> TxIsolation -> MSSQLConnectionInfo
[mciConnectionString] :: MSSQLConnectionInfo -> InputConnectionString
[mciPoolSettings] :: MSSQLConnectionInfo -> MSSQLPoolSettings
[mciIsolationLevel] :: MSSQLConnectionInfo -> TxIsolation
data MSSQLPoolSettings
MSSQLPoolSettingsPool :: MSSQLPoolConnectionSettings -> MSSQLPoolSettings
MSSQLPoolSettingsNoPool :: MSSQLPoolSettings
data MSSQLPoolConnectionSettings
MSSQLPoolConnectionSettings :: Maybe Int -> Maybe Int -> Int -> MSSQLPoolConnectionSettings
[mpsMaxConnections] :: MSSQLPoolConnectionSettings -> Maybe Int
[mpsTotalMaxConnections] :: MSSQLPoolConnectionSettings -> Maybe Int
[mpsIdleTimeout] :: MSSQLPoolConnectionSettings -> Int

-- | Execution Context required to execute MSSQL transactions
data MSSQLExecCtx
MSSQLExecCtx :: MSSQLRunTx -> MSSQLRunTx -> MSSQLRunTx -> IO () -> (ServerReplicas -> IO SourceResizePoolSummary) -> MSSQLExecCtx

-- | A function that runs read-only queries
[mssqlRunReadOnly] :: MSSQLExecCtx -> MSSQLRunTx

-- | A function that runs read-write queries; run in a transaction
[mssqlRunReadWrite] :: MSSQLExecCtx -> MSSQLRunTx

-- | A function that runs a transaction in the SERIALIZABLE transaction
--   isolation level. This is mainly intended to run source catalog
--   migrations.
[mssqlRunSerializableTx] :: MSSQLExecCtx -> MSSQLRunTx

-- | Destroys connection pools
[mssqlDestroyConn] :: MSSQLExecCtx -> IO ()

-- | Resize pools based on number of server instances
[mssqlResizePools] :: MSSQLExecCtx -> ServerReplicas -> IO SourceResizePoolSummary
class MonadError QErr m => MonadMSSQLTx (m :: Type -> Type)
liftMSSQLTx :: MonadMSSQLTx m => TxE QErr a -> m a
defaultMSSQLMaxConnections :: Int
createMSSQLPool :: (MonadIO m, QErrM m) => InputConnectionString -> ConnectionOptions -> Environment -> m (ConnectionString, MSSQLPool)

-- | Resize MSSQL pool by setting the number of connections equal to
--   allowed maximum connections across all server instances divided by
--   number of instances
resizeMSSQLPool :: MSSQLPool -> Int -> ServerReplicas -> IO ()
getEnv :: QErrM m => Environment -> Text -> m Text
odbcValueToJValue :: Value -> Value

-- | Creates a MSSQL execution context for a single primary pool
mkMSSQLExecCtx :: TxIsolation -> MSSQLPool -> ResizePoolStrategy -> MSSQLExecCtx

-- | Run any query discarding its results
mkMSSQLAnyQueryTx :: Query -> TxET QErr IO ()
runMSSQLSourceReadTx :: (MonadIO m, MonadBaseControl IO m) => MSSQLSourceConfig -> TxET QErr m a -> m (Either QErr a)
runMSSQLSourceWriteTx :: (MonadIO m, MonadBaseControl IO m) => MSSQLSourceConfig -> TxET QErr m a -> m (Either QErr a)
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Connection.InputConnectionString
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Connection.MSSQLConnConfiguration
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Connection.MSSQLConnectionInfo
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Connection.MSSQLConnectionString
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Connection.MSSQLPoolConnectionSettings
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Connection.MSSQLPoolSettings
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Connection.MSSQLSourceConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Connection.InputConnectionString
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Connection.MSSQLConnConfiguration
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Connection.MSSQLConnectionInfo
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Connection.MSSQLConnectionString
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Connection.MSSQLPoolSettings
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Connection.InputConnectionString
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Connection.MSSQLConnConfiguration
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Connection.MSSQLConnectionInfo
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Connection.MSSQLPoolConnectionSettings
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Connection.MSSQLPoolSettings
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Connection.MSSQLSourceConfig
instance Autodocodec.Class.HasCodec Hasura.Backends.MSSQL.Connection.InputConnectionString
instance Autodocodec.Class.HasCodec Hasura.Backends.MSSQL.Connection.MSSQLConnConfiguration
instance Autodocodec.Class.HasCodec Hasura.Backends.MSSQL.Connection.MSSQLConnectionInfo
instance Autodocodec.Class.HasCodec Hasura.Backends.MSSQL.Connection.MSSQLPoolSettings
instance Data.Has.Has () Hasura.Backends.MSSQL.Connection.MSSQLSourceConfig
instance Data.Hashable.Class.Hashable Database.MSSQL.Pool.ConnectionString
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Connection.InputConnectionString
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Connection.MSSQLConnConfiguration
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Connection.MSSQLConnectionInfo
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Connection.MSSQLConnectionString
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Connection.MSSQLPoolConnectionSettings
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Connection.MSSQLPoolSettings
instance Hasura.Backends.MSSQL.Connection.MonadMSSQLTx m => Hasura.Backends.MSSQL.Connection.MonadMSSQLTx (Control.Monad.Trans.Reader.ReaderT s m)
instance Hasura.Backends.MSSQL.Connection.MonadMSSQLTx m => Hasura.Backends.MSSQL.Connection.MonadMSSQLTx (Control.Monad.Trans.State.Strict.StateT s m)
instance Control.Monad.IO.Class.MonadIO m => Hasura.Backends.MSSQL.Connection.MonadMSSQLTx (Database.MSSQL.Transaction.TxET Hasura.Base.Error.QErr m)
instance (GHC.Internal.Base.Monoid w, Hasura.Backends.MSSQL.Connection.MonadMSSQLTx m) => Hasura.Backends.MSSQL.Connection.MonadMSSQLTx (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance Control.DeepSeq.NFData Database.MSSQL.Pool.ConnectionString
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Connection.InputConnectionString
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Connection.MSSQLConnConfiguration
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Connection.MSSQLConnectionInfo
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Connection.MSSQLConnectionString
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Connection.MSSQLPoolConnectionSettings
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Connection.MSSQLPoolSettings
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Connection.InputConnectionString
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Connection.MSSQLConnConfiguration
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Connection.MSSQLConnectionInfo
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Connection.MSSQLConnectionString
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Connection.MSSQLPoolConnectionSettings
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Connection.MSSQLPoolSettings
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Connection.MSSQLSourceConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MSSQL.Connection.InputConnectionString
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MSSQL.Connection.MSSQLConnConfiguration
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MSSQL.Connection.MSSQLConnectionInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MSSQL.Connection.MSSQLConnectionString
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MSSQL.Connection.MSSQLPoolSettings
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MSSQL.Connection.MSSQLSourceConfig

module Hasura.Backends.BigQuery.Connection
data BigQueryProblem
resolveConfigurationInput :: QErrM m => Environment -> ConfigurationInput -> m Text
resolveConfigurationInputs :: QErrM m => Environment -> ConfigurationInputs -> m [Text]
resolveConfigurationJson :: (QErrM m, FromJSON a) => Environment -> ConfigurationJSON a -> m (Either String a)
initConnection :: MonadIO m => ServiceAccount -> BigQueryProjectId -> Maybe RetryOptions -> m BigQueryConnection
runBigQuery :: MonadIO m => BigQueryConnection -> Request -> m (Either BigQueryProblem (Response ByteString))
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Connection.GoogleAccessTokenRequest
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Connection.Scope
instance GHC.Internal.Exception.Type.Exception Hasura.Backends.BigQuery.Connection.ServiceAccountProblem
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Connection.GoogleAccessTokenRequest
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Connection.BigQueryProblem
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Connection.GoogleAccessTokenRequest
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Connection.TokenProblem
instance GHC.Internal.Data.String.IsString Hasura.Backends.BigQuery.Connection.Scope
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Connection.BigQueryProblem
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Connection.GoogleAccessTokenRequest
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Connection.Scope
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Connection.ServiceAccountProblem
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Connection.TokenProblem
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Connection.BigQueryProblem
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Connection.GoogleAccessTokenRequest

module Hasura.RQL.Types.ResultCustomization

-- | Mapping that can be provided to a ResultCustomizer to map top-level
--   field aliases that were not available at field parse time. E.g. for
--   aliases created in the remote server query for remote joins.
data AliasMapping

-- | AliasMapping that maps a single field name to an alias
singletonAliasMapping :: Name -> Name -> AliasMapping

-- | Function to modify JSON values returned from the remote server e.g. to
--   map values of __typename fields to customized type names. The
--   customizer uses Maybe to allow short-circuiting subtrees where no
--   customizations are needed.
data ResultCustomizer

-- | Apply a ResultCustomizer to a JSON value
applyResultCustomizer :: ResultCustomizer -> Value -> Value

-- | Apply an AliasMapping to a ResultCustomizer.
applyAliasMapping :: AliasMapping -> ResultCustomizer -> ResultCustomizer

-- | Take a ResultCustomizer for a JSON subtree, and a fieldName, and
--   produce a ResultCustomizer for a parent object or array of objects
--   that applies the subtree customizer to the subtree at the given
--   fieldName.
modifyFieldByName :: Name -> ResultCustomizer -> ResultCustomizer

-- | Create a RemoteResultCustomizer that applies the typeNameMap to a JSON
--   string value, e.g. for use in customizing a __typename field value.
customizeTypeNameString :: HashMap Name Name -> ResultCustomizer
instance GHC.Internal.Base.Monoid Hasura.RQL.Types.ResultCustomization.AliasMapping
instance GHC.Internal.Base.Monoid Hasura.RQL.Types.ResultCustomization.ResultCustomizer
instance GHC.Internal.Base.Semigroup Hasura.RQL.Types.ResultCustomization.AliasMapping
instance GHC.Internal.Base.Semigroup Hasura.RQL.Types.ResultCustomization.ResultCustomizer
instance GHC.Internal.Show.Show Hasura.RQL.Types.ResultCustomization.ResultCustomizer


-- | Definitions for schema building configuration.
module Hasura.RQL.Types.Schema.Options

-- | The record of options required to build the schema. This includes
--   options that can be enabled with <a>ExperimentalFeature</a> flags.
data SchemaOptions
SchemaOptions :: StringifyNumbers -> DangerouslyCollapseBooleans -> RemoteNullForwardingPolicy -> InferFunctionPermissions -> OptimizePermissionFilters -> IncludeUpdateManyFields -> IncludeAggregationPredicates -> IncludeStreamFields -> BigQueryStringNumericInput -> IncludeGroupByAggregateFields -> UsePostgresArrays -> SchemaOptions
[soStringifyNumbers] :: SchemaOptions -> StringifyNumbers
[soDangerousBooleanCollapse] :: SchemaOptions -> DangerouslyCollapseBooleans
[soRemoteNullForwardingPolicy] :: SchemaOptions -> RemoteNullForwardingPolicy
[soInferFunctionPermissions] :: SchemaOptions -> InferFunctionPermissions
[soOptimizePermissionFilters] :: SchemaOptions -> OptimizePermissionFilters
[soIncludeUpdateManyFields] :: SchemaOptions -> IncludeUpdateManyFields
[soIncludeAggregationPredicates] :: SchemaOptions -> IncludeAggregationPredicates
[soIncludeStreamFields] :: SchemaOptions -> IncludeStreamFields
[soBigQueryStringNumericInput] :: SchemaOptions -> BigQueryStringNumericInput
[soIncludeGroupByAggregateFields] :: SchemaOptions -> IncludeGroupByAggregateFields
[soPostgresArrays] :: SchemaOptions -> UsePostgresArrays

-- | Should we represent numbers in our responses as numbers, or strings?
--   Some backends can return numbers that exceed the bounds of JSON's own
--   number type. In these cases, we can use stringified versions of these
--   numbers to avoid this problem.
data StringifyNumbers
StringifyNumbers :: StringifyNumbers
Don'tStringifyNumbers :: StringifyNumbers

-- | Should Boolean fields be collapsed to <a>True</a> when a null value is
--   given? This was the behaviour of Hasura V1, and is now discouraged.
data DangerouslyCollapseBooleans
DangerouslyCollapseBooleans :: DangerouslyCollapseBooleans
Don'tDangerouslyCollapseBooleans :: DangerouslyCollapseBooleans

-- | Should <a>null</a> values allowed for variables whose type is declared
--   as non-nullable in a GraphQL query. Until version 2.34.0 (except
--   2.11.11), <a>null</a> value is validated for non-nullable variables.
--   It is being fixed, to keep backwards compatible this option is
--   introduced.
data BackwardsCompatibleNullInNonNullableVariables
AllowNullInNonNullableVariables :: BackwardsCompatibleNullInNonNullableVariables
Don'tAllowNullInNonNullableVariables :: BackwardsCompatibleNullInNonNullableVariables
data RemoteNullForwardingPolicy
RemoteForwardAccurately :: RemoteNullForwardingPolicy
RemoteOnlyForwardNonNull :: RemoteNullForwardingPolicy

-- | Should we infer function permissions? If this flag is set to
--   <a>InferFunctionPermissions</a>, we may fail to build expression
--   parsers in <tt>buildQueryAndSubscriptionFields</tt> for users with
--   unrecognised roles.
data InferFunctionPermissions
InferFunctionPermissions :: InferFunctionPermissions
Don'tInferFunctionPermissions :: InferFunctionPermissions

-- | Should we enable remote schema permissions? If so, these permissions
--   will influence <a>buildGQLContext</a>.
data RemoteSchemaPermissions
EnableRemoteSchemaPermissions :: RemoteSchemaPermissions
DisableRemoteSchemaPermissions :: RemoteSchemaPermissions

-- | Should we attempt to deduplicate permission filters? This flag is used
--   in <a>relationshipField</a> to determine whether certain row-level
--   permission filters can be dropped in certain cases.
data OptimizePermissionFilters
OptimizePermissionFilters :: OptimizePermissionFilters
Don'tOptimizePermissionFilters :: OptimizePermissionFilters

-- | Should we include aggregation functions in where clauses? Because this
--   has the potential to cause naming conflicts in graphql schema types,
--   this flag allows users to toggle the feature off if it an upgrade
--   breaks their setup.
data IncludeAggregationPredicates
IncludeAggregationPredicates :: IncludeAggregationPredicates
Don'tIncludeAggregationPredicates :: IncludeAggregationPredicates

-- | Should we include <tt>TABLE_stream</tt> fields in schemas This is a
--   toggle so that users can opt-in, and so that we can rename any tables
--   that this may conflict with if needed
data IncludeStreamFields
IncludeStreamFields :: IncludeStreamFields
Don'tIncludeStreamFields :: IncludeStreamFields

-- | Should we include <tt>TABLE_updates</tt> fields in schemas This is a
--   toggle so that users can opt-in, and so that we can rename any tables
--   that this may conflict with if needed
data IncludeUpdateManyFields
IncludeUpdateManyFields :: IncludeUpdateManyFields
Don'tIncludeUpdateManyFields :: IncludeUpdateManyFields

-- | Should we enable string-accepting scalar parsers for BigQuery sources
data BigQueryStringNumericInput
EnableBigQueryStringNumericInput :: BigQueryStringNumericInput
DisableBigQueryStringNumericInput :: BigQueryStringNumericInput
data IncludeGroupByAggregateFields
IncludeGroupByAggregateFields :: IncludeGroupByAggregateFields
ExcludeGroupByAggregateFields :: IncludeGroupByAggregateFields

-- | if we use Postgres arrays then an array of <tt>text</tt> becomes
--   `[String!]`, however we want users to have the option to make it
--   output <tt>_text</tt> like it did before for compatibility.
data UsePostgresArrays
UsePostgresArrays :: UsePostgresArrays
DontUsePostgresArrays :: UsePostgresArrays
instance GHC.Classes.Eq Hasura.RQL.Types.Schema.Options.BackwardsCompatibleNullInNonNullableVariables
instance GHC.Classes.Eq Hasura.RQL.Types.Schema.Options.BigQueryStringNumericInput
instance GHC.Classes.Eq Hasura.RQL.Types.Schema.Options.DangerouslyCollapseBooleans
instance GHC.Classes.Eq Hasura.RQL.Types.Schema.Options.IncludeGroupByAggregateFields
instance GHC.Classes.Eq Hasura.RQL.Types.Schema.Options.IncludeStreamFields
instance GHC.Classes.Eq Hasura.RQL.Types.Schema.Options.IncludeUpdateManyFields
instance GHC.Classes.Eq Hasura.RQL.Types.Schema.Options.InferFunctionPermissions
instance GHC.Classes.Eq Hasura.RQL.Types.Schema.Options.OptimizePermissionFilters
instance GHC.Classes.Eq Hasura.RQL.Types.Schema.Options.RemoteNullForwardingPolicy
instance GHC.Classes.Eq Hasura.RQL.Types.Schema.Options.RemoteSchemaPermissions
instance GHC.Classes.Eq Hasura.RQL.Types.Schema.Options.StringifyNumbers
instance GHC.Classes.Eq Hasura.RQL.Types.Schema.Options.UsePostgresArrays
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Schema.Options.BackwardsCompatibleNullInNonNullableVariables
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Schema.Options.DangerouslyCollapseBooleans
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Schema.Options.InferFunctionPermissions
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Schema.Options.RemoteNullForwardingPolicy
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Schema.Options.RemoteSchemaPermissions
instance GHC.Internal.Show.Show Hasura.RQL.Types.Schema.Options.BackwardsCompatibleNullInNonNullableVariables
instance GHC.Internal.Show.Show Hasura.RQL.Types.Schema.Options.BigQueryStringNumericInput
instance GHC.Internal.Show.Show Hasura.RQL.Types.Schema.Options.DangerouslyCollapseBooleans
instance GHC.Internal.Show.Show Hasura.RQL.Types.Schema.Options.IncludeGroupByAggregateFields
instance GHC.Internal.Show.Show Hasura.RQL.Types.Schema.Options.IncludeStreamFields
instance GHC.Internal.Show.Show Hasura.RQL.Types.Schema.Options.IncludeUpdateManyFields
instance GHC.Internal.Show.Show Hasura.RQL.Types.Schema.Options.InferFunctionPermissions
instance GHC.Internal.Show.Show Hasura.RQL.Types.Schema.Options.OptimizePermissionFilters
instance GHC.Internal.Show.Show Hasura.RQL.Types.Schema.Options.RemoteNullForwardingPolicy
instance GHC.Internal.Show.Show Hasura.RQL.Types.Schema.Options.RemoteSchemaPermissions
instance GHC.Internal.Show.Show Hasura.RQL.Types.Schema.Options.StringifyNumbers
instance GHC.Internal.Show.Show Hasura.RQL.Types.Schema.Options.UsePostgresArrays
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Schema.Options.BackwardsCompatibleNullInNonNullableVariables
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Schema.Options.DangerouslyCollapseBooleans
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Schema.Options.InferFunctionPermissions
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Schema.Options.RemoteNullForwardingPolicy
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Schema.Options.RemoteSchemaPermissions

module Hasura.RQL.Types.Common
newtype RelName
RelName :: NonEmptyText -> RelName
[getRelTxt] :: RelName -> NonEmptyText
relNameToTxt :: RelName -> Text
fromRemoteRelationship :: RelName -> FieldName
data RelType
ObjRel :: RelType
ArrRel :: RelType
relTypeToTxt :: RelType -> Text

-- | Postgres OIDs.
--   <a>https://www.postgresql.org/docs/12/datatype-oid.html</a>
newtype OID
OID :: Int -> OID
[unOID] :: OID -> Int
newtype FieldName
FieldName :: Text -> FieldName
[getFieldNameTxt] :: FieldName -> Text
type Fields a = [(FieldName, a)]
data InsertOrder
BeforeParent :: InsertOrder
AfterParent :: InsertOrder
class ToAesonPairs a
toAesonPairs :: (ToAesonPairs a, KeyValue e v) => a -> [v]
data InpValInfo
InpValInfo :: Maybe Description -> Name -> Maybe (Value Void) -> GType -> InpValInfo
[_iviDesc] :: InpValInfo -> Maybe Description
[_iviName] :: InpValInfo -> Name
[_iviDefVal] :: InpValInfo -> Maybe (Value Void)
[_iviType] :: InpValInfo -> GType
newtype SystemDefined
SystemDefined :: Bool -> SystemDefined
[unSystemDefined] :: SystemDefined -> Bool
isSystemDefined :: SystemDefined -> Bool
data SQLGenCtx
SQLGenCtx :: StringifyNumbers -> DangerouslyCollapseBooleans -> BackwardsCompatibleNullInNonNullableVariables -> RemoteNullForwardingPolicy -> OptimizePermissionFilters -> BigQueryStringNumericInput -> SQLGenCtx
[stringifyNum] :: SQLGenCtx -> StringifyNumbers
[dangerousBooleanCollapse] :: SQLGenCtx -> DangerouslyCollapseBooleans
[nullInNonNullableVariables] :: SQLGenCtx -> BackwardsCompatibleNullInNonNullableVariables
[remoteNullForwardingPolicy] :: SQLGenCtx -> RemoteNullForwardingPolicy
[optimizePermissionFilters] :: SQLGenCtx -> OptimizePermissionFilters
[bigqueryStringNumericInput] :: SQLGenCtx -> BigQueryStringNumericInput
successMsg :: EncJSON
failureMsg :: EncJSON
newtype InputWebhook
InputWebhook :: Template -> InputWebhook
[unInputWebhook] :: InputWebhook -> Template
newtype ResolvedWebhook
ResolvedWebhook :: Text -> ResolvedWebhook
[unResolvedWebhook] :: ResolvedWebhook -> Text
newtype ResolveWebhookError
ResolveWebhookError :: Text -> ResolveWebhookError
[unResolveWebhookError] :: ResolveWebhookError -> Text
resolveWebhook :: QErrM m => Environment -> InputWebhook -> m ResolvedWebhook
resolveWebhookEither :: Environment -> InputWebhook -> Either ResolveWebhookError ResolvedWebhook
newtype Timeout
Timeout :: Int -> Timeout
[unTimeout] :: Timeout -> Int
defaultActionTimeoutSecs :: Timeout

-- | user PG connection configuration from which we'll eventually make a
--   <tt>ConnInfo</tt>
data UrlConf

-- | the database connection string
UrlValue :: InputWebhook -> UrlConf

-- | the name of environment variable containing the connection string
UrlFromEnv :: Text -> UrlConf

-- | the minimum required `connection parameters` to construct a valid
--   connection string
UrlFromParams :: PGConnectionParams -> UrlConf

-- | Filepath to a file containing a connection string. This is read before
--   each connect, and when in use connection errors will force a re-read.
--   This can support e.g. environments where passwords are frequently
--   rotated (not supported on cloud)
--   
--   This gets piped all the way through into the ConnInfo.
UrlDynamicFromFile :: FilePath -> UrlConf

-- | NOTE: Because hasura admins are not necessarily trusted to be able to
--   read arbitrary files on the machine running the server, we insist the
--   file path supplied by the hasura admin be validated against an
--   acceptable prefix (set only by an env var, presumably only by someone
--   with privileges to deploy).
--   
--   Altering the value of
--   HASURA_GRAPHQL_DYNAMIC_SECRETS_ALLOWED_PATH_PREFIX after adding a
--   dynamic source can result in inconsistent metadata.
resolveUrlConf :: (MonadIO m, MonadError QErr m) => Environment -> UrlConf -> m ConnDetails
getEnv :: QErrM m => Environment -> Text -> m Text
getEnvEither :: Environment -> Text -> Either Text Text
data SourceName
SNDefault :: SourceName
SNName :: NonEmptyText -> SourceName
defaultSource :: SourceName
sourceNameToText :: SourceName -> Text
data JsonAggSelect
JASMultipleRows :: JsonAggSelect
JASSingleObject :: JsonAggSelect

-- | Various user-controlled configuration for metrics used by Pro
data MetricsConfig
MetricsConfig :: Bool -> Bool -> MetricsConfig

-- | should the query-variables be logged and analyzed for metrics
[_mcAnalyzeQueryVariables] :: MetricsConfig -> Bool

-- | should the response-body be analyzed for empty and null responses
[_mcAnalyzeResponseBody] :: MetricsConfig -> Bool
emptyMetricsConfig :: MetricsConfig

-- | See API reference here:
--   <a>https://hasura.io/docs/latest/graphql/core/api-reference/syntax-defs.html#pgconnectionparameters</a>
data PGConnectionParams
PGConnectionParams :: Text -> Text -> Maybe Text -> Int -> Text -> PGConnectionParams
[_pgcpHost] :: PGConnectionParams -> Text
[_pgcpUsername] :: PGConnectionParams -> Text
[_pgcpPassword] :: PGConnectionParams -> Maybe Text
[_pgcpPort] :: PGConnectionParams -> Int
[_pgcpDatabase] :: PGConnectionParams -> Text

-- | Construct a Postgres connection URI as a String from
--   <a>PGConnectionParams</a>.
--   
--   NOTE: This function takes care to properly escape all URI components,
--   as Postgres requires that a connection URI is percent-encoded if it
--   includes symbols with "special meaning".
--   
--   See the <tt>libpq</tt> documentation for details:
--   <a>https://www.postgresql.org/docs/13/libpq-connect.html#id-1.7.3.8.3.6</a>
getPGConnectionStringFromParams :: PGConnectionParams -> String
getConnOptionsFromConnParams :: PGConnectionParams -> ConnOptions
data Comment

-- | Automatically generate a comment (derive it from DB comments, or a
--   sensible default describing the source of the data)
Automatic :: Comment

-- | The user's explicitly provided comment, or explicitly no comment (ie.
--   leave it blank, do not autogenerate one)
Explicit :: Maybe NonEmptyText -> Comment
commentToMaybeText :: Comment -> Maybe Text
commentFromMaybeText :: Maybe Text -> Comment

-- | We use the following type, after we resolve the env var. | This will
--   store both the env var name and the resolved value.
data EnvRecord a
EnvRecord :: Text -> a -> EnvRecord a
[_envVarName] :: EnvRecord a -> Text
[_envVarValue] :: EnvRecord a -> a
data ApolloFederationConfig
ApolloFederationConfig :: ApolloFederationVersion -> ApolloFederationConfig
[enable] :: ApolloFederationConfig -> ApolloFederationVersion
data ApolloFederationVersion
V1 :: ApolloFederationVersion
isApolloFedV1enabled :: Maybe ApolloFederationConfig -> Bool

-- | Metadata representation of a generic remote relationship, regardless
--   of the source: all sources use this same agnostic definition. The
--   internal definition field is where we differentiate between different
--   targets.
--   
--   TODO: This needs to be moved to an appropriate module, maybe something
--   like Hasura.RemoteRelationships.Metadata.
data RemoteRelationshipG definition
RemoteRelationship :: RelName -> definition -> RemoteRelationshipG definition
[_rrName] :: RemoteRelationshipG definition -> RelName
[_rrDefinition] :: RemoteRelationshipG definition -> definition
remoteRelationshipCodec :: Typeable definition => JSONCodec definition -> JSONCodec (RemoteRelationshipG definition)
rrDefinition :: forall def def' f. Functor f => (def -> f def') -> RemoteRelationshipG def -> f (RemoteRelationshipG def')
rrName :: forall def f. Functor f => (RelName -> f RelName) -> RemoteRelationshipG def -> f (RemoteRelationshipG def)

-- | Type to indicate if the SQL trigger should be enabled when data is
--   inserted into a table through replication.
data TriggerOnReplication
TOREnableTrigger :: TriggerOnReplication
TORDisableTrigger :: TriggerOnReplication
instance GHC.Internal.Data.Data.Data Hasura.RQL.Types.Common.FieldName
instance GHC.Internal.Data.Data.Data Hasura.RQL.Types.Common.RelType
instance GHC.Classes.Eq Hasura.RQL.Types.Common.ApolloFederationConfig
instance GHC.Classes.Eq Hasura.RQL.Types.Common.ApolloFederationVersion
instance GHC.Classes.Eq Hasura.RQL.Types.Common.Comment
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.RQL.Types.Common.EnvRecord a)
instance GHC.Classes.Eq Hasura.RQL.Types.Common.FieldName
instance GHC.Classes.Eq Hasura.RQL.Types.Common.InpValInfo
instance GHC.Classes.Eq Hasura.RQL.Types.Common.InputWebhook
instance GHC.Classes.Eq Hasura.RQL.Types.Common.InsertOrder
instance GHC.Classes.Eq Hasura.RQL.Types.Common.JsonAggSelect
instance GHC.Classes.Eq Hasura.RQL.Types.Common.MetricsConfig
instance GHC.Classes.Eq Hasura.RQL.Types.Common.OID
instance GHC.Classes.Eq Hasura.RQL.Types.Common.PGConnectionParams
instance GHC.Classes.Eq Hasura.RQL.Types.Common.RelName
instance GHC.Classes.Eq Hasura.RQL.Types.Common.RelType
instance GHC.Classes.Eq definition => GHC.Classes.Eq (Hasura.RQL.Types.Common.RemoteRelationshipG definition)
instance GHC.Classes.Eq Hasura.RQL.Types.Common.ResolvedWebhook
instance GHC.Classes.Eq Hasura.RQL.Types.Common.SQLGenCtx
instance GHC.Classes.Eq Hasura.RQL.Types.Common.SourceName
instance GHC.Classes.Eq Hasura.RQL.Types.Common.SystemDefined
instance GHC.Classes.Eq Hasura.RQL.Types.Common.Timeout
instance GHC.Classes.Eq Hasura.RQL.Types.Common.TriggerOnReplication
instance GHC.Classes.Eq Hasura.RQL.Types.Common.UrlConf
instance Database.PG.Query.Class.FromCol Hasura.RQL.Types.Common.InputWebhook
instance Database.PG.Query.Class.FromCol Hasura.RQL.Types.Common.OID
instance Database.PG.Query.Class.FromCol Hasura.RQL.Types.Common.RelName
instance Database.PG.Query.Class.FromCol Hasura.RQL.Types.Common.RelType
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.RQL.Types.Common.FieldName
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.RQL.Types.Common.RelName
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.RQL.Types.Common.SourceName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Common.ApolloFederationConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Common.ApolloFederationVersion
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Common.Comment
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Common.EnvRecord a)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Common.FieldName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Common.InputWebhook
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Common.InsertOrder
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Common.MetricsConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Common.OID
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Common.PGConnectionParams
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Common.RelName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Common.RelType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Common.ResolvedWebhook
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Common.SourceName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Common.SystemDefined
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Common.Timeout
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Common.TriggerOnReplication
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Common.UrlConf
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Common.ApolloFederationConfig
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Common.ApolloFederationVersion
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Common.Comment
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Common.EnvRecord a)
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Common.FieldName
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Common.InpValInfo
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Common.InputWebhook
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Common.InsertOrder
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Common.JsonAggSelect
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Common.MetricsConfig
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Common.PGConnectionParams
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Common.RelName
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Common.RelType
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Common.RemoteRelationshipG definition)
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Common.ResolvedWebhook
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Common.SourceName
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Common.SystemDefined
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Common.Timeout
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Common.TriggerOnReplication
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Common.UrlConf
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Common.ApolloFederationConfig
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Common.ApolloFederationVersion
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Common.Comment
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Common.FieldName
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Common.InputWebhook
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Common.InsertOrder
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Common.MetricsConfig
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Common.PGConnectionParams
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Common.RelName
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Common.RelType
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Common.SourceName
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Common.Timeout
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Common.TriggerOnReplication
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Common.UrlConf
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Common.Comment
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.RQL.Types.Common.EnvRecord a)
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Common.FieldName
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Common.InputWebhook
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Common.InsertOrder
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Common.JsonAggSelect
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Common.OID
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Common.PGConnectionParams
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Common.RelName
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Common.RelType
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Common.ResolvedWebhook
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Common.SourceName
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Common.UrlConf
instance GHC.Internal.Data.String.IsString Hasura.RQL.Types.Common.FieldName
instance Language.Haskell.TH.Syntax.Lift Hasura.RQL.Types.Common.InpValInfo
instance Control.DeepSeq.NFData Hasura.RQL.Types.Common.ApolloFederationConfig
instance Control.DeepSeq.NFData Hasura.RQL.Types.Common.ApolloFederationVersion
instance Control.DeepSeq.NFData Hasura.RQL.Types.Common.Comment
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.RQL.Types.Common.EnvRecord a)
instance Control.DeepSeq.NFData Hasura.RQL.Types.Common.FieldName
instance Control.DeepSeq.NFData Hasura.RQL.Types.Common.InputWebhook
instance Control.DeepSeq.NFData Hasura.RQL.Types.Common.InsertOrder
instance Control.DeepSeq.NFData Hasura.RQL.Types.Common.OID
instance Control.DeepSeq.NFData Hasura.RQL.Types.Common.PGConnectionParams
instance Control.DeepSeq.NFData Hasura.RQL.Types.Common.RelName
instance Control.DeepSeq.NFData Hasura.RQL.Types.Common.RelType
instance Control.DeepSeq.NFData Hasura.RQL.Types.Common.ResolvedWebhook
instance Control.DeepSeq.NFData Hasura.RQL.Types.Common.SourceName
instance Control.DeepSeq.NFData Hasura.RQL.Types.Common.SystemDefined
instance Control.DeepSeq.NFData Hasura.RQL.Types.Common.Timeout
instance Control.DeepSeq.NFData Hasura.RQL.Types.Common.TriggerOnReplication
instance Control.DeepSeq.NFData Hasura.RQL.Types.Common.UrlConf
instance GHC.Classes.Ord Hasura.RQL.Types.Common.FieldName
instance GHC.Classes.Ord Hasura.RQL.Types.Common.InsertOrder
instance GHC.Classes.Ord Hasura.RQL.Types.Common.RelName
instance GHC.Classes.Ord Hasura.RQL.Types.Common.RelType
instance GHC.Classes.Ord Hasura.RQL.Types.Common.SourceName
instance GHC.Internal.Base.Semigroup Hasura.RQL.Types.Common.FieldName
instance GHC.Internal.Show.Show Hasura.RQL.Types.Common.ApolloFederationConfig
instance GHC.Internal.Show.Show Hasura.RQL.Types.Common.ApolloFederationVersion
instance GHC.Internal.Show.Show Hasura.RQL.Types.Common.Comment
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (Hasura.RQL.Types.Common.EnvRecord a)
instance GHC.Internal.Show.Show Hasura.RQL.Types.Common.FieldName
instance GHC.Internal.Show.Show Hasura.RQL.Types.Common.InpValInfo
instance GHC.Internal.Show.Show Hasura.RQL.Types.Common.InputWebhook
instance GHC.Internal.Show.Show Hasura.RQL.Types.Common.InsertOrder
instance GHC.Internal.Show.Show Hasura.RQL.Types.Common.JsonAggSelect
instance GHC.Internal.Show.Show Hasura.RQL.Types.Common.MetricsConfig
instance GHC.Internal.Show.Show Hasura.RQL.Types.Common.OID
instance GHC.Internal.Show.Show Hasura.RQL.Types.Common.PGConnectionParams
instance GHC.Internal.Show.Show Hasura.RQL.Types.Common.RelName
instance GHC.Internal.Show.Show Hasura.RQL.Types.Common.RelType
instance GHC.Internal.Show.Show definition => GHC.Internal.Show.Show (Hasura.RQL.Types.Common.RemoteRelationshipG definition)
instance GHC.Internal.Show.Show Hasura.RQL.Types.Common.ResolveWebhookError
instance GHC.Internal.Show.Show Hasura.RQL.Types.Common.ResolvedWebhook
instance GHC.Internal.Show.Show Hasura.RQL.Types.Common.SQLGenCtx
instance GHC.Internal.Show.Show Hasura.RQL.Types.Common.SourceName
instance GHC.Internal.Show.Show Hasura.RQL.Types.Common.SystemDefined
instance GHC.Internal.Show.Show Hasura.RQL.Types.Common.Timeout
instance GHC.Internal.Show.Show Hasura.RQL.Types.Common.TriggerOnReplication
instance GHC.Internal.Show.Show Hasura.RQL.Types.Common.UrlConf
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.RQL.Types.Common.SourceName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.Types.Common.FieldName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.Types.Common.RelName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.Types.Common.SourceName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.ApolloFederationConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.ApolloFederationVersion
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.Comment
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Common.EnvRecord a)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.FieldName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.InputWebhook
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.InsertOrder
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.JsonAggSelect
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.MetricsConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.OID
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.PGConnectionParams
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.RelName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.RelType
instance Data.Aeson.Types.ToJSON.ToJSON definition => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Common.RemoteRelationshipG definition)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.ResolvedWebhook
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.SourceName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.SystemDefined
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.Timeout
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.TriggerOnReplication
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.UrlConf
instance Database.PG.Query.Class.ToPrepArg Hasura.RQL.Types.Common.RelName
instance Database.PG.Query.Class.ToPrepArg Hasura.RQL.Types.Common.SystemDefined
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.Common.FieldName
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.Common.RelName
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.Common.ResolveWebhookError
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.Common.ResolvedWebhook
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.Common.SourceName

module Hasura.RQL.Types.ComputedField.Name
newtype ComputedFieldName
ComputedFieldName :: NonEmptyText -> ComputedFieldName
[unComputedFieldName] :: ComputedFieldName -> NonEmptyText
computedFieldNameToText :: ComputedFieldName -> Text
fromComputedField :: ComputedFieldName -> FieldName
instance GHC.Classes.Eq Hasura.RQL.Types.ComputedField.Name.ComputedFieldName
instance Database.PG.Query.Class.FromCol Hasura.RQL.Types.ComputedField.Name.ComputedFieldName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ComputedField.Name.ComputedFieldName
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.ComputedField.Name.ComputedFieldName
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.ComputedField.Name.ComputedFieldName
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.ComputedField.Name.ComputedFieldName
instance Control.DeepSeq.NFData Hasura.RQL.Types.ComputedField.Name.ComputedFieldName
instance GHC.Classes.Ord Hasura.RQL.Types.ComputedField.Name.ComputedFieldName
instance GHC.Internal.Show.Show Hasura.RQL.Types.ComputedField.Name.ComputedFieldName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ComputedField.Name.ComputedFieldName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.Types.ComputedField.Name.ComputedFieldName
instance Database.PG.Query.Class.ToPrepArg Hasura.RQL.Types.ComputedField.Name.ComputedFieldName
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.ComputedField.Name.ComputedFieldName

module Hasura.RQL.IR.ModelInformation.Types
data ModelType
ModelTypeTable :: ModelType
ModelTypeLogicalModels :: ModelType
ModelTypeFunction :: ModelType
ModelTypeIdentifier :: ModelType
ModelTypeNativeQuery :: ModelType
ModelTypeStoredProcedures :: ModelType
ModelTypeRemoteSchema :: ModelType
ModelTypeAction :: ModelType
data ModelSourceType
ModelSourceTypePostgres :: ModelSourceType
ModelSourceTypeMSSQL :: ModelSourceType
ModelSourceTypeBigQuery :: ModelSourceType
ModelSourceTypeDataConnector :: ModelSourceType
newtype ModelOperationType
ModelOperationType :: OperationType -> ModelOperationType
[unModelOperationType] :: ModelOperationType -> OperationType
newtype ModelNameInfo
ModelNameInfo :: (Text, ModelType, SourceName, ModelSourceType) -> ModelNameInfo
[unModelNameInfo] :: ModelNameInfo -> (Text, ModelType, SourceName, ModelSourceType)
data ModelInfoPart
ModelInfoPart :: !Text -> !ModelType -> !Maybe Text -> !Maybe ModelSourceType -> !ModelOperationType -> ModelInfoPart
[mipModelName] :: ModelInfoPart -> !Text
[mipModelType] :: ModelInfoPart -> !ModelType
[mipSourceName] :: ModelInfoPart -> !Maybe Text
[mipSourceType] :: ModelInfoPart -> !Maybe ModelSourceType
[mipQueryType] :: ModelInfoPart -> !ModelOperationType
instance GHC.Classes.Eq Hasura.RQL.IR.ModelInformation.Types.ModelNameInfo
instance GHC.Classes.Eq Hasura.RQL.IR.ModelInformation.Types.ModelSourceType
instance GHC.Classes.Eq Hasura.RQL.IR.ModelInformation.Types.ModelType
instance GHC.Internal.Generics.Generic Hasura.RQL.IR.ModelInformation.Types.ModelInfoPart
instance GHC.Internal.Generics.Generic Hasura.RQL.IR.ModelInformation.Types.ModelOperationType
instance GHC.Internal.Generics.Generic Hasura.RQL.IR.ModelInformation.Types.ModelSourceType
instance GHC.Internal.Generics.Generic Hasura.RQL.IR.ModelInformation.Types.ModelType
instance GHC.Internal.Show.Show Hasura.RQL.IR.ModelInformation.Types.ModelInfoPart
instance GHC.Internal.Show.Show Hasura.RQL.IR.ModelInformation.Types.ModelNameInfo
instance GHC.Internal.Show.Show Hasura.RQL.IR.ModelInformation.Types.ModelOperationType
instance GHC.Internal.Show.Show Hasura.RQL.IR.ModelInformation.Types.ModelSourceType
instance GHC.Internal.Show.Show Hasura.RQL.IR.ModelInformation.Types.ModelType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.IR.ModelInformation.Types.ModelInfoPart
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.IR.ModelInformation.Types.ModelOperationType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.IR.ModelInformation.Types.ModelSourceType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.IR.ModelInformation.Types.ModelType
instance Data.Text.Extended.ToTxt Hasura.RQL.IR.ModelInformation.Types.ModelOperationType
instance Data.Text.Extended.ToTxt Hasura.RQL.IR.ModelInformation.Types.ModelSourceType
instance Data.Text.Extended.ToTxt Hasura.RQL.IR.ModelInformation.Types.ModelType

module Hasura.RQL.Types.Source.TableType
data SourceTableType
Table :: SourceTableType
View :: SourceTableType
instance GHC.Internal.Enum.Bounded Hasura.RQL.Types.Source.TableType.SourceTableType
instance GHC.Internal.Enum.Enum Hasura.RQL.Types.Source.TableType.SourceTableType
instance GHC.Classes.Eq Hasura.RQL.Types.Source.TableType.SourceTableType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Source.TableType.SourceTableType
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Source.TableType.SourceTableType
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Source.TableType.SourceTableType
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Source.TableType.SourceTableType
instance Control.DeepSeq.NFData Hasura.RQL.Types.Source.TableType.SourceTableType
instance GHC.Classes.Ord Hasura.RQL.Types.Source.TableType.SourceTableType
instance GHC.Internal.Show.Show Hasura.RQL.Types.Source.TableType.SourceTableType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Source.TableType.SourceTableType

module Hasura.RQL.Types.SourceConfiguration
class (Representable SourceConnConfiguration b, HasCodec SourceConnConfiguration b, FromJSON SourceConnConfiguration b, Show SourceConfig b, ToJSON SourceConfig b, ToJSON SourceConnConfiguration b, Eq SourceConfig b, Has ScalarTypeParsingContext b SourceConfig b, Eq ScalarTypeParsingContext b, Ord ScalarTypeParsingContext b, HasTag b) => HasSourceConfiguration (b :: BackendType) where {
    type ScalarTypeParsingContext (b :: BackendType);
    
    -- | User facing connection configuration for a database.
    type SourceConnConfiguration (b :: BackendType);
    
    -- | Internal connection configuration for a database - connection string,
    --   connection pool etc
    type SourceConfig (b :: BackendType);
    type ScalarTypeParsingContext b :: BackendType = ();
}

-- | The number of read replicas specified in the source configuration
sourceConfigNumReadReplicas :: HasSourceConfiguration b => SourceConfig b -> Int

-- | The connection template specified in the source configuration, if any
sourceConfigConnectonTemplate :: HasSourceConfiguration b => SourceConfig b -> Maybe ValueExt

-- | Whether or not the source supports performing column redaction. See
--   note [SQL generation for inherited roles] for more information
sourceSupportsColumnRedaction :: HasSourceConfiguration b => SourceConfig b -> Bool
sourceConfigBackendSourceKind :: HasSourceConfiguration b => SourceConfig b -> BackendSourceKind b
type Representable a = (Show a, Eq a, Hashable a, NFData a)

module Hasura.RQL.Types.Subscription

-- | CursorOrdering is used in the streaming subscriptions to specify how
--   to order the cursor.
data CursorOrdering
COAscending :: CursorOrdering
CODescending :: CursorOrdering
data SubscriptionType
Streaming :: SubscriptionType
LiveQuery :: SubscriptionType
instance GHC.Classes.Eq Hasura.RQL.Types.Subscription.CursorOrdering
instance GHC.Classes.Eq Hasura.RQL.Types.Subscription.SubscriptionType
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Subscription.CursorOrdering
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Subscription.SubscriptionType
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Subscription.CursorOrdering
instance GHC.Internal.Show.Show Hasura.RQL.Types.Subscription.CursorOrdering
instance GHC.Internal.Show.Show Hasura.RQL.Types.Subscription.SubscriptionType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Subscription.SubscriptionType

module Hasura.RQL.Types.Webhook.Transform.Class

-- | Textual transformation template.
newtype Template
Template :: Text -> Template
[unTemplate] :: Template -> Text

-- | Available templating engines.
data TemplatingEngine
Kriti :: TemplatingEngine

-- | The associated type 'TransformFn a' is the defunctionalized version of
--   some transformation that should be applied to a given request field.
--   
--   In most cases it is some variation on a piece of template text
--   describing the transformation.
data family TransformFn a
data family TransformCtx a

-- | We use collect all transformation failures as a '[J.Value]'.
newtype TransformErrorBundle
TransformErrorBundle :: [Value] -> TransformErrorBundle
[tebMessages] :: TransformErrorBundle -> [Value]

-- | Validated textual transformation template /for string interpolation
--   only/.
--   
--   This is necessary due to Kriti not distinguishing between string
--   literals and string templates.
newtype UnescapedTemplate
UnescapedTemplate :: Text -> UnescapedTemplate
[getUnescapedTemplate] :: UnescapedTemplate -> Text
instance GHC.Internal.Enum.Bounded Hasura.RQL.Types.Webhook.Transform.Class.TemplatingEngine
instance GHC.Internal.Enum.Enum Hasura.RQL.Types.Webhook.Transform.Class.TemplatingEngine
instance GHC.Classes.Eq Hasura.RQL.Types.Webhook.Transform.Class.Template
instance GHC.Classes.Eq Hasura.RQL.Types.Webhook.Transform.Class.TemplatingEngine
instance GHC.Classes.Eq Hasura.RQL.Types.Webhook.Transform.Class.TransformErrorBundle
instance GHC.Classes.Eq Hasura.RQL.Types.Webhook.Transform.Class.UnescapedTemplate
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.RQL.Types.Webhook.Transform.Class.Template
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.RQL.Types.Webhook.Transform.Class.UnescapedTemplate
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Webhook.Transform.Class.Template
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Webhook.Transform.Class.TemplatingEngine
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Webhook.Transform.Class.TransformErrorBundle
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Webhook.Transform.Class.UnescapedTemplate
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Webhook.Transform.Class.Template
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Webhook.Transform.Class.TemplatingEngine
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Webhook.Transform.Class.TransformErrorBundle
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Webhook.Transform.Class.UnescapedTemplate
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Webhook.Transform.Class.Template
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Webhook.Transform.Class.TemplatingEngine
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Webhook.Transform.Class.UnescapedTemplate
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Webhook.Transform.Class.Template
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Webhook.Transform.Class.UnescapedTemplate
instance GHC.Internal.Base.Monoid Hasura.RQL.Types.Webhook.Transform.Class.TransformErrorBundle
instance Control.DeepSeq.NFData Hasura.RQL.Types.Webhook.Transform.Class.Template
instance Control.DeepSeq.NFData Hasura.RQL.Types.Webhook.Transform.Class.TemplatingEngine
instance Control.DeepSeq.NFData Hasura.RQL.Types.Webhook.Transform.Class.TransformErrorBundle
instance Control.DeepSeq.NFData Hasura.RQL.Types.Webhook.Transform.Class.UnescapedTemplate
instance GHC.Classes.Ord Hasura.RQL.Types.Webhook.Transform.Class.Template
instance GHC.Classes.Ord Hasura.RQL.Types.Webhook.Transform.Class.UnescapedTemplate
instance GHC.Internal.Base.Semigroup Hasura.RQL.Types.Webhook.Transform.Class.TransformErrorBundle
instance GHC.Internal.Show.Show Hasura.RQL.Types.Webhook.Transform.Class.Template
instance GHC.Internal.Show.Show Hasura.RQL.Types.Webhook.Transform.Class.TemplatingEngine
instance GHC.Internal.Show.Show Hasura.RQL.Types.Webhook.Transform.Class.TransformErrorBundle
instance GHC.Internal.Show.Show Hasura.RQL.Types.Webhook.Transform.Class.UnescapedTemplate
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.Types.Webhook.Transform.Class.Template
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.Types.Webhook.Transform.Class.UnescapedTemplate
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Webhook.Transform.Class.Template
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Webhook.Transform.Class.TemplatingEngine
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Webhook.Transform.Class.TransformErrorBundle
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Webhook.Transform.Class.UnescapedTemplate


-- | The <a>Transform</a> typeclass with various types and helper functions
--   for evaluating transformations.
module Hasura.RQL.DDL.Webhook.Transform.Class

-- | <a>Transform</a> describes how to reify a defunctionalized
--   transformation for a particular request field.
class Transform a

-- | <a>transform</a> is a function which takes <a>TransformFn</a> of
--   <tt>a</tt> and reifies it into a function of the form:
--   
--   <pre>
--   ReqTransformCtx -&gt; a -&gt; m a
--   </pre>
transform :: (Transform a, MonadError TransformErrorBundle m) => TransformFn a -> TransformCtx a -> a -> m a

-- | Validate a <a>TransformFn</a> of <tt>a</tt>.
validate :: Transform a => TemplatingEngine -> TransformFn a -> Validation TransformErrorBundle ()

-- | We use collect all transformation failures as a '[J.Value]'.
newtype TransformErrorBundle
TransformErrorBundle :: [Value] -> TransformErrorBundle
[tebMessages] :: TransformErrorBundle -> [Value]

-- | A helper function for serializing transformation errors to JSON.
throwErrorBundle :: MonadError TransformErrorBundle m => Text -> Maybe Value -> m a

-- | Available templating engines.
data TemplatingEngine
Kriti :: TemplatingEngine

-- | Textual transformation template.
newtype Template
Template :: Text -> Template
[unTemplate] :: Template -> Text

-- | Validated textual transformation template /for string interpolation
--   only/.
--   
--   This is necessary due to Kriti not distinguishing between string
--   literals and string templates.
newtype UnescapedTemplate
UnescapedTemplate :: Text -> UnescapedTemplate
[getUnescapedTemplate] :: UnescapedTemplate -> Text

-- | Wrap an <a>UnescapedTemplate</a> with escaped double quotes.
wrapUnescapedTemplate :: UnescapedTemplate -> Template

-- | Encode a JSON Scalar Value as a <a>ByteString</a>. If a non-Scalar
--   value is provided, will return a <tt>TrnasformErrorBundle</tt>
encodeScalar :: MonadError TransformErrorBundle m => Value -> m ByteString


-- | Types and subroutines related to constructing transformations on HTTP
--   responses.
module Hasura.RQL.DDL.Webhook.Transform.Response

-- | Common context that is made available to all response transformations.
data ResponseTransformCtx
ResponseTransformCtx :: Value -> Value -> Maybe SessionVariables -> TemplatingEngine -> Int -> ResponseTransformCtx
[responseTransformBody] :: ResponseTransformCtx -> Value
[responseTransformReqCtx] :: ResponseTransformCtx -> Value
[responseSessionVariables] :: ResponseTransformCtx -> Maybe SessionVariables
[responseTransformEngine] :: ResponseTransformCtx -> TemplatingEngine
[responseStatusCode] :: ResponseTransformCtx -> Int

-- | A helper function for executing transformations from a <a>Template</a>
--   and a <a>ResponseTransformCtx</a>.
--   
--   NOTE: This and all related funtions are hard-coded to Kriti at the
--   moment. When we add additional template engines this function will
--   need to take a <a>TemplatingEngine</a> parameter.
runResponseTemplateTransform :: Template -> ResponseTransformCtx -> Either TransformErrorBundle Value

-- | Run an <a>UnescapedTemplate</a> with a <a>ResponseTransformCtx</a>.
runUnescapedResponseTemplateTransform :: ResponseTransformCtx -> UnescapedTemplate -> Either TransformErrorBundle ByteString

-- | Run an <a>UnescapedTemplate</a> with a <a>ResponseTransformCtx</a> in
--   <a>Validation</a>.
runUnescapedResponseTemplateTransform' :: ResponseTransformCtx -> UnescapedTemplate -> Validation TransformErrorBundle ByteString

module Hasura.RQL.Types.Webhook.Transform.Request

-- | Common context that is made available to all request transformations.
data RequestTransformCtx
RequestTransformCtx :: Maybe Value -> Value -> Maybe SessionVariables -> Maybe Value -> TemplatingEngine -> RequestTransformCtx
[rtcBaseUrl] :: RequestTransformCtx -> Maybe Value
[rtcBody] :: RequestTransformCtx -> Value
[rtcSessionVariables] :: RequestTransformCtx -> Maybe SessionVariables
[rtcQueryParams] :: RequestTransformCtx -> Maybe Value
[rtcEngine] :: RequestTransformCtx -> TemplatingEngine

-- | <tt>RequestTransform</tt> Versioning
data Version
V1 :: Version
V2 :: Version
instance GHC.Classes.Eq Hasura.RQL.Types.Webhook.Transform.Request.Version
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Webhook.Transform.Request.Version
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Webhook.Transform.Request.Version
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Webhook.Transform.Request.Version
instance Control.DeepSeq.NFData Hasura.RQL.Types.Webhook.Transform.Request.Version
instance GHC.Internal.Show.Show Hasura.RQL.Types.Webhook.Transform.Request.Version
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Webhook.Transform.Request.RequestTransformCtx
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Webhook.Transform.Request.Version

module Hasura.RQL.Types.Webhook.Transform.QueryParams

-- | The actual query params we are transforming.
--   
--   This newtype is necessary because otherwise we end up with an orphan
--   instance.
newtype QueryParams
QueryParams :: Query -> QueryParams
[unQueryParams] :: QueryParams -> Query

-- | The defunctionalized transformation <a>QueryParams</a>
data QueryParamsTransformFn
AddOrReplace :: [(UnescapedTemplate, Maybe UnescapedTemplate)] -> QueryParamsTransformFn
ParamTemplate :: UnescapedTemplate -> QueryParamsTransformFn
data family TransformCtx a

-- | The associated type 'TransformFn a' is the defunctionalized version of
--   some transformation that should be applied to a given request field.
--   
--   In most cases it is some variation on a piece of template text
--   describing the transformation.
data family TransformFn a
instance GHC.Classes.Eq Hasura.RQL.Types.Webhook.Transform.QueryParams.QueryParamsTransformFn
instance GHC.Classes.Eq (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.QueryParams.QueryParams)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Webhook.Transform.QueryParams.QueryParamsTransformFn
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.QueryParams.QueryParams)
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Webhook.Transform.QueryParams.QueryParamsTransformFn
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.QueryParams.QueryParams)
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Webhook.Transform.QueryParams.QueryParamsTransformFn
instance Control.DeepSeq.NFData Hasura.RQL.Types.Webhook.Transform.QueryParams.QueryParamsTransformFn
instance Control.DeepSeq.NFData (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.QueryParams.QueryParams)
instance GHC.Internal.Show.Show Hasura.RQL.Types.Webhook.Transform.QueryParams.QueryParamsTransformFn
instance GHC.Internal.Show.Show (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.QueryParams.QueryParams)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Webhook.Transform.QueryParams.QueryParamsTransformFn
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.QueryParams.QueryParams)

module Hasura.RQL.Types.Webhook.Transform.Method

-- | The actual request method we are transforming.
--   
--   This newtype is necessary because otherwise we end up with an orphan
--   instance.
newtype Method
Method :: CI Text -> Method

-- | The defunctionalized transformation on <a>Method</a>.
newtype MethodTransformFn

-- | Replace the HTTP existing <a>Method</a> with a new one.
Replace :: Method -> MethodTransformFn
data family TransformCtx a

-- | The associated type 'TransformFn a' is the defunctionalized version of
--   some transformation that should be applied to a given request field.
--   
--   In most cases it is some variation on a piece of template text
--   describing the transformation.
data family TransformFn a
instance GHC.Classes.Eq Hasura.RQL.Types.Webhook.Transform.Method.Method
instance GHC.Classes.Eq Hasura.RQL.Types.Webhook.Transform.Method.MethodTransformFn
instance GHC.Classes.Eq (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.Method.Method)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Webhook.Transform.Method.Method
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Webhook.Transform.Method.MethodTransformFn
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.Method.Method)
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Webhook.Transform.Method.Method
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Webhook.Transform.Method.MethodTransformFn
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.Method.Method)
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Webhook.Transform.Method.Method
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Webhook.Transform.Method.MethodTransformFn
instance Control.DeepSeq.NFData Hasura.RQL.Types.Webhook.Transform.Method.Method
instance Control.DeepSeq.NFData Hasura.RQL.Types.Webhook.Transform.Method.MethodTransformFn
instance Control.DeepSeq.NFData (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.Method.Method)
instance GHC.Internal.Show.Show Hasura.RQL.Types.Webhook.Transform.Method.Method
instance GHC.Internal.Show.Show Hasura.RQL.Types.Webhook.Transform.Method.MethodTransformFn
instance GHC.Internal.Show.Show (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.Method.Method)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Webhook.Transform.Method.Method
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Webhook.Transform.Method.MethodTransformFn
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.Method.Method)

module Hasura.RQL.Types.Webhook.Transform.Headers

-- | The user can supply a set of header keys to be filtered from the
--   request and a set of headers to be added to the request.
data AddReplaceOrRemoveFields
AddReplaceOrRemoveFields :: [(CI Text, UnescapedTemplate)] -> [CI Text] -> AddReplaceOrRemoveFields

-- | A list of key-value pairs for <a>Header</a>s which should be added (if
--   they don't exist) or replaced (if they do) within the HTTP message.
[addOrReplaceHeaders] :: AddReplaceOrRemoveFields -> [(CI Text, UnescapedTemplate)]

-- | A list of <a>Header</a> keys which should be removed from the HTTP
--   message.
[removeHeaders] :: AddReplaceOrRemoveFields -> [CI Text]

-- | The actual header data we are transforming..
--   
--   This newtype is necessary because otherwise we end up with an orphan
--   instance.
newtype Headers
Headers :: [Header] -> Headers

-- | The defunctionalized transformation on <a>Headers</a>
newtype HeadersTransformFn

-- | Add or replace matching <a>Header</a>s.
AddReplaceOrRemove :: AddReplaceOrRemoveFields -> HeadersTransformFn
data family TransformCtx a

-- | The associated type 'TransformFn a' is the defunctionalized version of
--   some transformation that should be applied to a given request field.
--   
--   In most cases it is some variation on a piece of template text
--   describing the transformation.
data family TransformFn a
instance GHC.Classes.Eq Hasura.RQL.Types.Webhook.Transform.Headers.AddReplaceOrRemoveFields
instance GHC.Classes.Eq Hasura.RQL.Types.Webhook.Transform.Headers.HeaderKey
instance GHC.Classes.Eq Hasura.RQL.Types.Webhook.Transform.Headers.HeadersTransformFn
instance GHC.Classes.Eq (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.Headers.Headers)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Webhook.Transform.Headers.AddReplaceOrRemoveFields
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Webhook.Transform.Headers.HeaderKey
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Webhook.Transform.Headers.HeadersTransformFn
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.Headers.Headers)
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Webhook.Transform.Headers.AddReplaceOrRemoveFields
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Webhook.Transform.Headers.HeaderKey
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Webhook.Transform.Headers.HeadersTransformFn
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.Headers.Headers)
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Webhook.Transform.Headers.AddReplaceOrRemoveFields
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Webhook.Transform.Headers.HeadersTransformFn
instance Control.DeepSeq.NFData Hasura.RQL.Types.Webhook.Transform.Headers.AddReplaceOrRemoveFields
instance Control.DeepSeq.NFData Hasura.RQL.Types.Webhook.Transform.Headers.HeaderKey
instance Control.DeepSeq.NFData Hasura.RQL.Types.Webhook.Transform.Headers.HeadersTransformFn
instance Control.DeepSeq.NFData (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.Headers.Headers)
instance GHC.Classes.Ord Hasura.RQL.Types.Webhook.Transform.Headers.AddReplaceOrRemoveFields
instance GHC.Classes.Ord Hasura.RQL.Types.Webhook.Transform.Headers.HeaderKey
instance GHC.Internal.Show.Show Hasura.RQL.Types.Webhook.Transform.Headers.AddReplaceOrRemoveFields
instance GHC.Internal.Show.Show Hasura.RQL.Types.Webhook.Transform.Headers.HeaderKey
instance GHC.Internal.Show.Show Hasura.RQL.Types.Webhook.Transform.Headers.HeadersTransformFn
instance GHC.Internal.Show.Show (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.Headers.Headers)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Webhook.Transform.Headers.AddReplaceOrRemoveFields
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Webhook.Transform.Headers.HeadersTransformFn
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.Headers.Headers)

module Hasura.RQL.Types.Webhook.Transform.Body

-- | HTTP message body being transformed.
data Body
JSONBody :: Maybe Value -> Body
RawBody :: ByteString -> Body

-- | The transformations which can be applied to an HTTP message body.
data BodyTransformFn

-- | Remove the HTTP message body.
Remove :: BodyTransformFn

-- | Modify the JSON message body by applying a <a>Template</a>
--   transformation.
ModifyAsJSON :: Template -> BodyTransformFn

-- | Modify the JSON message body by applying <a>UnescapedTemplate</a>
--   transformations to each field with a matching <a>Text</a> key.
ModifyAsFormURLEncoded :: HashMap Text UnescapedTemplate -> BodyTransformFn

-- | The associated type 'TransformFn a' is the defunctionalized version of
--   some transformation that should be applied to a given request field.
--   
--   In most cases it is some variation on a piece of template text
--   describing the transformation.
data family TransformFn a
data family TransformCtx a
instance GHC.Classes.Eq Hasura.RQL.Types.Webhook.Transform.Body.Body
instance GHC.Classes.Eq Hasura.RQL.Types.Webhook.Transform.Body.BodyTransformFn
instance GHC.Classes.Eq (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.Body.Body)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Webhook.Transform.Body.BodyTransformFn
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.Body.Body)
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Webhook.Transform.Body.BodyTransformFn
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.Body.Body)
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Webhook.Transform.Body.BodyTransformFn
instance Control.DeepSeq.NFData Hasura.RQL.Types.Webhook.Transform.Body.BodyTransformFn
instance Control.DeepSeq.NFData (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.Body.Body)
instance GHC.Internal.Show.Show Hasura.RQL.Types.Webhook.Transform.Body.Body
instance GHC.Internal.Show.Show Hasura.RQL.Types.Webhook.Transform.Body.BodyTransformFn
instance GHC.Internal.Show.Show (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.Body.Body)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Webhook.Transform.Body.BodyTransformFn
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.Body.Body)


-- | Types and subroutines related to constructing transformations on HTTP
--   requests.
module Hasura.RQL.DDL.Webhook.Transform.Request

-- | Common context that is made available to all request transformations.
data RequestTransformCtx
RequestTransformCtx :: Maybe Value -> Value -> Maybe SessionVariables -> Maybe Value -> TemplatingEngine -> RequestTransformCtx
[rtcBaseUrl] :: RequestTransformCtx -> Maybe Value
[rtcBody] :: RequestTransformCtx -> Value
[rtcSessionVariables] :: RequestTransformCtx -> Maybe SessionVariables
[rtcQueryParams] :: RequestTransformCtx -> Maybe Value
[rtcEngine] :: RequestTransformCtx -> TemplatingEngine

-- | A smart constructor for constructing the <a>RequestTransformCtx</a>
--   
--   XXX: This function makes internal usage of <a>decodeUtf8</a>, which
--   throws an impure exception when the supplied <a>ByteString</a> cannot
--   be decoded into valid UTF8 text!
mkReqTransformCtx :: Text -> Maybe SessionVariables -> TemplatingEngine -> Request -> RequestTransformCtx

-- | Available templating engines.
data TemplatingEngine
Kriti :: TemplatingEngine

-- | Textual transformation template.
newtype Template
Template :: Text -> Template
[unTemplate] :: Template -> Text

-- | <tt>RequestTransform</tt> Versioning
data Version
V1 :: Version
V2 :: Version

-- | A helper function for executing transformations from a <a>Template</a>
--   and a <a>RequestTransformCtx</a>.
--   
--   NOTE: This and all related funtions are hard-coded to Kriti at the
--   moment. When we add additional template engines this function will
--   need to take a <a>TemplatingEngine</a> parameter.
runRequestTemplateTransform :: Template -> RequestTransformCtx -> Either TransformErrorBundle Value
validateRequestTemplateTransform :: TemplatingEngine -> Template -> Either TransformErrorBundle ()
validateRequestTemplateTransform' :: TemplatingEngine -> Template -> Validation TransformErrorBundle ()

-- | A helper function for executing Kriti transformations from a
--   <a>UnescapedTemplate</a> and a <tt>RequestTrasformCtx</tt>.
--   
--   The difference from <a>runRequestTemplateTransform</a> is that this
--   function will wrap the template text in double quotes before running
--   Kriti.
runUnescapedRequestTemplateTransform :: RequestTransformCtx -> UnescapedTemplate -> Either TransformErrorBundle ByteString

-- | Run a Kriti transformation with an unescaped template in
--   <a>Validation</a> instead of <a>Either</a>.
runUnescapedRequestTemplateTransform' :: RequestTransformCtx -> UnescapedTemplate -> Validation TransformErrorBundle ByteString
validateRequestUnescapedTemplateTransform :: TemplatingEngine -> UnescapedTemplate -> Either TransformErrorBundle ()
validateRequestUnescapedTemplateTransform' :: TemplatingEngine -> UnescapedTemplate -> Validation TransformErrorBundle ()

module Hasura.RQL.DDL.Webhook.Transform.QueryParams

-- | The actual query params we are transforming.
--   
--   This newtype is necessary because otherwise we end up with an orphan
--   instance.
newtype QueryParams
QueryParams :: Query -> QueryParams
[unQueryParams] :: QueryParams -> Query

-- | The associated type 'TransformFn a' is the defunctionalized version of
--   some transformation that should be applied to a given request field.
--   
--   In most cases it is some variation on a piece of template text
--   describing the transformation.
data family TransformFn a
data family TransformCtx a

-- | The defunctionalized transformation <a>QueryParams</a>
data QueryParamsTransformFn
AddOrReplace :: [(UnescapedTemplate, Maybe UnescapedTemplate)] -> QueryParamsTransformFn
ParamTemplate :: UnescapedTemplate -> QueryParamsTransformFn
instance Hasura.RQL.DDL.Webhook.Transform.Class.Transform Hasura.RQL.Types.Webhook.Transform.QueryParams.QueryParams

module Hasura.RQL.DDL.Webhook.Transform.Method

-- | The actual request method we are transforming.
--   
--   This newtype is necessary because otherwise we end up with an orphan
--   instance.
newtype Method
Method :: CI Text -> Method

-- | The associated type 'TransformFn a' is the defunctionalized version of
--   some transformation that should be applied to a given request field.
--   
--   In most cases it is some variation on a piece of template text
--   describing the transformation.
data family TransformFn a
data family TransformCtx a

-- | The defunctionalized transformation on <a>Method</a>.
newtype MethodTransformFn

-- | Replace the HTTP existing <a>Method</a> with a new one.
Replace :: Method -> MethodTransformFn
instance Hasura.RQL.DDL.Webhook.Transform.Class.Transform Hasura.RQL.Types.Webhook.Transform.Method.Method

module Hasura.RQL.DDL.Webhook.Transform.Headers

-- | The actual header data we are transforming..
--   
--   This newtype is necessary because otherwise we end up with an orphan
--   instance.
newtype Headers
Headers :: [Header] -> Headers

-- | The associated type 'TransformFn a' is the defunctionalized version of
--   some transformation that should be applied to a given request field.
--   
--   In most cases it is some variation on a piece of template text
--   describing the transformation.
data family TransformFn a
data family TransformCtx a

-- | The defunctionalized transformation on <a>Headers</a>
newtype HeadersTransformFn

-- | Add or replace matching <a>Header</a>s.
AddReplaceOrRemove :: AddReplaceOrRemoveFields -> HeadersTransformFn

-- | The user can supply a set of header keys to be filtered from the
--   request and a set of headers to be added to the request.
data AddReplaceOrRemoveFields
AddReplaceOrRemoveFields :: [(CI Text, UnescapedTemplate)] -> [CI Text] -> AddReplaceOrRemoveFields

-- | A list of key-value pairs for <a>Header</a>s which should be added (if
--   they don't exist) or replaced (if they do) within the HTTP message.
[addOrReplaceHeaders] :: AddReplaceOrRemoveFields -> [(CI Text, UnescapedTemplate)]

-- | A list of <a>Header</a> keys which should be removed from the HTTP
--   message.
[removeHeaders] :: AddReplaceOrRemoveFields -> [CI Text]
instance Hasura.RQL.DDL.Webhook.Transform.Class.Transform Hasura.RQL.Types.Webhook.Transform.Headers.Headers

module Hasura.RQL.DDL.Webhook.Transform.Body

-- | HTTP message body being transformed.
data Body
JSONBody :: Maybe Value -> Body
RawBody :: ByteString -> Body

-- | The associated type 'TransformFn a' is the defunctionalized version of
--   some transformation that should be applied to a given request field.
--   
--   In most cases it is some variation on a piece of template text
--   describing the transformation.
data family TransformFn a
data family TransformCtx a

-- | The transformations which can be applied to an HTTP message body.
data BodyTransformFn

-- | Remove the HTTP message body.
Remove :: BodyTransformFn

-- | Modify the JSON message body by applying a <a>Template</a>
--   transformation.
ModifyAsJSON :: Template -> BodyTransformFn

-- | Modify the JSON message body by applying <a>UnescapedTemplate</a>
--   transformations to each field with a matching <a>Text</a> key.
ModifyAsFormURLEncoded :: HashMap Text UnescapedTemplate -> BodyTransformFn

-- | Fold a <a>HashMap</a> of header key/value pairs into an
--   <tt>x-www-form-urlencoded</tt> message body.
foldFormEncoded :: HashMap Text ByteString -> ByteString

-- | Validate that the provided <a>BodyTransformFn</a> is correct in the
--   context of a particular <a>TemplatingEngine</a>.
--   
--   This is a product of the fact that the correctness of a given
--   transformation may be dependent on zero, one, or more of the templated
--   transformations encoded within the given <a>BodyTransformFn</a>.
validateBodyTransformFn :: TemplatingEngine -> BodyTransformFn -> Validation TransformErrorBundle ()
instance Hasura.RQL.DDL.Webhook.Transform.Class.Transform Hasura.RQL.Types.Webhook.Transform.Body.Body

module Hasura.RQL.Types.Webhook.Transform.Url

-- | The actual URL string we are transforming.
--   
--   This newtype is necessary because otherwise we end up with an orphan
--   instance.
newtype Url
Url :: Text -> Url
[unUrl] :: Url -> Text

-- | The defunctionalized transformation function on <a>Url</a>
newtype UrlTransformFn
Modify :: UnescapedTemplate -> UrlTransformFn
data family TransformCtx a

-- | The associated type 'TransformFn a' is the defunctionalized version of
--   some transformation that should be applied to a given request field.
--   
--   In most cases it is some variation on a piece of template text
--   describing the transformation.
data family TransformFn a
instance GHC.Classes.Eq (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.Url.Url)
instance GHC.Classes.Eq Hasura.RQL.Types.Webhook.Transform.Url.Url
instance GHC.Classes.Eq Hasura.RQL.Types.Webhook.Transform.Url.UrlTransformFn
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.Url.Url)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Webhook.Transform.Url.UrlTransformFn
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.Url.Url)
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Webhook.Transform.Url.UrlTransformFn
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Webhook.Transform.Url.UrlTransformFn
instance Control.DeepSeq.NFData (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.Url.Url)
instance Control.DeepSeq.NFData Hasura.RQL.Types.Webhook.Transform.Url.UrlTransformFn
instance GHC.Internal.Show.Show (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.Url.Url)
instance GHC.Internal.Show.Show Hasura.RQL.Types.Webhook.Transform.Url.Url
instance GHC.Internal.Show.Show Hasura.RQL.Types.Webhook.Transform.Url.UrlTransformFn
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.Url.Url)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Webhook.Transform.Url.UrlTransformFn

module Hasura.RQL.DDL.Webhook.Transform.Url

-- | The actual URL string we are transforming.
--   
--   This newtype is necessary because otherwise we end up with an orphan
--   instance.
newtype Url
Url :: Text -> Url
[unUrl] :: Url -> Text

-- | The associated type 'TransformFn a' is the defunctionalized version of
--   some transformation that should be applied to a given request field.
--   
--   In most cases it is some variation on a piece of template text
--   describing the transformation.
data family TransformFn a
data family TransformCtx a

-- | The defunctionalized transformation function on <a>Url</a>
newtype UrlTransformFn
Modify :: UnescapedTemplate -> UrlTransformFn
instance Hasura.RQL.DDL.Webhook.Transform.Class.Transform Hasura.RQL.Types.Webhook.Transform.Url.Url

module Hasura.RQL.Types.Webhook.Transform.WithOptional

-- | Enrich a <a>Functor</a> <tt>f</tt> with optionality; this is primarily
--   useful when one wants to annotate fields as optional when using the
--   Higher-Kinded Data pattern.
--   
--   <a>WithOptional</a><tt> f</tt> is equivalent to <tt>Compose Maybe
--   f</tt>.
newtype WithOptional (f :: Type -> Type) result
WithOptional :: Maybe (f result) -> WithOptional (f :: Type -> Type) result
[getOptional] :: WithOptional (f :: Type -> Type) result -> Maybe (f result)

-- | <a>WithOptional</a> smart constructor for the special case of optional
--   values that are representationally equivalent to some "wrapper" type.
--   
--   For example: <tt> withOptional @HeaderTransformsAction headers ==
--   WithOptional $ fmap HeadersTransform headers </tt>
--   
--   In other words: this function observes the isomorphism between
--   <tt><a>Maybe</a> a</tt> and <tt><a>WithOptional</a> f b</tt> if an
--   isomorphism exists between <tt>a</tt> and <tt>f b</tt>.
withOptional :: forall a b (f :: Type -> Type). Coercible a (f b) => Maybe a -> WithOptional f b

-- | Define a field in an object codec that applies <a>withOptional</a>
--   when decoding, and applies <a>getOptional</a> when encoding.
withOptionalField' :: forall a b (f :: Type -> Type). (Coercible a (f b), HasCodec a) => Text -> ObjectCodec (WithOptional f b) (WithOptional f b)

-- | Define a field in an object codec that applies <a>withOptional</a>
--   when decoding, and applies <a>getOptional</a> when encoding.
--   
--   This version takes a codec for the underlying value type as an
--   argument.
withOptionalFieldWith' :: forall a b (f :: Type -> Type). Coercible a (f b) => Text -> ValueCodec a a -> ObjectCodec (WithOptional f b) (WithOptional f b)
instance GHC.Classes.Eq (f result) => GHC.Classes.Eq (Hasura.RQL.Types.Webhook.Transform.WithOptional.WithOptional f result)
instance GHC.Internal.Data.Foldable.Foldable f => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.Types.Webhook.Transform.WithOptional.WithOptional f)
instance Data.Aeson.Types.FromJSON.FromJSON (f result) => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Webhook.Transform.WithOptional.WithOptional f result)
instance GHC.Internal.Base.Functor f => GHC.Internal.Base.Functor (Hasura.RQL.Types.Webhook.Transform.WithOptional.WithOptional f)
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Webhook.Transform.WithOptional.WithOptional f result)
instance Control.DeepSeq.NFData (f result) => Control.DeepSeq.NFData (Hasura.RQL.Types.Webhook.Transform.WithOptional.WithOptional f result)
instance GHC.Internal.Show.Show (f result) => GHC.Internal.Show.Show (Hasura.RQL.Types.Webhook.Transform.WithOptional.WithOptional f result)
instance Data.Aeson.Types.ToJSON.ToJSON (f result) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Webhook.Transform.WithOptional.WithOptional f result)

module Hasura.RQL.Types.Webhook.Transform
data MetadataResponseTransform
MetadataResponseTransform :: Version -> Maybe BodyTransformFn -> TemplatingEngine -> MetadataResponseTransform
[mrtVersion] :: MetadataResponseTransform -> Version
[mrtBodyTransform] :: MetadataResponseTransform -> Maybe BodyTransformFn
[mrtTemplatingEngine] :: MetadataResponseTransform -> TemplatingEngine

-- | <a>RequestTransform</a> is the metadata representation of a request
--   transformation. It consists of a record of higher kinded data (HKD)
--   along with some regular data. We seperate the HKD data into its own
--   record field called <a>requestFields</a> which we nest inside our
--   non-HKD record. The actual transformation operations are contained in
--   the HKD.
data RequestTransform
RequestTransform :: Version -> RequestFields (WithOptional TransformFn) -> TemplatingEngine -> RequestTransform
[version] :: RequestTransform -> Version
[requestFields] :: RequestTransform -> RequestFields (WithOptional TransformFn)
[templateEngine] :: RequestTransform -> TemplatingEngine

-- | Defunctionalized Webhook Request Transformation
--   
--   We represent a defunctionalized request transformation by
--   parameterizing our HKD with <a>WithOptional</a><tt>
--   </tt><a>TransformFn</a>, which marks each of the fields as optional
--   and supplies the appropriate transformation function to them if if
--   they are provided.
type RequestTransformFns = RequestFields WithOptional TransformFn
type RequestContext = RequestFields TransformCtx

-- | Actual Request Data
--   
--   We represent the actual request data by parameterizing our HKD with
--   <a>Identity</a>, which allows us to trivially unwrap the fields (which
--   should exist after any transformations have been applied).
type RequestData = RequestFields Identity

-- | This is our HKD type. It is a record with fields for each component of
--   an <a>Request</a> we wish to transform.
data RequestFields (f :: Type -> Type)
RequestFields :: f Method -> f Url -> f Body -> f QueryParams -> f Headers -> RequestFields (f :: Type -> Type)
[method] :: RequestFields (f :: Type -> Type) -> f Method
[url] :: RequestFields (f :: Type -> Type) -> f Url
[body] :: RequestFields (f :: Type -> Type) -> f Body
[queryParams] :: RequestFields (f :: Type -> Type) -> f QueryParams
[requestHeaders] :: RequestFields (f :: Type -> Type) -> f Headers
instance Barbies.Internal.ApplicativeB.ApplicativeB Hasura.RQL.Types.Webhook.Transform.RequestFields
instance Barbies.Internal.ConstraintsB.ConstraintsB Hasura.RQL.Types.Webhook.Transform.RequestFields
instance GHC.Classes.Eq Hasura.RQL.Types.Webhook.Transform.MetadataResponseTransform
instance Barbies.Internal.ConstraintsB.AllBF GHC.Classes.Eq f Hasura.RQL.Types.Webhook.Transform.RequestFields => GHC.Classes.Eq (Hasura.RQL.Types.Webhook.Transform.RequestFields f)
instance GHC.Classes.Eq Hasura.RQL.Types.Webhook.Transform.RequestTransform
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Webhook.Transform.MetadataResponseTransform
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Webhook.Transform.RequestTransformFns
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Webhook.Transform.RequestTransform
instance Barbies.Internal.FunctorB.FunctorB Hasura.RQL.Types.Webhook.Transform.RequestFields
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Webhook.Transform.MetadataResponseTransform
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Webhook.Transform.RequestFields f)
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Webhook.Transform.RequestTransform
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Webhook.Transform.MetadataResponseTransform
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Webhook.Transform.RequestTransform
instance Control.DeepSeq.NFData Hasura.RQL.Types.Webhook.Transform.MetadataResponseTransform
instance Barbies.Internal.ConstraintsB.AllBF Control.DeepSeq.NFData f Hasura.RQL.Types.Webhook.Transform.RequestFields => Control.DeepSeq.NFData (Hasura.RQL.Types.Webhook.Transform.RequestFields f)
instance Control.DeepSeq.NFData Hasura.RQL.Types.Webhook.Transform.RequestTransform
instance GHC.Internal.Show.Show Hasura.RQL.Types.Webhook.Transform.MetadataResponseTransform
instance Barbies.Internal.ConstraintsB.AllBF GHC.Internal.Show.Show f Hasura.RQL.Types.Webhook.Transform.RequestFields => GHC.Internal.Show.Show (Hasura.RQL.Types.Webhook.Transform.RequestFields f)
instance GHC.Internal.Show.Show Hasura.RQL.Types.Webhook.Transform.RequestTransform
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Webhook.Transform.MetadataResponseTransform
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Webhook.Transform.RequestContext
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Webhook.Transform.RequestTransformFns
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Webhook.Transform.RequestTransform
instance Barbies.Internal.TraversableB.TraversableB Hasura.RQL.Types.Webhook.Transform.RequestFields


-- | Webhook Transformations are data transformations used to modify HTTP
--   Requests/Responses before requests are executed and after responses
--   are received.
--   
--   Transformations are supplied by users as part of the Metadata for a
--   particular Action or EventTrigger as a <a>RequestTransform</a> record.
--   Per-field Transformations are stored as data (defunctionalized), often
--   in the form of a Kriti template, and then converted into actual
--   functions (reified) at runtime by the <a>Transform</a> typeclass.
--   
--   We take a Higher Kinded Data (HKD) approach to representing the
--   transformations. <a>RequestFields</a> is an HKD which can represent
--   the actual request data as 'RequestFields Identity' or the
--   defunctionalized transforms as 'RequestFields (WithOptional
--   TransformFn)'.
--   
--   We can then traverse over the entire <a>RequestFields</a> HKD to reify
--   all the fields at once and apply them to our actual request data.
--   
--   NOTE: We don't literally use <a>traverse</a> or the HKD equivalent
--   <tt>btraverse</tt>, but you can think of this operation morally as a
--   traversal. See <a>applyRequestTransform</a> for implementation
--   details.
module Hasura.RQL.DDL.Webhook.Transform

-- | This is our HKD type. It is a record with fields for each component of
--   an <a>Request</a> we wish to transform.
data RequestFields (f :: Type -> Type)
RequestFields :: f Method -> f Url -> f Body -> f QueryParams -> f Headers -> RequestFields (f :: Type -> Type)
[method] :: RequestFields (f :: Type -> Type) -> f Method
[url] :: RequestFields (f :: Type -> Type) -> f Url
[body] :: RequestFields (f :: Type -> Type) -> f Body
[queryParams] :: RequestFields (f :: Type -> Type) -> f QueryParams
[requestHeaders] :: RequestFields (f :: Type -> Type) -> f Headers

-- | <a>RequestTransform</a> is the metadata representation of a request
--   transformation. It consists of a record of higher kinded data (HKD)
--   along with some regular data. We seperate the HKD data into its own
--   record field called <a>requestFields</a> which we nest inside our
--   non-HKD record. The actual transformation operations are contained in
--   the HKD.
data RequestTransform
RequestTransform :: Version -> RequestFields (WithOptional TransformFn) -> TemplatingEngine -> RequestTransform
[version] :: RequestTransform -> Version
[requestFields] :: RequestTransform -> RequestFields (WithOptional TransformFn)
[templateEngine] :: RequestTransform -> TemplatingEngine

-- | Defunctionalized Webhook Request Transformation
--   
--   We represent a defunctionalized request transformation by
--   parameterizing our HKD with <a>WithOptional</a><tt>
--   </tt><a>TransformFn</a>, which marks each of the fields as optional
--   and supplies the appropriate transformation function to them if if
--   they are provided.
type RequestTransformFns = RequestFields WithOptional TransformFn

-- | Transform an <a>Request</a> with a <a>RequestTransform</a>.
--   
--   Note: we pass in the request url explicitly for use in the
--   <tt>ReqTransformCtx</tt>. We do this so that we can ensure that the
--   url is syntactically identical to what the use submits. If we use the
--   parsed request from the <a>Request</a> term then it is possible that
--   the url is semantically equivalent but syntactically different. An
--   example of this is the presence or lack of a trailing slash on the URL
--   path. This important when performing string interpolation on the
--   request url.
applyRequestTransform :: MonadError TransformErrorBundle m => (Request -> RequestContext) -> RequestTransformFns -> Request -> m Request

-- | Common context that is made available to all request transformations.
data RequestTransformCtx
RequestTransformCtx :: Maybe Value -> Value -> Maybe SessionVariables -> Maybe Value -> TemplatingEngine -> RequestTransformCtx
[rtcBaseUrl] :: RequestTransformCtx -> Maybe Value
[rtcBody] :: RequestTransformCtx -> Value
[rtcSessionVariables] :: RequestTransformCtx -> Maybe SessionVariables
[rtcQueryParams] :: RequestTransformCtx -> Maybe Value
[rtcEngine] :: RequestTransformCtx -> TemplatingEngine
type RequestContext = RequestFields TransformCtx
mkRequestContext :: RequestTransformCtx -> RequestContext

-- | A smart constructor for constructing the <a>RequestTransformCtx</a>
--   
--   XXX: This function makes internal usage of <a>decodeUtf8</a>, which
--   throws an impure exception when the supplied <a>ByteString</a> cannot
--   be decoded into valid UTF8 text!
mkReqTransformCtx :: Text -> Maybe SessionVariables -> TemplatingEngine -> Request -> RequestTransformCtx

-- | We use collect all transformation failures as a '[J.Value]'.
newtype TransformErrorBundle
TransformErrorBundle :: [Value] -> TransformErrorBundle
[tebMessages] :: TransformErrorBundle -> [Value]

-- | Enrich a <a>Functor</a> <tt>f</tt> with optionality; this is primarily
--   useful when one wants to annotate fields as optional when using the
--   Higher-Kinded Data pattern.
--   
--   <a>WithOptional</a><tt> f</tt> is equivalent to <tt>Compose Maybe
--   f</tt>.
newtype WithOptional (f :: Type -> Type) result
WithOptional :: Maybe (f result) -> WithOptional (f :: Type -> Type) result
[getOptional] :: WithOptional (f :: Type -> Type) result -> Maybe (f result)

-- | <a>WithOptional</a> smart constructor for the special case of optional
--   values that are representationally equivalent to some "wrapper" type.
--   
--   For example: <tt> withOptional @HeaderTransformsAction headers ==
--   WithOptional $ fmap HeadersTransform headers </tt>
--   
--   In other words: this function observes the isomorphism between
--   <tt><a>Maybe</a> a</tt> and <tt><a>WithOptional</a> f b</tt> if an
--   isomorphism exists between <tt>a</tt> and <tt>f b</tt>.
withOptional :: forall a b (f :: Type -> Type). Coercible a (f b) => Maybe a -> WithOptional f b
data MetadataResponseTransform
MetadataResponseTransform :: Version -> Maybe BodyTransformFn -> TemplatingEngine -> MetadataResponseTransform
[mrtVersion] :: MetadataResponseTransform -> Version
[mrtBodyTransform] :: MetadataResponseTransform -> Maybe BodyTransformFn
[mrtTemplatingEngine] :: MetadataResponseTransform -> TemplatingEngine

-- | A set of data transformation functions generated from a
--   <a>MetadataResponseTransform</a>. <a>Nothing</a> means use the
--   original response value.
data ResponseTransform
ResponseTransform :: Maybe (ResponseTransformCtx -> Either TransformErrorBundle Value) -> TemplatingEngine -> ResponseTransform
[respTransformBody] :: ResponseTransform -> Maybe (ResponseTransformCtx -> Either TransformErrorBundle Value)
[respTransformTemplateEngine] :: ResponseTransform -> TemplatingEngine

-- | Common context that is made available to all response transformations.
data ResponseTransformCtx
ResponseTransformCtx :: Value -> Value -> Maybe SessionVariables -> TemplatingEngine -> Int -> ResponseTransformCtx
[responseTransformBody] :: ResponseTransformCtx -> Value
[responseTransformReqCtx] :: ResponseTransformCtx -> Value
[responseSessionVariables] :: ResponseTransformCtx -> Maybe SessionVariables
[responseTransformEngine] :: ResponseTransformCtx -> TemplatingEngine
[responseStatusCode] :: ResponseTransformCtx -> Int

-- | At the moment we only transform the body of Responses. 'http-client'
--   does not export the constructors for <tt>Response</tt>. If we want to
--   transform other fields then we will need additional <tt>apply</tt>
--   functions.
applyResponseTransform :: ResponseTransform -> ResponseTransformCtx -> Either TransformErrorBundle ByteString

-- | A helper function for constructing the <a>ResponseTransformCtx</a>
buildRespTransformCtx :: Maybe RequestContext -> Maybe SessionVariables -> TemplatingEngine -> ByteString -> Int -> ResponseTransformCtx
mkResponseTransform :: MetadataResponseTransform -> ResponseTransform


-- | We validate <a>TransformFn</a> terms inside <a>RequestTransform</a>
--   before dispatching Metadata actions in <tt>runMetadataQueryV1M</tt>.
--   Validation follows the same HKD pattern from
--   <a>applyRequestTransform</a> but using <a>btraverseC</a> to call
--   <a>validate</a> from the <a>Transform</a> class on all the HKD fields.
module Hasura.RQL.DDL.Webhook.Transform.Validation

-- | Used to annotate that a <a>RequestTransform</a>, or some record
--   containing a <a>RequestTransform</a> has not yet been validated.
newtype Unvalidated a
Unvalidated :: a -> Unvalidated a
[_unUnvalidate] :: Unvalidated a -> a

-- | Used to annotate that a higher kinded type containing a
--   <a>RequestTransform</a> has not yet been validated.
--   
--   This is needed specifically for <tt>CreateEventTriggerQuery</tt> and
--   any other type that is paramterized by a <tt>BackendType</tt>.
newtype Unvalidated1 (f :: k -> Type) (a :: k)
Unvalidated1 :: f a -> Unvalidated1 (f :: k -> Type) (a :: k)
[_unUnvalidate1] :: Unvalidated1 (f :: k -> Type) (a :: k) -> f a

-- | A lens for focusing through <a>Unvalidated</a> in
--   <a>validateTransforms</a>.
unUnvalidate :: forall a f. Functor f => (a -> f a) -> Unvalidated a -> f (Unvalidated a)

-- | A lens for focusing through <a>Unvalidated1</a> in
--   <a>validateTransforms</a>.
unUnvalidate1 :: forall {k} f1 (a :: k) f2. Functor f2 => (f1 a -> f2 (f1 a)) -> Unvalidated1 f1 a -> f2 (Unvalidated1 f1 a)

-- | Validate all 'TransformFn a' fields in the <a>RequestTransform</a>.
validateRequestTransform :: MonadError QErr m => RequestTransform -> m RequestTransform

-- | Used to focus into a records in <tt>RQLMetadataV1</tt> and validate
--   any <a>RequestTransform</a> terms present.
validateTransforms :: MonadError QErr m => LensLike m api api RequestTransform RequestTransform -> LensLike m api api MetadataResponseTransform MetadataResponseTransform -> (api -> m EncJSON) -> api -> m EncJSON
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Webhook.Transform.Validation.Unvalidated a)
instance forall k (f :: k -> *) (a :: k). Data.Aeson.Types.FromJSON.FromJSON (f a) => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Webhook.Transform.Validation.Unvalidated1 f a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.DDL.Webhook.Transform.Validation.Unvalidated a)
instance forall k (f :: k -> *) (a :: k). Data.Aeson.Types.ToJSON.ToJSON (f a) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.DDL.Webhook.Transform.Validation.Unvalidated1 f a)

module Hasura.RemoteSchema.Metadata.Base

-- | Remote schema identifier.
--   
--   NOTE: no validation on the character set is done here; it's likely
--   there is a bug (FIXME) where this interacts with remote relationships
--   and some name mangling needs to happen.
newtype RemoteSchemaName
RemoteSchemaName :: NonEmptyText -> RemoteSchemaName
[unRemoteSchemaName] :: RemoteSchemaName -> NonEmptyText
instance GHC.Classes.Eq Hasura.RemoteSchema.Metadata.Base.RemoteSchemaName
instance Database.PG.Query.Class.FromCol Hasura.RemoteSchema.Metadata.Base.RemoteSchemaName
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.RemoteSchema.Metadata.Base.RemoteSchemaName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RemoteSchema.Metadata.Base.RemoteSchemaName
instance GHC.Internal.Generics.Generic Hasura.RemoteSchema.Metadata.Base.RemoteSchemaName
instance Autodocodec.Class.HasCodec Hasura.RemoteSchema.Metadata.Base.RemoteSchemaName
instance Data.Hashable.Class.Hashable Hasura.RemoteSchema.Metadata.Base.RemoteSchemaName
instance Control.DeepSeq.NFData Hasura.RemoteSchema.Metadata.Base.RemoteSchemaName
instance GHC.Classes.Ord Hasura.RemoteSchema.Metadata.Base.RemoteSchemaName
instance GHC.Internal.Show.Show Hasura.RemoteSchema.Metadata.Base.RemoteSchemaName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RemoteSchema.Metadata.Base.RemoteSchemaName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RemoteSchema.Metadata.Base.RemoteSchemaName
instance Database.PG.Query.Class.ToPrepArg Hasura.RemoteSchema.Metadata.Base.RemoteSchemaName
instance Data.Text.Extended.ToTxt Hasura.RemoteSchema.Metadata.Base.RemoteSchemaName

module Hasura.RemoteSchema.Metadata.Customization
data RemoteTypeCustomization
RemoteTypeCustomization :: Maybe Name -> Maybe Name -> HashMap Name Name -> RemoteTypeCustomization
[_rtcPrefix] :: RemoteTypeCustomization -> Maybe Name
[_rtcSuffix] :: RemoteTypeCustomization -> Maybe Name
[_rtcMapping] :: RemoteTypeCustomization -> HashMap Name Name
data RemoteFieldCustomization
RemoteFieldCustomization :: Name -> Maybe Name -> Maybe Name -> HashMap Name Name -> RemoteFieldCustomization
[_rfcParentType] :: RemoteFieldCustomization -> Name
[_rfcPrefix] :: RemoteFieldCustomization -> Maybe Name
[_rfcSuffix] :: RemoteFieldCustomization -> Maybe Name
[_rfcMapping] :: RemoteFieldCustomization -> HashMap Name Name
data RemoteSchemaCustomization
RemoteSchemaCustomization :: Maybe Name -> Maybe RemoteTypeCustomization -> Maybe [RemoteFieldCustomization] -> RemoteSchemaCustomization
[_rscRootFieldsNamespace] :: RemoteSchemaCustomization -> Maybe Name
[_rscTypeNames] :: RemoteSchemaCustomization -> Maybe RemoteTypeCustomization
[_rscFieldNames] :: RemoteSchemaCustomization -> Maybe [RemoteFieldCustomization]
instance GHC.Classes.Eq Hasura.RemoteSchema.Metadata.Customization.RemoteFieldCustomization
instance GHC.Classes.Eq Hasura.RemoteSchema.Metadata.Customization.RemoteSchemaCustomization
instance GHC.Classes.Eq Hasura.RemoteSchema.Metadata.Customization.RemoteTypeCustomization
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RemoteSchema.Metadata.Customization.RemoteFieldCustomization
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RemoteSchema.Metadata.Customization.RemoteSchemaCustomization
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RemoteSchema.Metadata.Customization.RemoteTypeCustomization
instance GHC.Internal.Generics.Generic Hasura.RemoteSchema.Metadata.Customization.RemoteFieldCustomization
instance GHC.Internal.Generics.Generic Hasura.RemoteSchema.Metadata.Customization.RemoteSchemaCustomization
instance GHC.Internal.Generics.Generic Hasura.RemoteSchema.Metadata.Customization.RemoteTypeCustomization
instance Autodocodec.Class.HasCodec Hasura.RemoteSchema.Metadata.Customization.RemoteFieldCustomization
instance Autodocodec.Class.HasCodec Hasura.RemoteSchema.Metadata.Customization.RemoteSchemaCustomization
instance Autodocodec.Class.HasCodec Hasura.RemoteSchema.Metadata.Customization.RemoteTypeCustomization
instance Data.Hashable.Class.Hashable Hasura.RemoteSchema.Metadata.Customization.RemoteFieldCustomization
instance Data.Hashable.Class.Hashable Hasura.RemoteSchema.Metadata.Customization.RemoteSchemaCustomization
instance Data.Hashable.Class.Hashable Hasura.RemoteSchema.Metadata.Customization.RemoteTypeCustomization
instance Control.DeepSeq.NFData Hasura.RemoteSchema.Metadata.Customization.RemoteFieldCustomization
instance Control.DeepSeq.NFData Hasura.RemoteSchema.Metadata.Customization.RemoteSchemaCustomization
instance Control.DeepSeq.NFData Hasura.RemoteSchema.Metadata.Customization.RemoteTypeCustomization
instance GHC.Internal.Show.Show Hasura.RemoteSchema.Metadata.Customization.RemoteFieldCustomization
instance GHC.Internal.Show.Show Hasura.RemoteSchema.Metadata.Customization.RemoteSchemaCustomization
instance GHC.Internal.Show.Show Hasura.RemoteSchema.Metadata.Customization.RemoteTypeCustomization
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RemoteSchema.Metadata.Customization.RemoteFieldCustomization
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RemoteSchema.Metadata.Customization.RemoteSchemaCustomization
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RemoteSchema.Metadata.Customization.RemoteTypeCustomization

module Hasura.RemoteSchema.Metadata.Permission
newtype RemoteSchemaPermissionDefinition
RemoteSchemaPermissionDefinition :: SchemaDocument -> RemoteSchemaPermissionDefinition
[_rspdSchema] :: RemoteSchemaPermissionDefinition -> SchemaDocument
data RemoteSchemaPermissionMetadata
RemoteSchemaPermissionMetadata :: RoleName -> RemoteSchemaPermissionDefinition -> Maybe Text -> RemoteSchemaPermissionMetadata
[_rspmRole] :: RemoteSchemaPermissionMetadata -> RoleName
[_rspmDefinition] :: RemoteSchemaPermissionMetadata -> RemoteSchemaPermissionDefinition
[_rspmComment] :: RemoteSchemaPermissionMetadata -> Maybe Text
instance GHC.Classes.Eq Hasura.RemoteSchema.Metadata.Permission.RemoteSchemaPermissionDefinition
instance GHC.Classes.Eq Hasura.RemoteSchema.Metadata.Permission.RemoteSchemaPermissionMetadata
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RemoteSchema.Metadata.Permission.RemoteSchemaPermissionDefinition
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RemoteSchema.Metadata.Permission.RemoteSchemaPermissionMetadata
instance GHC.Internal.Generics.Generic Hasura.RemoteSchema.Metadata.Permission.RemoteSchemaPermissionDefinition
instance GHC.Internal.Generics.Generic Hasura.RemoteSchema.Metadata.Permission.RemoteSchemaPermissionMetadata
instance Autodocodec.Class.HasCodec Hasura.RemoteSchema.Metadata.Permission.RemoteSchemaPermissionDefinition
instance Autodocodec.Class.HasCodec Hasura.RemoteSchema.Metadata.Permission.RemoteSchemaPermissionMetadata
instance Data.Hashable.Class.Hashable Hasura.RemoteSchema.Metadata.Permission.RemoteSchemaPermissionDefinition
instance Control.DeepSeq.NFData Hasura.RemoteSchema.Metadata.Permission.RemoteSchemaPermissionDefinition
instance GHC.Internal.Show.Show Hasura.RemoteSchema.Metadata.Permission.RemoteSchemaPermissionDefinition
instance GHC.Internal.Show.Show Hasura.RemoteSchema.Metadata.Permission.RemoteSchemaPermissionMetadata
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RemoteSchema.Metadata.Permission.RemoteSchemaPermissionDefinition
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RemoteSchema.Metadata.Permission.RemoteSchemaPermissionMetadata

module Hasura.RemoteSchema.Metadata.RemoteRelationship

-- | Metadata representation of a relationship to a remote schema.
data ToSchemaRelationshipDef
ToSchemaRelationshipDef :: RemoteSchemaName -> HashSet FieldName -> RemoteFields -> ToSchemaRelationshipDef

-- | Identifier for this mapping.
[_trrdRemoteSchema] :: ToSchemaRelationshipDef -> RemoteSchemaName

-- | The lhs fields that must be forwarded to the remote schema.
[_trrdLhsFields] :: ToSchemaRelationshipDef -> HashSet FieldName
[_trrdRemoteField] :: ToSchemaRelationshipDef -> RemoteFields
trrdRemoteField :: Lens' ToSchemaRelationshipDef RemoteFields
trrdLhsFields :: Lens' ToSchemaRelationshipDef (HashSet FieldName)
trrdRemoteSchema :: Lens' ToSchemaRelationshipDef RemoteSchemaName

-- | Associates a field name with the arguments it will be passed in the
--   query.
--   
--   
--   <a>https://graphql.github.io/graphql-spec/June2018/#sec-Language.Arguments</a>
data FieldCall
FieldCall :: Name -> RemoteArguments -> FieldCall
[fcName] :: FieldCall -> Name
[fcArguments] :: FieldCall -> RemoteArguments

-- | Arguments to a remote GraphQL fields, represented as a mapping from
--   name to GraphQL Value. Said values can be variable names, in which
--   case they'll be referring to values we're closed over. TODO: expand on
--   this
newtype RemoteArguments
RemoteArguments :: HashMap Name (Value Name) -> RemoteArguments
[getRemoteArguments] :: RemoteArguments -> HashMap Name (Value Name)

-- | Targeted field in a remote schema relationship. TODO: explain about
--   subfields and why this is a container
newtype RemoteFields
RemoteFields :: NonEmpty FieldCall -> RemoteFields
[unRemoteFields] :: RemoteFields -> NonEmpty FieldCall
type SchemaRemoteRelationships r = InsOrdHashMap Name RemoteSchemaTypeRelationships r
data RemoteSchemaTypeRelationships r
RemoteSchemaTypeRelationships :: Name -> RemoteRelationships r -> RemoteSchemaTypeRelationships r
[_rstrsName] :: RemoteSchemaTypeRelationships r -> Name
[_rstrsRelationships] :: RemoteSchemaTypeRelationships r -> RemoteRelationships r
rstrsName :: forall r f. Functor f => (Name -> f Name) -> RemoteSchemaTypeRelationships r -> f (RemoteSchemaTypeRelationships r)
rstrsRelationships :: forall r1 r2 f. Functor f => (RemoteRelationships r1 -> f (RemoteRelationships r2)) -> RemoteSchemaTypeRelationships r1 -> f (RemoteSchemaTypeRelationships r2)
instance GHC.Classes.Eq Hasura.RemoteSchema.Metadata.RemoteRelationship.FieldCall
instance GHC.Classes.Eq Hasura.RemoteSchema.Metadata.RemoteRelationship.RemoteArguments
instance GHC.Classes.Eq Hasura.RemoteSchema.Metadata.RemoteRelationship.RemoteFields
instance GHC.Classes.Eq r => GHC.Classes.Eq (Hasura.RemoteSchema.Metadata.RemoteRelationship.RemoteSchemaTypeRelationships r)
instance GHC.Classes.Eq Hasura.RemoteSchema.Metadata.RemoteRelationship.ToSchemaRelationshipDef
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RemoteSchema.Metadata.RemoteRelationship.RemoteArguments
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RemoteSchema.Metadata.RemoteRelationship.RemoteFields
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Common.RemoteRelationshipG r) => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RemoteSchema.Metadata.RemoteRelationship.RemoteSchemaTypeRelationships r)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RemoteSchema.Metadata.RemoteRelationship.ToSchemaRelationshipDef
instance GHC.Internal.Generics.Generic Hasura.RemoteSchema.Metadata.RemoteRelationship.FieldCall
instance GHC.Internal.Generics.Generic Hasura.RemoteSchema.Metadata.RemoteRelationship.RemoteArguments
instance GHC.Internal.Generics.Generic Hasura.RemoteSchema.Metadata.RemoteRelationship.RemoteFields
instance GHC.Internal.Generics.Generic (Hasura.RemoteSchema.Metadata.RemoteRelationship.RemoteSchemaTypeRelationships r)
instance GHC.Internal.Generics.Generic Hasura.RemoteSchema.Metadata.RemoteRelationship.ToSchemaRelationshipDef
instance Autodocodec.Class.HasCodec Hasura.RemoteSchema.Metadata.RemoteRelationship.RemoteArguments
instance Autodocodec.Class.HasCodec Hasura.RemoteSchema.Metadata.RemoteRelationship.RemoteFields
instance (Autodocodec.Class.HasCodec (Hasura.RQL.Types.Common.RemoteRelationshipG r), GHC.Internal.Data.Typeable.Internal.Typeable r) => Autodocodec.Class.HasCodec (Hasura.RemoteSchema.Metadata.RemoteRelationship.RemoteSchemaTypeRelationships r)
instance Autodocodec.Class.HasCodec Hasura.RemoteSchema.Metadata.RemoteRelationship.ToSchemaRelationshipDef
instance Data.Hashable.Class.Hashable Hasura.RemoteSchema.Metadata.RemoteRelationship.FieldCall
instance Data.Hashable.Class.Hashable Hasura.RemoteSchema.Metadata.RemoteRelationship.RemoteArguments
instance Control.DeepSeq.NFData Hasura.RemoteSchema.Metadata.RemoteRelationship.FieldCall
instance Control.DeepSeq.NFData Hasura.RemoteSchema.Metadata.RemoteRelationship.RemoteArguments
instance Control.DeepSeq.NFData Hasura.RemoteSchema.Metadata.RemoteRelationship.RemoteFields
instance Control.DeepSeq.NFData Hasura.RemoteSchema.Metadata.RemoteRelationship.ToSchemaRelationshipDef
instance GHC.Internal.Show.Show Hasura.RemoteSchema.Metadata.RemoteRelationship.FieldCall
instance GHC.Internal.Show.Show Hasura.RemoteSchema.Metadata.RemoteRelationship.RemoteArguments
instance GHC.Internal.Show.Show Hasura.RemoteSchema.Metadata.RemoteRelationship.RemoteFields
instance GHC.Internal.Show.Show r => GHC.Internal.Show.Show (Hasura.RemoteSchema.Metadata.RemoteRelationship.RemoteSchemaTypeRelationships r)
instance GHC.Internal.Show.Show Hasura.RemoteSchema.Metadata.RemoteRelationship.ToSchemaRelationshipDef
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RemoteSchema.Metadata.RemoteRelationship.RemoteArguments
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RemoteSchema.Metadata.RemoteRelationship.RemoteFields
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Common.RemoteRelationshipG r) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RemoteSchema.Metadata.RemoteRelationship.RemoteSchemaTypeRelationships r)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RemoteSchema.Metadata.RemoteRelationship.ToSchemaRelationshipDef

module Hasura.RemoteSchema.Metadata.Core

-- | Unvalidated remote schema config, from the user's API request
data RemoteSchemaDef
RemoteSchemaDef :: Maybe InputWebhook -> Maybe UrlFromEnv -> Maybe [HeaderConf] -> Bool -> Maybe Int -> Maybe RemoteSchemaCustomization -> RemoteSchemaDef
[_rsdUrl] :: RemoteSchemaDef -> Maybe InputWebhook
[_rsdUrlFromEnv] :: RemoteSchemaDef -> Maybe UrlFromEnv
[_rsdHeaders] :: RemoteSchemaDef -> Maybe [HeaderConf]
[_rsdForwardClientHeaders] :: RemoteSchemaDef -> Bool
[_rsdTimeoutSeconds] :: RemoteSchemaDef -> Maybe Int
[_rsdCustomization] :: RemoteSchemaDef -> Maybe RemoteSchemaCustomization

-- | Remote schema identifier.
--   
--   NOTE: no validation on the character set is done here; it's likely
--   there is a bug (FIXME) where this interacts with remote relationships
--   and some name mangling needs to happen.
newtype RemoteSchemaName
RemoteSchemaName :: NonEmptyText -> RemoteSchemaName
[unRemoteSchemaName] :: RemoteSchemaName -> NonEmptyText
type UrlFromEnv = Text
getUrlFromEnv :: MonadError QErr m => Environment -> Text -> m (EnvRecord URI)
data RemoteSchemaMetadataG r
RemoteSchemaMetadata :: RemoteSchemaName -> RemoteSchemaDef -> Maybe Text -> [RemoteSchemaPermissionMetadata] -> SchemaRemoteRelationships r -> RemoteSchemaMetadataG r
[_rsmName] :: RemoteSchemaMetadataG r -> RemoteSchemaName
[_rsmDefinition] :: RemoteSchemaMetadataG r -> RemoteSchemaDef
[_rsmComment] :: RemoteSchemaMetadataG r -> Maybe Text
[_rsmPermissions] :: RemoteSchemaMetadataG r -> [RemoteSchemaPermissionMetadata]
[_rsmRemoteRelationships] :: RemoteSchemaMetadataG r -> SchemaRemoteRelationships r
rsmComment :: forall r f. Functor f => (Maybe Text -> f (Maybe Text)) -> RemoteSchemaMetadataG r -> f (RemoteSchemaMetadataG r)
rsmDefinition :: forall r f. Functor f => (RemoteSchemaDef -> f RemoteSchemaDef) -> RemoteSchemaMetadataG r -> f (RemoteSchemaMetadataG r)
rsmName :: forall r f. Functor f => (RemoteSchemaName -> f RemoteSchemaName) -> RemoteSchemaMetadataG r -> f (RemoteSchemaMetadataG r)
rsmPermissions :: forall r f. Functor f => ([RemoteSchemaPermissionMetadata] -> f [RemoteSchemaPermissionMetadata]) -> RemoteSchemaMetadataG r -> f (RemoteSchemaMetadataG r)
rsmRemoteRelationships :: forall r1 r2 f. Functor f => (SchemaRemoteRelationships r1 -> f (SchemaRemoteRelationships r2)) -> RemoteSchemaMetadataG r1 -> f (RemoteSchemaMetadataG r2)
instance GHC.Classes.Eq Hasura.RemoteSchema.Metadata.Core.RemoteSchemaDef
instance GHC.Classes.Eq r => GHC.Classes.Eq (Hasura.RemoteSchema.Metadata.Core.RemoteSchemaMetadataG r)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RemoteSchema.Metadata.Core.RemoteSchemaDef
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Common.RemoteRelationshipG r) => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RemoteSchema.Metadata.Core.RemoteSchemaMetadataG r)
instance GHC.Internal.Generics.Generic Hasura.RemoteSchema.Metadata.Core.RemoteSchemaDef
instance GHC.Internal.Generics.Generic (Hasura.RemoteSchema.Metadata.Core.RemoteSchemaMetadataG r)
instance Autodocodec.Class.HasCodec Hasura.RemoteSchema.Metadata.Core.RemoteSchemaDef
instance (Autodocodec.Class.HasCodec (Hasura.RQL.Types.Common.RemoteRelationshipG r), GHC.Internal.Data.Typeable.Internal.Typeable r) => Autodocodec.Class.HasCodec (Hasura.RemoteSchema.Metadata.Core.RemoteSchemaMetadataG r)
instance Control.DeepSeq.NFData Hasura.RemoteSchema.Metadata.Core.RemoteSchemaDef
instance GHC.Internal.Show.Show Hasura.RemoteSchema.Metadata.Core.RemoteSchemaDef
instance GHC.Internal.Show.Show r => GHC.Internal.Show.Show (Hasura.RemoteSchema.Metadata.Core.RemoteSchemaMetadataG r)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RemoteSchema.Metadata.Core.RemoteSchemaDef
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Common.RemoteRelationshipG r) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RemoteSchema.Metadata.Core.RemoteSchemaMetadataG r)

module Hasura.RemoteSchema.Metadata

module Hasura.RemoteSchema.SchemaCache.Types
type RemoteSchemaRelationshipsG remoteFieldInfo = InsOrdHashMap Name InsOrdHashMap RelName remoteFieldInfo
data IntrospectionResult
IntrospectionResult :: RemoteSchemaIntrospection -> Name -> Maybe Name -> Maybe Name -> IntrospectionResult
[irDoc] :: IntrospectionResult -> RemoteSchemaIntrospection
[irQueryRoot] :: IntrospectionResult -> Name
[irMutationRoot] :: IntrospectionResult -> Maybe Name
[irSubscriptionRoot] :: IntrospectionResult -> Maybe Name

-- | The resolved information of a remote schema. It is parameterized by
--   <tt>remoteFieldInfo</tt> so as to work on an arbitrary 'remote
--   relationship' TODO: Get rid of this <tt>G</tt> suffix using pattern
--   synonyms or qualified usage
data RemoteSchemaCtxG remoteFieldInfo
RemoteSchemaCtx :: RemoteSchemaName -> IntrospectionResult -> RemoteSchemaInfo -> ByteString -> HashMap RoleName IntrospectionResult -> RemoteSchemaRelationshipsG remoteFieldInfo -> RemoteSchemaCtxG remoteFieldInfo
[_rscName] :: RemoteSchemaCtxG remoteFieldInfo -> RemoteSchemaName

-- | Original remote schema without customizations
[_rscIntroOriginal] :: RemoteSchemaCtxG remoteFieldInfo -> IntrospectionResult
[_rscInfo] :: RemoteSchemaCtxG remoteFieldInfo -> RemoteSchemaInfo

-- | The raw response from the introspection query against the remote
--   server. We store this so we can efficiently service
--   <tt>introspect_remote_schema</tt>.
[_rscRawIntrospectionResult] :: RemoteSchemaCtxG remoteFieldInfo -> ByteString
[_rscPermissions] :: RemoteSchemaCtxG remoteFieldInfo -> HashMap RoleName IntrospectionResult
[_rscRemoteRelationships] :: RemoteSchemaCtxG remoteFieldInfo -> RemoteSchemaRelationshipsG remoteFieldInfo

-- | Resolved information of a remote relationship with the local
--   information that we have. Currently this is only the typename on which
--   the relationship is defined. TODO: also add the available join fields
--   on the type
data PartiallyResolvedRemoteRelationship remoteRelationshipDefinition
PartiallyResolvedRemoteRelationship :: Name -> RemoteRelationshipG remoteRelationshipDefinition -> PartiallyResolvedRemoteRelationship remoteRelationshipDefinition
[_prrrTypeName] :: PartiallyResolvedRemoteRelationship remoteRelationshipDefinition -> Name
[_prrrDefinition] :: PartiallyResolvedRemoteRelationship remoteRelationshipDefinition -> RemoteRelationshipG remoteRelationshipDefinition

-- | We can't go from RemoteSchemaMetadata to RemoteSchemaCtx in a single
--   phase because we don't have information to resolve remote
--   relationships. So we annotate remote relationships with as much
--   information as we know about them which would be further resolved in a
--   later stage.
type PartiallyResolvedRemoteSchemaCtxG remoteRelationshipDefinition = RemoteSchemaCtxG PartiallyResolvedRemoteRelationship remoteRelationshipDefinition
rscName :: forall remoteFieldInfo f. Functor f => (RemoteSchemaName -> f RemoteSchemaName) -> RemoteSchemaCtxG remoteFieldInfo -> f (RemoteSchemaCtxG remoteFieldInfo)
rscInfo :: forall remoteFieldInfo f. Functor f => (RemoteSchemaInfo -> f RemoteSchemaInfo) -> RemoteSchemaCtxG remoteFieldInfo -> f (RemoteSchemaCtxG remoteFieldInfo)
rscIntroOriginal :: forall remoteFieldInfo f. Functor f => (IntrospectionResult -> f IntrospectionResult) -> RemoteSchemaCtxG remoteFieldInfo -> f (RemoteSchemaCtxG remoteFieldInfo)
rscRawIntrospectionResult :: forall remoteFieldInfo f. Functor f => (ByteString -> f ByteString) -> RemoteSchemaCtxG remoteFieldInfo -> f (RemoteSchemaCtxG remoteFieldInfo)
rscPermissions :: forall remoteFieldInfo f. Functor f => (HashMap RoleName IntrospectionResult -> f (HashMap RoleName IntrospectionResult)) -> RemoteSchemaCtxG remoteFieldInfo -> f (RemoteSchemaCtxG remoteFieldInfo)
rscRemoteRelationships :: forall remoteFieldInfo1 remoteFieldInfo2 f. Functor f => (RemoteSchemaRelationshipsG remoteFieldInfo1 -> f (RemoteSchemaRelationshipsG remoteFieldInfo2)) -> RemoteSchemaCtxG remoteFieldInfo1 -> f (RemoteSchemaCtxG remoteFieldInfo2)
data RemoteSchemaCustomizer
RemoteSchemaCustomizer :: Maybe Name -> HashMap Name Name -> HashMap Name (HashMap Name Name) -> RemoteSchemaCustomizer
[_rscNamespaceFieldName] :: RemoteSchemaCustomizer -> Maybe Name

-- | type name -&gt; type name
[_rscCustomizeTypeName] :: RemoteSchemaCustomizer -> HashMap Name Name

-- | type name -&gt; field name -&gt; field name
[_rscCustomizeFieldName] :: RemoteSchemaCustomizer -> HashMap Name (HashMap Name Name)

-- | <a>RemoteSchemaDef</a> after the RemoteSchemaCustomizer has been
--   generated by fetchRemoteSchema
data RemoteSchemaInfo
RemoteSchemaInfo :: ValidatedRemoteSchemaDef -> RemoteSchemaCustomizer -> RemoteSchemaInfo
[rsDef] :: RemoteSchemaInfo -> ValidatedRemoteSchemaDef
[rsCustomizer] :: RemoteSchemaInfo -> RemoteSchemaCustomizer

-- | <a>RemoteSchemaDef</a> after validation and baking-in of defaults in
--   <a>validateRemoteSchemaDef</a>.
data ValidatedRemoteSchemaDef
ValidatedRemoteSchemaDef :: RemoteSchemaName -> EnvRecord URI -> [HeaderConf] -> Bool -> Int -> Maybe RemoteSchemaCustomization -> ValidatedRemoteSchemaDef
[_vrsdName] :: ValidatedRemoteSchemaDef -> RemoteSchemaName
[_vrsdUrl] :: ValidatedRemoteSchemaDef -> EnvRecord URI
[_vrsdHeaders] :: ValidatedRemoteSchemaDef -> [HeaderConf]
[_vrsdFwdClientHeaders] :: ValidatedRemoteSchemaDef -> Bool
[_vrsdTimeoutSeconds] :: ValidatedRemoteSchemaDef -> Int

-- | See <a>_rsdCustomization</a>.
[_vrsdCustomization] :: ValidatedRemoteSchemaDef -> Maybe RemoteSchemaCustomization
hasTypeOrFieldCustomizations :: RemoteSchemaCustomizer -> Bool
identityCustomizer :: RemoteSchemaCustomizer
remoteSchemaCustomizeFieldName :: RemoteSchemaCustomizer -> CustomizeRemoteFieldName
remoteSchemaCustomizeTypeName :: RemoteSchemaCustomizer -> MkTypename
validateRemoteSchemaCustomization :: MonadError QErr m => Maybe RemoteSchemaCustomization -> m ()
validateRemoteSchemaDef :: MonadError QErr m => RemoteSchemaName -> Environment -> RemoteSchemaDef -> m ValidatedRemoteSchemaDef
newtype CustomizeRemoteFieldName
CustomizeRemoteFieldName :: (Name -> Name -> Name) -> CustomizeRemoteFieldName
[runCustomizeRemoteFieldName] :: CustomizeRemoteFieldName -> Name -> Name -> Name
withRemoteFieldNameCustomization :: forall m r a. (MonadReader r m, Has CustomizeRemoteFieldName r) => CustomizeRemoteFieldName -> m a -> m a

-- | Extends <a>InputValueDefinition</a> with an optional preset argument.
--   
--   See Note [Remote Schema Argument Presets] for additional information.
data RemoteSchemaInputValueDefinition
RemoteSchemaInputValueDefinition :: InputValueDefinition -> Maybe (Value RemoteSchemaVariable) -> RemoteSchemaInputValueDefinition
[_rsitdDefinition] :: RemoteSchemaInputValueDefinition -> InputValueDefinition
[_rsitdPresetArgument] :: RemoteSchemaInputValueDefinition -> Maybe (Value RemoteSchemaVariable)
newtype RemoteSchemaIntrospection
RemoteSchemaIntrospection :: HashMap Name (TypeDefinition [Name] RemoteSchemaInputValueDefinition) -> RemoteSchemaIntrospection

-- | Details required to resolve a "session variable preset" variable.
--   
--   See Notes [Remote Schema Argument Presets] and [Remote Schema
--   Permissions Architecture] for additional information.
data RemoteSchemaVariable
SessionPresetVariable :: SessionVariable -> Name -> SessionArgumentPresetInfo -> RemoteSchemaVariable
QueryVariable :: Variable -> RemoteSchemaVariable
RemoteJSONValue :: GType -> Value -> RemoteSchemaVariable

-- | See <tt>resolveRemoteVariable</tt> function. This data type is used
--   for validation of the session variable value
data SessionArgumentPresetInfo
SessionArgumentPresetScalar :: SessionArgumentPresetInfo
SessionArgumentPresetEnum :: HashSet EnumValue -> SessionArgumentPresetInfo
lookupEnum :: RemoteSchemaIntrospection -> Name -> Maybe EnumTypeDefinition
lookupInputObject :: RemoteSchemaIntrospection -> Name -> Maybe (InputObjectTypeDefinition RemoteSchemaInputValueDefinition)
lookupInterface :: RemoteSchemaIntrospection -> Name -> Maybe (InterfaceTypeDefinition [Name] RemoteSchemaInputValueDefinition)
lookupObject :: RemoteSchemaIntrospection -> Name -> Maybe (ObjectTypeDefinition RemoteSchemaInputValueDefinition)
lookupScalar :: RemoteSchemaIntrospection -> Name -> Maybe ScalarTypeDefinition
lookupType :: RemoteSchemaIntrospection -> Name -> Maybe (TypeDefinition [Name] RemoteSchemaInputValueDefinition)
lookupUnion :: RemoteSchemaIntrospection -> Name -> Maybe UnionTypeDefinition

-- | Extracts the name of a given type from its definition. TODO: move this
--   to Language.GraphQL.Draft.Syntax.
getTypeName :: TypeDefinition possibleTypes inputType -> Name

-- | Associates a field name with the arguments it will be passed in the
--   query.
--   
--   
--   <a>https://graphql.github.io/graphql-spec/June2018/#sec-Language.Arguments</a>
data FieldCall
FieldCall :: Name -> RemoteArguments -> FieldCall
[fcName] :: FieldCall -> Name
[fcArguments] :: FieldCall -> RemoteArguments

-- | Arguments to a remote GraphQL fields, represented as a mapping from
--   name to GraphQL Value. Said values can be variable names, in which
--   case they'll be referring to values we're closed over. TODO: expand on
--   this
newtype RemoteArguments
RemoteArguments :: HashMap Name (Value Name) -> RemoteArguments
[getRemoteArguments] :: RemoteArguments -> HashMap Name (Value Name)

-- | Targeted field in a remote schema relationship. TODO: explain about
--   subfields and why this is a container
newtype RemoteFields
RemoteFields :: NonEmpty FieldCall -> RemoteFields
[unRemoteFields] :: RemoteFields -> NonEmpty FieldCall

-- | Schema cache information for a table field targeting a remote schema.
data RemoteSchemaFieldInfo
RemoteSchemaFieldInfo :: RelName -> HashMap Name RemoteSchemaInputValueDefinition -> RemoteFields -> RemoteSchemaInfo -> [TypeDefinition [Name] RemoteSchemaInputValueDefinition] -> RemoteSchemaName -> LHSIdentifier -> RemoteSchemaFieldInfo

-- | Field name to which we'll map the remote in hasura; this becomes part
--   of the hasura schema.
[_rrfiName] :: RemoteSchemaFieldInfo -> RelName

-- | Input arguments to the remote field info; The <tt>_rfiParamMap</tt>
--   will only include the arguments to the remote field that is being
--   joined. The names of the arguments here are modified, it will be in
--   the format of <a>Field Name</a>_remote_rel_<a>table
--   schema</a>_<a>table name</a><a>relationship name</a>
[_rrfiParamMap] :: RemoteSchemaFieldInfo -> HashMap Name RemoteSchemaInputValueDefinition
[_rrfiRemoteFields] :: RemoteSchemaFieldInfo -> RemoteFields
[_rrfiRemoteSchema] :: RemoteSchemaFieldInfo -> RemoteSchemaInfo

-- | The new input value definitions created for this remote field
[_rrfiInputValueDefinitions] :: RemoteSchemaFieldInfo -> [TypeDefinition [Name] RemoteSchemaInputValueDefinition]

-- | Name of the remote schema, that's used for joining
[_rrfiRemoteSchemaName] :: RemoteSchemaFieldInfo -> RemoteSchemaName

-- | TODO: this one should be gone when <tt>validateRemoteRelationship</tt>
--   function is cleaned up
[_rrfiLHSIdentifier] :: RemoteSchemaFieldInfo -> LHSIdentifier
graphQLValueToJSON :: Value Void -> Value
newtype LHSIdentifier
LHSIdentifier :: Text -> LHSIdentifier
[getLHSIdentifier] :: LHSIdentifier -> Text
remoteSchemaToLHSIdentifier :: RemoteSchemaName -> LHSIdentifier

-- | Generates a valid graphql name from an arbitrary LHS identifier. This
--   is done by replacing all unrecognized characters by '_'. This function
--   still returns a <tt>Maybe</tt> value, in cases we can't adjust the raw
--   text (such as the case of empty identifiers).
lhsIdentifierToGraphQLName :: LHSIdentifier -> Maybe Name
instance GHC.Classes.Eq Hasura.RemoteSchema.SchemaCache.Types.IntrospectionResult
instance GHC.Classes.Eq Hasura.RemoteSchema.SchemaCache.Types.LHSIdentifier
instance GHC.Classes.Eq remoteRelationshipDefinition => GHC.Classes.Eq (Hasura.RemoteSchema.SchemaCache.Types.PartiallyResolvedRemoteRelationship remoteRelationshipDefinition)
instance GHC.Classes.Eq remoteFieldInfo => GHC.Classes.Eq (Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaCtxG remoteFieldInfo)
instance GHC.Classes.Eq Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaCustomizer
instance GHC.Classes.Eq Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaFieldInfo
instance GHC.Classes.Eq Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaInfo
instance GHC.Classes.Eq Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaInputValueDefinition
instance GHC.Classes.Eq Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaIntrospection
instance GHC.Classes.Eq Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaVariable
instance GHC.Classes.Eq Hasura.RemoteSchema.SchemaCache.Types.SessionArgumentPresetInfo
instance GHC.Classes.Eq Hasura.RemoteSchema.SchemaCache.Types.ValidatedRemoteSchemaDef
instance Witherable.Filterable Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaCtxG
instance GHC.Internal.Data.Foldable.Foldable Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaCtxG
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaCustomizer
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaInfo
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RemoteSchema.SchemaCache.Types.ValidatedRemoteSchemaDef
instance GHC.Internal.Base.Functor Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaCtxG
instance GHC.Internal.Generics.Generic Hasura.RemoteSchema.SchemaCache.Types.IntrospectionResult
instance GHC.Internal.Generics.Generic Hasura.RemoteSchema.SchemaCache.Types.LHSIdentifier
instance GHC.Internal.Generics.Generic (Hasura.RemoteSchema.SchemaCache.Types.PartiallyResolvedRemoteRelationship remoteRelationshipDefinition)
instance GHC.Internal.Generics.Generic Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaCustomizer
instance GHC.Internal.Generics.Generic Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaFieldInfo
instance GHC.Internal.Generics.Generic Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaInfo
instance GHC.Internal.Generics.Generic Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaInputValueDefinition
instance GHC.Internal.Generics.Generic Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaIntrospection
instance GHC.Internal.Generics.Generic Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaVariable
instance GHC.Internal.Generics.Generic Hasura.RemoteSchema.SchemaCache.Types.SessionArgumentPresetInfo
instance GHC.Internal.Generics.Generic Hasura.RemoteSchema.SchemaCache.Types.ValidatedRemoteSchemaDef
instance Data.Hashable.Class.Hashable Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaCustomizer
instance Data.Hashable.Class.Hashable Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaInfo
instance Data.Hashable.Class.Hashable Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaInputValueDefinition
instance Data.Hashable.Class.Hashable Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaIntrospection
instance Data.Hashable.Class.Hashable Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaVariable
instance Data.Hashable.Class.Hashable Hasura.RemoteSchema.SchemaCache.Types.SessionArgumentPresetInfo
instance Data.Hashable.Class.Hashable Hasura.RemoteSchema.SchemaCache.Types.ValidatedRemoteSchemaDef
instance GHC.Internal.Base.Monoid Hasura.RemoteSchema.SchemaCache.Types.CustomizeRemoteFieldName
instance Control.DeepSeq.NFData Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaCustomizer
instance Control.DeepSeq.NFData Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaInfo
instance Control.DeepSeq.NFData Hasura.RemoteSchema.SchemaCache.Types.ValidatedRemoteSchemaDef
instance GHC.Classes.Ord Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaInputValueDefinition
instance GHC.Classes.Ord Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaIntrospection
instance GHC.Classes.Ord Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaVariable
instance GHC.Classes.Ord Hasura.RemoteSchema.SchemaCache.Types.SessionArgumentPresetInfo
instance GHC.Internal.Base.Semigroup Hasura.RemoteSchema.SchemaCache.Types.CustomizeRemoteFieldName
instance GHC.Internal.Show.Show Hasura.RemoteSchema.SchemaCache.Types.IntrospectionResult
instance GHC.Internal.Show.Show Hasura.RemoteSchema.SchemaCache.Types.LHSIdentifier
instance GHC.Internal.Show.Show Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaCustomizer
instance GHC.Internal.Show.Show Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaFieldInfo
instance GHC.Internal.Show.Show Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaInfo
instance GHC.Internal.Show.Show Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaInputValueDefinition
instance GHC.Internal.Show.Show Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaIntrospection
instance GHC.Internal.Show.Show Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaVariable
instance GHC.Internal.Show.Show Hasura.RemoteSchema.SchemaCache.Types.SessionArgumentPresetInfo
instance GHC.Internal.Show.Show Hasura.RemoteSchema.SchemaCache.Types.ValidatedRemoteSchemaDef
instance Data.Aeson.Types.ToJSON.ToJSON remoteFieldInfo => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaCtxG remoteFieldInfo)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaCustomizer
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaFieldInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RemoteSchema.SchemaCache.Types.ValidatedRemoteSchemaDef
instance GHC.Internal.Data.Traversable.Traversable Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaCtxG


-- | Representation for queries going to remote schemas. Due to the
--   existence of remote relationships from remote schemas, we can't simply
--   reuse the GraphQL document AST we define in graphql-parser-hs, and
--   instead redefine a custom structure to represent such queries.
module Hasura.RQL.IR.RemoteSchema

-- | Custom representation of a selection set.
--   
--   Similarly to other parts of the IR, the <tt>r</tt> argument is used
--   for remote relationships.
data SelectionSet r var
SelectionSetObject :: ObjectSelectionSet r var -> SelectionSet r var
SelectionSetUnion :: DeduplicatedSelectionSet r var -> SelectionSet r var
SelectionSetInterface :: DeduplicatedSelectionSet r var -> SelectionSet r var
SelectionSetNone :: SelectionSet r var

-- | Representation of the normalized selection set of an interface/union
--   type.
--   
--   This representation is used to attempt to minimize the size of the
--   GraphQL query that eventually gets sent to the GraphQL server by
--   defining as many fields as possible on the abstract type.
data DeduplicatedSelectionSet r var
DeduplicatedSelectionSet :: HashSet Name -> HashMap Name (ObjectSelectionSet r var) -> DeduplicatedSelectionSet r var

-- | Fields that aren't explicitly defined for member types
[_dssCommonFields] :: DeduplicatedSelectionSet r var -> HashSet Name

-- | SelectionSets of individual member types
[_dssMemberSelectionSets] :: DeduplicatedSelectionSet r var -> HashMap Name (ObjectSelectionSet r var)
dssCommonFields :: forall r var f. Functor f => (HashSet Name -> f (HashSet Name)) -> DeduplicatedSelectionSet r var -> f (DeduplicatedSelectionSet r var)
dssMemberSelectionSets :: forall r1 var1 r2 var2 f. Functor f => (HashMap Name (ObjectSelectionSet r1 var1) -> f (HashMap Name (ObjectSelectionSet r2 var2))) -> DeduplicatedSelectionSet r1 var1 -> f (DeduplicatedSelectionSet r2 var2)
type ObjectSelectionSet r var = InsOrdHashMap Name Field r var

-- | Constructs an <tt>InterfaceSelectionSet</tt> from a set of interface
--   fields and an association list of the fields. This function ensures
--   that <tt>__typename</tt> is present in the set of interface fields.
mkInterfaceSelectionSet :: HashSet Name -> [(Name, ObjectSelectionSet r var)] -> DeduplicatedSelectionSet r var

-- | Constructs an <tt>UnionSelectionSet</tt> from a list of the fields,
--   using a singleton set of <tt>__typename</tt> for the set of common
--   fields.
mkUnionSelectionSet :: [(Name, ObjectSelectionSet r var)] -> DeduplicatedSelectionSet r var

-- | Representation of one individual field.
--   
--   This particular type is the reason why we need a different
--   representation from the one in 'graphql-parser-hs': we differentiate
--   between selection fields that target the actual remote schema, and
--   fields that, instead, are remote from it and need to be treated
--   differently.
data Field r var
FieldGraphQL :: GraphQLField r var -> Field r var
FieldRemote :: SchemaRemoteRelationshipSelect r -> Field r var
_FieldGraphQL :: forall r var1 var2 p f. (Choice p, Applicative f) => p (GraphQLField r var1) (f (GraphQLField r var2)) -> p (Field r var1) (f (Field r var2))
_FieldRemote :: forall r var p f. (Choice p, Applicative f) => p (SchemaRemoteRelationshipSelect r) (f (SchemaRemoteRelationshipSelect r)) -> p (Field r var) (f (Field r var))

-- | Normalized representation of a GraphQL field.
--   
--   This type is almost identical to <a>Field</a>, except for the fact
--   that the selection set is our annotated <a>SelectionSet</a>, instead
--   of the original <a>SelectionSet</a>. We use this type to represent the
--   fields of a selection that do target the remote schema.
data GraphQLField r var
GraphQLField :: Name -> Name -> HashMap Name (Value var) -> [Directive var] -> SelectionSet r var -> GraphQLField r var
[_fAlias] :: GraphQLField r var -> Name
[_fName] :: GraphQLField r var -> Name
[_fArguments] :: GraphQLField r var -> HashMap Name (Value var)
[_fDirectives] :: GraphQLField r var -> [Directive var]
[_fSelectionSet] :: GraphQLField r var -> SelectionSet r var
fAlias :: forall r var f. Functor f => (Name -> f Name) -> GraphQLField r var -> f (GraphQLField r var)
fName :: forall r var f. Functor f => (Name -> f Name) -> GraphQLField r var -> f (GraphQLField r var)
fArguments :: forall r var f. Functor f => (HashMap Name (Value var) -> f (HashMap Name (Value var))) -> GraphQLField r var -> f (GraphQLField r var)
fDirectives :: forall r var f. Functor f => ([Directive var] -> f [Directive var]) -> GraphQLField r var -> f (GraphQLField r var)
fSelectionSet :: forall r1 var r2 f. Functor f => (SelectionSet r1 var -> f (SelectionSet r2 var)) -> GraphQLField r1 var -> f (GraphQLField r2 var)
mkGraphQLField :: Maybe Name -> Name -> HashMap Name (Value var) -> [Directive var] -> SelectionSet r var -> GraphQLField r var

-- | Root entry point for a remote schema.
data RemoteSchemaRootField r var
RemoteSchemaRootField :: RemoteSchemaInfo -> ResultCustomizer -> GraphQLField r var -> RemoteSchemaRootField r var
[_rfRemoteSchemaInfo] :: RemoteSchemaRootField r var -> RemoteSchemaInfo
[_rfResultCustomizer] :: RemoteSchemaRootField r var -> ResultCustomizer
[_rfField] :: RemoteSchemaRootField r var -> GraphQLField r var

-- | A remote relationship's selection and fields required for its join
--   condition.
data SchemaRemoteRelationshipSelect r
SchemaRemoteRelationshipSelect :: HashMap FieldName Name -> r -> SchemaRemoteRelationshipSelect r

-- | The fields on the table that are required for the join condition of
--   the remote relationship
[_srrsLHSJoinFields] :: SchemaRemoteRelationshipSelect r -> HashMap FieldName Name

-- | The field that captures the relationship r ~ (RemoteRelationshipField
--   UnpreparedValue) when the AST is emitted by the parser. r ~ Void when
--   an execution tree is constructed so that a backend is absolved of
--   dealing with remote relationships.
[_srrsRelationship] :: SchemaRemoteRelationshipSelect r -> r
data RemoteFieldArgument
RemoteFieldArgument :: Name -> InputValue RemoteSchemaVariable -> RemoteFieldArgument
[_rfaArgument] :: RemoteFieldArgument -> Name
[_rfaValue] :: RemoteFieldArgument -> InputValue RemoteSchemaVariable
data RemoteSchemaSelect r
RemoteSchemaSelect :: [RemoteFieldArgument] -> ResultCustomizer -> SelectionSet r RemoteSchemaVariable -> NonEmpty FieldCall -> RemoteSchemaInfo -> RemoteSchemaSelect r
[_rselArgs] :: RemoteSchemaSelect r -> [RemoteFieldArgument]
[_rselResultCustomizer] :: RemoteSchemaSelect r -> ResultCustomizer
[_rselSelection] :: RemoteSchemaSelect r -> SelectionSet r RemoteSchemaVariable
[_rselFieldCall] :: RemoteSchemaSelect r -> NonEmpty FieldCall
[_rselRemoteSchema] :: RemoteSchemaSelect r -> RemoteSchemaInfo

-- | Converts a normalized selection set back into a selection set as
--   defined in GraphQL spec, in order to send it to a remote server.
--   
--   This function expects a <a>SelectionSet</a> for which <tt>r</tt> is
--   <a>Void</a>, which guarantees that there is no longer any remote join
--   field in the selection set.
convertSelectionSet :: Eq var => SelectionSet Void var -> SelectionSet NoFragments var
convertGraphQLField :: Eq var => GraphQLField Void var -> Field NoFragments var
instance (GHC.Classes.Eq var, GHC.Classes.Eq r) => GHC.Classes.Eq (Hasura.RQL.IR.RemoteSchema.DeduplicatedSelectionSet r var)
instance (GHC.Classes.Eq var, GHC.Classes.Eq r) => GHC.Classes.Eq (Hasura.RQL.IR.RemoteSchema.Field r var)
instance (GHC.Classes.Eq var, GHC.Classes.Eq r) => GHC.Classes.Eq (Hasura.RQL.IR.RemoteSchema.GraphQLField r var)
instance GHC.Classes.Eq Hasura.RQL.IR.RemoteSchema.RemoteFieldArgument
instance GHC.Classes.Eq r => GHC.Classes.Eq (Hasura.RQL.IR.RemoteSchema.SchemaRemoteRelationshipSelect r)
instance (GHC.Classes.Eq var, GHC.Classes.Eq r) => GHC.Classes.Eq (Hasura.RQL.IR.RemoteSchema.SelectionSet r var)
instance GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.RemoteSchema.DeduplicatedSelectionSet r)
instance GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.RemoteSchema.Field r)
instance GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.RemoteSchema.GraphQLField r)
instance GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.RemoteSchema.RemoteSchemaRootField r)
instance GHC.Internal.Data.Foldable.Foldable Hasura.RQL.IR.RemoteSchema.SchemaRemoteRelationshipSelect
instance GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.RemoteSchema.SelectionSet r)
instance GHC.Internal.Base.Functor (Hasura.RQL.IR.RemoteSchema.DeduplicatedSelectionSet r)
instance GHC.Internal.Base.Functor (Hasura.RQL.IR.RemoteSchema.Field r)
instance GHC.Internal.Base.Functor (Hasura.RQL.IR.RemoteSchema.GraphQLField r)
instance GHC.Internal.Base.Functor (Hasura.RQL.IR.RemoteSchema.RemoteSchemaRootField r)
instance GHC.Internal.Base.Functor Hasura.RQL.IR.RemoteSchema.SchemaRemoteRelationshipSelect
instance GHC.Internal.Base.Functor (Hasura.RQL.IR.RemoteSchema.SelectionSet r)
instance GHC.Internal.Generics.Generic (Hasura.RQL.IR.RemoteSchema.DeduplicatedSelectionSet r var)
instance (GHC.Internal.Show.Show var, GHC.Internal.Show.Show r) => GHC.Internal.Show.Show (Hasura.RQL.IR.RemoteSchema.DeduplicatedSelectionSet r var)
instance (GHC.Internal.Show.Show var, GHC.Internal.Show.Show r) => GHC.Internal.Show.Show (Hasura.RQL.IR.RemoteSchema.Field r var)
instance (GHC.Internal.Show.Show var, GHC.Internal.Show.Show r) => GHC.Internal.Show.Show (Hasura.RQL.IR.RemoteSchema.GraphQLField r var)
instance GHC.Internal.Show.Show Hasura.RQL.IR.RemoteSchema.RemoteFieldArgument
instance GHC.Internal.Show.Show r => GHC.Internal.Show.Show (Hasura.RQL.IR.RemoteSchema.RemoteSchemaSelect r)
instance GHC.Internal.Show.Show r => GHC.Internal.Show.Show (Hasura.RQL.IR.RemoteSchema.SchemaRemoteRelationshipSelect r)
instance (GHC.Internal.Show.Show var, GHC.Internal.Show.Show r) => GHC.Internal.Show.Show (Hasura.RQL.IR.RemoteSchema.SelectionSet r var)
instance GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.RemoteSchema.DeduplicatedSelectionSet r)
instance GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.RemoteSchema.Field r)
instance GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.RemoteSchema.GraphQLField r)
instance GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.RemoteSchema.RemoteSchemaRootField r)
instance GHC.Internal.Data.Traversable.Traversable Hasura.RQL.IR.RemoteSchema.SchemaRemoteRelationshipSelect
instance GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.RemoteSchema.SelectionSet r)


-- | Dispatch over backends.
--   
--   <h1>Creating and consuming <a>AnyBackend</a></h1>
--   
--   Creating a new value of type <a>AnyBackend</a> is done via
--   <a>mkAnyBackend</a>.
--   
--   Consuming a value of type <a>AnyBackend</a> is done via either
--   <tt>runAnyBackend</tt> or any of the dispatch functions
--   (<a>dispatchAnyBackend</a>, <a>dispatchAnyBackend'</a>,
--   <a>dispatchAnyBackend''</a>).
--   
--   For implementation details, or when trying to understand this module,
--   start from <a>AnyBackend</a>.
--   
--   <h1>Backend Architecture</h1>
--   
--   Our multiple backend architecture uses type classes and associated
--   types in order to share code, such as parsing graphql queries,
--   building schemas and metadata, while still accounting for the
--   differences between backends.
--   
--   Each backend implements the <tt>Backend</tt> type class from
--   <a>Hasura.RQL.Types.Backend</a> as well as instances for other classes
--   such as <tt>BackendSchema</tt> from
--   <a>Hasura.GraphQL.Schema.Backend</a>, and define the associated types
--   and functions, such as <tt>ScalarType</tt> and
--   <tt>parseScalarValue</tt>, which fit the backend.
--   
--   Whenever one of these associated types (<tt>ScalarType</tt>,
--   <tt>Column</tt>, etc.) are used, we need to either push the
--   <a>BackendType</a> to our caller (and making our type <tt>BackendType
--   -&gt; Type</tt>), or use <a>AnyBackend</a> (and allow our type to be
--   <a>Type</a>). This is particularly useful when we need to store a
--   container of any backend.
--   
--   In order to actually program abstractly using type classes, we need
--   the type class instances to be available for us to use. This module is
--   a trick to enumerate all supported backends and their respective
--   instances to convince GHC that they can be used.
--   
--   <h1>Example usage</h1>
--   
--   As an example of using this module, consider wanting to write a
--   function that calculates metrics for each source. For example, we want
--   to count the number of tables each source has.
--   
--   The <tt>SchemaCache</tt> (defined in
--   <a>Hasura.RQL.Types.SchemaCache</a>) holds a hash map from each source
--   to their information. The source information is parameterized by the
--   <a>BackendType</a> and is hidden using an existential type inside
--   <a>AnyBackend</a>. It essentially looks like this:
--   
--   <pre>
--   data SourceInfo b = ...
--   
--   type SourceCache = HashMap SourceName (AnyBackend SourceInfo)
--   </pre>
--   
--   Our metrics calculation function cares which backend it receives, but
--   only for its type class instances so it can call the relevant
--   functions:
--   
--   <pre>
--   telemetryForSource :: forall (b :: BackendType). SourceInfo b -&gt; TelemetryPayload
--   </pre>
--   
--   In order to apply this function to all backends and return the
--   telemetry payload for each, we need to map over the hash map and
--   dispatch the function over the relevant backend. we can do this with
--   <a>runBackend</a>:
--   
--   <pre>
--   telemetries =
--     map
--       (`runBackend` telemetryForSource)
--       (scSources schemaCache)
--   </pre>
--   
--   If we want to be able to extract some information about the backend
--   type inside <tt>telemetryForSource</tt>, we can do this using
--   <a>backendTag</a>:
--   
--   <pre>
--   let telemetryForSource :: forall (b :: BackendType). HasTag b =&gt; SourceInfo b -&gt; TelemetryPayload
--       telemetryForSource =
--         let dbKind = reify (backendTag @b)
--   </pre>
--   
--   Note that we needed to add the <a>HasTag</a> constraint, which now
--   means we can't use <a>runBackend</a> because our function has the
--   wrong type (it has an extra constraint). Instead, we can use
--   <a>dispatchAnyBackend</a> which allows us to have one constraint:
--   
--   <pre>
--   telemetries =
--     fmap
--       (\sourceinfo -&gt; (Any.dispatchAnyBackend @HasTag) sourceinfo telemetryForSource)
--       (scSources schemaCache)
--   </pre>
--   
--   Note that we had to add the constraint name as a type application, and
--   we had to explicitly add a lambda instead of using <a>flip</a>.
module Hasura.SQL.AnyBackend

-- | Allows storing types of kind <tt>BackendType -&gt; Type</tt>
--   heterogenously.
--   
--   Adding a new constructor to <a>BackendType</a> will automatically
--   create a new constructor here.
--   
--   Given some type defined as <tt>data T (b :: BackendType) = ...</tt>,
--   we can define <tt>AnyBackend T</tt> without mentioning any
--   <a>BackendType</a>.
--   
--   This is useful for having generic containers of potentially different
--   types of T. For instance, <tt>SourceCache</tt> is defined as a
--   <tt>HashMap SourceName (AnyBackend SourceInfo)</tt>.
data AnyBackend (i :: BackendType -> Type)

-- | Generates a constraint for a generic type over all backends.
type SatisfiesForAllBackends (i :: BackendType -> Type) (c :: Type -> Constraint) = (c i 'Postgres 'Vanilla, c i 'Postgres 'Citus, c i 'Postgres 'Cockroach, c i 'MSSQL, c i 'BigQuery, c i 'DataConnector)

-- | How to obtain a tag from a runtime value.
liftTag :: BackendType -> AnyBackend BackendTag

-- | Obtain a <tt>BackendType</tt> from a runtime value.
lowerTag :: forall (i :: BackendType -> Type). AnyBackend i -> BackendType

-- | Creates a new <tt>AnyBackend i</tt> for a given backend <tt>b</tt> by
--   wrapping the given <tt>i b</tt>.
mkAnyBackend :: forall (b :: BackendType) i. HasTag b => i b -> AnyBackend i

-- | Transforms an <tt>AnyBackend i</tt> into an <tt>AnyBackend j</tt>.
mapBackend :: AnyBackend i -> (forall (b :: BackendType). () => i b -> j b) -> AnyBackend j

-- | Traverse an <tt>AnyBackend i</tt> into an <tt>f (AnyBackend j)</tt>.
traverseBackend :: forall c i j f. (AllBackendsSatisfy c, Functor f) => AnyBackend i -> (forall (b :: BackendType). c b => i b -> f (j b)) -> f (AnyBackend j)

-- | Dispatch an existential using an universally quantified function while
--   also resolving a different constraint. Use this to dispatch Backend*
--   instances. This is essentially a wrapper around <tt>runAnyBackend f .
--   repackAnyBackend @c</tt>.
dispatchAnyBackend :: AllBackendsSatisfy c => AnyBackend i -> (forall (b :: BackendType). c b => i b -> r) -> r

-- | Unlike <a>dispatchAnyBackend</a>, the expected constraint has a
--   different kind. Use for classes like <a>Show</a>, <a>ToJSON</a>, etc.
dispatchAnyBackend' :: forall c i r. SatisfiesForAllBackends i c => AnyBackend i -> (forall (b :: BackendType). c (i b) => i b -> r) -> r

-- | This allows you to apply a constraint to the Backend instances (c2) as
--   well as a constraint on the higher-kinded <tt>i b</tt> type (c1)
dispatchAnyBackend'' :: forall c1 c2 i r. (SatisfiesForAllBackends i c1, AllBackendsSatisfy c2) => AnyBackend i -> (forall (b :: BackendType). (c2 b, c1 (i b)) => i b -> r) -> r

-- | Dispatch variant for use with arrow syntax.
--   
--   NOTE: The below function accepts two constraints, if the arrow you
--   want to dispatch only has one constraint then repeat the constraint
--   twice. For example:
--   
--   <pre>
--   AB.dispatchAnyBackendArrow @BackendMetadata @BackendMetadata (proc (sourceMetadata, invalidationKeys)
--   </pre>
dispatchAnyBackendArrow :: forall c1 c2 i r arr x. (ArrowChoice arr, AllBackendsSatisfy c1, AllBackendsSatisfy c2) => (forall (b :: BackendType). (c1 b, c2 b) => arr (i b, x) r) -> arr (AnyBackend i, x) r
dispatchAnyBackendWithTwoConstraints :: (AllBackendsSatisfy c1, AllBackendsSatisfy c2) => AnyBackend i -> (forall (b :: BackendType). (c1 b, c2 b) => i b -> r) -> r

-- | Merge two matching backends, falling back on a default.
mergeAnyBackend :: forall c i. SatisfiesForAllBackends i c => (forall (b :: BackendType). c (i b) => i b -> i b -> i b) -> AnyBackend i -> AnyBackend i -> AnyBackend i -> AnyBackend i

-- | Try to unpack the type of an existential. Returns <tt>Just x</tt> upon
--   a succesful match, <tt>Nothing</tt> otherwise.
unpackAnyBackend :: forall (b :: BackendType) i. HasTag b => AnyBackend i -> Maybe (i b)

-- | Sometimes we need to run operations on two backends of the same type.
--   If the backends don't contain the same type, the given <tt>r</tt>
--   value is returned. Otherwise, the function is called with the two
--   wrapped values.
composeAnyBackend :: AllBackendsSatisfy c => (forall (b :: BackendType). c b => i b -> i b -> r) -> AnyBackend i -> AnyBackend i -> r -> r

-- | Dispatch a function to the value inside the <tt>AnyBackend</tt>, that
--   does not require bringing into scope a new class constraint.
runBackend :: AnyBackend i -> (forall (b :: BackendType). () => i b -> r) -> r

-- | Attempts to parse an <a>AnyBackend</a> from a JSON value, using the
--   provided backend information.
parseAnyBackendFromJSON :: forall (i :: BackendType -> Type). SatisfiesForAllBackends i FromJSON => BackendType -> Value -> Parser (AnyBackend i)

-- | Codec that can be used to decode and encode <tt>AnyBackend i</tt>
--   values. Throws an error when attempting to encode a value with a
--   mismatched <tt>backendKind</tt> argument.
anyBackendCodec :: forall (i :: BackendType -> Type). SatisfiesForAllBackends i HasCodec => BackendType -> JSONCodec (AnyBackend i)

-- | Outputs a debug JSON value from an <a>AnyBackend</a>. This function
--   must only be used for debug purposes, as it has no way of inserting
--   the backend kind in the output, since there's no guarantee that the
--   output will be an object.
debugAnyBackendToJSON :: forall (i :: BackendType -> Type). SatisfiesForAllBackends i ToJSON => AnyBackend i -> Value
backendSourceKindFromText :: Text -> Maybe (AnyBackend BackendSourceKind)
parseBackendSourceKindFromJSON :: Value -> Parser (AnyBackend BackendSourceKind)
instance Hasura.SQL.AnyBackend.SatisfiesForAllBackends i GHC.Classes.Eq => GHC.Classes.Eq (Hasura.SQL.AnyBackend.AnyBackend i)
instance Hasura.SQL.AnyBackend.SatisfiesForAllBackends i Data.Aeson.Types.FromJSON.FromJSON => Data.Aeson.Extended.FromJSONKeyValue (Hasura.SQL.AnyBackend.AnyBackend i)
instance GHC.Internal.Generics.Generic (Hasura.SQL.AnyBackend.AnyBackend i)
instance Hasura.SQL.AnyBackend.SatisfiesForAllBackends i Data.Hashable.Class.Hashable => Data.Hashable.Class.Hashable (Hasura.SQL.AnyBackend.AnyBackend i)
instance Hasura.SQL.AnyBackend.SatisfiesForAllBackends i GHC.Classes.Ord => GHC.Classes.Ord (Hasura.SQL.AnyBackend.AnyBackend i)
instance Hasura.SQL.AnyBackend.SatisfiesForAllBackends i GHC.Internal.Show.Show => GHC.Internal.Show.Show (Hasura.SQL.AnyBackend.AnyBackend i)

module Hasura.SQL.BackendMap

-- | A BackendMap is a data structure that can contain at most one value of
--   an <tt>i</tt> per <a>BackendType</a> The <tt>i</tt> type must be one
--   that is parameterized by a BackendType-kinded type parameter
data BackendMap (i :: BackendType -> Type)
singleton :: forall (b :: BackendType) i. HasTag b => i b -> BackendMap i

-- | Get a value from the map for the particular <a>BackendType</a>
--   <tt>b</tt>. This function is usually used with a type application.
--   <tt> lookup </tt>('Postgres 'Vanilla) backendMap @
lookup :: forall (b :: BackendType) i. HasTag b => BackendMap i -> Maybe (i b)
lookupD :: forall (b :: BackendType) i. HasTag b => Dependency (BackendMap i) -> Dependency (Maybe (i b))

-- | Get all values in the map
elems :: forall (i :: BackendType -> Type). BackendMap i -> [AnyBackend i]

-- | The expression <tt>alter f bmap</tt> alters the value <tt>x</tt> at
--   <tt>b</tt>, or absence thereof. alter can be used to insert, delete,
--   or update a value in a Map.
--   
--   In short : <tt>lookup k (alter f k m) = f (lookup k m)</tt>.
alter :: forall (b :: BackendType) i. HasTag b => (Maybe (i b) -> Maybe (i b)) -> BackendMap i -> BackendMap i

-- | The expression <tt>modify f bmap</tt> alters the value <tt>x</tt> at
--   <tt>b</tt>. <tt>modify</tt> is a restricted version of <a>alter</a>
--   which cannot delete entries and if there is no <tt>b</tt> key present
--   in the map, it will apply the modification function to the <tt>i
--   b</tt> unit value and insert the result at <tt>b</tt>.
modify :: forall (b :: BackendType) i. (HasTag b, Monoid (i b)) => (i b -> i b) -> BackendMap i -> BackendMap i

-- | The expression <tt>a `overridesDeeply b</tt> applies the values from
--   <tt>a</tt> on top of the defaults <tt>b</tt>. In practice this should
--   union the maps for each backend type.
overridesDeeply :: forall (i :: BackendType -> Type). SatisfiesForAllBackends i Semigroup => BackendMap i -> BackendMap i -> BackendMap i
instance Hasura.SQL.AnyBackend.SatisfiesForAllBackends i GHC.Classes.Eq => GHC.Classes.Eq (Hasura.SQL.BackendMap.BackendMap i)
instance Hasura.SQL.AnyBackend.SatisfiesForAllBackends i Data.Aeson.Types.FromJSON.FromJSON => Data.Aeson.Types.FromJSON.FromJSON (Hasura.SQL.BackendMap.BackendMap i)
instance Data.GADT.Internal.GCompare (Hasura.SQL.BackendMap.BackendMapS i)
instance Data.GADT.Internal.GEq (Hasura.SQL.BackendMap.BackendMapS i)
instance GHC.Internal.Generics.Generic (Hasura.SQL.BackendMap.BackendMap i)
instance (Hasura.SQL.AnyBackend.SatisfiesForAllBackends i Autodocodec.Class.HasCodec, Hasura.SQL.AnyBackend.SatisfiesForAllBackends i GHC.Internal.Data.Typeable.Internal.Typeable) => Autodocodec.Class.HasCodec (Hasura.SQL.BackendMap.BackendMap i)
instance GHC.Internal.Base.Monoid (Hasura.SQL.BackendMap.BackendMap i)
instance Hasura.Incremental.Select.Select (Hasura.SQL.BackendMap.BackendMap i)
instance GHC.Internal.Base.Semigroup (Hasura.SQL.BackendMap.BackendMap i)
instance Hasura.SQL.AnyBackend.SatisfiesForAllBackends i GHC.Internal.Show.Show => GHC.Internal.Show.Show (Hasura.SQL.BackendMap.BackendMap i)
instance Hasura.SQL.AnyBackend.SatisfiesForAllBackends i Data.Aeson.Types.ToJSON.ToJSON => Data.Aeson.Types.ToJSON.ToJSON (Hasura.SQL.BackendMap.BackendMap i)

module Hasura.SQL.GeoJSON
data Position
Position :: !Double -> !Double -> !Maybe Double -> Position
newtype Point
Point :: Position -> Point
[unPoint] :: Point -> Position
newtype MultiPoint
MultiPoint :: [Position] -> MultiPoint
[unMultiPoint] :: MultiPoint -> [Position]
data LineString
LineString :: !Position -> !Position -> ![Position] -> LineString
[_lsFirst] :: LineString -> !Position
[_lsSecond] :: LineString -> !Position
[_lsRest] :: LineString -> ![Position]
data LinearRing
LinearRing :: !Position -> !Position -> !Position -> ![Position] -> LinearRing
[_pFirst] :: LinearRing -> !Position
[_pSecond] :: LinearRing -> !Position
[_pThird] :: LinearRing -> !Position
[_pRest] :: LinearRing -> ![Position]
newtype MultiLineString
MultiLineString :: [LineString] -> MultiLineString
[unMultiLineString] :: MultiLineString -> [LineString]
newtype Polygon
Polygon :: [LinearRing] -> Polygon
[unPolygon] :: Polygon -> [LinearRing]
newtype MultiPolygon
MultiPolygon :: [Polygon] -> MultiPolygon
[unMultiPolygon] :: MultiPolygon -> [Polygon]
data Geometry
GPoint :: !Point -> Geometry
GMultiPoint :: !MultiPoint -> Geometry
GLineString :: !LineString -> Geometry
GMultiLineString :: !MultiLineString -> Geometry
GPolygon :: !Polygon -> Geometry
GMultiPolygon :: !MultiPolygon -> Geometry
GGeometryCollection :: !GeometryCollection -> Geometry
newtype GeometryCollection
GeometryCollection :: [GeometryWithCRS] -> GeometryCollection
[unGeometryCollection] :: GeometryCollection -> [GeometryWithCRS]
data GeometryWithCRS
GeometryWithCRS :: !Geometry -> !Maybe CRS -> GeometryWithCRS
[_gwcGeom] :: GeometryWithCRS -> !Geometry
[_gwcCrs] :: GeometryWithCRS -> !Maybe CRS
instance GHC.Classes.Eq Hasura.SQL.GeoJSON.CRS
instance GHC.Classes.Eq Hasura.SQL.GeoJSON.CRSLinkProps
instance GHC.Classes.Eq Hasura.SQL.GeoJSON.CRSNameProps
instance GHC.Classes.Eq Hasura.SQL.GeoJSON.Geometry
instance GHC.Classes.Eq Hasura.SQL.GeoJSON.GeometryCollection
instance GHC.Classes.Eq Hasura.SQL.GeoJSON.GeometryWithCRS
instance GHC.Classes.Eq Hasura.SQL.GeoJSON.LineString
instance GHC.Classes.Eq Hasura.SQL.GeoJSON.LinearRing
instance GHC.Classes.Eq Hasura.SQL.GeoJSON.MultiLineString
instance GHC.Classes.Eq Hasura.SQL.GeoJSON.MultiPoint
instance GHC.Classes.Eq Hasura.SQL.GeoJSON.MultiPolygon
instance GHC.Classes.Eq Hasura.SQL.GeoJSON.Point
instance GHC.Classes.Eq Hasura.SQL.GeoJSON.Polygon
instance GHC.Classes.Eq Hasura.SQL.GeoJSON.Position
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.SQL.GeoJSON.CRS
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.SQL.GeoJSON.CRSLinkProps
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.SQL.GeoJSON.CRSNameProps
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.SQL.GeoJSON.GeometryCollection
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.SQL.GeoJSON.GeometryWithCRS
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.SQL.GeoJSON.LineString
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.SQL.GeoJSON.LinearRing
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.SQL.GeoJSON.MultiLineString
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.SQL.GeoJSON.MultiPoint
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.SQL.GeoJSON.MultiPolygon
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.SQL.GeoJSON.Point
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.SQL.GeoJSON.Polygon
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.SQL.GeoJSON.Position
instance GHC.Internal.Generics.Generic Hasura.SQL.GeoJSON.CRS
instance GHC.Internal.Generics.Generic Hasura.SQL.GeoJSON.CRSLinkProps
instance GHC.Internal.Generics.Generic Hasura.SQL.GeoJSON.CRSNameProps
instance GHC.Internal.Show.Show Hasura.SQL.GeoJSON.CRS
instance GHC.Internal.Show.Show Hasura.SQL.GeoJSON.CRSLinkProps
instance GHC.Internal.Show.Show Hasura.SQL.GeoJSON.CRSNameProps
instance GHC.Internal.Show.Show Hasura.SQL.GeoJSON.Geometry
instance GHC.Internal.Show.Show Hasura.SQL.GeoJSON.GeometryCollection
instance GHC.Internal.Show.Show Hasura.SQL.GeoJSON.GeometryWithCRS
instance GHC.Internal.Show.Show Hasura.SQL.GeoJSON.LineString
instance GHC.Internal.Show.Show Hasura.SQL.GeoJSON.LinearRing
instance GHC.Internal.Show.Show Hasura.SQL.GeoJSON.MultiLineString
instance GHC.Internal.Show.Show Hasura.SQL.GeoJSON.MultiPoint
instance GHC.Internal.Show.Show Hasura.SQL.GeoJSON.MultiPolygon
instance GHC.Internal.Show.Show Hasura.SQL.GeoJSON.Point
instance GHC.Internal.Show.Show Hasura.SQL.GeoJSON.Polygon
instance GHC.Internal.Show.Show Hasura.SQL.GeoJSON.Position
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.SQL.GeoJSON.CRS
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.SQL.GeoJSON.CRSLinkProps
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.SQL.GeoJSON.CRSNameProps
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.SQL.GeoJSON.GeometryCollection
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.SQL.GeoJSON.GeometryWithCRS
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.SQL.GeoJSON.LineString
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.SQL.GeoJSON.LinearRing
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.SQL.GeoJSON.MultiLineString
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.SQL.GeoJSON.MultiPoint
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.SQL.GeoJSON.MultiPolygon
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.SQL.GeoJSON.Point
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.SQL.GeoJSON.Polygon
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.SQL.GeoJSON.Position

module Hasura.SQL.Time
data ZonedTimeOfDay
ZonedTimeOfDay :: TimeOfDay -> TimeZone -> ZonedTimeOfDay
[ztodTime] :: ZonedTimeOfDay -> TimeOfDay
[ztodZone] :: ZonedTimeOfDay -> TimeZone
instance GHC.Classes.Eq Hasura.SQL.Time.ZonedTimeOfDay
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.SQL.Time.ZonedTimeOfDay
instance GHC.Internal.Show.Show Hasura.SQL.Time.ZonedTimeOfDay

module Hasura.SQL.Types
class ToSQL a
toSQL :: ToSQL a => a -> Builder
toSQLTxt :: ToSQL a => a -> Text

-- | The type of all Postgres types (i.e. scalars and arrays). This type is
--   parameterized so that we can have both <tt><a>CollectableType</a>
--   <tt>PGScalarType</tt></tt> and <tt><a>CollectableType</a>
--   <a>PGColumnType</a></tt>, for when we care about the distinction made
--   by <a>PGColumnType</a>. If we ever change <a>PGColumnType</a> to
--   handle arrays, not just scalars, then the parameterization can go
--   away.
--   
--   TODO (from master): This is incorrect modeling, as
--   <tt>PGScalarType</tt> will capture anything (under
--   <tt>PGUnknown</tt>). This should be fixed when support for all types
--   is merged.
data CollectableType a
CollectableTypeScalar :: !a -> CollectableType a
CollectableTypeArray :: !a -> CollectableType a

-- | The name of the schema in which the graphql-engine will install
--   database extensions.
newtype ExtensionsSchema
ExtensionsSchema :: Text -> ExtensionsSchema
[_unExtensionsSchema] :: ExtensionsSchema -> Text
instance GHC.Internal.Data.Data.Data a => GHC.Internal.Data.Data.Data (Hasura.SQL.Types.CollectableType a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.SQL.Types.CollectableType a)
instance GHC.Classes.Eq Hasura.SQL.Types.ExtensionsSchema
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Hasura.SQL.Types.CollectableType a)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.SQL.Types.ExtensionsSchema
instance GHC.Internal.Base.Functor Hasura.SQL.Types.CollectableType
instance GHC.Internal.Generics.Generic (Hasura.SQL.Types.CollectableType a)
instance Autodocodec.Class.HasCodec Hasura.SQL.Types.ExtensionsSchema
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.SQL.Types.CollectableType a)
instance Data.Hashable.Class.Hashable Hasura.SQL.Types.ExtensionsSchema
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.SQL.Types.CollectableType a)
instance Control.DeepSeq.NFData Hasura.SQL.Types.ExtensionsSchema
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (Hasura.SQL.Types.CollectableType a)
instance GHC.Internal.Show.Show Hasura.SQL.Types.ExtensionsSchema
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.SQL.Types.CollectableType a)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.SQL.Types.ExtensionsSchema
instance Hasura.SQL.Types.ToSQL Text.Builder.Builder
instance Hasura.SQL.Types.ToSQL a => Hasura.SQL.Types.ToSQL (Hasura.SQL.Types.CollectableType a)
instance Hasura.SQL.Types.ToSQL a => Hasura.SQL.Types.ToSQL (GHC.Internal.Maybe.Maybe a)

module Hasura.SQL.Value
data TxtEncodedVal
TENull :: TxtEncodedVal
TELit :: !Text -> TxtEncodedVal
instance GHC.Classes.Eq Hasura.SQL.Value.TxtEncodedVal
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.SQL.Value.TxtEncodedVal
instance GHC.Internal.Generics.Generic Hasura.SQL.Value.TxtEncodedVal
instance Data.Hashable.Class.Hashable Hasura.SQL.Value.TxtEncodedVal
instance GHC.Internal.Show.Show Hasura.SQL.Value.TxtEncodedVal
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.SQL.Value.TxtEncodedVal

module Hasura.SQL.WKT
class ToWKT a
toWKT :: ToWKT a => a -> Either QErr WKT
newtype WKT
WKT :: Text -> WKT
[getWKT] :: WKT -> Text
instance Hasura.SQL.WKT.ToWKT Hasura.SQL.GeoJSON.Geometry
instance Hasura.SQL.WKT.ToWKT Hasura.SQL.GeoJSON.GeometryCollection
instance Hasura.SQL.WKT.ToWKT Hasura.SQL.GeoJSON.GeometryWithCRS
instance Hasura.SQL.WKT.ToWKT Hasura.SQL.GeoJSON.LineString
instance Hasura.SQL.WKT.ToWKT Hasura.SQL.GeoJSON.MultiLineString
instance Hasura.SQL.WKT.ToWKT Hasura.SQL.GeoJSON.MultiPoint
instance Hasura.SQL.WKT.ToWKT Hasura.SQL.GeoJSON.MultiPolygon
instance Hasura.SQL.WKT.ToWKT Hasura.SQL.GeoJSON.Point
instance Hasura.SQL.WKT.ToWKT Hasura.SQL.GeoJSON.Polygon


-- | API related to Postgres' pg dump
module Hasura.Server.API.PGDump
data PGDumpReqBody
PGDumpReqBody :: !SourceName -> ![String] -> !Bool -> PGDumpReqBody
[prbSource] :: PGDumpReqBody -> !SourceName
[prbOpts] :: PGDumpReqBody -> ![String]
[prbCleanOutput] :: PGDumpReqBody -> !Bool
execPGDump :: (MonadError QErr m, MonadIO m) => PGDumpReqBody -> ConnInfo -> m ByteString
instance GHC.Classes.Eq Hasura.Server.API.PGDump.PGDumpReqBody
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.API.PGDump.PGDumpReqBody
instance GHC.Internal.Show.Show Hasura.Server.API.PGDump.PGDumpReqBody

module Hasura.Server.Compression

-- | Maybe compress the response body, based on the client's
--   Accept-Encoding and our own judgement.
compressResponse :: RequestHeaders -> ByteString -> (ByteString, EncodingType)

-- | Compressed encodings which hasura supports
data CompressionType
CTGZip :: CompressionType

-- | Accept-Encoding directives (from client) which hasura supports.
--   <tt>Nothing</tt> indicates identity (no compression)
type EncodingType = Maybe CompressionType
identityEncoding :: EncodingType

-- | A map from Accept-Encoding directives to corresponding
--   Content-Encoding headers (from server). NOTE: <tt>identity</tt> is not
--   a valid directive for this header.
contentEncodingHeader :: CompressionType -> Header
compressionTypeToTxt :: CompressionType -> Text

-- | Compress the lazy bytestring preferring speed over compression ratio
compressFast :: CompressionType -> ByteString -> ByteString

-- | Which encodings can the client accept? The empty set returned here is
--   an error condition and the server tecnically ought to return a 406.
--   
--   
--   <a>https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Encoding</a>
getAcceptedEncodings :: RequestHeaders -> Set EncodingType
instance GHC.Classes.Eq Hasura.Server.Compression.CompressionType
instance GHC.Classes.Ord Hasura.Server.Compression.CompressionType
instance GHC.Internal.Show.Show Hasura.Server.Compression.CompressionType

module Hasura.Server.Init.Arg.PrettyPrinter
(<$>) :: Doc -> Doc -> Doc
type Doc = Doc AnsiStyle
text :: String -> Doc
mkEnvVarDoc :: [(String, String)] -> Doc
mkExamplesDoc :: [[String]] -> Doc


-- | Feature Flags are <i>temporary</i> toggles.
module Hasura.Server.Init.FeatureFlag
newtype FeatureFlag
FeatureFlag :: Text -> FeatureFlag
[ffIdentifier] :: FeatureFlag -> Text
data CheckFeatureFlag
CheckFeatureFlag :: (FeatureFlag -> IO Bool) -> [(FeatureFlag, Text)] -> CheckFeatureFlag

-- | Action that samples the value of a feature flag. Different products
--   will want to do different things. For example, the Cloud product will
--   want to use LaunchDarkly whereas the OSS and non-cloud EE products
--   will want to sample environment variables.
[runCheckFeatureFlag] :: CheckFeatureFlag -> FeatureFlag -> IO Bool

-- | A registry of flags that are <tt>known</tt> by the system. This is
--   used to inform of feature flag values via the '<i>v1alpha</i>config'
--   endpoint, as well as sampling feature flag values for use in schema
--   code.
[listKnownFeatureFlags] :: CheckFeatureFlag -> [(FeatureFlag, Text)]

-- | In OSS we _may_ look for a environment variable or fall back to the
--   default value.
ceCheckFeatureFlag :: Environment -> CheckFeatureFlag
class Monad m => HasFeatureFlagChecker (m :: Type -> Type)
checkFlag :: HasFeatureFlagChecker m => FeatureFlag -> m Bool

-- | Feature flag enabling the changes to the naming-convention feature
--   that were added in September 2023.
namingConventionSep2023 :: FeatureFlag
instance GHC.Classes.Eq Hasura.Server.Init.FeatureFlag.FeatureFlag
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Init.FeatureFlag.FeatureFlag
instance GHC.Internal.Generics.Generic Hasura.Server.Init.FeatureFlag.FeatureFlag
instance Hasura.Server.Init.FeatureFlag.HasFeatureFlagChecker m => Hasura.Server.Init.FeatureFlag.HasFeatureFlagChecker (Control.Monad.Trans.Except.ExceptT e m)
instance Hasura.Server.Init.FeatureFlag.HasFeatureFlagChecker m => Hasura.Server.Init.FeatureFlag.HasFeatureFlagChecker (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.Server.Init.FeatureFlag.HasFeatureFlagChecker m => Hasura.Server.Init.FeatureFlag.HasFeatureFlagChecker (Control.Monad.Trans.State.Strict.StateT s m)
instance Data.Hashable.Class.Hashable Hasura.Server.Init.FeatureFlag.FeatureFlag
instance GHC.Internal.Base.Semigroup Hasura.Server.Init.FeatureFlag.CheckFeatureFlag
instance GHC.Internal.Show.Show Hasura.Server.Init.FeatureFlag.FeatureFlag
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Init.FeatureFlag.FeatureFlag

module Hasura.Server.Metrics

-- | A specification of the metrics tracked by the server.
--   
--   The use of the "unit" type () for the "tag structure" type parameter
--   of a metric indicates that we prohibit that metric from being
--   annotated with tags.
data ServerMetricsSpec (a :: Symbol) (b :: MetricType) c

-- | Current Number of active Warp threads
[WarpThreads] :: ServerMetricsSpec "warp_threads" 'GaugeType ()

-- | Current number of active websocket connections
[WebsocketConnections] :: ServerMetricsSpec "websocket_connections" 'GaugeType ()

-- | Current number of active subscriptions
[ActiveSubscriptions] :: ServerMetricsSpec "active_subscriptions" 'GaugeType ()

-- | Total Number of events fetched from last 'Event Trigger Fetch'
[NumEventsFetchedPerBatch] :: ServerMetricsSpec "events_fetched_per_batch" 'DistributionType ()

-- | Current number of Event trigger's HTTP workers in process
[NumEventHTTPWorkers] :: ServerMetricsSpec "num_event_trigger_http_workers" 'GaugeType ()

-- | Time (in seconds) between the 'Event Trigger Fetch' from DB and the
--   processing of the event
[EventQueueTime] :: ServerMetricsSpec "event_queue_time" 'DistributionType ()

-- | The current schema cache metadata resource version
[SchemaCacheMetadataResourceVersion] :: ServerMetricsSpec "schema_cache_metadata_resource_version" 'GaugeType ()

-- | Current number of subscribers connected to live queries
[ActiveLiveQueries] :: ServerMetricsSpec "active_livequeries" 'GaugeType ()

-- | Current number of subscribers connected to streaming subscriptions
[ActiveStreaming] :: ServerMetricsSpec "active_streaming_subscriptions" 'GaugeType ()

-- | Latency of fetching a batch of events
[EventFetchTimePerBatch] :: ServerMetricsSpec "events_fetch_time_per_batch" 'DistributionType ()

-- | The time (in seconds) between when a event is picked for delivery to
--   the time its status is updated in the DB
[EventWebhookProcessingTime] :: ServerMetricsSpec "event_webhook_processing_time" 'DistributionType ()

-- | The time taken for an event to be delivered since it's been created
--   (if first attempt) or retried (after first attempt)
[EventProcessingTime] :: ServerMetricsSpec "event_processing_time" 'DistributionType ()

-- | Mutable references for the server metrics. See
--   <a>ServerMetricsSpec</a> for a description of each metric.
data ServerMetrics
ServerMetrics :: Gauge -> Gauge -> Gauge -> Distribution -> Gauge -> Distribution -> Gauge -> Gauge -> Gauge -> Distribution -> Distribution -> Distribution -> ServerMetrics
[smWarpThreads] :: ServerMetrics -> Gauge
[smWebsocketConnections] :: ServerMetrics -> Gauge
[smActiveSubscriptions] :: ServerMetrics -> Gauge
[smNumEventsFetchedPerBatch] :: ServerMetrics -> Distribution
[smNumEventHTTPWorkers] :: ServerMetrics -> Gauge
[smEventQueueTime] :: ServerMetrics -> Distribution
[smSchemaCacheMetadataResourceVersion] :: ServerMetrics -> Gauge
[smActiveLiveQueries] :: ServerMetrics -> Gauge
[smActiveStreamingSubscriptions] :: ServerMetrics -> Gauge
[smEventFetchTimePerBatch] :: ServerMetrics -> Distribution
[smEventWebhookProcessingTime] :: ServerMetrics -> Distribution
[smEventProcessingTime] :: ServerMetrics -> Distribution
createServerMetrics :: Store ServerMetricsSpec -> IO ServerMetrics

module Hasura.Server.Name
_Bool :: Name
_Double :: Name
_float8 :: Name
_Number :: Name
_numeric :: Name

module Hasura.Server.ResourceChecker

-- | Determine allocated cpu and memory resources of the host server or
--   Container Runtime. because HGE mainly runs in the container runtime we
--   need to determine the max cpu and memory limit constraints that are
--   managed by cgroups or fallback to physical cpu and memory information
--   of the server <a>https://hasurahq.atlassian.net/browse/INFRA-772</a>
--   
--   Those information are stored in many files of cgroup folders, the
--   logic is simply to read them and parse number values
--   
--   In cgroup v1 systems there are several ways in which the amount of
--   allocated cpu resources could be presented. We first try reading
--   requests (quota &amp; period); if that fails, we fallback to reading
--   limits (shares); if that fails, we fallback to reading the physical
--   cpu count, which should always succeed.
getServerResources :: MonadIO m => m ComputeResourcesResponse

-- | The response data of cpu and memory resources
data ComputeResourcesResponse
ComputeResourcesResponse :: Maybe Int -> Maybe Int64 -> Maybe ResourceCheckerError -> ComputeResourcesResponse
[_rcrCpu] :: ComputeResourcesResponse -> Maybe Int
[_rcrMemory] :: ComputeResourcesResponse -> Maybe Int64
[_rcrErrorCode] :: ComputeResourcesResponse -> Maybe ResourceCheckerError
data ResourceCheckerError
CGroupUnavailable :: ResourceCheckerError
CpuInconclusive :: ResourceCheckerError
MemoryInconclusive :: ResourceCheckerError
CpuMemoryInconclusive :: ResourceCheckerError
RCInternalError :: String -> ResourceCheckerError

-- | Compute the max physical memory size of the server
getMaxPhysicalMemory :: MonadIO m => m (Maybe Int64)

-- | Compute the cpu share allocations from the number of physical CPU
--   cores
getPhysicalCpuResource :: MonadIO m => m Int
getPhysicalResources :: MonadIO m => Maybe ResourceCheckerError -> m ComputeResourcesResponse
getServerResources_ :: MonadIO m => FilePath -> m ComputeResourcesResponse

-- | Determine cpu and memory resource allocations if the OCI Container
--   Runtime supports cgroup v1
getCGroupV1Resources :: MonadIO m => FilePath -> m ComputeResourcesResponse

-- | Determine cpu and memory resource allocations if the OCI Container
--   Runtime supports cgroup v2
getCGroupV2Resources :: MonadIO m => FilePath -> m ComputeResourcesResponse
instance GHC.Classes.Eq Hasura.Server.ResourceChecker.CGroupMode
instance GHC.Classes.Eq Hasura.Server.ResourceChecker.ComputeResourcesResponse
instance GHC.Classes.Eq Hasura.Server.ResourceChecker.ResourceCheckerError
instance GHC.Internal.Generics.Generic Hasura.Server.ResourceChecker.ComputeResourcesResponse
instance GHC.Internal.Show.Show Hasura.Server.ResourceChecker.CGroupMode
instance GHC.Internal.Show.Show Hasura.Server.ResourceChecker.ComputeResourcesResponse
instance GHC.Internal.Show.Show Hasura.Server.ResourceChecker.ResourceCheckerError
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.ResourceChecker.ComputeResourcesResponse
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.ResourceChecker.ResourceCheckerError


-- | Counters used in telemetry collection. Additional counters can be
--   added here.and serviced in <a>Hasura.Server.Telemetry</a>.
module Hasura.Server.Telemetry.Counters

-- | Save a timing metric sample in our in-memory store. These will be
--   accumulated and uploaded periodically in
--   <a>Hasura.Server.Telemetry</a>.
recordTimingMetric :: MonadIO m => RequestDimensions -> RequestTimings -> m ()

-- | The properties that characterize this request. The dimensions over
--   which we collect metrics for each serviced request.
data RequestDimensions
RequestDimensions :: !QueryType -> !Locality -> !Transport -> RequestDimensions
[telemQueryType] :: RequestDimensions -> !QueryType
[telemLocality] :: RequestDimensions -> !Locality
[telemTransport] :: RequestDimensions -> !Transport

-- | Accumulated time metrics.
data RequestTimings
RequestTimings :: !Seconds -> !Seconds -> RequestTimings

-- | Time spent waiting on PG/remote http calls
[telemTimeIO] :: RequestTimings -> !Seconds

-- | Total service time for request (including <a>telemTimeIO</a>)
[telemTimeTot] :: RequestTimings -> !Seconds

-- | Was this request a mutation (involved DB writes)?
data QueryType
Mutation :: QueryType
Query :: QueryType

-- | Was this a PG local query, or did it involve remote execution?
data Locality

-- | No data was fetched
Empty :: Locality

-- | local DB data
Local :: Locality

-- | remote schema
Remote :: Locality

-- | mixed
Heterogeneous :: Locality

-- | Was this a query over http or websockets?
data Transport
HTTP :: Transport
WebSocket :: Transport
dumpServiceTimingMetrics :: MonadIO m => m ServiceTimingMetrics

-- | The final shape of this part of our metrics data JSON. This should
--   allow reasonably efficient querying using GIN indexes and JSONB
--   containment operations (which treat arrays as sets).
data ServiceTimingMetrics
ServiceTimingMetrics :: Int -> [ServiceTimingMetric] -> ServiceTimingMetrics

-- | This is set to a new unique value when the counters reset (e.g.
--   because of a restart)
[collectionTag] :: ServiceTimingMetrics -> Int
[serviceTimingMetrics] :: ServiceTimingMetrics -> [ServiceTimingMetric]
data ServiceTimingMetric
ServiceTimingMetric :: RequestDimensions -> RunningTimeBucket -> RequestTimingsCount -> ServiceTimingMetric
[dimensions] :: ServiceTimingMetric -> RequestDimensions
[bucket] :: ServiceTimingMetric -> RunningTimeBucket
[metrics] :: ServiceTimingMetric -> RequestTimingsCount

-- | The timings and counts here were from requests with total time longer
--   than <a>bucketGreaterThan</a> (but less than any larger bucket cutoff
--   times).
newtype RunningTimeBucket
RunningTimeBucket :: Seconds -> RunningTimeBucket
[bucketGreaterThan] :: RunningTimeBucket -> Seconds

-- | <a>RequestTimings</a> along with the count
data RequestTimingsCount
RequestTimingsCount :: !Seconds -> !Seconds -> !Word -> RequestTimingsCount
[telemTimeIO] :: RequestTimingsCount -> !Seconds
[telemTimeTot] :: RequestTimingsCount -> !Seconds

-- | The number of requests that have contributed to the accumulated
--   timings above. So e.g. <tt>telemTimeTot / count</tt> would give the
--   mean service time.
[telemCount] :: RequestTimingsCount -> !Word
instance GHC.Internal.Enum.Enum Hasura.Server.Telemetry.Counters.Locality
instance GHC.Internal.Enum.Enum Hasura.Server.Telemetry.Counters.QueryType
instance GHC.Internal.Enum.Enum Hasura.Server.Telemetry.Counters.Transport
instance GHC.Classes.Eq Hasura.Server.Telemetry.Counters.Locality
instance GHC.Classes.Eq Hasura.Server.Telemetry.Counters.QueryType
instance GHC.Classes.Eq Hasura.Server.Telemetry.Counters.RequestDimensions
instance GHC.Classes.Eq Hasura.Server.Telemetry.Counters.RequestTimingsCount
instance GHC.Classes.Eq Hasura.Server.Telemetry.Counters.RunningTimeBucket
instance GHC.Classes.Eq Hasura.Server.Telemetry.Counters.ServiceTimingMetric
instance GHC.Classes.Eq Hasura.Server.Telemetry.Counters.ServiceTimingMetrics
instance GHC.Classes.Eq Hasura.Server.Telemetry.Counters.Transport
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Telemetry.Counters.Locality
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Telemetry.Counters.QueryType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Telemetry.Counters.RequestDimensions
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Telemetry.Counters.RequestTimingsCount
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Telemetry.Counters.RunningTimeBucket
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Telemetry.Counters.ServiceTimingMetric
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Telemetry.Counters.ServiceTimingMetrics
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Telemetry.Counters.Transport
instance GHC.Internal.Generics.Generic Hasura.Server.Telemetry.Counters.Locality
instance GHC.Internal.Generics.Generic Hasura.Server.Telemetry.Counters.QueryType
instance GHC.Internal.Generics.Generic Hasura.Server.Telemetry.Counters.RequestDimensions
instance GHC.Internal.Generics.Generic Hasura.Server.Telemetry.Counters.RequestTimingsCount
instance GHC.Internal.Generics.Generic Hasura.Server.Telemetry.Counters.RunningTimeBucket
instance GHC.Internal.Generics.Generic Hasura.Server.Telemetry.Counters.ServiceTimingMetric
instance GHC.Internal.Generics.Generic Hasura.Server.Telemetry.Counters.ServiceTimingMetrics
instance GHC.Internal.Generics.Generic Hasura.Server.Telemetry.Counters.Transport
instance Data.Hashable.Class.Hashable Hasura.Server.Telemetry.Counters.Locality
instance Data.Hashable.Class.Hashable Hasura.Server.Telemetry.Counters.QueryType
instance Data.Hashable.Class.Hashable Hasura.Server.Telemetry.Counters.RequestDimensions
instance Data.Hashable.Class.Hashable Hasura.Server.Telemetry.Counters.RunningTimeBucket
instance Data.Hashable.Class.Hashable Hasura.Server.Telemetry.Counters.Transport
instance GHC.Internal.Base.Monoid Hasura.Server.Telemetry.Counters.Locality
instance GHC.Classes.Ord Hasura.Server.Telemetry.Counters.Locality
instance GHC.Classes.Ord Hasura.Server.Telemetry.Counters.QueryType
instance GHC.Classes.Ord Hasura.Server.Telemetry.Counters.RequestDimensions
instance GHC.Classes.Ord Hasura.Server.Telemetry.Counters.RequestTimingsCount
instance GHC.Classes.Ord Hasura.Server.Telemetry.Counters.RunningTimeBucket
instance GHC.Classes.Ord Hasura.Server.Telemetry.Counters.ServiceTimingMetric
instance GHC.Classes.Ord Hasura.Server.Telemetry.Counters.ServiceTimingMetrics
instance GHC.Classes.Ord Hasura.Server.Telemetry.Counters.Transport
instance GHC.Internal.Base.Semigroup Hasura.Server.Telemetry.Counters.Locality
instance GHC.Internal.Base.Semigroup Hasura.Server.Telemetry.Counters.RequestTimings
instance GHC.Internal.Base.Semigroup Hasura.Server.Telemetry.Counters.RequestTimingsCount
instance GHC.Internal.Show.Show Hasura.Server.Telemetry.Counters.Locality
instance GHC.Internal.Show.Show Hasura.Server.Telemetry.Counters.QueryType
instance GHC.Internal.Show.Show Hasura.Server.Telemetry.Counters.RequestDimensions
instance GHC.Internal.Show.Show Hasura.Server.Telemetry.Counters.RequestTimingsCount
instance GHC.Internal.Show.Show Hasura.Server.Telemetry.Counters.RunningTimeBucket
instance GHC.Internal.Show.Show Hasura.Server.Telemetry.Counters.ServiceTimingMetric
instance GHC.Internal.Show.Show Hasura.Server.Telemetry.Counters.ServiceTimingMetrics
instance GHC.Internal.Show.Show Hasura.Server.Telemetry.Counters.Transport
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Counters.Locality
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Counters.QueryType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Counters.RequestDimensions
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Counters.RequestTimingsCount
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Counters.RunningTimeBucket
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Counters.ServiceTimingMetric
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Counters.ServiceTimingMetrics
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Counters.Transport

module Hasura.Server.Utils

-- | The version integer
data APIVersion
VIVersion1 :: APIVersion
VIVersion2 :: APIVersion

-- | These env vars are completely deprecated
newtype DeprecatedEnvVars
DeprecatedEnvVars :: [String] -> DeprecatedEnvVars
[unDeprecatedEnvVars] :: DeprecatedEnvVars -> [String]

-- | The environment variables that were moved to metadata. These
--   environment variables are available if a v1 hasura project is run an
--   v2 hasura server. These environment variables are marked as deprecated
--   only when the v1 hasura project is migrated to v2 project.
newtype EnvVarsMovedToMetadata
EnvVarsMovedToMetadata :: [String] -> EnvVarsMovedToMetadata
[unEnvVarsMovedToMetadata] :: EnvVarsMovedToMetadata -> [String]
cryptoHash :: ToJSON a => a -> ByteString
deprecatedEnvVars :: DeprecatedEnvVars
englishList :: Text -> NonEmpty Text -> Text
envVarsMovedToMetadata :: EnvVarsMovedToMetadata
executeJSONPath :: JSONPath -> Value -> IResult Value
fmapL :: (a -> a') -> Either a b -> Either a' b
generateFingerprint :: IO Text
httpExceptToJSON :: HttpException -> Value
isReqUserId :: Text -> Bool
makeReasonMessage :: [a] -> (a -> Text) -> Text
parseConnLifeTime :: Maybe NominalDiffTime -> Maybe NominalDiffTime

-- | Quotes a regex using Template Haskell so syntax errors can be reported
--   at compile-time.
quoteRegex :: CompOption -> ExecOption -> String -> Code Q Regex
readIsoLevel :: String -> Either String TxIsolation
sessionVariablePrefix :: Text
instance GHC.Classes.Eq Hasura.Server.Utils.APIVersion
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Utils.APIVersion
instance GHC.Internal.Show.Show Hasura.Server.Utils.APIVersion
instance GHC.Internal.Show.Show Hasura.Server.Utils.DeprecatedEnvVars
instance GHC.Internal.Show.Show Hasura.Server.Utils.EnvVarsMovedToMetadata
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Utils.APIVersion


-- | CORS (Cross Origin Resource Sharing) related configuration
module Hasura.Server.Cors
data CorsConfig
CCAllowAll :: CorsConfig
CCAllowedOrigins :: Domains -> CorsConfig
CCDisabled :: Bool -> CorsConfig
data CorsPolicy
CorsPolicy :: !CorsConfig -> ![Text] -> !Int -> CorsPolicy
[cpConfig] :: CorsPolicy -> !CorsConfig
[cpMethods] :: CorsPolicy -> ![Text]
[cpMaxAge] :: CorsPolicy -> !Int
parseOrigin :: Text -> Either String DomainParts
readCorsDomains :: String -> Either String CorsConfig
mkDefaultCorsPolicy :: CorsConfig -> CorsPolicy
isCorsDisabled :: CorsConfig -> Bool
data Domains
Domains :: !HashSet Text -> !HashSet DomainParts -> Domains
[dmFqdns] :: Domains -> !HashSet Text
[dmWildcards] :: Domains -> !HashSet DomainParts
inWildcardList :: Domains -> Text -> Bool
instance GHC.Classes.Eq Hasura.Server.Cors.CorsConfig
instance GHC.Classes.Eq Hasura.Server.Cors.CorsPolicy
instance GHC.Classes.Eq Hasura.Server.Cors.DomainParts
instance GHC.Classes.Eq Hasura.Server.Cors.Domains
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Cors.CorsConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Cors.DomainParts
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Cors.Domains
instance GHC.Internal.Generics.Generic Hasura.Server.Cors.DomainParts
instance GHC.Internal.Generics.Generic Hasura.Server.Cors.Domains
instance Data.Hashable.Class.Hashable Hasura.Server.Cors.DomainParts
instance GHC.Internal.Show.Show Hasura.Server.Cors.CorsConfig
instance GHC.Internal.Show.Show Hasura.Server.Cors.CorsPolicy
instance GHC.Internal.Show.Show Hasura.Server.Cors.DomainParts
instance GHC.Internal.Show.Show Hasura.Server.Cors.Domains
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Cors.CorsConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Cors.DomainParts
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Cors.Domains

module Hasura.Server.Middleware
corsMiddleware :: IO CorsPolicy -> Middleware

module Hasura.Server.Auth.JWT.Internal
parseEdDSAKey :: Text -> Either Text JWK

-- | Helper functions to decode Text to JWK
parseHmacKey :: Text -> Int64 -> Either Text JWK
parseRsaKey :: Text -> Either Text JWK
parseEsKey :: Text -> Either Text JWK


-- | Validate input queries against remote schemas.
module Hasura.RemoteSchema.SchemaCache.RemoteRelationship

-- | Validate a remote schema relationship given a context.
validateToSchemaRelationship :: MonadError ValidationError m => ToSchemaRelationshipDef -> LHSIdentifier -> RelName -> (RemoteSchemaInfo, IntrospectionResult) -> HashMap FieldName joinField -> m (HashMap FieldName joinField, RemoteSchemaFieldInfo)
errorToText :: ValidationError -> Text
instance GHC.Classes.Eq Hasura.RemoteSchema.SchemaCache.RemoteRelationship.ValidationError
instance GHC.Internal.Show.Show Hasura.RemoteSchema.SchemaCache.RemoteRelationship.ValidationError


-- | This module calculates parameterized query hash, which is a way to
--   hash an incoming query (after resolving variables) with all leaf nodes
--   (i.e. scalar values) discarded. In other words, two queries having the
--   same parameterized query hash are essentially the same query but may
--   differ in leaf values.
--   
--   For example:
--   
--   <ol>
--   <li>query { authors (where: {id: {_eq: 2}}) { id name } }</li>
--   <li>query { authors (where: {id: {_eq: 203943}}) { id name } }</li>
--   <li>query { authors (where: {id: {_eq: $id}}) { id name } }</li>
--   </ol>
--   
--   For any value of <a>id</a>
--   
--   <ol>
--   <li>query { authors (where: $whereBoolExp) { id name } }</li>
--   </ol>
--   
--   only when <tt>whereBoolExp</tt> is of the form of
--   
--   { "id": { "_eq": <a>id</a> } }
--   
--   All the above queries should result in the same parameterized query
--   hash.
--   
--   The following steps are done to calculate the parameterized query
--   hash:
--   
--   <ol>
--   <li>Normalize the GraphQL query by substituting the variables (if any)
--   in appropriate places.</li>
--   <li>Substitute any scalar GraphQL values (Int, Float, Enum, String and
--   Boolean) to null</li>
--   <li>For input objects and list, traverse through them and do step no
--   2.</li>
--   <li>Calculate the hash of the query obtained from step 3.</li>
--   </ol>
--   
--   Note: Parameterized query hash is a PRO only feature
module Hasura.GraphQL.ParameterizedQueryHash
calculateParameterizedQueryHash :: SelectionSet NoFragments Variable -> ParameterizedQueryHash
mkUnsafeParameterizedQueryHash :: Text -> ParameterizedQueryHash
unParamQueryHash :: ParameterizedQueryHash -> ByteString
data ParameterizedQueryHash

-- | a set of parameterized query hashes attached to a request this type
--   exists because a simple list of <tt>ParameterisedQueryHash</tt>es
--   won't let us log a single-request batch and a single non-batched
--   request differently. the log format uses json lists for requests
--   executed in batched mode, for fields like <tt>query</tt>, but not for
--   requests in single mode (e.g. <tt>query: "..."</tt> vs <tt>query:
--   ["..."]</tt>) and so to conform to that, we capture the whole _set_ of
--   parameterised query hashes when it's created, tagging it with
--   information about how it was created (i.e. from a batched request, a
--   single request, etc.)
data ParameterizedQueryHashList

-- | an empty query hash set, either for an operation that does not produce
--   query hashes, or due to failure in operation execution
PQHSetEmpty :: ParameterizedQueryHashList

-- | a query hash set consisting of a single element, corresponding to e.g.
--   a single (non-batched) graphql request
PQHSetSingleton :: !ParameterizedQueryHash -> ParameterizedQueryHashList

-- | a query hash set associated to a batched request note that this does
--   not need to contain multiple query hashes: it is possible for a batch
--   to contain only one request
PQHSetBatched :: ![ParameterizedQueryHash] -> ParameterizedQueryHashList

-- | we use something that explicitly produces an <a>Object</a> instead of
--   writing a <a>ToJSON</a> instance. in the latter case, functions
--   consuming the output of <a>toJSON</a> would have to perform a partial
--   pattern-match on the <a>Value</a> output to extract a JSON object from
--   it. for the other patterns, it would have to either throw a runtime
--   error on or silently ignore the other patterns, and the latter choice
--   would cause a silent failure if the <a>ToJSON</a> instance were
--   modified to no longer always return objects
parameterizedQueryHashListToObject :: ParameterizedQueryHashList -> Object
instance GHC.Classes.Eq Hasura.GraphQL.ParameterizedQueryHash.ParameterizedQueryHash
instance GHC.Classes.Eq Hasura.GraphQL.ParameterizedQueryHash.ParameterizedQueryHashList
instance Data.Hashable.Class.Hashable Hasura.GraphQL.ParameterizedQueryHash.ParameterizedQueryHash
instance GHC.Classes.Ord Hasura.GraphQL.ParameterizedQueryHash.ParameterizedQueryHash
instance GHC.Internal.Show.Show Hasura.GraphQL.ParameterizedQueryHash.ParameterizedQueryHash
instance GHC.Internal.Show.Show Hasura.GraphQL.ParameterizedQueryHash.ParameterizedQueryHashList
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.ParameterizedQueryHash.ParameterizedQueryHash


-- | This module implements <i>fragment inlining</i>, which converts all
--   fragment spreads in a GraphQL query to inline fragments. For example,
--   given a query like
--   
--   <pre>
--   query {
--     users {
--       id
--       ...userFields
--     }
--   }
--   
--   fragment userFields on User {
--     name
--     favoriteColor
--   }
--   </pre>
--   
--   the fragment inliner will convert it to this:
--   
--   <pre>
--   query {
--     users {
--       id
--       ... on User {
--         name
--         favoriteColor
--       }
--     }
--   }
--   </pre>
--   
--   This is a straightforward and mechanical transformation, but it
--   simplifies further processing, since we catch unbound fragments and
--   recursive fragment definitions early in the pipeline, so parsing does
--   not have to worry about it. In that sense, fragment inlining is
--   similar to the variable resolution pass performed by
--   <a>Hasura.GraphQL.Execute.Resolve</a>, but for fragment definitions
--   rather than variables.
module Hasura.GraphQL.Execute.Inline
type InlineMT (m :: Type -> Type) a = MonadError QErr m => StateT InlineState ReaderT InlineEnv m a
type InlineM a = InlineMT Except QErr a

-- | Inlines all fragment spreads in a <a>SelectionSet</a>; see the module
--   documentation for <a>Hasura.GraphQL.Execute.Inline</a> for details.
inlineSelectionSet :: (MonadError QErr m, Foldable t) => t FragmentDefinition -> SelectionSet FragmentSpread Name -> m (SelectionSet NoFragments Name)
inlineField :: MonadInline m => Field FragmentSpread Name -> m (Field NoFragments Name)
runInlineMT :: MonadError QErr m => HashMap Name FragmentDefinition -> InlineMT m a -> m a
runInlineM :: HashMap Name FragmentDefinition -> InlineM a -> Either QErr a

module Hasura.GraphQL.Transport.HTTP.Protocol

-- | <a>https://graphql.org/learn/serving-over-http/#post-request</a>
--   
--   See <a>GQLReqParsed</a> for invariants.
data GQLReq a
GQLReq :: !Maybe OperationName -> !a -> !Maybe VariableValues -> GQLReq a
[_grOperationName] :: GQLReq a -> !Maybe OperationName
[_grQuery] :: GQLReq a -> !a
[_grVariables] :: GQLReq a -> !Maybe VariableValues

-- | Batched queries are sent as a JSON array of <a>GQLReq</a> records.
--   This newtype exists to support the unusual JSON encoding.
--   
--   See <a>https://github.com/hasura/graphql-engine/issues/1812</a>.
data GQLBatchedReqs a
GQLSingleRequest :: a -> GQLBatchedReqs a
GQLBatchedReqs :: [a] -> GQLBatchedReqs a

-- | We've not yet parsed the graphql query string parameter of the POST.
type GQLReqUnparsed = GQLReq GQLQueryText

-- | Invariants:
--   
--   <ul>
--   <li>when <a>_grOperationName</a> is <tt>Nothing</tt>, <a>_grQuery</a>
--   contains exactly one <tt>ExecutableDefinitionOperation</tt> (and zero
--   or more <tt>ExecutableDefinitionFragment</tt>)</li>
--   <li>when <a>_grOperationName</a> is present, there is a corresponding
--   <tt>ExecutableDefinitionOperation</tt> in <a>_grQuery</a></li>
--   </ul>
type GQLReqParsed = GQLReq GQLExecDoc

-- | A simplified form of <a>GQLReqParsed</a> which is more ergonomic in
--   particular for APIs that act as graphql <i>clients</i> (e.g. in remote
--   relationship execution). This is a "desugared" request in which
--   fragments have been inlined (see <tt>inlineSelectionSet</tt>), and the
--   operation (<a>_grOperationName</a>) to be executed is the only payload
--   (in contrast to a <a>ExecutableDocument</a> with possibly many named
--   operations).
--   
--   <a>_grOperationName</a> is essentially ignored here, but should
--   correspond with <tt>_todName</tt> if present.
--   
--   These could maybe benefit from an HKD refactoring.
type GQLReqOutgoing = GQLReq SingleOperation
renderGQLReqOutgoing :: GQLReqOutgoing -> GQLReqUnparsed

-- | A single graphql operation to be executed, with fragment definitions
--   inlined. This is the simplified form of <a>GQLExecDoc</a> or
--   <a>ExecutableDocument</a>:
type SingleOperation = TypedOperationDefinition NoFragments Name

-- | Obtain the actual single operation to be executed, from the possibly-
--   multi-operation document, validating per the spec and inlining any
--   fragment definitions (pre-defined parts of a graphql query) at
--   fragment spreads (locations where fragments are "spliced"). See:
--   
--   <a>https://spec.graphql.org/June2018/#sec-Executable-Definitions</a>
--   and... <a>https://graphql.org/learn/serving-over-http/</a>
getSingleOperation :: MonadError QErr m => GQLReqParsed -> m SingleOperation
toParsed :: MonadError QErr m => GQLReqUnparsed -> m GQLReqParsed

-- | Get operation name from parsed executable document if the field
--   <tt>operationName</tt> is not explicitly sent by the client in the
--   body of the request
getOpNameFromParsedReq :: GQLReqParsed -> Maybe OperationName
newtype GQLQueryText
GQLQueryText :: Text -> GQLQueryText
[_unGQLQueryText] :: GQLQueryText -> Text
newtype GQLExecDoc
GQLExecDoc :: [ExecutableDefinition Name] -> GQLExecDoc
[unGQLExecDoc] :: GQLExecDoc -> [ExecutableDefinition Name]
newtype OperationName
OperationName :: Name -> OperationName
[_unOperationName] :: OperationName -> Name
type VariableValues = HashMap Name Value
encodeGQErr :: Bool -> QErr -> Encoding
encodeGQExecError :: GQExecError -> Encoding
encodeGQResp :: GQResponse -> EncJSON
decodeGQResp :: EncJSON -> (Maybe GQResponse, EncJSON)
encodeHTTPResp :: GQResponse -> EncJSON
type GQResult a = Either GQExecError a
newtype GQExecError
GQExecError :: [Encoding] -> GQExecError
type GQResponse = GQResult ByteString
isExecError :: GQResult a -> Bool
type ReqsText = GQLBatchedReqs GQLReq GQLQueryText
instance GHC.Classes.Eq Hasura.GraphQL.Transport.HTTP.Protocol.GQExecError
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.GraphQL.Transport.HTTP.Protocol.GQLBatchedReqs a)
instance GHC.Classes.Eq Hasura.GraphQL.Transport.HTTP.Protocol.GQLExecDoc
instance GHC.Classes.Eq Hasura.GraphQL.Transport.HTTP.Protocol.GQLQueryText
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.GraphQL.Transport.HTTP.Protocol.GQLReq a)
instance GHC.Classes.Eq Hasura.GraphQL.Transport.HTTP.Protocol.OperationName
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Hasura.GraphQL.Transport.HTTP.Protocol.GQLBatchedReqs a)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Transport.HTTP.Protocol.GQLExecDoc
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Transport.HTTP.Protocol.GQLQueryText
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Hasura.GraphQL.Transport.HTTP.Protocol.GQLReq a)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Transport.HTTP.Protocol.OperationName
instance GHC.Internal.Base.Functor Hasura.GraphQL.Transport.HTTP.Protocol.GQLBatchedReqs
instance GHC.Internal.Base.Functor Hasura.GraphQL.Transport.HTTP.Protocol.GQLReq
instance GHC.Internal.Generics.Generic (Hasura.GraphQL.Transport.HTTP.Protocol.GQLBatchedReqs a)
instance GHC.Internal.Generics.Generic (Hasura.GraphQL.Transport.HTTP.Protocol.GQLReq a)
instance Data.Hashable.Class.Hashable Hasura.GraphQL.Transport.HTTP.Protocol.GQLExecDoc
instance Data.Hashable.Class.Hashable Hasura.GraphQL.Transport.HTTP.Protocol.GQLQueryText
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.GraphQL.Transport.HTTP.Protocol.GQLReq a)
instance Data.Hashable.Class.Hashable Hasura.GraphQL.Transport.HTTP.Protocol.OperationName
instance GHC.Internal.Data.String.IsString Hasura.GraphQL.Transport.HTTP.Protocol.GQLQueryText
instance Language.Haskell.TH.Syntax.Lift Hasura.GraphQL.Transport.HTTP.Protocol.GQLExecDoc
instance Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift (Hasura.GraphQL.Transport.HTTP.Protocol.GQLReq a)
instance Language.Haskell.TH.Syntax.Lift Hasura.GraphQL.Transport.HTTP.Protocol.OperationName
instance GHC.Classes.Ord Hasura.GraphQL.Transport.HTTP.Protocol.GQLExecDoc
instance GHC.Classes.Ord Hasura.GraphQL.Transport.HTTP.Protocol.GQLQueryText
instance GHC.Classes.Ord Hasura.GraphQL.Transport.HTTP.Protocol.OperationName
instance GHC.Internal.Show.Show Hasura.GraphQL.Transport.HTTP.Protocol.GQExecError
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (Hasura.GraphQL.Transport.HTTP.Protocol.GQLBatchedReqs a)
instance GHC.Internal.Show.Show Hasura.GraphQL.Transport.HTTP.Protocol.GQLExecDoc
instance GHC.Internal.Show.Show Hasura.GraphQL.Transport.HTTP.Protocol.GQLQueryText
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (Hasura.GraphQL.Transport.HTTP.Protocol.GQLReq a)
instance GHC.Internal.Show.Show Hasura.GraphQL.Transport.HTTP.Protocol.OperationName
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.GraphQL.Transport.HTTP.Protocol.GQLBatchedReqs a)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.HTTP.Protocol.GQLExecDoc
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.HTTP.Protocol.GQLQueryText
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.GraphQL.Transport.HTTP.Protocol.GQLReq a)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.HTTP.Protocol.OperationName

module Hasura.Server.Types
data ExperimentalFeature
EFInheritedRoles :: ExperimentalFeature
EFOptimizePermissionFilters :: ExperimentalFeature
EFNamingConventions :: ExperimentalFeature
EFStreamingSubscriptions :: ExperimentalFeature
EFApolloFederation :: ExperimentalFeature
EFHideUpdateManyFields :: ExperimentalFeature
EFBigQueryStringNumericInput :: ExperimentalFeature
EFHideAggregationPredicates :: ExperimentalFeature
EFHideStreamFields :: ExperimentalFeature
EFGroupByAggregations :: ExperimentalFeature
EFDisablePostgresArrays :: ExperimentalFeature
experimentalFeatureKey :: ExperimentalFeature -> Text

-- | A UUID for each running instance of graphql-engine, generated fresh
--   each time graphql-engine starts up
newtype InstanceId
InstanceId :: Text -> InstanceId
[getInstanceId] :: InstanceId -> Text

-- | Generate an <a>InstanceId</a> from a <tt>UUID</tt>
generateInstanceId :: IO InstanceId

-- | A uuid of the postgres metadata db.
newtype MetadataDbId
MetadataDbId :: Text -> MetadataDbId
[getMetadataDbId] :: MetadataDbId -> Text

-- | A uuid of a source database.
newtype DbUid
DbUid :: Text -> DbUid
[getDbUid] :: DbUid -> Text
mdDbIdToDbUid :: MetadataDbId -> DbUid
data MaintenanceMode a
MaintenanceModeEnabled :: a -> MaintenanceMode a
MaintenanceModeDisabled :: MaintenanceMode a

-- | EventingMode decides whether the eventing subsystem should be enabled
--   or disabled. <tt>EventDisabled</tt> mode disables Event Triggers,
--   Async Actions, Scheduled Events and source catalaog migrations. This
--   is an internal feature and will not be exposed to users.
data EventingMode
EventingEnabled :: EventingMode
EventingDisabled :: EventingMode

-- | See Note [ReadOnly Mode]
data ReadOnlyMode
ReadOnlyModeEnabled :: ReadOnlyMode
ReadOnlyModeDisabled :: ReadOnlyMode
newtype DbVersion
DbVersion :: Text -> DbVersion
newtype PGVersion
PGVersion :: Int -> PGVersion
pgToDbVersion :: PGVersion -> DbVersion
newtype RequestId
RequestId :: Text -> RequestId
[unRequestId] :: RequestId -> Text
data CheckFeatureFlag
CheckFeatureFlag :: (FeatureFlag -> IO Bool) -> [(FeatureFlag, Text)] -> CheckFeatureFlag

-- | Action that samples the value of a feature flag. Different products
--   will want to do different things. For example, the Cloud product will
--   want to use LaunchDarkly whereas the OSS and non-cloud EE products
--   will want to sample environment variables.
[runCheckFeatureFlag] :: CheckFeatureFlag -> FeatureFlag -> IO Bool

-- | A registry of flags that are <tt>known</tt> by the system. This is
--   used to inform of feature flag values via the '<i>v1alpha</i>config'
--   endpoint, as well as sampling feature flag values for use in schema
--   code.
[listKnownFeatureFlags] :: CheckFeatureFlag -> [(FeatureFlag, Text)]
getRequestId :: MonadIO m => [Header] -> m (RequestId, [Header])

-- | Whether or not to enable apollo federation fields.
data ApolloFederationStatus
ApolloFederationEnabled :: ApolloFederationStatus
ApolloFederationDisabled :: ApolloFederationStatus
data TriggersErrorLogLevelStatus
TriggersErrorLogLevelEnabled :: TriggersErrorLogLevelStatus
TriggersErrorLogLevelDisabled :: TriggersErrorLogLevelStatus
isApolloFederationEnabled :: ApolloFederationStatus -> Bool
isTriggersErrorLogLevelEnabled :: TriggersErrorLogLevelStatus -> Bool
data ModelInfoLogState
ModelInfoLogOff :: ModelInfoLogState
ModelInfoLogOn :: ModelInfoLogState

-- | Whether or not to enable granular metrics for Prometheus.
--   
--   <a>GranularMetricsOn</a> will enable the dynamic labels for the
--   metrics. <a>GranularMetricsOff</a> will disable the dynamic labels for
--   the metrics.
--   
--   <ul>
--   <li>*Warning**: Enabling dynamic labels for Prometheus metrics can
--   cause cardinality issues and can cause memory usage to increase.</li>
--   </ul>
data GranularPrometheusMetricsState
GranularMetricsOff :: GranularPrometheusMetricsState
GranularMetricsOn :: GranularPrometheusMetricsState

-- | Whether or not to enable OpenTelemetry Exporter.
--   
--   <a>OpenTelemetryExporterOn</a> will enable exporting of traces &amp;
--   metrics via the OTel Exporter. <a>OpenTelemetryExporterOff</a> will
--   disable exporting of traces &amp; metrics via the OTel Exporter.
data OpenTelemetryExporterState
OpenTelemetryExporterOff :: OpenTelemetryExporterState
OpenTelemetryExporterOn :: OpenTelemetryExporterState

-- | Whether or not to close websocket connections on metadata change.
data CloseWebsocketsOnMetadataChangeStatus
CWMCEnabled :: CloseWebsocketsOnMetadataChangeStatus
CWMCDisabled :: CloseWebsocketsOnMetadataChangeStatus
isCloseWebsocketsOnMetadataChangeStatusEnabled :: CloseWebsocketsOnMetadataChangeStatus -> Bool
data PersistedQueriesState
PersistedQueriesDisabled :: PersistedQueriesState
PersistedQueriesEnabled :: PersistedQueriesState

-- | The persisted query request sent by Apollo clients. Ref:
--   <a>https://www.apollographql.com/docs/apollo-server/performance/apq/#verify</a>
data PersistedQueryRequest
PersistedQueryRequest :: Int -> Text -> PersistedQueryRequest
[_pqrVersion] :: PersistedQueryRequest -> Int
[_pqrSha256Hash] :: PersistedQueryRequest -> Text

-- | The persisted query request sent in the POST body by Apollo Clients.
--   Ref:
--   <a>https://github.com/apollographql/apollo-link-persisted-queries#protocol</a>
--   Read as Extended Persisted Query request. The Query field in the
--   request body, will contain the query only when it is not present in
--   the system, thus `HGE.GQLReq (Maybe a)`
data ExtPersistedQueryRequest a
ExtPersistedQueryRequest :: Maybe OperationName -> Maybe GQLQueryText -> Maybe VariableValues -> PersistedQueryRequest -> ExtPersistedQueryRequest a
[_extOperationName] :: ExtPersistedQueryRequest a -> Maybe OperationName
[_extQuery] :: ExtPersistedQueryRequest a -> Maybe GQLQueryText
[_extVariables] :: ExtPersistedQueryRequest a -> Maybe VariableValues
[_extExtensions] :: ExtPersistedQueryRequest a -> PersistedQueryRequest

-- | The POST request might either be a normal GQL request or a persisted
--   query request
data ExtQueryReqs
EqrGQLReq :: ReqsText -> ExtQueryReqs
EqrAPQReq :: ExtPersistedQueryRequest (GQLReq GQLQueryText) -> ExtQueryReqs
class Monad m => MonadGetPolicies (m :: Type -> Type)
runGetApiTimeLimit :: MonadGetPolicies m => m (Maybe MaxTime)
runGetPrometheusMetricsGranularity :: MonadGetPolicies m => m (IO GranularPrometheusMetricsState)
runGetModelInfoLogStatus :: MonadGetPolicies m => m (IO ModelInfoLogState)
data TraceQueryStatus
TraceQueryEnabled :: TraceQueryStatus
TraceQueryDisabled :: TraceQueryStatus
instance GHC.Internal.Enum.Bounded Hasura.Server.Types.ExperimentalFeature
instance GHC.Internal.Enum.Enum Hasura.Server.Types.ExperimentalFeature
instance GHC.Classes.Eq Hasura.Server.Types.ApolloFederationStatus
instance GHC.Classes.Eq Hasura.Server.Types.CloseWebsocketsOnMetadataChangeStatus
instance GHC.Classes.Eq Hasura.Server.Types.DbUid
instance GHC.Classes.Eq Hasura.Server.Types.DbVersion
instance GHC.Classes.Eq Hasura.Server.Types.EventingMode
instance GHC.Classes.Eq Hasura.Server.Types.ExperimentalFeature
instance GHC.Classes.Eq (Hasura.Server.Types.ExtPersistedQueryRequest a)
instance GHC.Classes.Eq Hasura.Server.Types.ExtQueryReqs
instance GHC.Classes.Eq Hasura.Server.Types.GranularPrometheusMetricsState
instance GHC.Classes.Eq Hasura.Server.Types.InstanceId
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.Server.Types.MaintenanceMode a)
instance GHC.Classes.Eq Hasura.Server.Types.MetadataDbId
instance GHC.Classes.Eq Hasura.Server.Types.ModelInfoLogState
instance GHC.Classes.Eq Hasura.Server.Types.OpenTelemetryExporterState
instance GHC.Classes.Eq Hasura.Server.Types.PGVersion
instance GHC.Classes.Eq Hasura.Server.Types.PersistedQueriesState
instance GHC.Classes.Eq Hasura.Server.Types.PersistedQueryRequest
instance GHC.Classes.Eq Hasura.Server.Types.ReadOnlyMode
instance GHC.Classes.Eq Hasura.Server.Types.RequestId
instance GHC.Classes.Eq Hasura.Server.Types.TraceQueryStatus
instance GHC.Classes.Eq Hasura.Server.Types.TriggersErrorLogLevelStatus
instance Database.PG.Query.Class.FromCol Hasura.Server.Types.InstanceId
instance Database.PG.Query.Class.FromCol Hasura.Server.Types.MetadataDbId
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Types.ApolloFederationStatus
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Types.CloseWebsocketsOnMetadataChangeStatus
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Types.DbUid
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Types.ExperimentalFeature
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Server.Types.ExtPersistedQueryRequest a)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Types.ExtQueryReqs
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Types.GranularPrometheusMetricsState
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Types.InstanceId
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.Server.Types.MaintenanceMode ())
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Types.MetadataDbId
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Types.ModelInfoLogState
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Types.OpenTelemetryExporterState
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Types.PersistedQueriesState
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Types.PersistedQueryRequest
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Types.RequestId
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Types.TraceQueryStatus
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Types.TriggersErrorLogLevelStatus
instance GHC.Internal.Generics.Generic Hasura.Server.Types.ApolloFederationStatus
instance GHC.Internal.Generics.Generic Hasura.Server.Types.CloseWebsocketsOnMetadataChangeStatus
instance GHC.Internal.Generics.Generic Hasura.Server.Types.ExperimentalFeature
instance GHC.Internal.Generics.Generic (Hasura.Server.Types.ExtPersistedQueryRequest a)
instance GHC.Internal.Generics.Generic Hasura.Server.Types.ExtQueryReqs
instance GHC.Internal.Generics.Generic Hasura.Server.Types.PersistedQueryRequest
instance GHC.Internal.Generics.Generic Hasura.Server.Types.TraceQueryStatus
instance GHC.Internal.Generics.Generic Hasura.Server.Types.TriggersErrorLogLevelStatus
instance Data.Hashable.Class.Hashable Hasura.Server.Types.ApolloFederationStatus
instance Data.Hashable.Class.Hashable Hasura.Server.Types.CloseWebsocketsOnMetadataChangeStatus
instance Data.Hashable.Class.Hashable Hasura.Server.Types.ExperimentalFeature
instance Data.Hashable.Class.Hashable Hasura.Server.Types.RequestId
instance Hasura.Server.Types.MonadGetPolicies m => Hasura.Server.Types.MonadGetPolicies (Control.Monad.Trans.Except.ExceptT e m)
instance Hasura.Server.Types.MonadGetPolicies m => Hasura.Server.Types.MonadGetPolicies (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.Server.Types.MonadGetPolicies m => Hasura.Server.Types.MonadGetPolicies (Control.Monad.Trans.State.Strict.StateT w m)
instance Control.DeepSeq.NFData Hasura.Server.Types.ApolloFederationStatus
instance Control.DeepSeq.NFData Hasura.Server.Types.CloseWebsocketsOnMetadataChangeStatus
instance GHC.Classes.Ord Hasura.Server.Types.ApolloFederationStatus
instance GHC.Classes.Ord Hasura.Server.Types.CloseWebsocketsOnMetadataChangeStatus
instance GHC.Classes.Ord Hasura.Server.Types.TriggersErrorLogLevelStatus
instance GHC.Internal.Show.Show Hasura.Server.Types.ApolloFederationStatus
instance GHC.Internal.Show.Show Hasura.Server.Types.CloseWebsocketsOnMetadataChangeStatus
instance GHC.Internal.Show.Show Hasura.Server.Types.DbUid
instance GHC.Internal.Show.Show Hasura.Server.Types.DbVersion
instance GHC.Internal.Show.Show Hasura.Server.Types.EventingMode
instance GHC.Internal.Show.Show Hasura.Server.Types.ExperimentalFeature
instance GHC.Internal.Show.Show (Hasura.Server.Types.ExtPersistedQueryRequest a)
instance GHC.Internal.Show.Show Hasura.Server.Types.ExtQueryReqs
instance GHC.Internal.Show.Show Hasura.Server.Types.GranularPrometheusMetricsState
instance GHC.Internal.Show.Show Hasura.Server.Types.InstanceId
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (Hasura.Server.Types.MaintenanceMode a)
instance GHC.Internal.Show.Show Hasura.Server.Types.MetadataDbId
instance GHC.Internal.Show.Show Hasura.Server.Types.ModelInfoLogState
instance GHC.Internal.Show.Show Hasura.Server.Types.OpenTelemetryExporterState
instance GHC.Internal.Show.Show Hasura.Server.Types.PGVersion
instance GHC.Internal.Show.Show Hasura.Server.Types.PersistedQueriesState
instance GHC.Internal.Show.Show Hasura.Server.Types.PersistedQueryRequest
instance GHC.Internal.Show.Show Hasura.Server.Types.ReadOnlyMode
instance GHC.Internal.Show.Show Hasura.Server.Types.RequestId
instance GHC.Internal.Show.Show Hasura.Server.Types.TraceQueryStatus
instance GHC.Internal.Show.Show Hasura.Server.Types.TriggersErrorLogLevelStatus
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Types.ApolloFederationStatus
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Types.CloseWebsocketsOnMetadataChangeStatus
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Types.DbUid
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Types.DbVersion
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Types.ExperimentalFeature
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Server.Types.ExtPersistedQueryRequest a)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Types.ExtQueryReqs
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Types.GranularPrometheusMetricsState
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Types.InstanceId
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.Server.Types.MaintenanceMode ())
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Types.MetadataDbId
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Types.ModelInfoLogState
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Types.OpenTelemetryExporterState
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Types.PGVersion
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Types.PersistedQueriesState
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Types.PersistedQueryRequest
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Types.RequestId
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Types.TraceQueryStatus
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Types.TriggersErrorLogLevelStatus
instance Database.PG.Query.Class.ToPrepArg Hasura.Server.Types.InstanceId
instance Database.PG.Query.Class.ToPrepArg Hasura.Server.Types.MetadataDbId

module Hasura.GraphQL.Schema.NamingCase
isGraphqlCase :: NamingCase -> Bool

-- | Check if naming convention has changed The value of naming convention
--   depends on whether the naming convention is enabled in experimental
--   features and what the default naming convention
--   (<tt>HASURA_GRAPHQL_DEFAULT_NAMING_CONVENTION</tt>) is hence use both
--   these values to decide if naming convention has changed
hasNamingConventionChanged :: (HashSet ExperimentalFeature, NamingCase) -> (HashSet ExperimentalFeature, NamingCase) -> Bool


-- | Implements <i>variable resolution</i> for GraphQL queries, which
--   annotates the use site of each GraphQL variable with its value.
module Hasura.GraphQL.Execute.Resolve
resolveVariables :: forall m (fragments :: Type -> Type). (MonadError QErr m, Traversable fragments) => BackwardsCompatibleNullInNonNullableVariables -> [VariableDefinition] -> VariableValues -> [Directive Name] -> SelectionSet fragments Name -> m ([Directive Variable], SelectionSet fragments Variable)


-- | Postgres Connection Settings
--   
--   This module contains types and combinators related to postgres
--   connection, pool, and replica related settings.
module Hasura.Backends.Postgres.Connection.Settings
data PostgresPoolSettings
PostgresPoolSettings :: Maybe Int -> Maybe Int -> Maybe Int -> Maybe Int -> Maybe NominalDiffTime -> Maybe NominalDiffTime -> PostgresPoolSettings
[ppsMaxConnections] :: PostgresPoolSettings -> Maybe Int
[ppsTotalMaxConnections] :: PostgresPoolSettings -> Maybe Int
[ppsIdleTimeout] :: PostgresPoolSettings -> Maybe Int
[ppsRetries] :: PostgresPoolSettings -> Maybe Int
[ppsPoolTimeout] :: PostgresPoolSettings -> Maybe NominalDiffTime
[ppsConnectionLifetime] :: PostgresPoolSettings -> Maybe NominalDiffTime
data PostgresSourceConnInfo
PostgresSourceConnInfo :: UrlConf -> Maybe PostgresPoolSettings -> Bool -> TxIsolation -> Maybe (PGClientCerts CertVar CertVar) -> PostgresSourceConnInfo
[psciDatabaseUrl] :: PostgresSourceConnInfo -> UrlConf
[psciPoolSettings] :: PostgresSourceConnInfo -> Maybe PostgresPoolSettings
[psciUsePreparedStatements] :: PostgresSourceConnInfo -> Bool
[psciIsolationLevel] :: PostgresSourceConnInfo -> TxIsolation
[psciSslConfiguration] :: PostgresSourceConnInfo -> Maybe (PGClientCerts CertVar CertVar)
data PostgresConnConfiguration
PostgresConnConfiguration :: PostgresSourceConnInfo -> Maybe (NonEmpty PostgresSourceConnInfo) -> ExtensionsSchema -> Maybe ConnectionTemplate -> Maybe PostgresConnectionSet -> PostgresConnConfiguration
[pccConnectionInfo] :: PostgresConnConfiguration -> PostgresSourceConnInfo
[pccReadReplicas] :: PostgresConnConfiguration -> Maybe (NonEmpty PostgresSourceConnInfo)
[pccExtensionsSchema] :: PostgresConnConfiguration -> ExtensionsSchema
[pccConnectionTemplate] :: PostgresConnConfiguration -> Maybe ConnectionTemplate
[pccConnectionSet] :: PostgresConnConfiguration -> Maybe PostgresConnectionSet
data PGClientCerts p a
PGClientCerts :: Maybe a -> Maybe a -> Maybe a -> SSLMode -> Maybe p -> PGClientCerts p a
[pgcSslCert] :: PGClientCerts p a -> Maybe a
[pgcSslKey] :: PGClientCerts p a -> Maybe a
[pgcSslRootCert] :: PGClientCerts p a -> Maybe a
[pgcSslMode] :: PGClientCerts p a -> SSLMode
[pgcSslPassword] :: PGClientCerts p a -> Maybe p
newtype CertVar
CertVar :: String -> CertVar
newtype CertData
CertData :: Text -> CertData
[unCert] :: CertData -> Text
data SSLMode
Disable :: SSLMode
Allow :: SSLMode
Prefer :: SSLMode
Require :: SSLMode
VerifyCA :: SSLMode
VerifyFull :: SSLMode
data DefaultPostgresPoolSettings
DefaultPostgresPoolSettings :: Int -> Int -> Int -> Maybe NominalDiffTime -> DefaultPostgresPoolSettings
[dppsMaxConnections] :: DefaultPostgresPoolSettings -> Int
[dppsIdleTimeout] :: DefaultPostgresPoolSettings -> Int
[dppsRetries] :: DefaultPostgresPoolSettings -> Int
[dppsConnectionLifetime] :: DefaultPostgresPoolSettings -> Maybe NominalDiffTime

-- | Connection template for the dynamic DB connection.
data ConnectionTemplate
ConnectionTemplate :: Int -> KritiTemplate -> ConnectionTemplate

-- | Version for the connection template. Please read more about this in
--   the dynamic DB connection RFC (Metadata API &gt; Versioning).
[ctVersion] :: ConnectionTemplate -> Int

-- | `kriti-lang` template for the dynamic DB connection.
[ctTemplate] :: ConnectionTemplate -> KritiTemplate

-- | Name of the member of a connection set.
newtype PostgresConnectionSetMemberName
PostgresConnectionSetMemberName :: NonEmptyText -> PostgresConnectionSetMemberName
[getPostgresConnectionSetMemberName] :: PostgresConnectionSetMemberName -> NonEmptyText

-- | HashMap of the connection set. This is used for the dynamic DB
--   connection feature.
newtype PostgresConnectionSet
PostgresConnectionSet :: NEHashMap PostgresConnectionSetMemberName PostgresConnectionSetMember -> PostgresConnectionSet
[getPostgresConnectionSet] :: PostgresConnectionSet -> NEHashMap PostgresConnectionSetMemberName PostgresConnectionSetMember
data PostgresConnectionSetMember
PostgresConnectionSetMember :: PostgresConnectionSetMemberName -> PostgresSourceConnInfo -> PostgresConnectionSetMember
[pscmName] :: PostgresConnectionSetMember -> PostgresConnectionSetMemberName
[pscmConnectionInfo] :: PostgresConnectionSetMember -> PostgresSourceConnInfo

-- | `kriti-lang` template.
data KritiTemplate
KritiTemplate :: Text -> ValueExt -> KritiTemplate

-- | Raw kriti template
[ktSource] :: KritiTemplate -> Text

-- | Parsed kriti template
[ktParsedAST] :: KritiTemplate -> ValueExt
getDefaultPGPoolSettingIfNotExists :: Maybe PostgresPoolSettings -> DefaultPostgresPoolSettings -> (Int, Int, Int)
defaultPostgresPoolSettings :: DefaultPostgresPoolSettings
defaultPostgresExtensionsSchema :: ExtensionsSchema
setPostgresPoolSettings :: PostgresPoolSettings
instance Data.Bifoldable.Bifoldable Hasura.Backends.Postgres.Connection.Settings.PGClientCerts
instance Data.Bifunctor.Bifunctor Hasura.Backends.Postgres.Connection.Settings.PGClientCerts
instance Data.Bitraversable.Bitraversable Hasura.Backends.Postgres.Connection.Settings.PGClientCerts
instance GHC.Internal.Enum.Bounded Hasura.Backends.Postgres.Connection.Settings.SSLMode
instance GHC.Internal.Enum.Enum Hasura.Backends.Postgres.Connection.Settings.SSLMode
instance GHC.Classes.Eq Hasura.Backends.Postgres.Connection.Settings.CertData
instance GHC.Classes.Eq Hasura.Backends.Postgres.Connection.Settings.CertVar
instance GHC.Classes.Eq Hasura.Backends.Postgres.Connection.Settings.ConnectionTemplate
instance GHC.Classes.Eq Hasura.Backends.Postgres.Connection.Settings.DefaultPostgresPoolSettings
instance GHC.Classes.Eq Hasura.Backends.Postgres.Connection.Settings.KritiTemplate
instance (GHC.Classes.Eq a, GHC.Classes.Eq p) => GHC.Classes.Eq (Hasura.Backends.Postgres.Connection.Settings.PGClientCerts p a)
instance GHC.Classes.Eq Hasura.Backends.Postgres.Connection.Settings.PostgresConnConfiguration
instance GHC.Classes.Eq Hasura.Backends.Postgres.Connection.Settings.PostgresConnectionSet
instance GHC.Classes.Eq Hasura.Backends.Postgres.Connection.Settings.PostgresConnectionSetMember
instance GHC.Classes.Eq Hasura.Backends.Postgres.Connection.Settings.PostgresConnectionSetMemberName
instance GHC.Classes.Eq Hasura.Backends.Postgres.Connection.Settings.PostgresPoolSettings
instance GHC.Classes.Eq Hasura.Backends.Postgres.Connection.Settings.PostgresSourceConnInfo
instance GHC.Classes.Eq Hasura.Backends.Postgres.Connection.Settings.SSLMode
instance GHC.Internal.Data.Foldable.Foldable (Hasura.Backends.Postgres.Connection.Settings.PGClientCerts p)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Connection.Settings.CertVar
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Connection.Settings.ConnectionTemplate
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Connection.Settings.KritiTemplate
instance (Data.Aeson.Types.FromJSON.FromJSON p, Data.Aeson.Types.FromJSON.FromJSON a) => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Backends.Postgres.Connection.Settings.PGClientCerts p a)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Connection.Settings.PostgresConnConfiguration
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Connection.Settings.PostgresConnectionSet
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Connection.Settings.PostgresConnectionSetMember
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Connection.Settings.PostgresConnectionSetMemberName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Connection.Settings.PostgresPoolSettings
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Connection.Settings.PostgresSourceConnInfo
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Connection.Settings.SSLMode
instance Data.Aeson.Types.FromJSON.FromJSON Database.PG.Query.Transaction.TxIsolation
instance GHC.Internal.Base.Functor (Hasura.Backends.Postgres.Connection.Settings.PGClientCerts p)
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.Connection.Settings.CertData
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.Connection.Settings.CertVar
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.Connection.Settings.ConnectionTemplate
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.Connection.Settings.KritiTemplate
instance GHC.Internal.Generics.Generic (Hasura.Backends.Postgres.Connection.Settings.PGClientCerts p a)
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.Connection.Settings.PostgresConnConfiguration
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.Connection.Settings.PostgresConnectionSet
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.Connection.Settings.PostgresConnectionSetMember
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.Connection.Settings.PostgresConnectionSetMemberName
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.Connection.Settings.PostgresPoolSettings
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.Connection.Settings.PostgresSourceConnInfo
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.Connection.Settings.SSLMode
instance GHC.Internal.Generics.Generic Database.PG.Query.Transaction.TxIsolation
instance Autodocodec.Class.HasCodec Hasura.Backends.Postgres.Connection.Settings.CertData
instance Autodocodec.Class.HasCodec Hasura.Backends.Postgres.Connection.Settings.CertVar
instance Autodocodec.Class.HasCodec Hasura.Backends.Postgres.Connection.Settings.ConnectionTemplate
instance Autodocodec.Class.HasCodec Hasura.Backends.Postgres.Connection.Settings.KritiTemplate
instance (Autodocodec.Class.HasCodec p, Autodocodec.Class.HasCodec a) => Autodocodec.Class.HasCodec (Hasura.Backends.Postgres.Connection.Settings.PGClientCerts p a)
instance Autodocodec.Class.HasCodec Hasura.Backends.Postgres.Connection.Settings.PostgresConnConfiguration
instance Autodocodec.Class.HasCodec Hasura.Backends.Postgres.Connection.Settings.PostgresConnectionSet
instance Autodocodec.Class.HasCodec Hasura.Backends.Postgres.Connection.Settings.PostgresPoolSettings
instance Autodocodec.Class.HasCodec Hasura.Backends.Postgres.Connection.Settings.PostgresSourceConnInfo
instance Autodocodec.Class.HasCodec Hasura.Backends.Postgres.Connection.Settings.SSLMode
instance Autodocodec.Class.HasCodec Database.PG.Query.Transaction.TxIsolation
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Connection.Settings.CertVar
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Connection.Settings.ConnectionTemplate
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Connection.Settings.KritiTemplate
instance (Data.Hashable.Class.Hashable p, Data.Hashable.Class.Hashable a) => Data.Hashable.Class.Hashable (Hasura.Backends.Postgres.Connection.Settings.PGClientCerts p a)
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Connection.Settings.PostgresConnConfiguration
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Connection.Settings.PostgresConnectionSet
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Connection.Settings.PostgresConnectionSetMember
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Connection.Settings.PostgresConnectionSetMemberName
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Connection.Settings.PostgresPoolSettings
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Connection.Settings.PostgresSourceConnInfo
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Connection.Settings.SSLMode
instance Data.Hashable.Class.Hashable Database.PG.Query.Transaction.TxIsolation
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Connection.Settings.CertVar
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Connection.Settings.ConnectionTemplate
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Connection.Settings.KritiTemplate
instance (Control.DeepSeq.NFData p, Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (Hasura.Backends.Postgres.Connection.Settings.PGClientCerts p a)
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Connection.Settings.PostgresConnConfiguration
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Connection.Settings.PostgresConnectionSet
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Connection.Settings.PostgresConnectionSetMember
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Connection.Settings.PostgresConnectionSetMemberName
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Connection.Settings.PostgresPoolSettings
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Connection.Settings.PostgresSourceConnInfo
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Connection.Settings.SSLMode
instance Control.DeepSeq.NFData Database.PG.Query.Transaction.TxIsolation
instance GHC.Classes.Ord Hasura.Backends.Postgres.Connection.Settings.PostgresConnectionSetMemberName
instance GHC.Classes.Ord Hasura.Backends.Postgres.Connection.Settings.SSLMode
instance GHC.Internal.Base.Semigroup Hasura.Backends.Postgres.Connection.Settings.PostgresConnectionSet
instance GHC.Internal.Base.Semigroup Hasura.Backends.Postgres.Connection.Settings.SSLMode
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Connection.Settings.CertData
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Connection.Settings.CertVar
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Connection.Settings.ConnectionTemplate
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Connection.Settings.DefaultPostgresPoolSettings
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Connection.Settings.KritiTemplate
instance (GHC.Internal.Show.Show a, GHC.Internal.Show.Show p) => GHC.Internal.Show.Show (Hasura.Backends.Postgres.Connection.Settings.PGClientCerts p a)
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Connection.Settings.PostgresConnConfiguration
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Connection.Settings.PostgresConnectionSet
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Connection.Settings.PostgresConnectionSetMember
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Connection.Settings.PostgresConnectionSetMemberName
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Connection.Settings.PostgresPoolSettings
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Connection.Settings.PostgresSourceConnInfo
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Connection.Settings.SSLMode
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Connection.Settings.CertData
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Connection.Settings.CertVar
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Connection.Settings.ConnectionTemplate
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Connection.Settings.KritiTemplate
instance (Data.Aeson.Types.ToJSON.ToJSON p, Data.Aeson.Types.ToJSON.ToJSON a) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Backends.Postgres.Connection.Settings.PGClientCerts p a)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Connection.Settings.PostgresConnConfiguration
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Connection.Settings.PostgresConnectionSet
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Connection.Settings.PostgresConnectionSetMember
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Connection.Settings.PostgresConnectionSetMemberName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Connection.Settings.PostgresPoolSettings
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Connection.Settings.PostgresSourceConnInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Connection.Settings.SSLMode
instance Data.Aeson.Types.ToJSON.ToJSON Database.PG.Query.Transaction.TxIsolation
instance Data.Text.Extended.ToTxt Hasura.Backends.Postgres.Connection.Settings.PostgresConnectionSetMemberName
instance GHC.Internal.Data.Traversable.Traversable (Hasura.Backends.Postgres.Connection.Settings.PGClientCerts p)

module Hasura.RQL.Types.Backend

-- | Mapping from abstract types to concrete backend representation
--   
--   The RQL IR, used as the output of GraphQL parsers and of the RQL
--   parsers, is backend-agnostic: it uses an abstract representation of
--   the structure of a query, and delegates to the backends the task of
--   choosing an appropriate concrete representation.
--   
--   Additionally, grouping all those types under one typeclass rather than
--   having dedicated type families allows to explicitly list all typeclass
--   requirements, which simplifies the instance declarations of all IR
--   types.
--   
--   There are no injectivity requirements on those type families: it's
--   okay for two different backends to use the same types. That means,
--   however, that functions cannot identify to what backend b a given
--   <tt>TableName b</tt> refers to; most generic functions will need
--   either a type application or a <tt>Proxy</tt> parameter to
--   disambiguate between different backends at the call site.
class (HasSourceConfiguration b, Representable BasicOrderType b, Representable Column b, Representable ColumnPath b, Representable ComputedFieldDefinition b, Representable ComputedFieldImplicitArguments b, Representable ComputedFieldReturn b, Representable ConstraintName b, Representable ExtraTableMetadata b, Representable FunctionArgument b, Representable FunctionName b, Representable FunctionReturnType b, Representable HealthCheckTest b, Representable NullsOrderType b, Representable SQLExpression b, Representable ScalarSelectionArguments b, Representable ScalarType b, Representable XComputedField b, Representable XGroupBy b, Representable TableName b, Eq RawFunctionInfo b, Show RawFunctionInfo b, Representable ResolvedConnectionTemplate b, Ord TableName b, Ord FunctionName b, Ord ScalarType b, Ord Column b, Ord ColumnPath b, Ord ComputedFieldReturn b, Ord ComputedFieldImplicitArguments b, Ord ConstraintName b, Ord FunctionArgument b, Ord XComputedField b, Data TableName b, From Column b ColumnPath b, FromJSON BackendConfig b, FromJSON Column b, FromJSON ColumnPath b, FromJSON ColumnPath b, FromJSON ComputedFieldDefinition b, FromJSON ConnectionTemplateRequestContext b, FromJSON ConstraintName b, FromJSON ExtraTableMetadata b, FromJSON FunctionName b, FromJSON FunctionReturnType b, FromJSON HealthCheckTest b, FromJSON RawFunctionInfo b, FromJSON ScalarType b, FromJSON TableName b, FromJSONKey Column b, FromJSONKey ColumnPath b, FromJSONKey ConstraintName b, HasCodec BackendConfig b, HasCodec BackendSourceKind b, HasCodec Column b, HasCodec ColumnPath b, HasCodec ComputedFieldDefinition b, HasCodec FunctionName b, HasCodec FunctionReturnType b, HasCodec ScalarType b, HasCodec TableName b, Hashable Column b, Hashable ColumnPath b, ToJSON BackendConfig b, ToJSON Column b, ToJSON ColumnPath b, ToJSON ConstraintName b, ToJSON ExecutionStatistics b, ToJSON FunctionArgument b, ToJSON FunctionName b, ToJSON FunctionReturnType b, ToJSON RawFunctionInfo b, ToJSON ScalarType b, ToJSON TableName b, ToJSON ExtraTableMetadata b, ToJSON SQLExpression b, ToJSON ComputedFieldDefinition b, ToJSON ComputedFieldImplicitArguments b, ToJSON ComputedFieldReturn b, ToJSON HealthCheckTest b, ToJSON ResolvedConnectionTemplate b, ToJSONKey Column b, ToJSONKey ColumnPath b, ToJSONKey ConstraintName b, ToJSONKey ScalarType b, ToTxt Column b, ToTxt FunctionName b, ToTxt ScalarType b, ToTxt TableName b, ToTxt ConstraintName b, ToErrorValue Column b, ToErrorValue TableName b, Typeable Column b, Typeable ColumnPath b, Typeable b, HasTag b, Traversable CountType b, Traversable FunctionArgumentExp b, Eq BackendConfig b, Show BackendConfig b, Eq BackendInfo b, Show BackendInfo b, Monoid BackendInfo b, Eq ScalarValue b, Show ScalarValue b, Eq XNodesAgg b, Show XNodesAgg b, Eq XRelay b, Show XRelay b, Eq XStreamingSubscription b, Show XStreamingSubscription b, Eq XNestedObjects b, Ord XNestedObjects b, Show XNestedObjects b, NFData XNestedObjects b, Hashable XNestedObjects b, ToJSON XNestedObjects b, FromJSON XNestedObjects b, ToTxt XNestedObjects b, Traversable BooleanOperators b, Traversable UpdateVariant b, Traversable BackendInsert b, Traversable AggregationPredicates b, LiftedConstraint Eq FunctionArgumentExp b, LiftedConstraint Eq AggregationPredicates b, LiftedConstraint Eq BooleanOperators b, LiftedConstraint Eq CountType b, LiftedConstraint Show CountType b, LiftedConstraint Show BooleanOperators b, LiftedConstraint NFData BooleanOperators b, LiftedConstraint Hashable BooleanOperators b, ComposeConstraint ToJSONKeyValue ToJSON BooleanOperators b, LiftedConstraint Show FunctionArgumentExp b, LiftedConstraint NFData FunctionArgumentExp b, LiftedConstraint Hashable FunctionArgumentExp b, LiftedConstraint Show AggregationPredicates b, LiftedConstraint NFData AggregationPredicates b, LiftedConstraint Hashable AggregationPredicates b, ComposeConstraint ToJSONKeyValue ToJSON AggregationPredicates b, LiftedConstraint Eq UpdateVariant b, LiftedConstraint Show UpdateVariant b) => Backend (b :: BackendType) where {
    
    -- | Backend configuration stored in metadata
    type BackendConfig (b :: BackendType);
    
    -- | Runtime backend info derived from (possibly enriched) BackendConfig
    --   and stored in SchemaCache
    type BackendInfo (b :: BackendType);
    type TableName (b :: BackendType);
    type FunctionName (b :: BackendType);
    type FunctionReturnType (b :: BackendType);
    type RawFunctionInfo (b :: BackendType);
    type ConstraintName (b :: BackendType);
    type BasicOrderType (b :: BackendType);
    type NullsOrderType (b :: BackendType);
    
    -- | The type that captures how count aggregations are modelled
    --   
    --   It is parameterised over the type of fields, which changes during the
    --   IR translation phases.
    type CountType (b :: BackendType) :: Type -> Type;
    type Column (b :: BackendType);
    type ColumnPath (b :: BackendType);
    type ScalarValue (b :: BackendType);
    type ScalarType (b :: BackendType);
    type SQLExpression (b :: BackendType);
    type ComputedFieldDefinition (b :: BackendType);
    
    -- | Arguments of a scalar field's selection { query { some_table { # a
    --   scalar field column(ScalarSelectionArguments) } } }
    type ScalarSelectionArguments (b :: BackendType);
    type ExtraTableMetadata (b :: BackendType);
    
    -- | FunctionArgument
    type FunctionArgument (b :: BackendType);
    
    -- | Function input argument expression
    --   
    --   It is parameterised over the type of fields, which changes during the
    --   IR translation phases.
    type FunctionArgumentExp (b :: BackendType) :: Type -> Type;
    
    -- | Computed field function argument values which are being implicitly
    --   inferred from table and/or session information
    type ComputedFieldImplicitArguments (b :: BackendType);
    
    -- | Computed field return information
    type ComputedFieldReturn (b :: BackendType);
    
    -- | A config type for health check tests
    type HealthCheckTest (b :: BackendType);
    
    -- | Intermediate Representation of extensions to the shared set of boolean
    --   operators on table fields.
    --   
    --   It is parameterised over the type of fields, which changes during the
    --   IR translation phases.
    type BooleanOperators (b :: BackendType) :: Type -> Type;
    
    -- | Intermediate Representation of aggregation predicates. The default
    --   implementation makes aggregation predicates uninstantiable.
    --   
    --   It is parameterised over the type of fields, which changes during the
    --   IR translation phases.
    type AggregationPredicates (b :: BackendType) :: Type -> Type;
    
    -- | The different variants of update supported by a backend for their
    --   intermediate representation. For example, a backend could use a sum
    --   type encapsulating either a single batch update or multiple batch
    --   updates.
    --   
    --   The default implementation makes update expressions uninstantiable.
    --   
    --   It is parameterised over the type of fields, which changes during the
    --   IR translation phases.
    type UpdateVariant (b :: BackendType) :: Type -> Type;
    
    -- | Intermediate Representation of Insert Mutations. The default
    --   implementation makes insert expressions uninstantiable.
    --   
    --   It is parameterised over the type of fields, which changes during the
    --   IR translation phases.
    type BackendInsert (b :: BackendType) :: Type -> Type;
    type XComputedField (b :: BackendType);
    type XRelay (b :: BackendType);
    type XNodesAgg (b :: BackendType);
    
    -- | Flag the availability of event triggers.
    type XEventTriggers (b :: BackendType);
    
    -- | Extension to flag the availability of object and array relationships
    --   in inserts (aka nested inserts).
    type XNestedInserts (b :: BackendType);
    type XStreamingSubscription (b :: BackendType);
    type XNestedObjects (b :: BackendType);
    type XGroupBy (b :: BackendType);
    type ResolvedConnectionTemplate (b :: BackendType);
    type ConnectionTemplateRequestContext (b :: BackendType);
    
    -- | Information about the query execution that may be useful for debugging
    --   or reporting.
    type ExecutionStatistics (b :: BackendType);
    type FunctionReturnType b :: BackendType = XDisable;
    type AggregationPredicates b :: BackendType = Const Void :: Type -> Type;
    type UpdateVariant b :: BackendType = Const Void :: Type -> Type;
    type BackendInsert b :: BackendType = Const Void :: Type -> Type;
    type XNestedObjects b :: BackendType = XDisable;
    type XGroupBy b :: BackendType = XDisable;
    type ResolvedConnectionTemplate b :: BackendType = ();
    type ConnectionTemplateRequestContext b :: BackendType = ();
    type ExecutionStatistics b :: BackendType = ();
}

-- | A backend type can opt into supporting health checks by providing an
--   implementation that includes a default health check test, and a health
--   check test codec.
healthCheckImplementation :: Backend b => Maybe (HealthCheckImplementation (HealthCheckTest b))

-- | An Implementation for version checking when adding a source.
versionCheckImplementation :: Backend b => Environment -> SourceName -> SourceConnConfiguration b -> IO (Either QErr ())

-- | A backend type can opt into providing an implementation for
--   fingerprinted pings to the source, useful for attribution that the
--   user is using Hasura
runPingSource :: Backend b => Environment -> (String -> IO ()) -> SourceName -> SourceConnConfiguration b -> IO ()
resolveConnectionTemplate :: Backend b => SourceConfig b -> ConnectionTemplateRequestContext b -> Maybe ConnectionTemplate -> Either QErr EncJSON
isComparableType :: Backend b => ScalarType b -> Bool
isNumType :: Backend b => ScalarType b -> Bool

-- | Custom aggregate operators supported by the backend. Backends that
--   support custom aggregate operators should return a HashMap from
--   operator name to a scalar type mapping. In the scalar type mapping the
--   key represents the input type for the operator and the value
--   represents the result type. Backends that do not support custom
--   aggregate operators can use the default implementation which returns
--   an empty map.
getCustomAggregateOperators :: Backend b => SourceConfig b -> HashMap Name (HashMap (ScalarType b) (ScalarType b))
textToScalarValue :: Backend b => Maybe Text -> ScalarValue b
parseScalarValue :: Backend b => ScalarTypeParsingContext b -> ScalarType b -> Value -> Either QErr (ScalarValue b)
scalarValueToJSON :: Backend b => ScalarValue b -> Value
functionToTable :: Backend b => FunctionName b -> TableName b
tableToFunction :: Backend b => TableName b -> FunctionName b
computedFieldFunction :: Backend b => ComputedFieldDefinition b -> FunctionName b
computedFieldReturnType :: Backend b => ComputedFieldReturn b -> ComputedFieldReturnType b

-- | Backends that don't support aggregate computed fields will never
--   encounter an <a>SelectionField</a>. However, backends are expected to
--   provide a total transformation from <tt>SelectionField</tt> to the
--   backend's query language.
--   
--   Rather than implement error handling for every backend that doesn't
--   support aggregate computed fields, and then remove that error handling
--   for each backend when we <i>add</i> support - honestly, adding error
--   handling would probably take longer than adding aggregate computed
--   field support - we instead have a flag.
--   
--   If a backend declares this flag as <a>False</a>, computed fields will
--   not be added to the GraphQL schema. This means that backends can
--   safely handle <tt>SFComputedField</tt> with a runtime exception <i>as
--   long as</i> this flag is <a>False</a>.
--   
--   Once all backends support all aggregate computed field operations,
--   this flag can be deleted.
supportsAggregateComputedFields :: Backend b => Bool

-- | Build function arguments expression from computed field implicit
--   arguments
fromComputedFieldImplicitArguments :: Backend b => v -> ComputedFieldImplicitArguments b -> [FunctionArgumentExp b v]
tableGraphQLName :: Backend b => TableName b -> Either QErr Name
functionGraphQLName :: Backend b => FunctionName b -> Either QErr Name
getTableIdentifier :: Backend b => TableName b -> Either QErr GQLNameIdentifier
snakeCaseTableName :: Backend b => TableName b -> Text
namingConventionSupport :: Backend b => SupportedNamingCase
resizeSourcePools :: Backend b => SourceConfig b -> ServerReplicas -> IO SourceResizePoolSummary

-- | Default behaviour of SQL triggers on logically replicated database.
--   Setting this to <tt>Nothing</tt> will disable event trigger
--   configuration in the metadata.
defaultTriggerOnReplication :: Backend b => Maybe (XEventTriggers b, TriggerOnReplication)

-- | Get values from a column in a table with some filters. This function
--   is used in evaluating remote relationship predicate in permissions
--   
--   TODO (paritosh): This function should return a JSON array of column
--   values. We shouldn't have to parse the column values as Text. The
--   database's JSON serialize/deserialize can take care of correct casting
--   of values (GS-642).
getColVals :: (Backend b, MonadIO m, MonadError QErr m) => SessionVariables -> SourceName -> SourceConfig b -> TableName b -> (ScalarType b, Column b) -> (Column b, [RemoteRelSupportedOp RemoteRelSessionVariableORLiteralValue]) -> m [Text]

-- | Get the top-level column from a ColumnPath For backends that don't
--   support nested objects (i.e. where ColumnPath b = Column b) this will
--   be <a>id</a>.
getColumnPathColumn :: Backend b => ColumnPath b -> Column b

-- | Convert a singleton ColumnPath to a Column Should return Nothing for
--   paths to nested fields
tryColumnPathToColumn :: Backend b => ColumnPath b -> Maybe (Column b)
backendSupportsNestedObjects :: Backend b => Either QErr (XNestedObjects b)
($dmbackendSupportsNestedObjects) :: (Backend b, XNestedObjects b ~ XDisable) => Either QErr (XNestedObjects b)
sourceSupportsSchemalessTables :: Backend b => SourceConfig b -> Bool
getAggregationPredicatesModels :: (Backend b, MonadState [ModelNameInfo] m) => SourceName -> ModelSourceType -> AggregationPredicates b a -> m ()
type SessionVarType (b :: BackendType) = CollectableType ScalarType b
type XDisable = Void
type XEnable = ()
data ComputedFieldReturnType (b :: BackendType)
ReturnsScalar :: ScalarType b -> ComputedFieldReturnType (b :: BackendType)
ReturnsTable :: TableName b -> ComputedFieldReturnType (b :: BackendType)
ReturnsOthers :: ComputedFieldReturnType (b :: BackendType)
_ReturnsTable :: forall (b :: BackendType) p f. (Choice p, Applicative f) => p (TableName b) (f (TableName b)) -> p (ComputedFieldReturnType b) (f (ComputedFieldReturnType b))

-- | Used for keeping track of the extent of support of naming convention
--   across different backends.
--   
--   <tt>AllConventions</tt> implies a full support whereas
--   <tt>OnlyHasuraCase</tt> implies a partial support of only
--   <tt>HasuraCase</tt>
data SupportedNamingCase
OnlyHasuraCase :: SupportedNamingCase
AllConventions :: SupportedNamingCase
class (Representable SourceConnConfiguration b, HasCodec SourceConnConfiguration b, FromJSON SourceConnConfiguration b, Show SourceConfig b, ToJSON SourceConfig b, ToJSON SourceConnConfiguration b, Eq SourceConfig b, Has ScalarTypeParsingContext b SourceConfig b, Eq ScalarTypeParsingContext b, Ord ScalarTypeParsingContext b, HasTag b) => HasSourceConfiguration (b :: BackendType) where {
    type ScalarTypeParsingContext (b :: BackendType);
    
    -- | User facing connection configuration for a database.
    type SourceConnConfiguration (b :: BackendType);
    
    -- | Internal connection configuration for a database - connection string,
    --   connection pool etc
    type SourceConfig (b :: BackendType);
    type ScalarTypeParsingContext b :: BackendType = ();
}

-- | The number of read replicas specified in the source configuration
sourceConfigNumReadReplicas :: HasSourceConfiguration b => SourceConfig b -> Int

-- | The connection template specified in the source configuration, if any
sourceConfigConnectonTemplate :: HasSourceConfiguration b => SourceConfig b -> Maybe ValueExt

-- | Whether or not the source supports performing column redaction. See
--   note [SQL generation for inherited roles] for more information
sourceSupportsColumnRedaction :: HasSourceConfiguration b => SourceConfig b -> Bool
sourceConfigBackendSourceKind :: HasSourceConfiguration b => SourceConfig b -> BackendSourceKind b
type Representable a = (Show a, Eq a, Hashable a, NFData a)

module Hasura.RQL.Types.SourceCustomization
data SourceTypeCustomization
data RootFieldsCustomization
RootFieldsCustomization :: Maybe Name -> Maybe Name -> Maybe Name -> RootFieldsCustomization
[_rootfcNamespace] :: RootFieldsCustomization -> Maybe Name
[_rootfcPrefix] :: RootFieldsCustomization -> Maybe Name
[_rootfcSuffix] :: RootFieldsCustomization -> Maybe Name
mkCustomizedTypename :: Maybe SourceTypeCustomization -> NamingCase -> MkTypename
emptySourceCustomization :: SourceCustomization
emptySourceTypeCustomization :: SourceTypeCustomization
getSourceTypeCustomization :: SourceCustomization -> SourceTypeCustomization

-- | Source customization information as it appears in the metadata.
data SourceCustomization
SourceCustomization :: Maybe RootFieldsCustomization -> Maybe SourceTypeCustomization -> Maybe NamingCase -> SourceCustomization
[_scRootFields] :: SourceCustomization -> Maybe RootFieldsCustomization
[_scTypeNames] :: SourceCustomization -> Maybe SourceTypeCustomization
[_scNamingConvention] :: SourceCustomization -> Maybe NamingCase

-- | Source customization as it appears in the SchemaCache.
data ResolvedSourceCustomization
ResolvedSourceCustomization :: MkRootFieldName -> MkTypename -> NamingCase -> Maybe Name -> ResolvedSourceCustomization
[_rscRootFields] :: ResolvedSourceCustomization -> MkRootFieldName
[_rscTypeNames] :: ResolvedSourceCustomization -> MkTypename
[_rscNamingConvention] :: ResolvedSourceCustomization -> NamingCase
[_rscRootNamespace] :: ResolvedSourceCustomization -> Maybe Name
mkResolvedSourceCustomization :: SourceCustomization -> NamingCase -> ResolvedSourceCustomization

-- | Function to apply root field name customizations.
newtype MkRootFieldName
MkRootFieldName :: (Name -> Name) -> MkRootFieldName
[runMkRootFieldName] :: MkRootFieldName -> Name -> Name
applyEnumValueCase :: NamingCase -> Name -> Name

-- | apply naming convention to field name
applyFieldNameCaseCust :: NamingCase -> Name -> Name

-- | apply naming convention to type name
applyTypeNameCaseCust :: NamingCase -> Name -> Name

-- | applies naming convention and returns type name
--   
--   Note: This can't possibly fail as <tt>GQLNameIdentifier</tt> contains
--   already validated identifiers
applyFieldNameCaseIdentifier :: NamingCase -> GQLNameIdentifier -> Name

-- | applies naming convention and returns field name
--   
--   Note: This can't possibly fail as <tt>GQLNameIdentifier</tt> contains
--   already validated identifiers
applyTypeNameCaseIdentifier :: NamingCase -> GQLNameIdentifier -> Name
getNamingCase :: MonadError QErr m => SourceCustomization -> SupportedNamingCase -> NamingCase -> m NamingCase

-- | returns field name according to the naming conventions as
--   <tt>Text</tt>
getTextFieldName :: NamingCase -> GQLNameIdentifier -> Text

-- | returns type name according to the naming conventions as <tt>Text</tt>
getTextTypeName :: NamingCase -> GQLNameIdentifier -> Text
mkSelectField :: GQLNameIdentifier -> GQLNameIdentifier
mkSelectAggregateField :: GQLNameIdentifier -> GQLNameIdentifier
mkSelectByPkField :: GQLNameIdentifier -> GQLNameIdentifier
mkSelectStreamField :: GQLNameIdentifier -> GQLNameIdentifier
mkInsertField :: GQLNameIdentifier -> GQLNameIdentifier
mkInsertOneField :: GQLNameIdentifier -> GQLNameIdentifier
mkUpdateField :: GQLNameIdentifier -> GQLNameIdentifier
mkUpdateByPkField :: GQLNameIdentifier -> GQLNameIdentifier
mkUpdateManyField :: GQLNameIdentifier -> GQLNameIdentifier
mkDeleteField :: GQLNameIdentifier -> GQLNameIdentifier
mkDeleteByPkField :: GQLNameIdentifier -> GQLNameIdentifier
mkRelayConnectionField :: GQLNameIdentifier -> GQLNameIdentifier
mkRelationFunctionArgumentsFieldName :: GQLNameIdentifier -> Name -> GQLNameIdentifier
mkMultiRowUpdateTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkOnConflictTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkTableConstraintTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkTableAggregateTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkFunctionArgsTypeName :: Name -> GQLNameIdentifier -> GQLNameIdentifier
mkTableBoolExpTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkTableTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkTableInsertInputTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkTableObjRelInsertInputTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkTableArrRelInsertInputTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkTableMutationResponseTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkTableOrderByTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkTableAggregateOrderByTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkTableAggregateOrderByOpTypeName :: GQLNameIdentifier -> GQLNameIdentifier -> GQLNameIdentifier
mkTableAggregateFieldTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkTableAggOperatorTypeName :: GQLNameIdentifier -> GQLNameIdentifier -> GQLNameIdentifier
mkTableSelectColumnTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkTableUpdateColumnTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkTableOperatorInputTypeName :: GQLNameIdentifier -> GQLNameIdentifier -> GQLNameIdentifier
mkTablePkColumnsInputTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkEnumTableTypeName :: GQLNameIdentifier -> Maybe Name -> GQLNameIdentifier
mkStreamCursorInputTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkStreamCursorValueInputTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkSelectColumnPredTypeName :: GQLNameIdentifier -> GQLNameIdentifier -> GQLNameIdentifier
mkTableAggregateBoolExpTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkGroupByTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkGroupByKeyTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkGroupByKeyFieldsTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkRelationFunctionIdentifier :: GQLNameIdentifier -> Name -> GQLNameIdentifier
updateColumnsFieldName :: GQLNameIdentifier
affectedRowsFieldName :: GQLNameIdentifier
pkColumnsFieldName :: GQLNameIdentifier
instance GHC.Classes.Eq Hasura.RQL.Types.SourceCustomization.RootFieldsCustomization
instance GHC.Classes.Eq Hasura.RQL.Types.SourceCustomization.SourceCustomization
instance GHC.Classes.Eq Hasura.RQL.Types.SourceCustomization.SourceTypeCustomization
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.SourceCustomization.RootFieldsCustomization
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.SourceCustomization.SourceCustomization
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.SourceCustomization.SourceTypeCustomization
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.SourceCustomization.RootFieldsCustomization
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.SourceCustomization.SourceCustomization
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.SourceCustomization.SourceTypeCustomization
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.SourceCustomization.RootFieldsCustomization
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.SourceCustomization.SourceCustomization
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.SourceCustomization.SourceTypeCustomization
instance GHC.Internal.Base.Monoid Hasura.RQL.Types.SourceCustomization.MkRootFieldName
instance GHC.Internal.Base.Semigroup Hasura.RQL.Types.SourceCustomization.MkRootFieldName
instance GHC.Internal.Show.Show Hasura.RQL.Types.SourceCustomization.RootFieldsCustomization
instance GHC.Internal.Show.Show Hasura.RQL.Types.SourceCustomization.SourceCustomization
instance GHC.Internal.Show.Show Hasura.RQL.Types.SourceCustomization.SourceTypeCustomization
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.SourceCustomization.RootFieldsCustomization
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.SourceCustomization.SourceCustomization
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.SourceCustomization.SourceTypeCustomization

module Hasura.RQL.Types.Relationships.ToSource

-- | Metadata representation of a "remote" relationship targetting a
--   source.
--   
--   This representation has to be backend-agnostic, as it will be parsed
--   before the source cache is built, meaning we can't decide how
--   something backend specific should be resolved based solely on the
--   source name. But the table name is specific to the targeted backend...
--   There are two solutions to this problem: - we can either include an
--   additional field in the serialization that tells us the "kind" of the
--   backend; but that requies an additional field that is technically not
--   required, and that could potentially be inconsistent - or we can do
--   the same thing that we do for source to source relationships: we store
--   an unparsed JSON value as far as the metadata goes, and we parse it
--   when building the schema cache, when we know the kind of the source
--   from its name We chose the latter.
--   
--   Furthermore, the mapping is represented using a backend-agnostic
--   <a>FieldName</a>, whose interpretation is likewise delayed until the
--   schema cache is built.
--   
--   FIXME: move this to Hasura/Metadata
data ToSourceRelationshipDef
ToSourceRelationshipDef :: RelType -> HashMap FieldName FieldName -> SourceName -> Value -> ToSourceRelationshipDef
[_tsrdRelationshipType] :: ToSourceRelationshipDef -> RelType
[_tsrdFieldMapping] :: ToSourceRelationshipDef -> HashMap FieldName FieldName
[_tsrdSource] :: ToSourceRelationshipDef -> SourceName
[_tsrdTable] :: ToSourceRelationshipDef -> Value
tsrdFieldMapping :: Lens' ToSourceRelationshipDef (HashMap FieldName FieldName)
tsrdRelationshipType :: Lens' ToSourceRelationshipDef RelType
tsrdSource :: Lens' ToSourceRelationshipDef SourceName
tsrdTable :: Lens' ToSourceRelationshipDef Value

-- | Schema cache information for a table field targeting a remote source.
data RemoteSourceFieldInfo (tgt :: BackendType)
RemoteSourceFieldInfo :: RelName -> RelType -> SourceName -> SourceConfig tgt -> TableName tgt -> HashMap FieldName (ScalarType tgt, Column tgt) -> RemoteSourceFieldInfo (tgt :: BackendType)
[_rsfiName] :: RemoteSourceFieldInfo (tgt :: BackendType) -> RelName
[_rsfiType] :: RemoteSourceFieldInfo (tgt :: BackendType) -> RelType
[_rsfiSource] :: RemoteSourceFieldInfo (tgt :: BackendType) -> SourceName
[_rsfiSourceConfig] :: RemoteSourceFieldInfo (tgt :: BackendType) -> SourceConfig tgt

-- | this is parsed from <a>Value</a>
[_rsfiTable] :: RemoteSourceFieldInfo (tgt :: BackendType) -> TableName tgt

-- | LHS field name -&gt; RHS Column, RHS Column type
[_rsfiMapping] :: RemoteSourceFieldInfo (tgt :: BackendType) -> HashMap FieldName (ScalarType tgt, Column tgt)
instance Hasura.RQL.Types.Backend.Backend tgt => GHC.Classes.Eq (Hasura.RQL.Types.Relationships.ToSource.RemoteSourceFieldInfo tgt)
instance GHC.Classes.Eq Hasura.RQL.Types.Relationships.ToSource.ToSourceRelationshipDef
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Relationships.ToSource.ToSourceRelationshipDef
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Relationships.ToSource.RemoteSourceFieldInfo tgt)
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Relationships.ToSource.ToSourceRelationshipDef
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Relationships.ToSource.ToSourceRelationshipDef
instance Control.DeepSeq.NFData Hasura.RQL.Types.Relationships.ToSource.ToSourceRelationshipDef
instance GHC.Internal.Show.Show Hasura.RQL.Types.Relationships.ToSource.ToSourceRelationshipDef
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Relationships.ToSource.ToSourceRelationshipDef

module Hasura.RQL.Types.HealthCheck
data HealthCheckConfig (b :: BackendType)
HealthCheckConfig :: HealthCheckTest b -> HealthCheckInterval -> HealthCheckRetries -> HealthCheckRetryInterval -> HealthCheckTimeout -> HealthCheckConfig (b :: BackendType)
[_hccTest] :: HealthCheckConfig (b :: BackendType) -> HealthCheckTest b
[_hccInterval] :: HealthCheckConfig (b :: BackendType) -> HealthCheckInterval
[_hccRetries] :: HealthCheckConfig (b :: BackendType) -> HealthCheckRetries
[_hccRetryInterval] :: HealthCheckConfig (b :: BackendType) -> HealthCheckRetryInterval
[_hccTimeout] :: HealthCheckConfig (b :: BackendType) -> HealthCheckTimeout
newtype HealthCheckTestSql
HealthCheckTestSql :: Text -> HealthCheckTestSql
[_hctSql] :: HealthCheckTestSql -> Text
newtype HealthCheckInterval
HealthCheckInterval :: Seconds -> HealthCheckInterval
[unHealthCheckInterval] :: HealthCheckInterval -> Seconds
newtype HealthCheckRetries
HealthCheckRetries :: Int -> HealthCheckRetries
[unHealthCheckRetries] :: HealthCheckRetries -> Int
newtype HealthCheckRetryInterval
HealthCheckRetryInterval :: Seconds -> HealthCheckRetryInterval
[unHealthCheckRetryInterval] :: HealthCheckRetryInterval -> Seconds
newtype HealthCheckTimeout
HealthCheckTimeout :: Seconds -> HealthCheckTimeout
[unHealthCheckTimeout] :: HealthCheckTimeout -> Seconds
defaultHealthCheckTestSql :: HealthCheckTestSql
healthCheckConfigCodec :: forall (b :: BackendType). Backend b => HealthCheckImplementation (HealthCheckTest b) -> JSONCodec (HealthCheckConfig b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.HealthCheck.HealthCheckConfig b)
instance GHC.Classes.Eq Hasura.RQL.Types.HealthCheck.HealthCheckInterval
instance GHC.Classes.Eq Hasura.RQL.Types.HealthCheck.HealthCheckRetries
instance GHC.Classes.Eq Hasura.RQL.Types.HealthCheck.HealthCheckRetryInterval
instance GHC.Classes.Eq Hasura.RQL.Types.HealthCheck.HealthCheckTestSql
instance GHC.Classes.Eq Hasura.RQL.Types.HealthCheck.HealthCheckTimeout
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.HealthCheck.HealthCheckConfig b)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.HealthCheck.HealthCheckInterval
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.HealthCheck.HealthCheckRetries
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.HealthCheck.HealthCheckRetryInterval
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.HealthCheck.HealthCheckTestSql
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.HealthCheck.HealthCheckTimeout
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.HealthCheck.HealthCheckConfig b)
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.HealthCheck.HealthCheckInterval
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.HealthCheck.HealthCheckRetries
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.HealthCheck.HealthCheckRetryInterval
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.HealthCheck.HealthCheckTestSql
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.HealthCheck.HealthCheckTimeout
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.HealthCheck.HealthCheckInterval
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.HealthCheck.HealthCheckRetries
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.HealthCheck.HealthCheckRetryInterval
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.HealthCheck.HealthCheckTestSql
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.HealthCheck.HealthCheckTimeout
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.HealthCheck.HealthCheckTestSql
instance Control.DeepSeq.NFData Hasura.RQL.Types.HealthCheck.HealthCheckTestSql
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.Types.HealthCheck.HealthCheckConfig b)
instance GHC.Internal.Show.Show Hasura.RQL.Types.HealthCheck.HealthCheckInterval
instance GHC.Internal.Show.Show Hasura.RQL.Types.HealthCheck.HealthCheckRetries
instance GHC.Internal.Show.Show Hasura.RQL.Types.HealthCheck.HealthCheckRetryInterval
instance GHC.Internal.Show.Show Hasura.RQL.Types.HealthCheck.HealthCheckTestSql
instance GHC.Internal.Show.Show Hasura.RQL.Types.HealthCheck.HealthCheckTimeout
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.HealthCheck.HealthCheckConfig b)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.HealthCheck.HealthCheckInterval
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.HealthCheck.HealthCheckRetries
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.HealthCheck.HealthCheckRetryInterval
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.HealthCheck.HealthCheckTestSql
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.HealthCheck.HealthCheckTimeout

module Hasura.RQL.Types.EventTrigger
data SubscribeOpSpec (b :: BackendType)
SubscribeOpSpec :: SubscribeColumns b -> Maybe (SubscribeColumns b) -> SubscribeOpSpec (b :: BackendType)

-- | Columns of the table that user can subscribe to listen for changes.
[sosColumns] :: SubscribeOpSpec (b :: BackendType) -> SubscribeColumns b

-- | Columns that the event trigger payload should consists. If set, only
--   those columns will be visible in the payload. By default, the payload
--   consists of all the columns of the table.
[sosPayload] :: SubscribeOpSpec (b :: BackendType) -> Maybe (SubscribeColumns b)
data SubscribeColumns (b :: BackendType)
SubCStar :: SubscribeColumns (b :: BackendType)
SubCArray :: [Column b] -> SubscribeColumns (b :: BackendType)

-- | Unique name for event trigger.
newtype TriggerName
TriggerName :: NonEmptyText -> TriggerName
[unTriggerName] :: TriggerName -> NonEmptyText
triggerNameToTxt :: TriggerName -> Text
data Ops
INSERT :: Ops
UPDATE :: Ops
DELETE :: Ops
MANUAL :: Ops

-- | The table operations on which the event trigger will be invoked.
data TriggerOpsDef (b :: BackendType)
TriggerOpsDef :: Maybe (SubscribeOpSpec b) -> Maybe (SubscribeOpSpec b) -> Maybe (SubscribeOpSpec b) -> Maybe Bool -> TriggerOpsDef (b :: BackendType)
[tdInsert] :: TriggerOpsDef (b :: BackendType) -> Maybe (SubscribeOpSpec b)
[tdUpdate] :: TriggerOpsDef (b :: BackendType) -> Maybe (SubscribeOpSpec b)
[tdDelete] :: TriggerOpsDef (b :: BackendType) -> Maybe (SubscribeOpSpec b)
[tdEnableManual] :: TriggerOpsDef (b :: BackendType) -> Maybe Bool
data EventTriggerConf (b :: BackendType)
EventTriggerConf :: TriggerName -> TriggerOpsDef b -> Maybe InputWebhook -> Maybe Text -> RetryConf -> Maybe [HeaderConf] -> Maybe RequestTransform -> Maybe MetadataResponseTransform -> Maybe AutoTriggerLogCleanupConfig -> TriggerOnReplication -> EventTriggerConf (b :: BackendType)
[etcName] :: EventTriggerConf (b :: BackendType) -> TriggerName
[etcDefinition] :: EventTriggerConf (b :: BackendType) -> TriggerOpsDef b
[etcWebhook] :: EventTriggerConf (b :: BackendType) -> Maybe InputWebhook
[etcWebhookFromEnv] :: EventTriggerConf (b :: BackendType) -> Maybe Text
[etcRetryConf] :: EventTriggerConf (b :: BackendType) -> RetryConf
[etcHeaders] :: EventTriggerConf (b :: BackendType) -> Maybe [HeaderConf]
[etcRequestTransform] :: EventTriggerConf (b :: BackendType) -> Maybe RequestTransform
[etcResponseTransform] :: EventTriggerConf (b :: BackendType) -> Maybe MetadataResponseTransform
[etcCleanupConfig] :: EventTriggerConf (b :: BackendType) -> Maybe AutoTriggerLogCleanupConfig
[etcTriggerOnReplication] :: EventTriggerConf (b :: BackendType) -> TriggerOnReplication
data RetryConf
RetryConf :: Int -> Int -> Maybe Int -> RetryConf
[rcNumRetries] :: RetryConf -> Int
[rcIntervalSec] :: RetryConf -> Int
[rcTimeoutSec] :: RetryConf -> Maybe Int
data EventHeaderInfo
EventHeaderInfo :: HeaderConf -> Text -> EventHeaderInfo
[ehiHeaderConf] :: EventHeaderInfo -> HeaderConf
[ehiCachedValue] :: EventHeaderInfo -> Text
data WebhookConf
WCValue :: InputWebhook -> WebhookConf
WCEnv :: Text -> WebhookConf
data WebhookConfInfo
WebhookConfInfo :: WebhookConf -> EnvRecord ResolvedWebhook -> WebhookConfInfo
[wciWebhookConf] :: WebhookConfInfo -> WebhookConf
[wciCachedValue] :: WebhookConfInfo -> EnvRecord ResolvedWebhook
data HeaderConf
HeaderConf :: HeaderName -> HeaderValue -> HeaderConf
defaultRetryConf :: RetryConf
defaultTimeoutSeconds :: Int
data RecreateEventTriggers
RETRecreate :: RecreateEventTriggers
RETDoNothing :: RecreateEventTriggers

-- | The event payload processed by <tt>processEvent</tt>
data EventWithSource (b :: BackendType)
EventWithSource :: Event b -> SourceConfig b -> SourceName -> UTCTime -> EventWithSource (b :: BackendType)
[_ewsEvent] :: EventWithSource (b :: BackendType) -> Event b
[_ewsSourceConfig] :: EventWithSource (b :: BackendType) -> SourceConfig b
[_ewsSourceName] :: EventWithSource (b :: BackendType) -> SourceName

-- | The <a>UTCTime</a> represents the time when the event was fetched from
--   DB. ^ Used to calculate Event Lock time
[_ewsFetchTime] :: EventWithSource (b :: BackendType) -> UTCTime
data TriggerMetadata
TriggerMetadata :: TriggerName -> TriggerMetadata
[tmName] :: TriggerMetadata -> TriggerName

-- | Change data for a particular row
--   
--   
--   <a>https://docs.hasura.io/1.0/graphql/manual/event-triggers/payload.html</a>
data Event (b :: BackendType)
Event :: EventId -> SourceName -> TableName b -> TriggerMetadata -> Value -> Int -> LocalTime -> Maybe UTCTime -> UTCTime -> Maybe UTCTime -> Event (b :: BackendType)
[eId] :: Event (b :: BackendType) -> EventId
[eSource] :: Event (b :: BackendType) -> SourceName
[eTable] :: Event (b :: BackendType) -> TableName b
[eTrigger] :: Event (b :: BackendType) -> TriggerMetadata
[eEvent] :: Event (b :: BackendType) -> Value
[eTries] :: Event (b :: BackendType) -> Int
[eCreatedAt] :: Event (b :: BackendType) -> LocalTime
[eRetryAt] :: Event (b :: BackendType) -> Maybe UTCTime

-- | The values <a>eCreatedAtUTC</a> and <a>eRetryAtUTC</a> are only used
--   for calculating the <tt>event_processing_time</tt> metric.
[eCreatedAtUTC] :: Event (b :: BackendType) -> UTCTime
[eRetryAtUTC] :: Event (b :: BackendType) -> Maybe UTCTime

-- | There are two types of events: EventType (for event triggers) and
--   ScheduledType (for scheduled triggers)
data TriggerTypes
EventType :: TriggerTypes
ScheduledType :: TriggerTypes
data Invocation (a :: TriggerTypes)
Invocation :: EventId -> Maybe Int -> WebhookRequest -> Response a -> Invocation (a :: TriggerTypes)
[iEventId] :: Invocation (a :: TriggerTypes) -> EventId
[iStatus] :: Invocation (a :: TriggerTypes) -> Maybe Int
[iRequest] :: Invocation (a :: TriggerTypes) -> WebhookRequest
[iResponse] :: Invocation (a :: TriggerTypes) -> Response a
data ProcessEventError
PESetRetry :: UTCTime -> ProcessEventError
PESetError :: ProcessEventError
type EventTriggerInfoMap (b :: BackendType) = HashMap TriggerName EventTriggerInfo b
data EventTriggerInfo (b :: BackendType)
EventTriggerInfo :: TriggerName -> TriggerOpsDef b -> RetryConf -> WebhookConfInfo -> [EventHeaderInfo] -> Maybe RequestTransform -> Maybe MetadataResponseTransform -> Maybe AutoTriggerLogCleanupConfig -> TriggerOnReplication -> EventTriggerInfo (b :: BackendType)
[etiName] :: EventTriggerInfo (b :: BackendType) -> TriggerName
[etiOpsDef] :: EventTriggerInfo (b :: BackendType) -> TriggerOpsDef b
[etiRetryConf] :: EventTriggerInfo (b :: BackendType) -> RetryConf

-- | The HTTP(s) URL which will be called with the event payload on
--   configured operation. Must be a POST handler. This URL can be entered
--   manually or can be picked up from an environment variable (the
--   environment variable needs to be set before using it for this
--   configuration).
[etiWebhookInfo] :: EventTriggerInfo (b :: BackendType) -> WebhookConfInfo

-- | Custom headers can be added to an event trigger. Each webhook request
--   will have these headers added.
[etiHeaders] :: EventTriggerInfo (b :: BackendType) -> [EventHeaderInfo]
[etiRequestTransform] :: EventTriggerInfo (b :: BackendType) -> Maybe RequestTransform
[etiResponseTransform] :: EventTriggerInfo (b :: BackendType) -> Maybe MetadataResponseTransform
[etiCleanupConfig] :: EventTriggerInfo (b :: BackendType) -> Maybe AutoTriggerLogCleanupConfig
[etiTriggerOnReplication] :: EventTriggerInfo (b :: BackendType) -> TriggerOnReplication
newtype FetchBatchSize
FetchBatchSize :: Int -> FetchBatchSize
[_unFetchBatchSize] :: FetchBatchSize -> Int

-- | Automatic event trigger log cleanup configuration
data AutoTriggerLogCleanupConfig
AutoTriggerLogCleanupConfig :: CronSchedule -> Int -> Int -> Int -> Bool -> EventTriggerCleanupStatus -> AutoTriggerLogCleanupConfig

-- | cron schedule for the automatic cleanup
[_atlccSchedule] :: AutoTriggerLogCleanupConfig -> CronSchedule

-- | maximum number of events to be deleted in a single cleanup action
[_atlccBatchSize] :: AutoTriggerLogCleanupConfig -> Int

-- | retention period (in hours) for the event trigger logs
[_atlccClearOlderThan] :: AutoTriggerLogCleanupConfig -> Int

-- | SQL query timeout (in seconds)
[_atlccTimeout] :: AutoTriggerLogCleanupConfig -> Int

-- | should we clean the invocation logs as well
[_atlccCleanInvocationLogs] :: AutoTriggerLogCleanupConfig -> Bool

-- | is the cleanup action paused
[_atlccPaused] :: AutoTriggerLogCleanupConfig -> EventTriggerCleanupStatus

-- | Manual event trigger log cleanup configuration
data TriggerLogCleanupConfig
TriggerLogCleanupConfig :: TriggerName -> SourceName -> Int -> Int -> Int -> Bool -> TriggerLogCleanupConfig

-- | name of the event trigger
[tlccEventTriggerName] :: TriggerLogCleanupConfig -> TriggerName

-- | source of the event trigger
[tlccSourceName] :: TriggerLogCleanupConfig -> SourceName

-- | batch size of for the cleanup action
[tlccBatchSize] :: TriggerLogCleanupConfig -> Int

-- | retention period (in hours) for the event trigger logs
[tlccClearOlderThan] :: TriggerLogCleanupConfig -> Int

-- | SQL query timeout (in seconds)
[tlccTimeout] :: TriggerLogCleanupConfig -> Int

-- | should we clean the invocation logs as well
[tlccCleanInvocationLogs] :: TriggerLogCleanupConfig -> Bool
data EventTriggerCleanupStatus
ETCSPaused :: EventTriggerCleanupStatus
ETCSUnpaused :: EventTriggerCleanupStatus

-- | Statistics of deleted event logs and invocation logs
data DeletedEventLogStats
DeletedEventLogStats :: Int -> Int -> DeletedEventLogStats
[deletedEventLogs] :: DeletedEventLogStats -> Int
[deletedInvocationLogs] :: DeletedEventLogStats -> Int
data EventTriggerQualifier
EventTriggerQualifier :: SourceName -> NonEmpty TriggerName -> EventTriggerQualifier
[_etqSourceName] :: EventTriggerQualifier -> SourceName
[_etqEventTriggers] :: EventTriggerQualifier -> NonEmpty TriggerName
data TriggerLogCleanupSources
TriggerAllSource :: TriggerLogCleanupSources
TriggerSource :: NonEmpty SourceName -> TriggerLogCleanupSources
data TriggerLogCleanupToggleConfig
TriggerLogCleanupSources :: TriggerLogCleanupSources -> TriggerLogCleanupToggleConfig
TriggerQualifier :: NonEmpty EventTriggerQualifier -> TriggerLogCleanupToggleConfig
updateCleanupConfig :: forall (b :: BackendType). Maybe AutoTriggerLogCleanupConfig -> EventTriggerConf b -> EventTriggerConf b
isIllegalTriggerName :: TriggerName -> Bool
data EventLogStatus
Processed :: EventLogStatus
Pending :: EventLogStatus
All :: EventLogStatus
data GetEventLogs (b :: BackendType)
GetEventLogs :: TriggerName -> SourceName -> Int -> Int -> EventLogStatus -> GetEventLogs (b :: BackendType)
[_gelName] :: GetEventLogs (b :: BackendType) -> TriggerName
[_gelSourceName] :: GetEventLogs (b :: BackendType) -> SourceName
[_gelLimit] :: GetEventLogs (b :: BackendType) -> Int
[_gelOffset] :: GetEventLogs (b :: BackendType) -> Int
[_gelStatus] :: GetEventLogs (b :: BackendType) -> EventLogStatus
data EventLog
EventLog :: EventId -> Text -> Text -> TriggerName -> Value -> Bool -> Bool -> Int -> UTCTime -> Maybe UTCTime -> Maybe UTCTime -> Bool -> EventLog
[elId] :: EventLog -> EventId
[elSchemaName] :: EventLog -> Text
[elTableName] :: EventLog -> Text
[elTriggerName] :: EventLog -> TriggerName
[elPayload] :: EventLog -> Value
[elDelivered] :: EventLog -> Bool
[elError] :: EventLog -> Bool
[elTries] :: EventLog -> Int
[elCreatedAt] :: EventLog -> UTCTime
[elLocked] :: EventLog -> Maybe UTCTime
[elNextRetryAt] :: EventLog -> Maybe UTCTime
[elArchived] :: EventLog -> Bool
data GetEventInvocations (b :: BackendType)
GetEventInvocations :: TriggerName -> SourceName -> Int -> Int -> GetEventInvocations (b :: BackendType)
[_geiName] :: GetEventInvocations (b :: BackendType) -> TriggerName
[_geiSourceName] :: GetEventInvocations (b :: BackendType) -> SourceName
[_geiLimit] :: GetEventInvocations (b :: BackendType) -> Int
[_geiOffset] :: GetEventInvocations (b :: BackendType) -> Int
data EventInvocationLog
EventInvocationLog :: Text -> TriggerName -> EventId -> Maybe Int -> Value -> Value -> UTCTime -> EventInvocationLog
[eilId] :: EventInvocationLog -> Text
[eilTriggerName] :: EventInvocationLog -> TriggerName
[eilEventId] :: EventInvocationLog -> EventId
[eilHttpStatus] :: EventInvocationLog -> Maybe Int
[eilRequest] :: EventInvocationLog -> Value
[eilResponse] :: EventInvocationLog -> Value
[eilCreatedAt] :: EventInvocationLog -> UTCTime
data GetEventById (b :: BackendType)
GetEventById :: SourceName -> EventId -> Int -> Int -> GetEventById (b :: BackendType)
[_gebiSourceName] :: GetEventById (b :: BackendType) -> SourceName
[_gebiEventId] :: GetEventById (b :: BackendType) -> EventId
[_gebiInvocationLogLimit] :: GetEventById (b :: BackendType) -> Int
[_gebiInvocationLogOffset] :: GetEventById (b :: BackendType) -> Int
data EventLogWithInvocations
EventLogWithInvocations :: Maybe EventLog -> [EventInvocationLog] -> EventLogWithInvocations
[elwiEvent] :: EventLogWithInvocations -> Maybe EventLog
[elwiInvocations] :: EventLogWithInvocations -> [EventInvocationLog]
instance GHC.Classes.Eq Hasura.RQL.Types.EventTrigger.AutoTriggerLogCleanupConfig
instance GHC.Classes.Eq Hasura.RQL.Types.EventTrigger.DeletedEventLogStats
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.EventTrigger.Event b)
instance GHC.Classes.Eq Hasura.RQL.Types.EventTrigger.EventHeaderInfo
instance GHC.Classes.Eq Hasura.RQL.Types.EventTrigger.EventLog
instance GHC.Classes.Eq Hasura.RQL.Types.EventTrigger.EventLogStatus
instance GHC.Classes.Eq Hasura.RQL.Types.EventTrigger.EventTriggerCleanupStatus
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.EventTrigger.EventTriggerConf b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.EventTrigger.EventTriggerInfo b)
instance GHC.Classes.Eq Hasura.RQL.Types.EventTrigger.EventTriggerQualifier
instance GHC.Classes.Eq Hasura.RQL.Types.EventTrigger.FetchBatchSize
instance GHC.Classes.Eq Hasura.RQL.Types.EventTrigger.Ops
instance GHC.Classes.Eq Hasura.RQL.Types.EventTrigger.ProcessEventError
instance GHC.Classes.Eq Hasura.RQL.Types.EventTrigger.RecreateEventTriggers
instance GHC.Classes.Eq Hasura.RQL.Types.EventTrigger.RetryConf
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.EventTrigger.SubscribeColumns b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.EventTrigger.SubscribeOpSpec b)
instance GHC.Classes.Eq Hasura.RQL.Types.EventTrigger.TriggerLogCleanupConfig
instance GHC.Classes.Eq Hasura.RQL.Types.EventTrigger.TriggerLogCleanupSources
instance GHC.Classes.Eq Hasura.RQL.Types.EventTrigger.TriggerLogCleanupToggleConfig
instance GHC.Classes.Eq Hasura.RQL.Types.EventTrigger.TriggerMetadata
instance GHC.Classes.Eq Hasura.RQL.Types.EventTrigger.TriggerName
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.EventTrigger.TriggerOpsDef b)
instance GHC.Classes.Eq Hasura.RQL.Types.EventTrigger.WebhookConf
instance GHC.Classes.Eq Hasura.RQL.Types.EventTrigger.WebhookConfInfo
instance Database.PG.Query.Class.FromCol Hasura.RQL.Types.EventTrigger.TriggerName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.EventTrigger.AutoTriggerLogCleanupConfig
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.EventTrigger.Event b)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.EventTrigger.EventLogStatus
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.EventTrigger.EventTriggerCleanupStatus
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.EventTrigger.EventTriggerConf b)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.EventTrigger.EventTriggerQualifier
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.EventTrigger.GetEventById b)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.EventTrigger.GetEventInvocations b)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.EventTrigger.GetEventLogs b)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.EventTrigger.RetryConf
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.EventTrigger.SubscribeColumns b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.EventTrigger.SubscribeOpSpec b)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.EventTrigger.TriggerLogCleanupConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.EventTrigger.TriggerLogCleanupSources
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.EventTrigger.TriggerLogCleanupToggleConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.EventTrigger.TriggerMetadata
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.EventTrigger.TriggerName
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.EventTrigger.TriggerOpsDef b)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.EventTrigger.WebhookConf
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.EventTrigger.AutoTriggerLogCleanupConfig
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.EventTrigger.Event b)
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.EventTrigger.EventHeaderInfo
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.EventTrigger.EventInvocationLog
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.EventTrigger.EventLog
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.EventTrigger.EventLogWithInvocations
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.EventTrigger.EventTriggerCleanupStatus
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.EventTrigger.EventTriggerConf b)
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.EventTrigger.EventTriggerInfo b)
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.EventTrigger.EventTriggerQualifier
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.EventTrigger.Ops
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.EventTrigger.RecreateEventTriggers
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.EventTrigger.RetryConf
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.EventTrigger.SubscribeColumns b)
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.EventTrigger.SubscribeOpSpec b)
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.EventTrigger.TriggerLogCleanupConfig
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.EventTrigger.TriggerLogCleanupSources
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.EventTrigger.TriggerLogCleanupToggleConfig
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.EventTrigger.TriggerMetadata
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.EventTrigger.TriggerName
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.EventTrigger.TriggerOpsDef b)
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.EventTrigger.WebhookConf
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.EventTrigger.WebhookConfInfo
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.EventTrigger.AutoTriggerLogCleanupConfig
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.EventTrigger.EventTriggerCleanupStatus
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.Types.EventTrigger.EventTriggerConf b)
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.EventTrigger.RetryConf
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.Types.EventTrigger.SubscribeColumns b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.Types.EventTrigger.SubscribeOpSpec b)
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.EventTrigger.TriggerName
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.Types.EventTrigger.TriggerOpsDef b)
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.EventTrigger.Ops
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.EventTrigger.TriggerName
instance Control.DeepSeq.NFData Hasura.RQL.Types.EventTrigger.AutoTriggerLogCleanupConfig
instance Control.DeepSeq.NFData Hasura.RQL.Types.EventTrigger.EventHeaderInfo
instance Control.DeepSeq.NFData Hasura.RQL.Types.EventTrigger.EventTriggerCleanupStatus
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.Types.EventTrigger.EventTriggerInfo b)
instance Control.DeepSeq.NFData Hasura.RQL.Types.EventTrigger.EventTriggerQualifier
instance Control.DeepSeq.NFData Hasura.RQL.Types.EventTrigger.RetryConf
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.Types.EventTrigger.SubscribeColumns b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.Types.EventTrigger.SubscribeOpSpec b)
instance Control.DeepSeq.NFData Hasura.RQL.Types.EventTrigger.TriggerLogCleanupConfig
instance Control.DeepSeq.NFData Hasura.RQL.Types.EventTrigger.TriggerLogCleanupSources
instance Control.DeepSeq.NFData Hasura.RQL.Types.EventTrigger.TriggerLogCleanupToggleConfig
instance Control.DeepSeq.NFData Hasura.RQL.Types.EventTrigger.TriggerName
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.Types.EventTrigger.TriggerOpsDef b)
instance Control.DeepSeq.NFData Hasura.RQL.Types.EventTrigger.WebhookConf
instance Control.DeepSeq.NFData Hasura.RQL.Types.EventTrigger.WebhookConfInfo
instance GHC.Classes.Ord Hasura.RQL.Types.EventTrigger.TriggerName
instance GHC.Internal.Base.Semigroup Hasura.RQL.Types.EventTrigger.RecreateEventTriggers
instance GHC.Internal.Show.Show Hasura.RQL.Types.EventTrigger.AutoTriggerLogCleanupConfig
instance GHC.Internal.Show.Show Hasura.RQL.Types.EventTrigger.DeletedEventLogStats
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.Types.EventTrigger.Event b)
instance GHC.Internal.Show.Show Hasura.RQL.Types.EventTrigger.EventHeaderInfo
instance GHC.Internal.Show.Show Hasura.RQL.Types.EventTrigger.EventLogStatus
instance GHC.Internal.Show.Show Hasura.RQL.Types.EventTrigger.EventTriggerCleanupStatus
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.Types.EventTrigger.EventTriggerConf b)
instance GHC.Internal.Show.Show Hasura.RQL.Types.EventTrigger.EventTriggerQualifier
instance GHC.Internal.Show.Show Hasura.RQL.Types.EventTrigger.FetchBatchSize
instance GHC.Internal.Show.Show (Hasura.RQL.Types.EventTrigger.GetEventById b)
instance GHC.Internal.Show.Show (Hasura.RQL.Types.EventTrigger.GetEventInvocations b)
instance GHC.Internal.Show.Show (Hasura.RQL.Types.EventTrigger.GetEventLogs b)
instance GHC.Internal.Show.Show Hasura.RQL.Types.EventTrigger.Ops
instance GHC.Internal.Show.Show Hasura.RQL.Types.EventTrigger.ProcessEventError
instance GHC.Internal.Show.Show Hasura.RQL.Types.EventTrigger.RecreateEventTriggers
instance GHC.Internal.Show.Show Hasura.RQL.Types.EventTrigger.RetryConf
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.Types.EventTrigger.SubscribeColumns b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.Types.EventTrigger.SubscribeOpSpec b)
instance GHC.Internal.Show.Show Hasura.RQL.Types.EventTrigger.TriggerLogCleanupConfig
instance GHC.Internal.Show.Show Hasura.RQL.Types.EventTrigger.TriggerLogCleanupSources
instance GHC.Internal.Show.Show Hasura.RQL.Types.EventTrigger.TriggerLogCleanupToggleConfig
instance GHC.Internal.Show.Show Hasura.RQL.Types.EventTrigger.TriggerMetadata
instance GHC.Internal.Show.Show Hasura.RQL.Types.EventTrigger.TriggerName
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.Types.EventTrigger.TriggerOpsDef b)
instance GHC.Internal.Show.Show Hasura.RQL.Types.EventTrigger.WebhookConf
instance GHC.Internal.Show.Show Hasura.RQL.Types.EventTrigger.WebhookConfInfo
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.Types.EventTrigger.TriggerName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.EventTrigger.AutoTriggerLogCleanupConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.EventTrigger.EventHeaderInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.EventTrigger.EventInvocationLog
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.EventTrigger.EventLog
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.EventTrigger.EventLogStatus
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.EventTrigger.EventLogWithInvocations
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.EventTrigger.EventTriggerCleanupStatus
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.EventTrigger.EventTriggerConf b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.EventTrigger.EventTriggerInfo b)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.EventTrigger.EventTriggerQualifier
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.EventTrigger.GetEventById b)
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.EventTrigger.GetEventInvocations b)
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.EventTrigger.GetEventLogs b)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.EventTrigger.RetryConf
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.EventTrigger.SubscribeColumns b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.EventTrigger.SubscribeOpSpec b)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.EventTrigger.TriggerLogCleanupConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.EventTrigger.TriggerLogCleanupSources
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.EventTrigger.TriggerLogCleanupToggleConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.EventTrigger.TriggerMetadata
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.EventTrigger.TriggerName
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.EventTrigger.TriggerOpsDef b)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.EventTrigger.WebhookConf
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.EventTrigger.WebhookConfInfo
instance Database.PG.Query.Class.ToPrepArg Hasura.RQL.Types.EventTrigger.TriggerName
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.EventTrigger.TriggerName


-- | Mutable references for Prometheus metrics.
--   
--   These metrics are independent from the metrics in
--   <a>Hasura.Server.Metrics</a>.
module Hasura.Server.Prometheus

-- | Mutable references for Prometheus metrics.
data PrometheusMetrics
PrometheusMetrics :: ConnectionsGauge -> GraphQLRequestMetrics -> EventTriggerMetrics -> Counter -> CounterVector DynamicGraphqlOperationLabel -> Counter -> Counter -> ScheduledTriggerMetrics -> SubscriptionMetrics -> Histogram -> Histogram -> CacheRequestMetrics -> OpenTelemetryMetrics -> PrometheusMetrics
[pmConnections] :: PrometheusMetrics -> ConnectionsGauge
[pmGraphQLRequestMetrics] :: PrometheusMetrics -> GraphQLRequestMetrics
[pmEventTriggerMetrics] :: PrometheusMetrics -> EventTriggerMetrics
[pmWebSocketBytesReceived] :: PrometheusMetrics -> Counter
[pmWebSocketBytesSent] :: PrometheusMetrics -> CounterVector DynamicGraphqlOperationLabel
[pmActionBytesReceived] :: PrometheusMetrics -> Counter
[pmActionBytesSent] :: PrometheusMetrics -> Counter
[pmScheduledTriggerMetrics] :: PrometheusMetrics -> ScheduledTriggerMetrics
[pmSubscriptionMetrics] :: PrometheusMetrics -> SubscriptionMetrics
[pmWebsocketMsgQueueTimeSeconds] :: PrometheusMetrics -> Histogram
[pmWebsocketMsgWriteTimeSeconds] :: PrometheusMetrics -> Histogram
[pmCacheRequestMetrics] :: PrometheusMetrics -> CacheRequestMetrics
[pmOpenTelemetryMetrics] :: PrometheusMetrics -> OpenTelemetryMetrics
data GraphQLRequestMetrics
GraphQLRequestMetrics :: CounterVector GraphQLRequestsLabels -> Histogram -> Histogram -> GraphQLRequestMetrics
[gqlRequests] :: GraphQLRequestMetrics -> CounterVector GraphQLRequestsLabels
[gqlExecutionTimeSecondsQuery] :: GraphQLRequestMetrics -> Histogram
[gqlExecutionTimeSecondsMutation] :: GraphQLRequestMetrics -> Histogram
data EventTriggerMetrics
EventTriggerMetrics :: Gauge -> Gauge -> HistogramVector (Maybe DynamicEventTriggerLabel) -> Histogram -> HistogramVector (Maybe DynamicEventTriggerLabel) -> HistogramVector (Maybe DynamicEventTriggerLabel) -> Counter -> Counter -> CounterVector EventStatusWithTriggerLabel -> CounterVector EventStatusWithTriggerLabel -> EventTriggerMetrics
[eventTriggerHTTPWorkers] :: EventTriggerMetrics -> Gauge
[eventsFetchedPerBatch] :: EventTriggerMetrics -> Gauge
[eventQueueTimeSeconds] :: EventTriggerMetrics -> HistogramVector (Maybe DynamicEventTriggerLabel)
[eventsFetchTimePerBatch] :: EventTriggerMetrics -> Histogram
[eventWebhookProcessingTime] :: EventTriggerMetrics -> HistogramVector (Maybe DynamicEventTriggerLabel)
[eventProcessingTime] :: EventTriggerMetrics -> HistogramVector (Maybe DynamicEventTriggerLabel)
[eventTriggerBytesReceived] :: EventTriggerMetrics -> Counter
[eventTriggerBytesSent] :: EventTriggerMetrics -> Counter
[eventProcessedTotal] :: EventTriggerMetrics -> CounterVector EventStatusWithTriggerLabel
[eventInvocationTotal] :: EventTriggerMetrics -> CounterVector EventStatusWithTriggerLabel
data CacheRequestMetrics
CacheRequestMetrics :: Counter -> Counter -> CacheRequestMetrics
[crmCacheHits] :: CacheRequestMetrics -> Counter
[crmCacheMisses] :: CacheRequestMetrics -> Counter

-- | Metrics related to OTel telemetry export; for now the volume of logs
--   and trace spans shipped, and counts of log lines and spans dropped due
--   to high volume.
data OpenTelemetryMetrics
OpenTelemetryMetrics :: Counter -> Counter -> Counter -> Counter -> Counter -> Counter -> OpenTelemetryMetrics
[otmSentSpans] :: OpenTelemetryMetrics -> Counter

-- | Dropped due to the send buffer being full
[otmDroppedSpansInBuffer] :: OpenTelemetryMetrics -> Counter

-- | Dropped due to some error (after retrying) when sending to collector
[otmDroppedSpansInSend] :: OpenTelemetryMetrics -> Counter
[otmSentLogs] :: OpenTelemetryMetrics -> Counter
[otmDroppedLogsInBuffer] :: OpenTelemetryMetrics -> Counter
[otmDroppedLogsInSend] :: OpenTelemetryMetrics -> Counter

-- | Create dummy mutable references without associating them to a metrics
--   store.
makeDummyPrometheusMetrics :: IO PrometheusMetrics

-- | A mutable reference for atomically sampling the number of websocket
--   connections and number of threads forked by the warp webserver.
--   
--   Because we derive the number of (non-websocket) HTTP connections by
--   the difference of these two metrics, we must sample them
--   simultaneously, otherwise we might report a negative number of HTTP
--   connections.
data ConnectionsGauge
data Connections
Connections :: Int64 -> Int64 -> Connections
[connWarpThreads] :: Connections -> Int64
[connWebsockets] :: Connections -> Int64
newConnectionsGauge :: IO ConnectionsGauge
readConnectionsGauge :: ConnectionsGauge -> IO Connections
incWarpThreads :: ConnectionsGauge -> IO ()
decWarpThreads :: ConnectionsGauge -> IO ()
incWebsocketConnections :: ConnectionsGauge -> IO ()
decWebsocketConnections :: ConnectionsGauge -> IO ()
data ScheduledTriggerMetrics
ScheduledTriggerMetrics :: Counter -> Counter -> Counter -> Counter -> Counter -> Counter -> Counter -> Counter -> Counter -> Counter -> ScheduledTriggerMetrics
[stmScheduledTriggerBytesReceived] :: ScheduledTriggerMetrics -> Counter
[stmScheduledTriggerBytesSent] :: ScheduledTriggerMetrics -> Counter
[stmCronEventsInvocationTotalSuccess] :: ScheduledTriggerMetrics -> Counter
[stmCronEventsInvocationTotalFailure] :: ScheduledTriggerMetrics -> Counter
[stmOneOffEventsInvocationTotalSuccess] :: ScheduledTriggerMetrics -> Counter
[stmOneOffEventsInvocationTotalFailure] :: ScheduledTriggerMetrics -> Counter
[stmCronEventsProcessedTotalSuccess] :: ScheduledTriggerMetrics -> Counter
[stmCronEventsProcessedTotalFailure] :: ScheduledTriggerMetrics -> Counter
[stmOneOffEventsProcessedTotalSuccess] :: ScheduledTriggerMetrics -> Counter
[stmOneOffEventsProcessedTotalFailure] :: ScheduledTriggerMetrics -> Counter
data SubscriptionMetrics
SubscriptionMetrics :: Gauge -> Gauge -> Gauge -> Gauge -> HistogramVector SubscriptionLabel -> HistogramVector SubscriptionLabel -> GaugeVector SubscriptionLabel -> SubscriptionMetrics
[submActiveLiveQueryPollers] :: SubscriptionMetrics -> Gauge
[submActiveStreamingPollers] :: SubscriptionMetrics -> Gauge
[submActiveLiveQueryPollersInError] :: SubscriptionMetrics -> Gauge
[submActiveStreamingPollersInError] :: SubscriptionMetrics -> Gauge
[submTotalTime] :: SubscriptionMetrics -> HistogramVector SubscriptionLabel
[submDBExecTotalTime] :: SubscriptionMetrics -> HistogramVector SubscriptionLabel
[submActiveSubscriptions] :: SubscriptionMetrics -> GaugeVector SubscriptionLabel
data DynamicEventTriggerLabel
DynamicEventTriggerLabel :: TriggerName -> SourceName -> DynamicEventTriggerLabel
[_detlTriggerName] :: DynamicEventTriggerLabel -> TriggerName
[_detlSourceName] :: DynamicEventTriggerLabel -> SourceName
data ResponseStatus
Success :: ResponseStatus
Failed :: ResponseStatus
responseStatusToLabelValue :: ResponseStatus -> Text
newtype EventStatusLabel
EventStatusLabel :: Text -> EventStatusLabel
[status] :: EventStatusLabel -> Text
eventSuccessLabel :: EventStatusLabel
eventFailedLabel :: EventStatusLabel
data EventStatusWithTriggerLabel
EventStatusWithTriggerLabel :: EventStatusLabel -> Maybe DynamicEventTriggerLabel -> EventStatusWithTriggerLabel
[_eswtlStatus] :: EventStatusWithTriggerLabel -> EventStatusLabel
[_eswtlDynamicLabels] :: EventStatusWithTriggerLabel -> Maybe DynamicEventTriggerLabel

-- | Whether or not to enable granular metrics for Prometheus.
--   
--   <a>GranularMetricsOn</a> will enable the dynamic labels for the
--   metrics. <a>GranularMetricsOff</a> will disable the dynamic labels for
--   the metrics.
--   
--   <ul>
--   <li>*Warning**: Enabling dynamic labels for Prometheus metrics can
--   cause cardinality issues and can cause memory usage to increase.</li>
--   </ul>
data GranularPrometheusMetricsState
GranularMetricsOff :: GranularPrometheusMetricsState
GranularMetricsOn :: GranularPrometheusMetricsState

-- | Observe a histogram metric with a label.
--   
--   If the granularity is set to <a>GranularMetricsOn</a>, the label will
--   be included in the metric. Otherwise, the label will be set to
--   <a>Nothing</a>
observeHistogramWithLabel :: (Ord l, MonadIO m) => IO GranularPrometheusMetricsState -> Bool -> HistogramVector (Maybe l) -> l -> Double -> m ()
data SubscriptionKindLabel
SubscriptionKindLabel :: Text -> SubscriptionKindLabel
[subscription_kind] :: SubscriptionKindLabel -> Text
data SubscriptionLabel
SubscriptionLabel :: SubscriptionKindLabel -> Maybe DynamicGraphqlOperationLabel -> SubscriptionLabel
[_slKind] :: SubscriptionLabel -> SubscriptionKindLabel
[_slDynamicLabels] :: SubscriptionLabel -> Maybe DynamicGraphqlOperationLabel
data DynamicGraphqlOperationLabel
DynamicGraphqlOperationLabel :: Maybe ParameterizedQueryHash -> Maybe OperationName -> DynamicGraphqlOperationLabel
[_dslParamQueryHash] :: DynamicGraphqlOperationLabel -> Maybe ParameterizedQueryHash
[_dslOperationName] :: DynamicGraphqlOperationLabel -> Maybe OperationName
streamingSubscriptionLabel :: SubscriptionKindLabel
liveQuerySubscriptionLabel :: SubscriptionKindLabel

-- | Record metrics with dynamic label
recordMetricWithLabel :: MonadIO m => IO GranularPrometheusMetricsState -> Bool -> IO () -> IO () -> m ()

-- | Record a subscription metric for all the operation names present in
--   the subscription. Use this when you want to update the same value of
--   the metric for all the operation names.
recordSubscriptionMetric :: MonadIO m => IO GranularPrometheusMetricsState -> Bool -> HashMap (Maybe OperationName) Int -> ParameterizedQueryHash -> SubscriptionKindLabel -> (SubscriptionLabel -> IO ()) -> m ()
data GraphQLRequestsLabels
recordGraphqlOperationMetric :: MonadIO m => IO GranularPrometheusMetricsState -> Maybe OperationType -> ResponseStatus -> Maybe OperationName -> Maybe ParameterizedQueryHash -> (GraphQLRequestsLabels -> IO ()) -> m ()
instance GHC.Classes.Eq Hasura.Server.Prometheus.DynamicEventTriggerLabel
instance GHC.Classes.Eq Hasura.Server.Prometheus.DynamicGraphqlOperationLabel
instance GHC.Classes.Eq Hasura.Server.Prometheus.EventStatusLabel
instance GHC.Classes.Eq Hasura.Server.Prometheus.EventStatusWithTriggerLabel
instance GHC.Classes.Eq Hasura.Server.Prometheus.GraphQLRequestsLabels
instance GHC.Classes.Eq Hasura.Server.Prometheus.ResponseStatus
instance GHC.Classes.Eq Hasura.Server.Prometheus.SubscriptionKindLabel
instance GHC.Classes.Eq Hasura.Server.Prometheus.SubscriptionLabel
instance GHC.Internal.Generics.Generic Hasura.Server.Prometheus.DynamicGraphqlOperationLabel
instance GHC.Internal.Generics.Generic Hasura.Server.Prometheus.EventStatusLabel
instance GHC.Internal.Generics.Generic Hasura.Server.Prometheus.EventStatusWithTriggerLabel
instance GHC.Internal.Generics.Generic Hasura.Server.Prometheus.GraphQLRequestsLabels
instance GHC.Internal.Generics.Generic Hasura.Server.Prometheus.ResponseStatus
instance GHC.Internal.Generics.Generic Hasura.Server.Prometheus.SubscriptionKindLabel
instance GHC.Internal.Generics.Generic Hasura.Server.Prometheus.SubscriptionLabel
instance GHC.Classes.Ord Hasura.Server.Prometheus.DynamicEventTriggerLabel
instance GHC.Classes.Ord Hasura.Server.Prometheus.DynamicGraphqlOperationLabel
instance GHC.Classes.Ord Hasura.Server.Prometheus.EventStatusLabel
instance GHC.Classes.Ord Hasura.Server.Prometheus.EventStatusWithTriggerLabel
instance GHC.Classes.Ord Hasura.Server.Prometheus.GraphQLRequestsLabels
instance GHC.Classes.Ord Hasura.Server.Prometheus.ResponseStatus
instance GHC.Classes.Ord Hasura.Server.Prometheus.SubscriptionKindLabel
instance GHC.Classes.Ord Hasura.Server.Prometheus.SubscriptionLabel
instance System.Metrics.Prometheus.ToLabels Hasura.Server.Prometheus.DynamicGraphqlOperationLabel
instance System.Metrics.Prometheus.ToLabels Hasura.Server.Prometheus.EventStatusLabel
instance System.Metrics.Prometheus.ToLabels Hasura.Server.Prometheus.EventStatusWithTriggerLabel
instance System.Metrics.Prometheus.ToLabels Hasura.Server.Prometheus.GraphQLRequestsLabels
instance System.Metrics.Prometheus.ToLabels (GHC.Internal.Maybe.Maybe Hasura.Server.Prometheus.DynamicEventTriggerLabel)
instance System.Metrics.Prometheus.ToLabels Hasura.Server.Prometheus.SubscriptionKindLabel
instance System.Metrics.Prometheus.ToLabels Hasura.Server.Prometheus.SubscriptionLabel


-- | These are types for Scheduled Trigger definition; see
--   <a>Hasura.Eventing.ScheduledTrigger</a>
module Hasura.RQL.Types.ScheduledTrigger
newtype ScheduledTriggerName
ScheduledTriggerName :: TriggerName -> ScheduledTriggerName
[unName] :: ScheduledTriggerName -> TriggerName
data CronTriggerMetadata
CronTriggerMetadata :: TriggerName -> InputWebhook -> CronSchedule -> Maybe Value -> STRetryConf -> [HeaderConf] -> Bool -> Maybe Text -> Maybe RequestTransform -> Maybe MetadataResponseTransform -> CronTriggerMetadata
[ctName] :: CronTriggerMetadata -> TriggerName
[ctWebhook] :: CronTriggerMetadata -> InputWebhook
[ctSchedule] :: CronTriggerMetadata -> CronSchedule
[ctPayload] :: CronTriggerMetadata -> Maybe Value
[ctRetryConf] :: CronTriggerMetadata -> STRetryConf
[ctHeaders] :: CronTriggerMetadata -> [HeaderConf]
[ctIncludeInMetadata] :: CronTriggerMetadata -> Bool
[ctComment] :: CronTriggerMetadata -> Maybe Text
[ctRequestTransform] :: CronTriggerMetadata -> Maybe RequestTransform
[ctResponseTransform] :: CronTriggerMetadata -> Maybe MetadataResponseTransform
data CreateCronTrigger
CreateCronTrigger :: TriggerName -> InputWebhook -> CronSchedule -> Maybe Value -> STRetryConf -> [HeaderConf] -> Bool -> Maybe Text -> Bool -> Maybe RequestTransform -> Maybe MetadataResponseTransform -> CreateCronTrigger
[_cctName] :: CreateCronTrigger -> TriggerName
[_cctWebhook] :: CreateCronTrigger -> InputWebhook
[_cctCronSchedule] :: CreateCronTrigger -> CronSchedule
[_cctPayload] :: CreateCronTrigger -> Maybe Value
[_cctRetryConf] :: CreateCronTrigger -> STRetryConf
[_cctHeaders] :: CreateCronTrigger -> [HeaderConf]
[_cctIncludeInMetadata] :: CreateCronTrigger -> Bool
[_cctComment] :: CreateCronTrigger -> Maybe Text
[_cctReplace] :: CreateCronTrigger -> Bool
[_cctRequestTransform] :: CreateCronTrigger -> Maybe RequestTransform
[_cctResponseTransform] :: CreateCronTrigger -> Maybe MetadataResponseTransform
data STRetryConf
STRetryConf :: Int -> Refined NonNegative DiffTime -> Refined NonNegative DiffTime -> Refined NonNegative DiffTime -> STRetryConf
[strcNumRetries] :: STRetryConf -> Int
[strcRetryIntervalSeconds] :: STRetryConf -> Refined NonNegative DiffTime
[strcTimeoutSeconds] :: STRetryConf -> Refined NonNegative DiffTime

-- | The tolerance configuration is used to determine whether a scheduled
--   event is not too old to process. The age of the scheduled event is the
--   difference between the current timestamp and the scheduled event's
--   timestamp, if the age is than the tolerance then the scheduled event
--   is marked as dead.
[strcToleranceSeconds] :: STRetryConf -> Refined NonNegative DiffTime
data CreateScheduledEvent
CreateScheduledEvent :: InputWebhook -> UTCTime -> Maybe Value -> [HeaderConf] -> STRetryConf -> Maybe Text -> Maybe RequestTransform -> Maybe MetadataResponseTransform -> CreateScheduledEvent
[cseWebhook] :: CreateScheduledEvent -> InputWebhook

-- | The timestamp should be in the <a>8601
--   https://en.wikipedia.org/wiki/ISO_8601</a> format (which is what
--   <tt>aeson</tt> expects by default for <a>UTCTime</a>).
[cseScheduleAt] :: CreateScheduledEvent -> UTCTime
[csePayload] :: CreateScheduledEvent -> Maybe Value
[cseHeaders] :: CreateScheduledEvent -> [HeaderConf]
[cseRetryConf] :: CreateScheduledEvent -> STRetryConf
[cseComment] :: CreateScheduledEvent -> Maybe Text
[cseRequestTransform] :: CreateScheduledEvent -> Maybe RequestTransform
[cseResponseTransform] :: CreateScheduledEvent -> Maybe MetadataResponseTransform
type CronEventId = EventId
type OneOffScheduledEventId = EventId
formatTime' :: UTCTime -> Text
defaultSTRetryConf :: STRetryConf
type ScheduledEventId = EventId
type InvocationId = Text
data CronEventSeed
CronEventSeed :: TriggerName -> UTCTime -> CronEventSeed
[cesName] :: CronEventSeed -> TriggerName
[cesScheduledTime] :: CronEventSeed -> UTCTime
type OneOffEvent = CreateScheduledEvent
data ScheduledEventStatus
SESScheduled :: ScheduledEventStatus
SESLocked :: ScheduledEventStatus
SESDelivered :: ScheduledEventStatus
SESError :: ScheduledEventStatus
SESDead :: ScheduledEventStatus
scheduledEventStatusToText :: ScheduledEventStatus -> Text

-- | The <a>ScheduledEventType</a> data type is needed to differentiate
--   between a <tt>CronScheduledEvent</tt> and <a>OneOffScheduledEvent</a>
--   scheduled event because they both have different configurations and
--   they live in different tables.
data ScheduledEventType

-- | A Cron scheduled event has a template defined which will contain the
--   webhook, header configuration, retry configuration and a payload.
--   Every cron event created uses the above mentioned configurations
--   defined in the template. The configuration defined with the cron
--   trigger is cached and hence it's not fetched along the cron scheduled
--   events.
Cron :: ScheduledEventType

-- | A One-off scheduled event doesn't have any template defined so all the
--   configuration is fetched along the scheduled events.
OneOff :: ScheduledEventType
data ScheduledEvent
SEOneOff :: ScheduledEvent
SECron :: TriggerName -> ScheduledEvent
data ScheduledEventInvocation
ScheduledEventInvocation :: InvocationId -> EventId -> Maybe Int -> Maybe Value -> Maybe Value -> UTCTime -> ScheduledEventInvocation
[_seiId] :: ScheduledEventInvocation -> InvocationId
[_seiEventId] :: ScheduledEventInvocation -> EventId
[_seiStatus] :: ScheduledEventInvocation -> Maybe Int
[_seiRequest] :: ScheduledEventInvocation -> Maybe Value
[_seiResponse] :: ScheduledEventInvocation -> Maybe Value
[_seiCreatedAt] :: ScheduledEventInvocation -> UTCTime
data OneOffScheduledEvent
OneOffScheduledEvent :: OneOffScheduledEventId -> InputWebhook -> UTCTime -> STRetryConf -> Maybe Value -> [HeaderConf] -> Text -> Int -> UTCTime -> Maybe UTCTime -> Maybe Text -> Maybe RequestTransform -> Maybe MetadataResponseTransform -> OneOffScheduledEvent
[_ooseId] :: OneOffScheduledEvent -> OneOffScheduledEventId
[_ooseWebhookConf] :: OneOffScheduledEvent -> InputWebhook
[_ooseScheduledTime] :: OneOffScheduledEvent -> UTCTime
[_ooseRetryConf] :: OneOffScheduledEvent -> STRetryConf
[_oosePayload] :: OneOffScheduledEvent -> Maybe Value
[_ooseHeaderConf] :: OneOffScheduledEvent -> [HeaderConf]
[_ooseStatus] :: OneOffScheduledEvent -> Text
[_ooseTries] :: OneOffScheduledEvent -> Int
[_ooseCreatedAt] :: OneOffScheduledEvent -> UTCTime
[_ooseNextRetryAt] :: OneOffScheduledEvent -> Maybe UTCTime
[_ooseComment] :: OneOffScheduledEvent -> Maybe Text
[_ooseRequestTransform] :: OneOffScheduledEvent -> Maybe RequestTransform
[_ooseResponseTransform] :: OneOffScheduledEvent -> Maybe MetadataResponseTransform
data CronEvent
CronEvent :: CronEventId -> TriggerName -> UTCTime -> Text -> Int -> UTCTime -> Maybe UTCTime -> CronEvent
[_ceId] :: CronEvent -> CronEventId
[_ceTriggerName] :: CronEvent -> TriggerName

-- | We expect this to always be at second zero, since cron events have
--   minute resolution. Note that a OneOffScheduledEvent has full timestamp
--   precision.
[_ceScheduledTime] :: CronEvent -> UTCTime
[_ceStatus] :: CronEvent -> Text
[_ceTries] :: CronEvent -> Int

-- | it is the time at which the cron event generator created the event
[_ceCreatedAt] :: CronEvent -> UTCTime
[_ceNextRetryAt] :: CronEvent -> Maybe UTCTime
data RowsCountOption
IncludeRowsCount :: RowsCountOption
DontIncludeRowsCount :: RowsCountOption
data ScheduledEventPagination
ScheduledEventPagination :: Maybe Int -> Maybe Int -> ScheduledEventPagination
[_sepLimit] :: ScheduledEventPagination -> Maybe Int
[_sepOffset] :: ScheduledEventPagination -> Maybe Int

-- | Query type to fetch all one-off/cron scheduled events
data GetScheduledEvents
GetScheduledEvents :: ScheduledEvent -> ScheduledEventPagination -> [ScheduledEventStatus] -> RowsCountOption -> GetScheduledEvents
[_gseScheduledEvent] :: GetScheduledEvents -> ScheduledEvent
[_gsePagination] :: GetScheduledEvents -> ScheduledEventPagination
[_gseStatus] :: GetScheduledEvents -> [ScheduledEventStatus]
[_gseGetRowsCount] :: GetScheduledEvents -> RowsCountOption
data WithOptionalTotalCount a
WithOptionalTotalCount :: Maybe Int -> a -> WithOptionalTotalCount a
[_wtcCount] :: WithOptionalTotalCount a -> Maybe Int
[_wtcData] :: WithOptionalTotalCount a -> a

-- | Query type to delete cron/one-off events.
data DeleteScheduledEvent
DeleteScheduledEvent :: ScheduledEventType -> ScheduledEventId -> DeleteScheduledEvent
[_dseType] :: DeleteScheduledEvent -> ScheduledEventType
[_dseEventId] :: DeleteScheduledEvent -> ScheduledEventId
data GetScheduledEventInvocationsBy
GIBEventId :: EventId -> ScheduledEventType -> GetScheduledEventInvocationsBy
GIBEvent :: ScheduledEvent -> GetScheduledEventInvocationsBy
data GetScheduledEventInvocations
GetScheduledEventInvocations :: GetScheduledEventInvocationsBy -> ScheduledEventPagination -> RowsCountOption -> GetScheduledEventInvocations
[_geiInvocationsBy] :: GetScheduledEventInvocations -> GetScheduledEventInvocationsBy
[_geiPagination] :: GetScheduledEventInvocations -> ScheduledEventPagination

-- | Option to include the total rows corresponding in response.
[_geiGetRowsCount] :: GetScheduledEventInvocations -> RowsCountOption
data ClearCronEvents

-- | Used to delete the cron events only of the specified cron trigger
SingleCronTrigger :: TriggerName -> ClearCronEvents

-- | Used to delete all the cron events of the cron triggers with
--   `include_in_metadata: true` It is used in the case of the
--   <tt>replace_metadata</tt> API
MetadataCronTriggers :: [TriggerName] -> ClearCronEvents
cctName :: Lens' CreateCronTrigger TriggerName
cctWebhook :: Lens' CreateCronTrigger InputWebhook
cctCronSchedule :: Lens' CreateCronTrigger CronSchedule
cctPayload :: Lens' CreateCronTrigger (Maybe Value)
cctRetryConf :: Lens' CreateCronTrigger STRetryConf
cctHeaders :: Lens' CreateCronTrigger [HeaderConf]
cctIncludeInMetadata :: Lens' CreateCronTrigger Bool
cctComment :: Lens' CreateCronTrigger (Maybe Text)
cctReplace :: Lens' CreateCronTrigger Bool
cctRequestTransform :: Lens' CreateCronTrigger (Maybe RequestTransform)
cctResponseTransform :: Lens' CreateCronTrigger (Maybe MetadataResponseTransform)
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.ClearCronEvents
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.CreateCronTrigger
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.CreateScheduledEvent
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.CronEvent
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.CronEventSeed
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.CronTriggerMetadata
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.DeleteScheduledEvent
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.GetScheduledEventInvocations
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.GetScheduledEventInvocationsBy
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.GetScheduledEvents
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.OneOffScheduledEvent
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.RowsCountOption
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.STRetryConf
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.ScheduledEvent
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.ScheduledEventInvocation
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.ScheduledEventPagination
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.ScheduledEventStatus
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.ScheduledEventType
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.ScheduledTriggerName
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.RQL.Types.ScheduledTrigger.WithOptionalTotalCount a)
instance Database.PG.Query.Class.FromCol Hasura.RQL.Types.ScheduledTrigger.ScheduledEventStatus
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ScheduledTrigger.CreateCronTrigger
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ScheduledTrigger.CreateScheduledEvent
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ScheduledTrigger.CronEvent
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ScheduledTrigger.CronTriggerMetadata
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ScheduledTrigger.DeleteScheduledEvent
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ScheduledTrigger.GetScheduledEventInvocations
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ScheduledTrigger.GetScheduledEvents
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ScheduledTrigger.OneOffScheduledEvent
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ScheduledTrigger.RowsCountOption
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ScheduledTrigger.STRetryConf
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ScheduledTrigger.ScheduledEventInvocation
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ScheduledTrigger.ScheduledEventStatus
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ScheduledTrigger.ScheduledEventType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ScheduledTrigger.ScheduledTriggerName
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.ScheduledTrigger.CreateCronTrigger
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.ScheduledTrigger.CreateScheduledEvent
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.ScheduledTrigger.CronEvent
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.ScheduledTrigger.CronTriggerMetadata
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.ScheduledTrigger.DeleteScheduledEvent
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.ScheduledTrigger.OneOffScheduledEvent
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.ScheduledTrigger.STRetryConf
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.ScheduledTrigger.ScheduledEventInvocation
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.ScheduledTrigger.ScheduledEventType
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.ScheduledTrigger.ScheduledTriggerName
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.ScheduledTrigger.CronTriggerMetadata
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.ScheduledTrigger.STRetryConf
instance Control.DeepSeq.NFData Hasura.RQL.Types.ScheduledTrigger.CreateCronTrigger
instance Control.DeepSeq.NFData Hasura.RQL.Types.ScheduledTrigger.CronTriggerMetadata
instance Control.DeepSeq.NFData Hasura.RQL.Types.ScheduledTrigger.STRetryConf
instance GHC.Internal.Show.Show Hasura.RQL.Types.ScheduledTrigger.ClearCronEvents
instance GHC.Internal.Show.Show Hasura.RQL.Types.ScheduledTrigger.CreateCronTrigger
instance GHC.Internal.Show.Show Hasura.RQL.Types.ScheduledTrigger.CreateScheduledEvent
instance GHC.Internal.Show.Show Hasura.RQL.Types.ScheduledTrigger.CronEvent
instance GHC.Internal.Show.Show Hasura.RQL.Types.ScheduledTrigger.CronEventSeed
instance GHC.Internal.Show.Show Hasura.RQL.Types.ScheduledTrigger.CronTriggerMetadata
instance GHC.Internal.Show.Show Hasura.RQL.Types.ScheduledTrigger.DeleteScheduledEvent
instance GHC.Internal.Show.Show Hasura.RQL.Types.ScheduledTrigger.GetScheduledEventInvocations
instance GHC.Internal.Show.Show Hasura.RQL.Types.ScheduledTrigger.GetScheduledEventInvocationsBy
instance GHC.Internal.Show.Show Hasura.RQL.Types.ScheduledTrigger.GetScheduledEvents
instance GHC.Internal.Show.Show Hasura.RQL.Types.ScheduledTrigger.OneOffScheduledEvent
instance GHC.Internal.Show.Show Hasura.RQL.Types.ScheduledTrigger.RowsCountOption
instance GHC.Internal.Show.Show Hasura.RQL.Types.ScheduledTrigger.STRetryConf
instance GHC.Internal.Show.Show Hasura.RQL.Types.ScheduledTrigger.ScheduledEvent
instance GHC.Internal.Show.Show Hasura.RQL.Types.ScheduledTrigger.ScheduledEventInvocation
instance GHC.Internal.Show.Show Hasura.RQL.Types.ScheduledTrigger.ScheduledEventPagination
instance GHC.Internal.Show.Show Hasura.RQL.Types.ScheduledTrigger.ScheduledEventStatus
instance GHC.Internal.Show.Show Hasura.RQL.Types.ScheduledTrigger.ScheduledEventType
instance GHC.Internal.Show.Show Hasura.RQL.Types.ScheduledTrigger.ScheduledTriggerName
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (Hasura.RQL.Types.ScheduledTrigger.WithOptionalTotalCount a)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ScheduledTrigger.CreateCronTrigger
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ScheduledTrigger.CreateScheduledEvent
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ScheduledTrigger.CronEvent
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ScheduledTrigger.CronTriggerMetadata
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ScheduledTrigger.DeleteScheduledEvent
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ScheduledTrigger.GetScheduledEventInvocations
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ScheduledTrigger.GetScheduledEvents
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ScheduledTrigger.OneOffScheduledEvent
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ScheduledTrigger.RowsCountOption
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ScheduledTrigger.STRetryConf
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ScheduledTrigger.ScheduledEventInvocation
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ScheduledTrigger.ScheduledEventStatus
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ScheduledTrigger.ScheduledEventType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ScheduledTrigger.ScheduledTriggerName
instance Database.PG.Query.Class.ToPrepArg Hasura.RQL.Types.ScheduledTrigger.ScheduledEventStatus

module Hasura.RQL.IR.OrderBy
data OrderByCol
OCPG :: FieldName -> OrderByCol
OCRel :: FieldName -> OrderByCol -> OrderByCol
data OrderByItemG (b :: BackendType) a
OrderByItemG :: Maybe (BasicOrderType b) -> a -> Maybe (NullsOrderType b) -> OrderByItemG (b :: BackendType) a
[obiType] :: OrderByItemG (b :: BackendType) a -> Maybe (BasicOrderType b)
[obiColumn] :: OrderByItemG (b :: BackendType) a -> a
[obiNulls] :: OrderByItemG (b :: BackendType) a -> Maybe (NullsOrderType b)
type OrderByItem (b :: BackendType) = OrderByItemG b OrderByCol
orderByColFromTxt :: MonadFail m => Text -> m OrderByCol
instance GHC.Classes.Eq Hasura.RQL.IR.OrderBy.OrderByCol
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq a) => GHC.Classes.Eq (Hasura.RQL.IR.OrderBy.OrderByItemG b a)
instance GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.OrderBy.OrderByItemG b)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.IR.OrderBy.OrderByCol
instance GHC.Internal.Base.Functor (Hasura.RQL.IR.OrderBy.OrderByItemG b)
instance GHC.Internal.Generics.Generic (Hasura.RQL.IR.OrderBy.OrderByItemG b a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable a) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.OrderBy.OrderByItemG b a)
instance GHC.Internal.Show.Show Hasura.RQL.IR.OrderBy.OrderByCol
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show a) => GHC.Internal.Show.Show (Hasura.RQL.IR.OrderBy.OrderByItemG b a)
instance GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.OrderBy.OrderByItemG b)


-- | A scalar type to be used for logical models and resolvers.
module Hasura.LogicalModel.NullableScalarType

-- | A ScalarType that can be nullable with an optional description
data NullableScalarType (b :: BackendType)
NullableScalarType :: ScalarType b -> Bool -> Maybe Text -> NullableScalarType (b :: BackendType)
[nstType] :: NullableScalarType (b :: BackendType) -> ScalarType b
[nstNullable] :: NullableScalarType (b :: BackendType) -> Bool
[nstDescription] :: NullableScalarType (b :: BackendType) -> Maybe Text
nullableScalarTypeMapCodec :: forall (b :: BackendType). Backend b => Codec Value (InsOrdHashMap (Column b) (NullableScalarType b)) (InsOrdHashMap (Column b) (NullableScalarType b))
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.LogicalModel.NullableScalarType.NullableScalarType b)
instance GHC.Internal.Generics.Generic (Hasura.LogicalModel.NullableScalarType.NullableScalarType b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.LogicalModel.NullableScalarType.NullableScalarType b)
instance (Autodocodec.Class.HasObjectCodec a, Autodocodec.Class.HasObjectCodec b) => Autodocodec.Class.HasObjectCodec (Hasura.LogicalModel.NullableScalarType.MergedObject a b)
instance Autodocodec.Class.HasCodec a => Autodocodec.Class.HasObjectCodec (Hasura.LogicalModel.NullableScalarType.NameField a)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasObjectCodec (Hasura.LogicalModel.NullableScalarType.NullableScalarType b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.LogicalModel.NullableScalarType.NullableScalarType b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.LogicalModel.NullableScalarType.NullableScalarType b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.LogicalModel.NullableScalarType.NullableScalarType b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.LogicalModel.NullableScalarType.NullableScalarType b)


-- | A name for a native query as it is recognized by the graphql schema.
module Hasura.NativeQuery.Types
newtype NativeQueryName
NativeQueryName :: Name -> NativeQueryName
[getNativeQueryName] :: NativeQueryName -> Name

-- | A ScalarType that can be nullable with an optional description
data NullableScalarType (b :: BackendType)
NullableScalarType :: ScalarType b -> Bool -> Maybe Text -> NullableScalarType (b :: BackendType)
[nstType] :: NullableScalarType (b :: BackendType) -> ScalarType b
[nstNullable] :: NullableScalarType (b :: BackendType) -> Bool
[nstDescription] :: NullableScalarType (b :: BackendType) -> Maybe Text
instance GHC.Internal.Data.Data.Data Hasura.NativeQuery.Types.NativeQueryName
instance GHC.Classes.Eq Hasura.NativeQuery.Types.NativeQueryName
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.NativeQuery.Types.NativeQueryName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.NativeQuery.Types.NativeQueryName
instance GHC.Internal.Generics.Generic Hasura.NativeQuery.Types.NativeQueryName
instance Autodocodec.Class.HasCodec Hasura.NativeQuery.Types.NativeQueryName
instance Data.Hashable.Class.Hashable Hasura.NativeQuery.Types.NativeQueryName
instance Language.Haskell.TH.Syntax.Lift Hasura.NativeQuery.Types.NativeQueryName
instance Control.DeepSeq.NFData Hasura.NativeQuery.Types.NativeQueryName
instance GHC.Classes.Ord Hasura.NativeQuery.Types.NativeQueryName
instance GHC.Internal.Show.Show Hasura.NativeQuery.Types.NativeQueryName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.NativeQuery.Types.NativeQueryName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.NativeQuery.Types.NativeQueryName
instance Data.Text.Extended.ToTxt Hasura.NativeQuery.Types.NativeQueryName

module Hasura.RQL.Types.Relationships.Local
type ArrRelDef (b :: BackendType) = RelDef ArrRelUsing b
type ArrRelUsing (b :: BackendType) = RelUsing b ArrRelUsingFKeyOn b
data ArrRelUsingFKeyOn (b :: BackendType)
ArrRelUsingFKeyOn :: TableName b -> NonEmpty (ColumnPath b) -> ArrRelUsingFKeyOn (b :: BackendType)
[arufTable] :: ArrRelUsingFKeyOn (b :: BackendType) -> TableName b
[arufColumns] :: ArrRelUsingFKeyOn (b :: BackendType) -> NonEmpty (ColumnPath b)
data Nullable
Nullable :: Nullable
NotNullable :: Nullable
type ObjRelDef (b :: BackendType) = RelDef ObjRelUsing b
type ObjRelUsing (b :: BackendType) = RelUsing b ObjRelUsingChoice b
data ObjRelUsingChoice (b :: BackendType)
SameTable :: NonEmpty (ColumnPath b) -> ObjRelUsingChoice (b :: BackendType)
RemoteTable :: TableName b -> NonEmpty (ColumnPath b) -> ObjRelUsingChoice (b :: BackendType)
data RelDef a
RelDef :: RelName -> a -> Maybe Text -> RelDef a
[_rdName] :: RelDef a -> RelName
[_rdUsing] :: RelDef a -> a
[_rdComment] :: RelDef a -> Maybe Text
data RelTarget (b :: BackendType)
RelTargetTable :: TableName b -> RelTarget (b :: BackendType)
RelTargetNativeQuery :: NativeQueryName -> RelTarget (b :: BackendType)
newtype RelMapping (b :: BackendType)
RelMapping :: HashMap (ColumnPath b) (ColumnPath b) -> RelMapping (b :: BackendType)
[unRelMapping] :: RelMapping (b :: BackendType) -> HashMap (ColumnPath b) (ColumnPath b)
data RelInfo (b :: BackendType)
RelInfo :: RelName -> RelType -> RelMapping b -> RelTarget b -> Bool -> InsertOrder -> RelInfo (b :: BackendType)
[riName] :: RelInfo (b :: BackendType) -> RelName
[riType] :: RelInfo (b :: BackendType) -> RelType
[riMapping] :: RelInfo (b :: BackendType) -> RelMapping b
[riTarget] :: RelInfo (b :: BackendType) -> RelTarget b
[riIsManual] :: RelInfo (b :: BackendType) -> Bool
[riInsertOrder] :: RelInfo (b :: BackendType) -> InsertOrder
data RelManualConfig (b :: BackendType)
RelManualTableConfig :: RelManualTableConfig b -> RelManualConfig (b :: BackendType)
RelManualNativeQueryConfig :: RelManualNativeQueryConfig b -> RelManualConfig (b :: BackendType)
data RelManualTableConfig (b :: BackendType)
RelManualTableConfigC :: TableName b -> RelManualCommon b -> RelManualTableConfig (b :: BackendType)
[rmtTable] :: RelManualTableConfig (b :: BackendType) -> TableName b
[rmtCommon] :: RelManualTableConfig (b :: BackendType) -> RelManualCommon b
data RelManualNativeQueryConfig (b :: BackendType)
RelManualNativeQueryConfigC :: NativeQueryName -> RelManualCommon b -> RelManualNativeQueryConfig (b :: BackendType)
[rmnNativeQueryName] :: RelManualNativeQueryConfig (b :: BackendType) -> NativeQueryName
[rmnCommon] :: RelManualNativeQueryConfig (b :: BackendType) -> RelManualCommon b
data RelManualCommon (b :: BackendType)
RelManualCommon :: RelMapping b -> Maybe InsertOrder -> RelManualCommon (b :: BackendType)
[rmColumns] :: RelManualCommon (b :: BackendType) -> RelMapping b
[rmInsertOrder] :: RelManualCommon (b :: BackendType) -> Maybe InsertOrder
data RelUsing (b :: BackendType) a
RUFKeyOn :: a -> RelUsing (b :: BackendType) a
RUManual :: RelManualConfig b -> RelUsing (b :: BackendType) a
data WithTable (b :: BackendType) a
WithTable :: SourceName -> TableName b -> a -> WithTable (b :: BackendType) a
[wtSource] :: WithTable (b :: BackendType) a -> SourceName
[wtName] :: WithTable (b :: BackendType) a -> TableName b
[wtInfo] :: WithTable (b :: BackendType) a -> a
boolToNullable :: Bool -> Nullable
fromRel :: RelName -> FieldName
rdComment :: forall a f. Functor f => (Maybe Text -> f (Maybe Text)) -> RelDef a -> f (RelDef a)
rdName :: forall a f. Functor f => (RelName -> f RelName) -> RelDef a -> f (RelDef a)
rdUsing :: forall a1 a2 f. Functor f => (a1 -> f a2) -> RelDef a1 -> f (RelDef a2)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Relationships.Local.ArrRelUsingFKeyOn b)
instance GHC.Classes.Eq Hasura.RQL.Types.Relationships.Local.Nullable
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Relationships.Local.ObjRelUsingChoice b)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.RQL.Types.Relationships.Local.RelDef a)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Relationships.Local.RelInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Relationships.Local.RelManualCommon b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Relationships.Local.RelManualConfig b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Relationships.Local.RelManualNativeQueryConfig b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Relationships.Local.RelManualTableConfig b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Relationships.Local.RelMapping b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Relationships.Local.RelTarget b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq a) => GHC.Classes.Eq (Hasura.RQL.Types.Relationships.Local.RelUsing b a)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq a) => GHC.Classes.Eq (Hasura.RQL.Types.Relationships.Local.WithTable b a)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Relationships.Local.ArrRelUsingFKeyOn b)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Relationships.Local.Nullable
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Relationships.Local.ObjRelUsingChoice b)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Relationships.Local.RelDef a)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Relationships.Local.RelInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Relationships.Local.RelManualConfig b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Relationships.Local.RelManualTableConfig b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Relationships.Local.RelMapping b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Relationships.Local.RelTarget b)
instance (Data.Aeson.Types.FromJSON.FromJSON a, Hasura.RQL.Types.Backend.Backend b) => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Relationships.Local.RelUsing b a)
instance (Data.Aeson.Types.FromJSON.FromJSON a, Hasura.RQL.Types.Backend.Backend b) => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Relationships.Local.WithTable b a)
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Relationships.Local.ArrRelUsingFKeyOn b)
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Relationships.Local.Nullable
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Relationships.Local.ObjRelUsingChoice b)
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Relationships.Local.RelDef a)
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Relationships.Local.RelInfo b)
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Relationships.Local.RelManualCommon b)
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Relationships.Local.RelManualConfig b)
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Relationships.Local.RelManualNativeQueryConfig b)
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Relationships.Local.RelManualTableConfig b)
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Relationships.Local.RelMapping b)
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Relationships.Local.RelTarget b)
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Relationships.Local.RelUsing b a)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Relationships.Local.ArrRelUsingFKeyOn b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Relationships.Local.ObjRelUsingChoice b)
instance (Autodocodec.Class.HasCodec a, GHC.Internal.Data.Typeable.Internal.Typeable a) => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Relationships.Local.RelDef a)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Relationships.Local.RelManualConfig b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Relationships.Local.RelManualNativeQueryConfig b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Relationships.Local.RelManualTableConfig b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Relationships.Local.RelMapping b)
instance (Hasura.RQL.Types.Backend.Backend b, Autodocodec.Class.HasCodec a, GHC.Internal.Data.Typeable.Internal.Typeable a) => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Relationships.Local.RelUsing b a)
instance Autodocodec.Class.HasCodec a => Autodocodec.Class.HasObjectCodec (Hasura.RQL.Types.Relationships.Local.RelDef a)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasObjectCodec (Hasura.RQL.Types.Relationships.Local.RelManualCommon b)
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Relationships.Local.Nullable
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.Relationships.Local.RelInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.Relationships.Local.RelMapping b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.Relationships.Local.RelTarget b)
instance Control.DeepSeq.NFData Hasura.RQL.Types.Relationships.Local.Nullable
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.Types.Relationships.Local.RelInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.Types.Relationships.Local.RelMapping b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.Types.Relationships.Local.RelTarget b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Ord (Hasura.RQL.Types.Relationships.Local.RelInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Ord (Hasura.RQL.Types.Relationships.Local.RelMapping b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Ord (Hasura.RQL.Types.Relationships.Local.RelTarget b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.Types.Relationships.Local.ArrRelUsingFKeyOn b)
instance GHC.Internal.Show.Show Hasura.RQL.Types.Relationships.Local.Nullable
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.Types.Relationships.Local.ObjRelUsingChoice b)
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (Hasura.RQL.Types.Relationships.Local.RelDef a)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.Types.Relationships.Local.RelInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.Types.Relationships.Local.RelManualCommon b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.Types.Relationships.Local.RelManualConfig b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.Types.Relationships.Local.RelManualNativeQueryConfig b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.Types.Relationships.Local.RelManualTableConfig b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.Types.Relationships.Local.RelMapping b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.Types.Relationships.Local.RelTarget b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show a) => GHC.Internal.Show.Show (Hasura.RQL.Types.Relationships.Local.RelUsing b a)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show a) => GHC.Internal.Show.Show (Hasura.RQL.Types.Relationships.Local.WithTable b a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Hasura.RQL.Types.Common.ToAesonPairs (Hasura.RQL.Types.Relationships.Local.RelDef a)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Relationships.Local.ArrRelUsingFKeyOn b)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Relationships.Local.Nullable
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Relationships.Local.ObjRelUsingChoice b)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Relationships.Local.RelDef a)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Relationships.Local.RelInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Relationships.Local.RelManualConfig b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Relationships.Local.RelManualTableConfig b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Relationships.Local.RelMapping b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Relationships.Local.RelTarget b)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.ToJSON.ToJSON a) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Relationships.Local.RelUsing b a)
instance (Hasura.RQL.Types.Common.ToAesonPairs a, Hasura.RQL.Types.Backend.Backend b) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Relationships.Local.WithTable b a)


-- | More leaves cut from RQL.IR.Select for sake of breaking up the big
--   pile of things
module Hasura.RQL.IR.Select.RelationSelect
data AnnRelationSelectG (b :: BackendType) a
AnnRelationSelectG :: RelName -> HashMap (ColumnPath b) (ColumnPath b) -> Nullable -> a -> AnnRelationSelectG (b :: BackendType) a
[_aarRelationshipName] :: AnnRelationSelectG (b :: BackendType) a -> RelName
[_aarColumnMapping] :: AnnRelationSelectG (b :: BackendType) a -> HashMap (ColumnPath b) (ColumnPath b)
[_aarNullable] :: AnnRelationSelectG (b :: BackendType) a -> Nullable
[_aarAnnSelect] :: AnnRelationSelectG (b :: BackendType) a -> a
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq v) => GHC.Classes.Eq (Hasura.RQL.IR.Select.RelationSelect.AnnRelationSelectG b v)
instance GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.Select.RelationSelect.AnnRelationSelectG b)
instance GHC.Internal.Base.Functor (Hasura.RQL.IR.Select.RelationSelect.AnnRelationSelectG b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show v) => GHC.Internal.Show.Show (Hasura.RQL.IR.Select.RelationSelect.AnnRelationSelectG b v)
instance GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.Select.RelationSelect.AnnRelationSelectG b)


-- | Common codecs shared between similar logical model resolvers.
module Hasura.LogicalModelResolver.Codec

-- | Codec for native-query-or-table relationships
nativeQueryRelationshipsCodec :: forall (b :: BackendType). Backend b => Codec Value (InsOrdHashMap RelName (RelDef (RelManualConfig b))) (InsOrdHashMap RelName (RelDef (RelManualConfig b)))
instance (Autodocodec.Class.HasObjectCodec a, Autodocodec.Class.HasObjectCodec b) => Autodocodec.Class.HasObjectCodec (Hasura.LogicalModelResolver.Codec.MergedObject a b)
instance Autodocodec.Class.HasCodec a => Autodocodec.Class.HasObjectCodec (Hasura.LogicalModelResolver.Codec.NameField a)


-- | A name for a logical model as it is recognized by the graphql schema.
module Hasura.LogicalModel.Types
newtype LogicalModelName
LogicalModelName :: Name -> LogicalModelName
[getLogicalModelName] :: LogicalModelName -> Name

-- | a single field in a Logical Model
data LogicalModelField (b :: BackendType)
LogicalModelField :: Column b -> LogicalModelType b -> Maybe Text -> LogicalModelField (b :: BackendType)
[lmfName] :: LogicalModelField (b :: BackendType) -> Column b
[lmfType] :: LogicalModelField (b :: BackendType) -> LogicalModelType b
[lmfDescription] :: LogicalModelField (b :: BackendType) -> Maybe Text
type LogicalModelFields (b :: BackendType) = InsOrdHashMap Column b LogicalModelField b
data LogicalModelType (b :: BackendType)
LogicalModelTypeScalar :: LogicalModelTypeScalar b -> LogicalModelType (b :: BackendType)
LogicalModelTypeArray :: LogicalModelTypeArray b -> LogicalModelType (b :: BackendType)
LogicalModelTypeReference :: LogicalModelTypeReference -> LogicalModelType (b :: BackendType)
data LogicalModelTypeScalar (b :: BackendType)
LogicalModelTypeScalarC :: ScalarType b -> Bool -> LogicalModelTypeScalar (b :: BackendType)
[lmtsScalar] :: LogicalModelTypeScalar (b :: BackendType) -> ScalarType b
[lmtsNullable] :: LogicalModelTypeScalar (b :: BackendType) -> Bool
data LogicalModelTypeArray (b :: BackendType)
LogicalModelTypeArrayC :: LogicalModelType b -> Bool -> LogicalModelTypeArray (b :: BackendType)
[lmtaArray] :: LogicalModelTypeArray (b :: BackendType) -> LogicalModelType b
[lmtaNullable] :: LogicalModelTypeArray (b :: BackendType) -> Bool
data LogicalModelTypeReference
LogicalModelTypeReferenceC :: LogicalModelName -> Bool -> LogicalModelTypeReference
[lmtrReference] :: LogicalModelTypeReference -> LogicalModelName
[lmtrNullable] :: LogicalModelTypeReference -> Bool
logicalModelFieldMapCodec :: forall (b :: BackendType). Backend b => Codec Value (LogicalModelFields b) (LogicalModelFields b)
data LogicalModelLocation
LMLLogicalModel :: LogicalModelName -> LogicalModelLocation
LMLNativeQuery :: NativeQueryName -> LogicalModelLocation
instance GHC.Internal.Data.Data.Data Hasura.LogicalModel.Types.LogicalModelName
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.LogicalModel.Types.LogicalModelField b)
instance GHC.Classes.Eq Hasura.LogicalModel.Types.LogicalModelLocation
instance GHC.Classes.Eq Hasura.LogicalModel.Types.LogicalModelName
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.LogicalModel.Types.LogicalModelType b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.LogicalModel.Types.LogicalModelTypeArray b)
instance GHC.Classes.Eq Hasura.LogicalModel.Types.LogicalModelTypeReference
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.LogicalModel.Types.LogicalModelTypeScalar b)
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.LogicalModel.Types.LogicalModelName
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.LogicalModel.Types.LogicalModelField b)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.LogicalModel.Types.LogicalModelName
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.LogicalModel.Types.LogicalModelType b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.LogicalModel.Types.LogicalModelTypeArray b)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.LogicalModel.Types.LogicalModelTypeReference
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.LogicalModel.Types.LogicalModelTypeScalar b)
instance GHC.Internal.Generics.Generic (Hasura.LogicalModel.Types.LogicalModelField b)
instance GHC.Internal.Generics.Generic Hasura.LogicalModel.Types.LogicalModelLocation
instance GHC.Internal.Generics.Generic Hasura.LogicalModel.Types.LogicalModelName
instance GHC.Internal.Generics.Generic (Hasura.LogicalModel.Types.LogicalModelType b)
instance GHC.Internal.Generics.Generic (Hasura.LogicalModel.Types.LogicalModelTypeArray b)
instance GHC.Internal.Generics.Generic Hasura.LogicalModel.Types.LogicalModelTypeReference
instance GHC.Internal.Generics.Generic (Hasura.LogicalModel.Types.LogicalModelTypeScalar b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.LogicalModel.Types.LogicalModelField b)
instance Autodocodec.Class.HasCodec Hasura.LogicalModel.Types.LogicalModelName
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.LogicalModel.Types.LogicalModelType b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.LogicalModel.Types.LogicalModelTypeArray b)
instance Autodocodec.Class.HasCodec Hasura.LogicalModel.Types.LogicalModelTypeReference
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.LogicalModel.Types.LogicalModelTypeScalar b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.LogicalModel.Types.LogicalModelField b)
instance Data.Hashable.Class.Hashable Hasura.LogicalModel.Types.LogicalModelLocation
instance Data.Hashable.Class.Hashable Hasura.LogicalModel.Types.LogicalModelName
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.LogicalModel.Types.LogicalModelType b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.LogicalModel.Types.LogicalModelTypeArray b)
instance Data.Hashable.Class.Hashable Hasura.LogicalModel.Types.LogicalModelTypeReference
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.LogicalModel.Types.LogicalModelTypeScalar b)
instance Language.Haskell.TH.Syntax.Lift Hasura.LogicalModel.Types.LogicalModelName
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.LogicalModel.Types.LogicalModelField b)
instance Control.DeepSeq.NFData Hasura.LogicalModel.Types.LogicalModelName
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.LogicalModel.Types.LogicalModelType b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.LogicalModel.Types.LogicalModelTypeArray b)
instance Control.DeepSeq.NFData Hasura.LogicalModel.Types.LogicalModelTypeReference
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.LogicalModel.Types.LogicalModelTypeScalar b)
instance GHC.Classes.Ord Hasura.LogicalModel.Types.LogicalModelLocation
instance GHC.Classes.Ord Hasura.LogicalModel.Types.LogicalModelName
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.LogicalModel.Types.LogicalModelField b)
instance GHC.Internal.Show.Show Hasura.LogicalModel.Types.LogicalModelLocation
instance GHC.Internal.Show.Show Hasura.LogicalModel.Types.LogicalModelName
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.LogicalModel.Types.LogicalModelType b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.LogicalModel.Types.LogicalModelTypeArray b)
instance GHC.Internal.Show.Show Hasura.LogicalModel.Types.LogicalModelTypeReference
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.LogicalModel.Types.LogicalModelTypeScalar b)
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.LogicalModel.Types.LogicalModelName
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.LogicalModel.Types.LogicalModelField b)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.LogicalModel.Types.LogicalModelName
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.LogicalModel.Types.LogicalModelType b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.LogicalModel.Types.LogicalModelTypeArray b)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.LogicalModel.Types.LogicalModelTypeReference
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.LogicalModel.Types.LogicalModelTypeScalar b)
instance Data.Text.Extended.ToTxt Hasura.LogicalModel.Types.LogicalModelLocation
instance Data.Text.Extended.ToTxt Hasura.LogicalModel.Types.LogicalModelName

module Hasura.RQL.Types.Column

-- | The type we use for columns, which are currently always “scalars”
--   (though see the note about <a>CollectableType</a>). Unlike
--   <a>ScalarType</a>, which represents a type that a backend knows about,
--   this type characterizes distinctions we make but the backend doesn’t.
data ColumnType (b :: BackendType)

-- | Ordinary Postgres columns.
ColumnScalar :: ScalarType b -> ColumnType (b :: BackendType)

-- | Columns that reference enum tables (see
--   <a>Hasura.RQL.Schema.Enum</a>). This is not actually a distinct type
--   from the perspective of Postgres (at the time of this writing, we
--   ensure they always have type <tt>text</tt>), but we really want to
--   distinguish this case, since we treat it <i>completely</i> differently
--   in the GraphQL schema.
ColumnEnumReference :: EnumReference b -> ColumnType (b :: BackendType)
_ColumnScalar :: forall (b :: BackendType) p f. (Choice p, Applicative f) => p (ScalarType b) (f (ScalarType b)) -> p (ColumnType b) (f (ColumnType b))
_ColumnEnumReference :: forall (b :: BackendType) p f. (Choice p, Applicative f) => p (EnumReference b) (f (EnumReference b)) -> p (ColumnType b) (f (ColumnType b))
isEnumColumn :: forall (b :: BackendType). ColumnType b -> Bool
isScalarColumnWhere :: forall (b :: BackendType). (ScalarType b -> Bool) -> ColumnType b -> Bool

-- | A parser to parse a json value with enforcing column type
type ValueParser (b :: BackendType) (m :: Type -> Type) v = CollectableType ColumnType b -> Value -> m v
onlyNumCols :: forall (b :: BackendType). Backend b => [ColumnInfo b] -> [ColumnInfo b]
isNumCol :: forall (b :: BackendType). Backend b => ColumnInfo b -> Bool
onlyComparableCols :: forall (b :: BackendType). Backend b => [ColumnInfo b] -> [ColumnInfo b]
isComparableCol :: forall (b :: BackendType). Backend b => ColumnInfo b -> Bool

-- | Note: Unconditionally accepts null values and returns <tt>PGNull</tt>.
parseScalarValueColumnTypeWithContext :: forall m (b :: BackendType). (MonadError QErr m, Backend b) => ScalarTypeParsingContext b -> ColumnType b -> Value -> m (ScalarValue b)

-- | Note: Unconditionally accepts null values and returns <tt>PGNull</tt>.
parseScalarValueColumnType :: forall m (b :: BackendType) r. (MonadError QErr m, Backend b, MonadReader r m, Has (ScalarTypeParsingContext b) r) => ColumnType b -> Value -> m (ScalarValue b)
parseScalarValuesColumnTypeWithContext :: forall m (b :: BackendType). (MonadError QErr m, Backend b) => ScalarTypeParsingContext b -> ColumnType b -> [Value] -> m [ScalarValue b]
parseScalarValuesColumnType :: forall m (b :: BackendType) r. (MonadError QErr m, Backend b, MonadReader r m, Has (ScalarTypeParsingContext b) r) => ColumnType b -> [Value] -> m [ScalarValue b]
data ColumnValue (b :: BackendType)
ColumnValue :: ColumnType b -> ScalarValue b -> ColumnValue (b :: BackendType)
[cvType] :: ColumnValue (b :: BackendType) -> ColumnType b
[cvValue] :: ColumnValue (b :: BackendType) -> ScalarValue b

-- | Indicates whether a column may participate in certain mutations.
--   
--   For example, identity columns may sometimes be insertable but rarely
--   updatable, depending on the backend and how they're declared.
--   
--   This guides the schema parsers such that they only generate fields for
--   columns where they're valid without having to model the exact
--   circumstances which cause a column to appear or not.
--   
--   See
--   <a>https://github.com/hasura/graphql-engine/blob/master/rfcs/column-mutability.md</a>.
data ColumnMutability
ColumnMutability :: Bool -> Bool -> ColumnMutability
[_cmIsInsertable] :: ColumnMutability -> Bool
[_cmIsUpdatable] :: ColumnMutability -> Bool

-- | “Resolved” column info, produced from a <a>RawColumnInfo</a> value
--   that has been combined with other schema information to produce a
--   <tt>PGColumnType</tt>.
data ColumnInfo (b :: BackendType)
ColumnInfo :: Column b -> Name -> Int -> ColumnType b -> Bool -> Maybe Description -> ColumnMutability -> ColumnInfo (b :: BackendType)
[ciColumn] :: ColumnInfo (b :: BackendType) -> Column b

-- | field name exposed in GraphQL interface
[ciName] :: ColumnInfo (b :: BackendType) -> Name
[ciPosition] :: ColumnInfo (b :: BackendType) -> Int
[ciType] :: ColumnInfo (b :: BackendType) -> ColumnType b
[ciIsNullable] :: ColumnInfo (b :: BackendType) -> Bool
[ciDescription] :: ColumnInfo (b :: BackendType) -> Maybe Description
[ciMutability] :: ColumnInfo (b :: BackendType) -> ColumnMutability
data NestedObjectInfo (b :: BackendType)
NestedObjectInfo :: XNestedObjects b -> Column b -> Name -> LogicalModelName -> Bool -> Maybe Description -> ColumnMutability -> NestedObjectInfo (b :: BackendType)
[_noiSupportsNestedObjects] :: NestedObjectInfo (b :: BackendType) -> XNestedObjects b
[_noiColumn] :: NestedObjectInfo (b :: BackendType) -> Column b
[_noiName] :: NestedObjectInfo (b :: BackendType) -> Name
[_noiType] :: NestedObjectInfo (b :: BackendType) -> LogicalModelName
[_noiIsNullable] :: NestedObjectInfo (b :: BackendType) -> Bool
[_noiDescription] :: NestedObjectInfo (b :: BackendType) -> Maybe Description
[_noiMutability] :: NestedObjectInfo (b :: BackendType) -> ColumnMutability
data RawColumnType (b :: BackendType)
RawColumnTypeScalar :: ScalarType b -> RawColumnType (b :: BackendType)
RawColumnTypeObject :: XNestedObjects b -> Name -> RawColumnType (b :: BackendType)
RawColumnTypeArray :: XNestedObjects b -> RawColumnType b -> Bool -> RawColumnType (b :: BackendType)

-- | “Raw” column info, as stored in the catalog (but not in the schema
--   cache). Instead of containing a <tt>PGColumnType</tt>, it only
--   contains a <tt>PGScalarType</tt>, which is combined with the
--   <tt>pcirReferences</tt> field and other table data to eventually
--   resolve the type to a <tt>PGColumnType</tt>.
data RawColumnInfo (b :: BackendType)
RawColumnInfo :: Column b -> Int -> RawColumnType b -> Bool -> Maybe Description -> ColumnMutability -> RawColumnInfo (b :: BackendType)
[rciName] :: RawColumnInfo (b :: BackendType) -> Column b

-- | The “ordinal position” of the column according to Postgres. Numbering
--   starts at 1 and increases. Dropping a column does <i>not</i> cause the
--   columns to be renumbered, so a column can be consistently identified
--   by its position.
[rciPosition] :: RawColumnInfo (b :: BackendType) -> Int
[rciType] :: RawColumnInfo (b :: BackendType) -> RawColumnType b
[rciIsNullable] :: RawColumnInfo (b :: BackendType) -> Bool
[rciDescription] :: RawColumnInfo (b :: BackendType) -> Maybe Description
[rciMutability] :: RawColumnInfo (b :: BackendType) -> ColumnMutability
type PrimaryKeyColumns (b :: BackendType) = NESeq ColumnInfo b
getColInfos :: forall (b :: BackendType). Backend b => [Column b] -> [ColumnInfo b] -> [ColumnInfo b]

-- | Represents a reference to an “enum table,” a single-column Postgres
--   table that is referenced via foreign key.
data EnumReference (b :: BackendType)
EnumReference :: TableName b -> EnumValues -> Maybe Name -> EnumReference (b :: BackendType)
[erTable] :: EnumReference (b :: BackendType) -> TableName b
[erValues] :: EnumReference (b :: BackendType) -> EnumValues
[erTableCustomName] :: EnumReference (b :: BackendType) -> Maybe Name
type EnumValues = HashMap EnumValue EnumValueInfo
newtype EnumValue
EnumValue :: Name -> EnumValue
[getEnumValue] :: EnumValue -> Name
newtype EnumValueInfo
EnumValueInfo :: Maybe Text -> EnumValueInfo
[evComment] :: EnumValueInfo -> Maybe Text
fromCol :: forall (b :: BackendType). Backend b => Column b -> FieldName
type ColumnValues (b :: BackendType) a = HashMap Column b a

-- | Represents a reference to a source column, possibly casted an
--   arbitrary number of times. Used within <tt>parseBoolExpOperations</tt>
--   for bookkeeping.
data ColumnReference (b :: BackendType)
ColumnReferenceColumn :: ColumnInfo b -> ColumnReference (b :: BackendType)
ColumnReferenceComputedField :: ComputedFieldName -> ScalarType b -> ColumnReference (b :: BackendType)
ColumnReferenceCast :: ColumnReference b -> ColumnType b -> ColumnReference (b :: BackendType)
columnReferenceType :: forall (backend :: BackendType). ColumnReference backend -> ColumnType backend

-- | Whether the column referred to might be null. Currently we can only
--   tell for references that refer to proper relation columns.
columnReferenceNullable :: forall (b :: BackendType). ColumnReference b -> Maybe Bool
data NestedArrayInfo (b :: BackendType)
NestedArrayInfo :: XNestedObjects b -> Bool -> StructuredColumnInfo b -> NestedArrayInfo (b :: BackendType)
[_naiSupportsNestedArrays] :: NestedArrayInfo (b :: BackendType) -> XNestedObjects b
[_naiIsNullable] :: NestedArrayInfo (b :: BackendType) -> Bool
[_naiColumnInfo] :: NestedArrayInfo (b :: BackendType) -> StructuredColumnInfo b
data StructuredColumnInfo (b :: BackendType)
SCIScalarColumn :: ColumnInfo b -> StructuredColumnInfo (b :: BackendType)
SCIObjectColumn :: NestedObjectInfo b -> StructuredColumnInfo (b :: BackendType)
SCIArrayColumn :: NestedArrayInfo b -> StructuredColumnInfo (b :: BackendType)
_SCIScalarColumn :: forall (b :: BackendType) p f. (Choice p, Applicative f) => p (ColumnInfo b) (f (ColumnInfo b)) -> p (StructuredColumnInfo b) (f (StructuredColumnInfo b))
_SCIObjectColumn :: forall (b :: BackendType) p f. (Choice p, Applicative f) => p (NestedObjectInfo b) (f (NestedObjectInfo b)) -> p (StructuredColumnInfo b) (f (StructuredColumnInfo b))
_SCIArrayColumn :: forall (b :: BackendType) p f. (Choice p, Applicative f) => p (NestedArrayInfo b) (f (NestedArrayInfo b)) -> p (StructuredColumnInfo b) (f (StructuredColumnInfo b))
structuredColumnInfoName :: forall (b :: BackendType). StructuredColumnInfo b -> Name
structuredColumnInfoColumn :: forall (b :: BackendType). StructuredColumnInfo b -> Column b
structuredColumnInfoMutability :: forall (b :: BackendType). StructuredColumnInfo b -> ColumnMutability
toScalarColumnInfo :: forall (b :: BackendType). StructuredColumnInfo b -> Maybe (ColumnInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Column.ColumnInfo b)
instance GHC.Classes.Eq Hasura.RQL.Types.Column.ColumnMutability
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Column.ColumnType b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Column.ColumnValue b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Column.EnumReference b)
instance GHC.Classes.Eq Hasura.RQL.Types.Column.EnumValue
instance GHC.Classes.Eq Hasura.RQL.Types.Column.EnumValueInfo
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Column.NestedArrayInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Column.NestedObjectInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Column.RawColumnInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Column.RawColumnType b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Column.StructuredColumnInfo b)
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.RQL.Types.Column.EnumValue
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Column.ColumnMutability
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Column.EnumReference b)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Column.EnumValue
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Column.EnumValueInfo
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Column.RawColumnInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Column.RawColumnType b)
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Column.ColumnInfo b)
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Column.ColumnMutability
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Column.ColumnType b)
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Column.EnumReference b)
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Column.EnumValue
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Column.EnumValueInfo
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Column.NestedArrayInfo b)
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Column.NestedObjectInfo b)
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Column.RawColumnInfo b)
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Column.RawColumnType b)
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Column.StructuredColumnInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Column.RawColumnType b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.Column.ColumnInfo b)
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Column.ColumnMutability
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.Column.ColumnType b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.Column.EnumReference b)
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Column.EnumValue
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Column.EnumValueInfo
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.Column.NestedArrayInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.Column.NestedObjectInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.Column.RawColumnType b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.Column.StructuredColumnInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.Types.Column.ColumnInfo b)
instance Control.DeepSeq.NFData Hasura.RQL.Types.Column.ColumnMutability
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.Types.Column.ColumnType b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.Types.Column.EnumReference b)
instance Control.DeepSeq.NFData Hasura.RQL.Types.Column.EnumValue
instance Control.DeepSeq.NFData Hasura.RQL.Types.Column.EnumValueInfo
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.Types.Column.NestedArrayInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.Types.Column.NestedObjectInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.Types.Column.RawColumnInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.Types.Column.RawColumnType b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.Types.Column.StructuredColumnInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Ord (Hasura.RQL.Types.Column.ColumnInfo b)
instance GHC.Classes.Ord Hasura.RQL.Types.Column.ColumnMutability
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Ord (Hasura.RQL.Types.Column.ColumnType b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Ord (Hasura.RQL.Types.Column.EnumReference b)
instance GHC.Classes.Ord Hasura.RQL.Types.Column.EnumValue
instance GHC.Classes.Ord Hasura.RQL.Types.Column.EnumValueInfo
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Ord (Hasura.RQL.Types.Column.NestedArrayInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Ord (Hasura.RQL.Types.Column.NestedObjectInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Ord (Hasura.RQL.Types.Column.RawColumnType b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Ord (Hasura.RQL.Types.Column.StructuredColumnInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.Types.Column.ColumnInfo b)
instance GHC.Internal.Show.Show Hasura.RQL.Types.Column.ColumnMutability
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.Types.Column.ColumnType b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.Types.Column.ColumnValue b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.Types.Column.EnumReference b)
instance GHC.Internal.Show.Show Hasura.RQL.Types.Column.EnumValue
instance GHC.Internal.Show.Show Hasura.RQL.Types.Column.EnumValueInfo
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.Types.Column.NestedArrayInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.Types.Column.NestedObjectInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.Types.Column.RawColumnInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.Types.Column.RawColumnType b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.Types.Column.StructuredColumnInfo b)
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.Types.Column.EnumValue
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Column.ColumnInfo b)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Column.ColumnMutability
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Column.ColumnType b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Column.EnumReference b)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Column.EnumValue
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Column.EnumValueInfo
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Column.NestedArrayInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Column.NestedObjectInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Column.RawColumnInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Column.RawColumnType b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Column.StructuredColumnInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Text.Extended.ToTxt (Hasura.RQL.Types.Column.ColumnReference b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Text.Extended.ToTxt (Hasura.RQL.Types.Column.ColumnType b)

module Hasura.RQL.Types.Source.Column
data SourceColumnInfo (b :: BackendType)
SourceColumnInfo :: Column b -> RawColumnType b -> Bool -> Maybe Text -> Bool -> Bool -> Maybe ColumnValueGenerationStrategy -> SourceColumnInfo (b :: BackendType)
[_sciName] :: SourceColumnInfo (b :: BackendType) -> Column b
[_sciType] :: SourceColumnInfo (b :: BackendType) -> RawColumnType b
[_sciNullable] :: SourceColumnInfo (b :: BackendType) -> Bool
[_sciDescription] :: SourceColumnInfo (b :: BackendType) -> Maybe Text
[_sciInsertable] :: SourceColumnInfo (b :: BackendType) -> Bool
[_sciUpdatable] :: SourceColumnInfo (b :: BackendType) -> Bool
[_sciValueGenerated] :: SourceColumnInfo (b :: BackendType) -> Maybe ColumnValueGenerationStrategy
sciName :: forall (b :: BackendType) f. Functor f => (Column b -> f (Column b)) -> SourceColumnInfo b -> f (SourceColumnInfo b)
sciType :: forall (b :: BackendType) f. Functor f => (RawColumnType b -> f (RawColumnType b)) -> SourceColumnInfo b -> f (SourceColumnInfo b)
sciNullable :: forall (b :: BackendType) f. Functor f => (Bool -> f Bool) -> SourceColumnInfo b -> f (SourceColumnInfo b)
sciDescription :: forall (b :: BackendType) f. Functor f => (Maybe Text -> f (Maybe Text)) -> SourceColumnInfo b -> f (SourceColumnInfo b)
sciInsertable :: forall (b :: BackendType) f. Functor f => (Bool -> f Bool) -> SourceColumnInfo b -> f (SourceColumnInfo b)
sciUpdatable :: forall (b :: BackendType) f. Functor f => (Bool -> f Bool) -> SourceColumnInfo b -> f (SourceColumnInfo b)
sciValueGenerated :: forall (b :: BackendType) f. Functor f => (Maybe ColumnValueGenerationStrategy -> f (Maybe ColumnValueGenerationStrategy)) -> SourceColumnInfo b -> f (SourceColumnInfo b)
data ColumnValueGenerationStrategy
AutoIncrement :: ColumnValueGenerationStrategy
UniqueIdentifier :: ColumnValueGenerationStrategy
DefaultValue :: ColumnValueGenerationStrategy
instance GHC.Classes.Eq Hasura.RQL.Types.Source.Column.ColumnValueGenerationStrategy
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Source.Column.SourceColumnInfo b)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Source.Column.ColumnValueGenerationStrategy
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Source.Column.SourceColumnInfo b)
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Source.Column.ColumnValueGenerationStrategy
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Source.Column.SourceColumnInfo b)
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Source.Column.ColumnValueGenerationStrategy
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Source.Column.SourceColumnInfo b)
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Source.Column.ColumnValueGenerationStrategy
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.Source.Column.SourceColumnInfo b)
instance Control.DeepSeq.NFData Hasura.RQL.Types.Source.Column.ColumnValueGenerationStrategy
instance GHC.Classes.Ord Hasura.RQL.Types.Source.Column.ColumnValueGenerationStrategy
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Ord (Hasura.RQL.Types.Source.Column.SourceColumnInfo b)
instance GHC.Internal.Show.Show Hasura.RQL.Types.Source.Column.ColumnValueGenerationStrategy
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.Types.Source.Column.SourceColumnInfo b)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Source.Column.ColumnValueGenerationStrategy
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Source.Column.SourceColumnInfo b)
instance Data.OpenApi.Internal.Schema.ToSchema Hasura.RQL.Types.Source.Column.ColumnValueGenerationStrategy
instance Hasura.RQL.Types.Backend.Backend b => Data.OpenApi.Internal.Schema.ToSchema (Hasura.RQL.Types.Source.Column.SourceColumnInfo b)

module Hasura.RQL.IR.Value
data UnpreparedValue (b :: BackendType)

-- | A SQL value that can be parameterized over.
UVParameter :: Provenance -> ColumnValue b -> UnpreparedValue (b :: BackendType)

-- | A literal SQL expression that <i>cannot</i> be parameterized over.
UVLiteral :: SQLExpression b -> UnpreparedValue (b :: BackendType)

-- | The entire session variables JSON object.
UVSession :: UnpreparedValue (b :: BackendType)

-- | A single session variable.
UVSessionVar :: SessionVarType b -> SessionVariable -> UnpreparedValue (b :: BackendType)

-- | Where did this variable come from?
data Provenance
FromGraphQL :: VariableInfo -> Provenance

-- | An internal source
FromInternal :: Text -> Provenance

-- | A unique, fresh occurrence of a variable. E.g. a native query
--   argument, or generated values that benefit from being prepared rather
--   than inlined.
FreshVar :: Provenance

-- | This indicates whether a variable value came from a certain GraphQL
--   variable
data ValueWithOrigin a
ValueWithOrigin :: VariableInfo -> a -> ValueWithOrigin a
ValueNoOrigin :: a -> ValueWithOrigin a
openValueOrigin :: ValueWithOrigin a -> a
mkParameter :: forall (b :: BackendType). ValueWithOrigin (ColumnValue b) -> UnpreparedValue b
instance GHC.Classes.Eq Hasura.RQL.IR.Value.Provenance
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.IR.Value.UnpreparedValue b)
instance GHC.Internal.Base.Functor Hasura.RQL.IR.Value.ValueWithOrigin
instance GHC.Internal.Show.Show Hasura.RQL.IR.Value.Provenance
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.IR.Value.UnpreparedValue b)


-- | Common types shared between similar logical model resolvers.
module Hasura.LogicalModelResolver.Types

-- | A name of an argument to a native query or stored procedure.
newtype ArgumentName
ArgumentName :: Text -> ArgumentName
[getArgumentName] :: ArgumentName -> Text

-- | A ScalarType that can be nullable with an optional description
data NullableScalarType (b :: BackendType)
NullableScalarType :: ScalarType b -> Bool -> Maybe Text -> NullableScalarType (b :: BackendType)
[nstType] :: NullableScalarType (b :: BackendType) -> ScalarType b
[nstNullable] :: NullableScalarType (b :: BackendType) -> Bool
[nstDescription] :: NullableScalarType (b :: BackendType) -> Maybe Text
nullableScalarTypeMapCodec :: forall (b :: BackendType). Backend b => Codec Value (InsOrdHashMap (Column b) (NullableScalarType b)) (InsOrdHashMap (Column b) (NullableScalarType b))
instance GHC.Classes.Eq Hasura.LogicalModelResolver.Types.ArgumentName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.LogicalModelResolver.Types.ArgumentName
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.LogicalModelResolver.Types.ArgumentName
instance GHC.Internal.Generics.Generic Hasura.LogicalModelResolver.Types.ArgumentName
instance Autodocodec.Class.HasCodec Hasura.LogicalModelResolver.Types.ArgumentName
instance Data.Hashable.Class.Hashable Hasura.LogicalModelResolver.Types.ArgumentName
instance Control.DeepSeq.NFData Hasura.LogicalModelResolver.Types.ArgumentName
instance GHC.Classes.Ord Hasura.LogicalModelResolver.Types.ArgumentName
instance GHC.Internal.Show.Show Hasura.LogicalModelResolver.Types.ArgumentName
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.LogicalModelResolver.Types.ArgumentName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.LogicalModelResolver.Types.ArgumentName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.LogicalModelResolver.Types.ArgumentName


-- | Parser and prettyprinter for native query code.
module Hasura.NativeQuery.InterpolatedQuery

-- | A name of an argument to a native query or stored procedure.
newtype ArgumentName
ArgumentName :: Text -> ArgumentName
[getArgumentName] :: ArgumentName -> Text

-- | A component of an interpolated query
data InterpolatedItem variable

-- | normal text
IIText :: Text -> InterpolatedItem variable

-- | a captured variable
IIVariable :: variable -> InterpolatedItem variable

-- | A list of stored procedure components representing a single stored
--   procedure, separating the variables from the text.
newtype InterpolatedQuery variable
InterpolatedQuery :: [InterpolatedItem variable] -> InterpolatedQuery variable
[getInterpolatedQuery] :: InterpolatedQuery variable -> [InterpolatedItem variable]

-- | extract all of the `{{ variable }}` inside our query string
parseInterpolatedQuery :: Text -> Either Text (InterpolatedQuery ArgumentName)

-- | Get a set of all arguments used in an interpolated query.
getUniqueVariables :: Ord var => InterpolatedQuery var -> Set var

-- | Remove spaces and semicolon from the end of a query and add a newline,
--   for sql backends.
trimQueryEnd :: InterpolatedQuery var -> InterpolatedQuery var
ppInterpolatedQuery :: InterpolatedQuery ArgumentName -> Text
instance GHC.Internal.Data.Data.Data variable => GHC.Internal.Data.Data.Data (Hasura.NativeQuery.InterpolatedQuery.InterpolatedItem variable)
instance GHC.Internal.Data.Data.Data variable => GHC.Internal.Data.Data.Data (Hasura.NativeQuery.InterpolatedQuery.InterpolatedQuery variable)
instance GHC.Classes.Eq variable => GHC.Classes.Eq (Hasura.NativeQuery.InterpolatedQuery.InterpolatedItem variable)
instance GHC.Classes.Eq variable => GHC.Classes.Eq (Hasura.NativeQuery.InterpolatedQuery.InterpolatedQuery variable)
instance GHC.Classes.Eq Hasura.NativeQuery.InterpolatedQuery.RawQuery
instance GHC.Internal.Data.Foldable.Foldable Hasura.NativeQuery.InterpolatedQuery.InterpolatedItem
instance GHC.Internal.Data.Foldable.Foldable Hasura.NativeQuery.InterpolatedQuery.InterpolatedQuery
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.NativeQuery.InterpolatedQuery.RawQuery
instance GHC.Internal.Base.Functor Hasura.NativeQuery.InterpolatedQuery.InterpolatedItem
instance GHC.Internal.Base.Functor Hasura.NativeQuery.InterpolatedQuery.InterpolatedQuery
instance GHC.Internal.Generics.Generic (Hasura.NativeQuery.InterpolatedQuery.InterpolatedItem variable)
instance GHC.Internal.Generics.Generic (Hasura.NativeQuery.InterpolatedQuery.InterpolatedQuery variable)
instance (v GHC.Types.~ Hasura.LogicalModelResolver.Types.ArgumentName) => Autodocodec.Class.HasCodec (Hasura.NativeQuery.InterpolatedQuery.InterpolatedQuery v)
instance Autodocodec.Class.HasCodec Hasura.NativeQuery.InterpolatedQuery.RawQuery
instance Data.Hashable.Class.Hashable variable => Data.Hashable.Class.Hashable (Hasura.NativeQuery.InterpolatedQuery.InterpolatedItem variable)
instance Data.Hashable.Class.Hashable variable => Data.Hashable.Class.Hashable (Hasura.NativeQuery.InterpolatedQuery.InterpolatedQuery variable)
instance Language.Haskell.TH.Syntax.Lift variable => Language.Haskell.TH.Syntax.Lift (Hasura.NativeQuery.InterpolatedQuery.InterpolatedItem variable)
instance Language.Haskell.TH.Syntax.Lift variable => Language.Haskell.TH.Syntax.Lift (Hasura.NativeQuery.InterpolatedQuery.InterpolatedQuery variable)
instance Control.DeepSeq.NFData variable => Control.DeepSeq.NFData (Hasura.NativeQuery.InterpolatedQuery.InterpolatedItem variable)
instance Control.DeepSeq.NFData variable => Control.DeepSeq.NFData (Hasura.NativeQuery.InterpolatedQuery.InterpolatedQuery variable)
instance GHC.Classes.Ord variable => GHC.Classes.Ord (Hasura.NativeQuery.InterpolatedQuery.InterpolatedItem variable)
instance GHC.Classes.Ord variable => GHC.Classes.Ord (Hasura.NativeQuery.InterpolatedQuery.InterpolatedQuery variable)
instance GHC.Classes.Ord Hasura.NativeQuery.InterpolatedQuery.RawQuery
instance GHC.Internal.Show.Show variable => GHC.Internal.Show.Show (Hasura.NativeQuery.InterpolatedQuery.InterpolatedItem variable)
instance GHC.Internal.Show.Show variable => GHC.Internal.Show.Show (Hasura.NativeQuery.InterpolatedQuery.InterpolatedQuery variable)
instance GHC.Internal.Show.Show Hasura.NativeQuery.InterpolatedQuery.RawQuery
instance (v GHC.Types.~ Hasura.LogicalModelResolver.Types.ArgumentName) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.NativeQuery.InterpolatedQuery.InterpolatedQuery v)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.NativeQuery.InterpolatedQuery.RawQuery
instance GHC.Internal.Data.Traversable.Traversable Hasura.NativeQuery.InterpolatedQuery.InterpolatedItem
instance GHC.Internal.Data.Traversable.Traversable Hasura.NativeQuery.InterpolatedQuery.InterpolatedQuery

module Hasura.LogicalModel.IR

-- | Description of a logical model for use in IR
data LogicalModel (b :: BackendType)
LogicalModel :: LogicalModelName -> InsOrdHashMap (Column b) (LogicalModelField b) -> LogicalModel (b :: BackendType)
[lmName] :: LogicalModel (b :: BackendType) -> LogicalModelName
[lmFields] :: LogicalModel (b :: BackendType) -> InsOrdHashMap (Column b) (LogicalModelField b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.LogicalModel.IR.LogicalModel b)
instance GHC.Internal.Generics.Generic (Hasura.LogicalModel.IR.LogicalModel b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.LogicalModel.IR.LogicalModel b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.LogicalModel.IR.LogicalModel b)


-- | types and helpers for user-defined-functions after they have been
--   resolved in the schema cache
module Hasura.Function.Cache
type DBFunctionsMetadata (b :: BackendType) = HashMap FunctionName b FunctionOverloads b
newtype FunctionOverloads (b :: BackendType)
FunctionOverloads :: NonEmpty (RawFunctionInfo b) -> FunctionOverloads (b :: BackendType)
[getFunctionOverloads] :: FunctionOverloads (b :: BackendType) -> NonEmpty (RawFunctionInfo b)
newtype FunctionArgName
FunctionArgName :: Text -> FunctionArgName
[getFuncArgNameTxt] :: FunctionArgName -> Text
type FunctionCache (b :: BackendType) = HashMap FunctionName b FunctionInfo b

-- | Tracked function configuration, and payload of the
--   <tt>pg_track_function</tt> and <tt>pg_set_function_customization</tt>
--   API calls.
data FunctionConfig (b :: BackendType)
FunctionConfig :: Maybe FunctionArgName -> Maybe FunctionExposedAs -> FunctionCustomRootFields -> Maybe Name -> Maybe (FunctionReturnType b) -> FunctionConfig (b :: BackendType)
[_fcSessionArgument] :: FunctionConfig (b :: BackendType) -> Maybe FunctionArgName

-- | In which top-level field should we expose this function?
--   
--   The user might omit this, in which case we'll infer the location from
--   the SQL functions volatility. See <tt>mkFunctionInfo</tt> or the
--   <tt>track_function</tt> API docs for details of validation, etc.
[_fcExposedAs] :: FunctionConfig (b :: BackendType) -> Maybe FunctionExposedAs
[_fcCustomRootFields] :: FunctionConfig (b :: BackendType) -> FunctionCustomRootFields
[_fcCustomName] :: FunctionConfig (b :: BackendType) -> Maybe Name
[_fcResponse] :: FunctionConfig (b :: BackendType) -> Maybe (FunctionReturnType b)

-- | Custom root fields for functions. When set, will be the names exposed
--   to the user in the schema.
--   
--   See rfcs/function-root-field-customisation.md for more information.
data FunctionCustomRootFields
FunctionCustomRootFields :: Maybe Name -> Maybe Name -> FunctionCustomRootFields
[_fcrfFunction] :: FunctionCustomRootFields -> Maybe Name
[_fcrfFunctionAggregate] :: FunctionCustomRootFields -> Maybe Name

-- | Indicates whether the user requested the corresponding function to be
--   tracked as a mutation or a query/subscription, in
--   <tt>track_function</tt>.
data FunctionExposedAs
FEAQuery :: FunctionExposedAs
FEAMutation :: FunctionExposedAs

-- | Tracked SQL function metadata. See <tt>buildFunctionInfo</tt>.
data FunctionInfo (b :: BackendType)
FunctionInfo :: FunctionName b -> Name -> Name -> Name -> SystemDefined -> FunctionVolatility -> FunctionExposedAs -> Seq (FunctionInputArgument b) -> TableName b -> Maybe Text -> FunctionPermissionsMap -> JsonAggSelect -> Maybe Text -> FunctionInfo (b :: BackendType)
[_fiSQLName] :: FunctionInfo (b :: BackendType) -> FunctionName b
[_fiGQLName] :: FunctionInfo (b :: BackendType) -> Name
[_fiGQLArgsName] :: FunctionInfo (b :: BackendType) -> Name
[_fiGQLAggregateName] :: FunctionInfo (b :: BackendType) -> Name
[_fiSystemDefined] :: FunctionInfo (b :: BackendType) -> SystemDefined
[_fiVolatility] :: FunctionInfo (b :: BackendType) -> FunctionVolatility

-- | In which part of the schema should this function be exposed?
--   
--   See <tt>mkFunctionInfo</tt> and <a>_fcExposedAs</a>.
[_fiExposedAs] :: FunctionInfo (b :: BackendType) -> FunctionExposedAs
[_fiInputArgs] :: FunctionInfo (b :: BackendType) -> Seq (FunctionInputArgument b)

-- | NOTE: when a table is created, a new composite type of the same name
--   is automatically created; so strictly speaking this field means "the
--   function returns the composite type corresponding to this table".
[_fiReturnType] :: FunctionInfo (b :: BackendType) -> TableName b

-- | this field represents the description of the function as present on
--   the database
[_fiDescription] :: FunctionInfo (b :: BackendType) -> Maybe Text

-- | Roles to which the function is accessible
[_fiPermissions] :: FunctionInfo (b :: BackendType) -> FunctionPermissionsMap
[_fiJsonAggSelect] :: FunctionInfo (b :: BackendType) -> JsonAggSelect
[_fiComment] :: FunctionInfo (b :: BackendType) -> Maybe Text
type FunctionInputArgument (b :: BackendType) = InputArgument FunctionArgument b
newtype FunctionPermissionInfo
FunctionPermissionInfo :: RoleName -> FunctionPermissionInfo
[_fpmRole] :: FunctionPermissionInfo -> RoleName
type FunctionPermissionsMap = HashMap RoleName FunctionPermissionInfo

-- | <a>https://www.postgresql.org/docs/current/xfunc-volatility.html</a>
data FunctionVolatility
FTVOLATILE :: FunctionVolatility
FTIMMUTABLE :: FunctionVolatility
FTSTABLE :: FunctionVolatility
data InputArgument a
IAUserProvided :: a -> InputArgument a
IASessionVariables :: FunctionArgName -> InputArgument a
data FunctionArgsExpG a
FunctionArgsExp :: [a] -> HashMap Text a -> FunctionArgsExpG a
[_faePositional] :: FunctionArgsExpG a -> [a]
[_faeNamed] :: FunctionArgsExpG a -> HashMap Text a
type FunctionArgsExp (b :: BackendType) v = FunctionArgsExpG FunctionArgumentExp b v
data TrackableFunctionInfo (b :: BackendType)
TrackableFunctionInfo :: FunctionName b -> FunctionVolatility -> TrackableFunctionInfo (b :: BackendType)
[tfiFunctionName] :: TrackableFunctionInfo (b :: BackendType) -> FunctionName b
[tfiFunctionVolitility] :: TrackableFunctionInfo (b :: BackendType) -> FunctionVolatility
newtype TrackableTableInfo (b :: BackendType)
TrackableTableInfo :: TableName b -> TrackableTableInfo (b :: BackendType)
[tfTableiName] :: TrackableTableInfo (b :: BackendType) -> TableName b
data TrackableInfo (b :: BackendType)
TrackableInfo :: [TrackableFunctionInfo b] -> [TrackableTableInfo b] -> TrackableInfo (b :: BackendType)
[trackableFunctions] :: TrackableInfo (b :: BackendType) -> [TrackableFunctionInfo b]
[trackableTables] :: TrackableInfo (b :: BackendType) -> [TrackableTableInfo b]

-- | The default function config; v1 of the API implies this.
emptyFunctionConfig :: forall (b :: BackendType). FunctionConfig b

-- | A function custom root fields without custom names set. This is the
--   default.
emptyFunctionCustomRootFields :: FunctionCustomRootFields
funcTypToTxt :: FunctionVolatility -> Text
emptyFunctionArgsExp :: FunctionArgsExpG a
instance GHC.Internal.Data.Data.Data Hasura.Function.Cache.FunctionArgName
instance GHC.Classes.Eq Hasura.Function.Cache.FunctionArgName
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.Function.Cache.FunctionArgsExpG a)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.Function.Cache.FunctionConfig b)
instance GHC.Classes.Eq Hasura.Function.Cache.FunctionCustomRootFields
instance GHC.Classes.Eq Hasura.Function.Cache.FunctionExposedAs
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.Function.Cache.FunctionInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.Function.Cache.FunctionOverloads b)
instance GHC.Classes.Eq Hasura.Function.Cache.FunctionPermissionInfo
instance GHC.Classes.Eq Hasura.Function.Cache.FunctionVolatility
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.Function.Cache.InputArgument a)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.Function.Cache.TrackableFunctionInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.Function.Cache.TrackableInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.Function.Cache.TrackableTableInfo b)
instance GHC.Internal.Data.Foldable.Foldable Hasura.Function.Cache.FunctionArgsExpG
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Function.Cache.FunctionArgName
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Function.Cache.FunctionConfig b)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Function.Cache.FunctionCustomRootFields
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Function.Cache.FunctionExposedAs
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Backend.RawFunctionInfo b) => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Function.Cache.FunctionOverloads b)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Function.Cache.FunctionPermissionInfo
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Function.Cache.FunctionVolatility
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.Function.Cache.FunctionArgName
instance GHC.Internal.Base.Functor Hasura.Function.Cache.FunctionArgsExpG
instance GHC.Internal.Base.Functor Hasura.Function.Cache.InputArgument
instance GHC.Internal.Generics.Generic Hasura.Function.Cache.FunctionArgName
instance GHC.Internal.Generics.Generic (Hasura.Function.Cache.FunctionArgsExpG a)
instance GHC.Internal.Generics.Generic (Hasura.Function.Cache.FunctionConfig b)
instance GHC.Internal.Generics.Generic Hasura.Function.Cache.FunctionCustomRootFields
instance GHC.Internal.Generics.Generic Hasura.Function.Cache.FunctionExposedAs
instance GHC.Internal.Generics.Generic (Hasura.Function.Cache.FunctionInfo b)
instance GHC.Internal.Generics.Generic Hasura.Function.Cache.FunctionPermissionInfo
instance GHC.Internal.Generics.Generic Hasura.Function.Cache.FunctionVolatility
instance GHC.Internal.Generics.Generic (Hasura.Function.Cache.InputArgument a)
instance GHC.Internal.Generics.Generic (Hasura.Function.Cache.TrackableFunctionInfo b)
instance GHC.Internal.Generics.Generic (Hasura.Function.Cache.TrackableInfo b)
instance GHC.Internal.Generics.Generic (Hasura.Function.Cache.TrackableTableInfo b)
instance Autodocodec.Class.HasCodec Hasura.Function.Cache.FunctionArgName
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.Function.Cache.FunctionConfig b)
instance Autodocodec.Class.HasCodec Hasura.Function.Cache.FunctionCustomRootFields
instance Autodocodec.Class.HasCodec Hasura.Function.Cache.FunctionExposedAs
instance Autodocodec.Class.HasCodec Hasura.Function.Cache.FunctionPermissionInfo
instance Data.Hashable.Class.Hashable Hasura.Function.Cache.FunctionArgName
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.Function.Cache.FunctionArgsExpG a)
instance GHC.Internal.Data.String.IsString Hasura.Function.Cache.FunctionArgName
instance Language.Haskell.TH.Syntax.Lift Hasura.Function.Cache.FunctionArgName
instance Control.DeepSeq.NFData Hasura.Function.Cache.FunctionArgName
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.Function.Cache.FunctionArgsExpG a)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.Function.Cache.FunctionConfig b)
instance Control.DeepSeq.NFData Hasura.Function.Cache.FunctionCustomRootFields
instance Control.DeepSeq.NFData Hasura.Function.Cache.FunctionExposedAs
instance Control.DeepSeq.NFData Hasura.Function.Cache.FunctionVolatility
instance GHC.Classes.Ord Hasura.Function.Cache.FunctionArgName
instance GHC.Internal.Show.Show Hasura.Function.Cache.FunctionArgName
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (Hasura.Function.Cache.FunctionArgsExpG a)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.Function.Cache.FunctionConfig b)
instance GHC.Internal.Show.Show Hasura.Function.Cache.FunctionCustomRootFields
instance GHC.Internal.Show.Show Hasura.Function.Cache.FunctionExposedAs
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.Function.Cache.FunctionInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.Function.Cache.FunctionOverloads b)
instance GHC.Internal.Show.Show Hasura.Function.Cache.FunctionPermissionInfo
instance GHC.Internal.Show.Show Hasura.Function.Cache.FunctionVolatility
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (Hasura.Function.Cache.InputArgument a)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.Function.Cache.TrackableFunctionInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.Function.Cache.TrackableInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.Function.Cache.TrackableTableInfo b)
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Function.Cache.FunctionArgName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Function.Cache.FunctionArgName
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Function.Cache.FunctionConfig b)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Function.Cache.FunctionCustomRootFields
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Function.Cache.FunctionExposedAs
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Function.Cache.FunctionInfo b)
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Backend.RawFunctionInfo b) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Function.Cache.FunctionOverloads b)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Function.Cache.FunctionPermissionInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Function.Cache.FunctionVolatility
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Function.Cache.InputArgument a)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Function.Cache.TrackableFunctionInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Function.Cache.TrackableInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Function.Cache.TrackableTableInfo b)
instance Data.Text.Extended.ToTxt Hasura.Function.Cache.FunctionArgName
instance GHC.Internal.Data.Traversable.Traversable Hasura.Function.Cache.FunctionArgsExpG


-- | Types for storing user-defined-functions in metadata
module Hasura.Function.Metadata
data FunctionMetadata (b :: BackendType)
FunctionMetadata :: FunctionName b -> FunctionConfig b -> [FunctionPermissionInfo] -> Maybe Text -> FunctionMetadata (b :: BackendType)
[_fmFunction] :: FunctionMetadata (b :: BackendType) -> FunctionName b
[_fmConfiguration] :: FunctionMetadata (b :: BackendType) -> FunctionConfig b
[_fmPermissions] :: FunctionMetadata (b :: BackendType) -> [FunctionPermissionInfo]
[_fmComment] :: FunctionMetadata (b :: BackendType) -> Maybe Text
fmComment :: forall (b :: BackendType) f. Functor f => (Maybe Text -> f (Maybe Text)) -> FunctionMetadata b -> f (FunctionMetadata b)
fmConfiguration :: forall (b :: BackendType) f. Functor f => (FunctionConfig b -> f (FunctionConfig b)) -> FunctionMetadata b -> f (FunctionMetadata b)
fmFunction :: forall (b :: BackendType) f. Functor f => (FunctionName b -> f (FunctionName b)) -> FunctionMetadata b -> f (FunctionMetadata b)
fmPermissions :: forall (b :: BackendType) f. Functor f => ([FunctionPermissionInfo] -> f [FunctionPermissionInfo]) -> FunctionMetadata b -> f (FunctionMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.Function.Metadata.FunctionMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Function.Metadata.FunctionMetadata b)
instance GHC.Internal.Generics.Generic (Hasura.Function.Metadata.FunctionMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.Function.Metadata.FunctionMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.Function.Metadata.FunctionMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Function.Metadata.FunctionMetadata b)

module Hasura.Function.Lenses
fiComment :: forall (b :: BackendType) f. Functor f => (Maybe Text -> f (Maybe Text)) -> FunctionInfo b -> f (FunctionInfo b)
fiDescription :: forall (b :: BackendType) f. Functor f => (Maybe Text -> f (Maybe Text)) -> FunctionInfo b -> f (FunctionInfo b)
fiExposedAs :: forall (b :: BackendType) f. Functor f => (FunctionExposedAs -> f FunctionExposedAs) -> FunctionInfo b -> f (FunctionInfo b)
fiGQLAggregateName :: forall (b :: BackendType) f. Functor f => (Name -> f Name) -> FunctionInfo b -> f (FunctionInfo b)
fiGQLArgsName :: forall (b :: BackendType) f. Functor f => (Name -> f Name) -> FunctionInfo b -> f (FunctionInfo b)
fiGQLName :: forall (b :: BackendType) f. Functor f => (Name -> f Name) -> FunctionInfo b -> f (FunctionInfo b)
fiInputArgs :: forall (b :: BackendType) f. Functor f => (Seq (FunctionInputArgument b) -> f (Seq (FunctionInputArgument b))) -> FunctionInfo b -> f (FunctionInfo b)
fiJsonAggSelect :: forall (b :: BackendType) f. Functor f => (JsonAggSelect -> f JsonAggSelect) -> FunctionInfo b -> f (FunctionInfo b)
fiPermissions :: forall (b :: BackendType) f. Functor f => (FunctionPermissionsMap -> f FunctionPermissionsMap) -> FunctionInfo b -> f (FunctionInfo b)
fiReturnType :: forall (b :: BackendType) f. Functor f => (TableName b -> f (TableName b)) -> FunctionInfo b -> f (FunctionInfo b)
fiSQLName :: forall (b :: BackendType) f. Functor f => (FunctionName b -> f (FunctionName b)) -> FunctionInfo b -> f (FunctionInfo b)
fiSystemDefined :: forall (b :: BackendType) f. Functor f => (SystemDefined -> f SystemDefined) -> FunctionInfo b -> f (FunctionInfo b)
fiVolatility :: forall (b :: BackendType) f. Functor f => (FunctionVolatility -> f FunctionVolatility) -> FunctionInfo b -> f (FunctionInfo b)
fpmRole :: Iso' FunctionPermissionInfo RoleName
_IASessionVariables :: forall a p f. (Choice p, Applicative f) => p FunctionArgName (f FunctionArgName) -> p (InputArgument a) (f (InputArgument a))
_IAUserProvided :: forall a1 a2 p f. (Choice p, Applicative f) => p a1 (f a2) -> p (InputArgument a1) (f (InputArgument a2))

module Hasura.Function.Common

-- | Apply function name customization to the aggregate function variation,
--   as detailed in 'rfcs/function-root-field-customisation.md'.
getFunctionAggregateGQLName :: forall (b :: BackendType). Name -> FunctionConfig b -> (Name -> Name) -> Name

-- | Apply function name customization to function arguments, as detailed
--   in 'rfcs/function-root-field-customisation.md'. We want the different
--   variations of a function (i.e. basic, aggregate) to share the same
--   type name for their arguments.
getFunctionArgsGQLName :: forall (b :: BackendType). Name -> FunctionConfig b -> (Name -> Name) -> Name

-- | Apply function name customization to the basic function variation, as
--   detailed in 'rfcs/function-root-field-customisation.md'.
getFunctionGQLName :: forall (b :: BackendType). Name -> FunctionConfig b -> (Name -> Name) -> Name
getInputArgs :: forall (b :: BackendType). FunctionInfo b -> Seq (FunctionArgument b)


-- | Postgres SQL Types
--   
--   Combinators and helpers for dealing with Postgres types such as
--   strings, numerals, geography and geometry, etc.
module Hasura.Backends.Postgres.SQL.Types
pgFmtLit :: Text -> Text
pgFmtIdentifier :: Text -> Text
isView :: TableType -> Bool

-- | Represents a database table qualified with the schema name.
type QualifiedTable = QualifiedObject TableName
type QualifiedFunction = QualifiedObject FunctionName
newtype PGDescription
PGDescription :: Text -> PGDescription
[getPGDescription] :: PGDescription -> Text
data PGCol
unsafePGCol :: Text -> PGCol
getPGColTxt :: PGCol -> Text
showPGCols :: (Foldable t, Functor t) => t PGCol -> Text
isNumType :: PGScalarType -> Bool
stringTypes :: [PGScalarType]
isStringType :: PGScalarType -> Bool
isJSONType :: PGScalarType -> Bool
isComparableType :: PGScalarType -> Bool
isBigNum :: PGScalarType -> Bool
geoTypes :: [PGScalarType]
isGeoType :: PGScalarType -> Bool
class IsIdentifier a
toIdentifier :: IsIdentifier a => a -> Identifier
newtype Identifier
Identifier :: Text -> Identifier
[getIdenTxt] :: Identifier -> Text

-- | The type of identifiers representing scalar values
newtype ColumnIdentifier
ColumnIdentifier :: Text -> ColumnIdentifier
[unColumnIdentifier] :: ColumnIdentifier -> Text

-- | The type of identifiers representing tabular values. While we are
--   transitioning away from <a>Identifier</a> we provisionally export the
--   value constructor.
newtype TableIdentifier
TableIdentifier :: Text -> TableIdentifier
[unTableIdentifier] :: TableIdentifier -> Text
newtype SchemaName
SchemaName :: Text -> SchemaName
[getSchemaTxt] :: SchemaName -> Text
publicSchema :: SchemaName
hdbCatalogSchema :: SchemaName
newtype TableName
TableName :: Text -> TableName
[getTableTxt] :: TableName -> Text
newtype FunctionName
FunctionName :: Text -> FunctionName
[getFunctionTxt] :: FunctionName -> Text
newtype ConstraintName
ConstraintName :: Text -> ConstraintName
[getConstraintTxt] :: ConstraintName -> Text
data QualifiedObject a
QualifiedObject :: SchemaName -> a -> QualifiedObject a
[qSchema] :: QualifiedObject a -> SchemaName
[qName] :: QualifiedObject a -> a
getIdentifierQualifiedObject :: ToTxt a => QualifiedObject a -> Either QErr GQLNameIdentifier
qualifiedObjectToText :: ToTxt a => QualifiedObject a -> Text
snakeCaseQualifiedObject :: ToTxt a => QualifiedObject a -> Text
namingConventionSupport :: SupportedNamingCase
qualifiedObjectToName :: (ToTxt a, MonadError QErr m) => QualifiedObject a -> m Name
data PGScalarType
PGSmallInt :: PGScalarType
PGInteger :: PGScalarType
PGBigInt :: PGScalarType
PGSerial :: PGScalarType
PGBigSerial :: PGScalarType
PGFloat :: PGScalarType
PGDouble :: PGScalarType
PGNumeric :: PGScalarType
PGMoney :: PGScalarType
PGBoolean :: PGScalarType
PGChar :: PGScalarType
PGVarchar :: PGScalarType
PGText :: PGScalarType
PGCitext :: PGScalarType
PGDate :: PGScalarType
PGTimeStamp :: PGScalarType
PGTimeStampTZ :: PGScalarType
PGTimeTZ :: PGScalarType
PGJSON :: PGScalarType
PGJSONB :: PGScalarType
PGGeometry :: PGScalarType
PGGeography :: PGScalarType
PGRaster :: PGScalarType
PGUUID :: PGScalarType
PGLtree :: PGScalarType
PGLquery :: PGScalarType
PGLtxtquery :: PGScalarType
PGArray :: PGScalarType -> PGScalarType
PGUnknown :: Text -> PGScalarType
PGCompositeScalar :: Text -> PGScalarType
PGEnumScalar :: Text -> PGScalarType
textToPGScalarType :: Text -> PGScalarType
pgScalarTranslations :: [(Text, PGScalarType)]
pgScalarTypeToText :: PGScalarType -> Text
data PGTypeKind
PGKindBase :: PGTypeKind
PGKindComposite :: PGTypeKind
PGKindDomain :: PGTypeKind
PGKindEnum :: PGTypeKind
PGKindRange :: PGTypeKind
PGKindPseudo :: PGTypeKind
PGKindUnknown :: Text -> PGTypeKind
data QualifiedPGType
QualifiedPGType :: SchemaName -> PGScalarType -> PGTypeKind -> QualifiedPGType
[_qptSchema] :: QualifiedPGType -> SchemaName
[_qptName] :: QualifiedPGType -> PGScalarType
[_qptType] :: QualifiedPGType -> PGTypeKind
isBaseType :: QualifiedPGType -> Bool
typeToTable :: QualifiedPGType -> QualifiedTable
mkFunctionArgScalarType :: QualifiedPGType -> PGScalarType

-- | Metadata describing SQL functions at the DB level, i.e. below the
--   GraphQL layer.
data PGRawFunctionInfo
PGRawFunctionInfo :: OID -> Bool -> FunctionVolatility -> SchemaName -> PGScalarType -> PGTypeKind -> Bool -> [QualifiedPGType] -> [FunctionArgName] -> Int -> Bool -> Maybe PGDescription -> PGRawFunctionInfo
[rfiOid] :: PGRawFunctionInfo -> OID
[rfiHasVariadic] :: PGRawFunctionInfo -> Bool
[rfiFunctionType] :: PGRawFunctionInfo -> FunctionVolatility
[rfiReturnTypeSchema] :: PGRawFunctionInfo -> SchemaName
[rfiReturnTypeName] :: PGRawFunctionInfo -> PGScalarType
[rfiReturnTypeType] :: PGRawFunctionInfo -> PGTypeKind
[rfiReturnsSet] :: PGRawFunctionInfo -> Bool
[rfiInputArgTypes] :: PGRawFunctionInfo -> [QualifiedPGType]
[rfiInputArgNames] :: PGRawFunctionInfo -> [FunctionArgName]
[rfiDefaultArgs] :: PGRawFunctionInfo -> Int
[rfiReturnsTable] :: PGRawFunctionInfo -> Bool
[rfiDescription] :: PGRawFunctionInfo -> Maybe PGDescription
mkScalarTypeName :: MonadError QErr m => NamingCase -> PGScalarType -> m Name
pgTypeOid :: PGScalarType -> Oid

-- | Temporary conversion function, to be removed once <a>Identifier</a>
--   has been entirely split into <a>TableIdentifier</a> and
--   <a>ColumnIdentifier</a>.
tableIdentifierToIdentifier :: TableIdentifier -> Identifier

-- | Temporary conversion function, to be removed once <a>Identifier</a>
--   has been entirely split into <a>TableIdentifier</a> and
--   <a>ColumnIdentifier</a>.
identifierToTableIdentifier :: Identifier -> TableIdentifier
data PGExtraTableMetadata
PGExtraTableMetadata :: SourceTableType -> PGExtraTableMetadata
[_petmTableType] :: PGExtraTableMetadata -> SourceTableType
instance GHC.Internal.Data.Data.Data Hasura.Backends.Postgres.SQL.Types.ColumnIdentifier
instance GHC.Internal.Data.Data.Data Hasura.Backends.Postgres.SQL.Types.FunctionName
instance GHC.Internal.Data.Data.Data Hasura.Backends.Postgres.SQL.Types.Identifier
instance GHC.Internal.Data.Data.Data Hasura.Backends.Postgres.SQL.Types.PGCol
instance GHC.Internal.Data.Data.Data Hasura.Backends.Postgres.SQL.Types.PGScalarType
instance GHC.Internal.Data.Data.Data a => GHC.Internal.Data.Data.Data (Hasura.Backends.Postgres.SQL.Types.QualifiedObject a)
instance GHC.Internal.Data.Data.Data Hasura.Backends.Postgres.SQL.Types.SchemaName
instance GHC.Internal.Data.Data.Data Hasura.Backends.Postgres.SQL.Types.TableIdentifier
instance GHC.Internal.Data.Data.Data Hasura.Backends.Postgres.SQL.Types.TableName
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Types.ColumnIdentifier
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Types.ConstraintName
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Types.FunctionName
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Types.Identifier
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Types.PGCol
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Types.PGDescription
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Types.PGExtraTableMetadata
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Types.PGRawFunctionInfo
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Types.PGScalarType
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Types.PGTypeKind
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.Backends.Postgres.SQL.Types.QualifiedObject a)
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Types.QualifiedPGType
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Types.SchemaName
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Types.TableIdentifier
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Types.TableName
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Types.TableType
instance Database.PG.Query.Class.FromCol Hasura.Backends.Postgres.SQL.Types.ConstraintName
instance Database.PG.Query.Class.FromCol Hasura.Backends.Postgres.SQL.Types.FunctionName
instance Database.PG.Query.Class.FromCol Hasura.Backends.Postgres.SQL.Types.PGCol
instance Database.PG.Query.Class.FromCol Hasura.Backends.Postgres.SQL.Types.PGDescription
instance Database.PG.Query.Class.FromCol Hasura.Backends.Postgres.SQL.Types.SchemaName
instance Database.PG.Query.Class.FromCol Hasura.Backends.Postgres.SQL.Types.TableName
instance Database.PG.Query.Class.FromCol Hasura.Backends.Postgres.SQL.Types.TableType
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.Backends.Postgres.SQL.Types.ConstraintName
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.Backends.Postgres.SQL.Types.PGCol
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.SQL.Types.ColumnIdentifier
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.SQL.Types.ConstraintName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.SQL.Types.FunctionName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.SQL.Types.Identifier
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.SQL.Types.PGCol
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.SQL.Types.PGDescription
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.SQL.Types.PGExtraTableMetadata
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.SQL.Types.PGRawFunctionInfo
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.SQL.Types.PGScalarType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.SQL.Types.PGTypeKind
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Backends.Postgres.SQL.Types.QualifiedObject a)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.SQL.Types.QualifiedPGType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.SQL.Types.SchemaName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.SQL.Types.TableIdentifier
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.SQL.Types.TableName
instance GHC.Internal.Base.Functor Hasura.Backends.Postgres.SQL.Types.QualifiedObject
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.SQL.Types.FunctionName
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.SQL.Types.PGCol
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.SQL.Types.PGExtraTableMetadata
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.SQL.Types.PGRawFunctionInfo
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.SQL.Types.PGScalarType
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.SQL.Types.PGTypeKind
instance GHC.Internal.Generics.Generic (Hasura.Backends.Postgres.SQL.Types.QualifiedObject a)
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.SQL.Types.QualifiedPGType
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.SQL.Types.SchemaName
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.SQL.Types.TableName
instance Autodocodec.Class.HasCodec Hasura.Backends.Postgres.SQL.Types.FunctionName
instance Autodocodec.Class.HasCodec Hasura.Backends.Postgres.SQL.Types.PGCol
instance Autodocodec.Class.HasCodec Hasura.Backends.Postgres.SQL.Types.PGScalarType
instance (Autodocodec.Class.HasCodec a, GHC.Internal.Data.Typeable.Internal.Typeable a) => Autodocodec.Class.HasCodec (Hasura.Backends.Postgres.SQL.Types.QualifiedObject a)
instance Autodocodec.Class.HasCodec Hasura.Backends.Postgres.SQL.Types.SchemaName
instance Autodocodec.Class.HasCodec Hasura.Backends.Postgres.SQL.Types.TableName
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.Types.ColumnIdentifier
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.Types.ConstraintName
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.Types.FunctionName
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.Types.Identifier
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.Types.PGCol
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.Types.PGDescription
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.Types.PGExtraTableMetadata
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.Types.PGScalarType
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.Types.PGTypeKind
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.Backends.Postgres.SQL.Types.QualifiedObject a)
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.Types.QualifiedPGType
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.Types.SchemaName
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.Types.TableIdentifier
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.Types.TableName
instance Hasura.Backends.Postgres.SQL.Types.IsIdentifier Hasura.RQL.Types.ComputedField.Name.ComputedFieldName
instance Hasura.Backends.Postgres.SQL.Types.IsIdentifier Hasura.Backends.Postgres.SQL.Types.ConstraintName
instance Hasura.Backends.Postgres.SQL.Types.IsIdentifier Hasura.RQL.Types.Common.FieldName
instance Hasura.Backends.Postgres.SQL.Types.IsIdentifier Hasura.Backends.Postgres.SQL.Types.FunctionName
instance Hasura.Backends.Postgres.SQL.Types.IsIdentifier Hasura.Backends.Postgres.SQL.Types.Identifier
instance Hasura.Backends.Postgres.SQL.Types.IsIdentifier Hasura.Backends.Postgres.SQL.Types.PGCol
instance Hasura.Backends.Postgres.SQL.Types.IsIdentifier Hasura.RQL.Types.Common.RelName
instance Hasura.Backends.Postgres.SQL.Types.IsIdentifier Hasura.Backends.Postgres.SQL.Types.SchemaName
instance Hasura.Backends.Postgres.SQL.Types.IsIdentifier Hasura.Backends.Postgres.SQL.Types.TableName
instance GHC.Internal.Data.String.IsString Hasura.Backends.Postgres.SQL.Types.PGCol
instance GHC.Internal.Data.String.IsString Hasura.Backends.Postgres.SQL.Types.SchemaName
instance GHC.Internal.Data.String.IsString Hasura.Backends.Postgres.SQL.Types.TableName
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.Types.ColumnIdentifier
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.Types.ConstraintName
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.Types.FunctionName
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.Types.Identifier
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.Types.PGCol
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.Types.PGDescription
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.Types.PGExtraTableMetadata
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.Types.PGRawFunctionInfo
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.Types.PGScalarType
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.Types.PGTypeKind
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.Backends.Postgres.SQL.Types.QualifiedObject a)
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.Types.QualifiedPGType
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.Types.SchemaName
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.Types.TableIdentifier
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.Types.TableName
instance GHC.Classes.Ord Hasura.Backends.Postgres.SQL.Types.ConstraintName
instance GHC.Classes.Ord Hasura.Backends.Postgres.SQL.Types.FunctionName
instance GHC.Classes.Ord Hasura.Backends.Postgres.SQL.Types.PGCol
instance GHC.Classes.Ord Hasura.Backends.Postgres.SQL.Types.PGDescription
instance GHC.Classes.Ord Hasura.Backends.Postgres.SQL.Types.PGScalarType
instance GHC.Classes.Ord Hasura.Backends.Postgres.SQL.Types.PGTypeKind
instance GHC.Classes.Ord a => GHC.Classes.Ord (Hasura.Backends.Postgres.SQL.Types.QualifiedObject a)
instance GHC.Classes.Ord Hasura.Backends.Postgres.SQL.Types.QualifiedPGType
instance GHC.Classes.Ord Hasura.Backends.Postgres.SQL.Types.SchemaName
instance GHC.Classes.Ord Hasura.Backends.Postgres.SQL.Types.TableName
instance GHC.Internal.Base.Semigroup Hasura.Backends.Postgres.SQL.Types.ColumnIdentifier
instance GHC.Internal.Base.Semigroup Hasura.Backends.Postgres.SQL.Types.Identifier
instance GHC.Internal.Base.Semigroup Hasura.Backends.Postgres.SQL.Types.TableIdentifier
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.Types.ColumnIdentifier
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.Types.ConstraintName
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.Types.FunctionName
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.Types.Identifier
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.Types.PGCol
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.Types.PGDescription
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.Types.PGExtraTableMetadata
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.Types.PGRawFunctionInfo
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.Types.PGScalarType
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.Types.PGTypeKind
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (Hasura.Backends.Postgres.SQL.Types.QualifiedObject a)
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.Types.QualifiedPGType
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.Types.SchemaName
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.Types.TableIdentifier
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.Types.TableName
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.Postgres.SQL.Types.ConstraintName
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.Postgres.SQL.Types.FunctionName
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.Postgres.SQL.Types.PGCol
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.Postgres.SQL.Types.PGScalarType
instance Data.Text.Extended.ToTxt a => Hasura.Base.ToErrorValue.ToErrorValue (Hasura.Backends.Postgres.SQL.Types.QualifiedObject a)
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.Postgres.SQL.Types.ConstraintName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.Postgres.SQL.Types.PGCol
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.Postgres.SQL.Types.PGScalarType
instance (Data.Aeson.Types.ToJSON.ToJSON a, Data.Text.Extended.ToTxt a) => Data.Aeson.Types.ToJSON.ToJSONKey (Hasura.Backends.Postgres.SQL.Types.QualifiedObject a)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.Types.ColumnIdentifier
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.Types.ConstraintName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.Types.FunctionName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.Types.Identifier
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.Types.PGCol
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.Types.PGDescription
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.Types.PGExtraTableMetadata
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.Types.PGRawFunctionInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.Types.PGScalarType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.Types.PGTypeKind
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Backends.Postgres.SQL.Types.QualifiedObject a)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.Types.QualifiedPGType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.Types.SchemaName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.Types.TableIdentifier
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.Types.TableName
instance Database.PG.Query.Class.ToPrepArg Hasura.Backends.Postgres.SQL.Types.ConstraintName
instance Database.PG.Query.Class.ToPrepArg Hasura.Backends.Postgres.SQL.Types.FunctionName
instance Database.PG.Query.Class.ToPrepArg Hasura.Backends.Postgres.SQL.Types.PGCol
instance Database.PG.Query.Class.ToPrepArg Hasura.Backends.Postgres.SQL.Types.SchemaName
instance Database.PG.Query.Class.ToPrepArg Hasura.Backends.Postgres.SQL.Types.TableName
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.Types.ColumnIdentifier
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.Types.ConstraintName
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.Types.FunctionName
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.Types.Identifier
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.Types.PGCol
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.Types.PGScalarType
instance Hasura.SQL.Types.ToSQL a => Hasura.SQL.Types.ToSQL (Hasura.Backends.Postgres.SQL.Types.QualifiedObject a)
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.Types.SchemaName
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.Types.TableIdentifier
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.Types.TableName
instance Data.Text.Extended.ToTxt Hasura.Backends.Postgres.SQL.Types.ConstraintName
instance Data.Text.Extended.ToTxt Hasura.Backends.Postgres.SQL.Types.FunctionName
instance Data.Text.Extended.ToTxt Hasura.Backends.Postgres.SQL.Types.PGCol
instance Data.Text.Extended.ToTxt Hasura.Backends.Postgres.SQL.Types.PGScalarType
instance Data.Text.Extended.ToTxt a => Data.Text.Extended.ToTxt (Hasura.Backends.Postgres.SQL.Types.QualifiedObject a)
instance Data.Text.Extended.ToTxt Hasura.Backends.Postgres.SQL.Types.TableName


module Hasura.RQL.Types.ComputedField
data ComputedFieldFunction (b :: BackendType)
ComputedFieldFunction :: FunctionName b -> Seq (FunctionArgument b) -> ComputedFieldImplicitArguments b -> Maybe PGDescription -> ComputedFieldFunction (b :: BackendType)
[_cffName] :: ComputedFieldFunction (b :: BackendType) -> FunctionName b
[_cffInputArgs] :: ComputedFieldFunction (b :: BackendType) -> Seq (FunctionArgument b)
[_cffComputedFieldImplicitArgs] :: ComputedFieldFunction (b :: BackendType) -> ComputedFieldImplicitArguments b
[_cffDescription] :: ComputedFieldFunction (b :: BackendType) -> Maybe PGDescription
data ComputedFieldInfo (b :: BackendType)
ComputedFieldInfo :: XComputedField b -> ComputedFieldName -> ComputedFieldFunction b -> ComputedFieldReturn b -> Maybe Text -> ComputedFieldInfo (b :: BackendType)
[_cfiXComputedFieldInfo] :: ComputedFieldInfo (b :: BackendType) -> XComputedField b
[_cfiName] :: ComputedFieldInfo (b :: BackendType) -> ComputedFieldName
[_cfiFunction] :: ComputedFieldInfo (b :: BackendType) -> ComputedFieldFunction b
[_cfiReturnType] :: ComputedFieldInfo (b :: BackendType) -> ComputedFieldReturn b
[_cfiDescription] :: ComputedFieldInfo (b :: BackendType) -> Maybe Text
newtype ComputedFieldName
ComputedFieldName :: NonEmptyText -> ComputedFieldName
[unComputedFieldName] :: ComputedFieldName -> NonEmptyText

-- | The function name and input arguments name for the "args" field
--   parser.
--   
--   <pre>
--   function_name(args: args_name)
--   </pre>
data CustomFunctionNames
CustomFunctionNames :: Name -> Name -> CustomFunctionNames
[cfnFunctionName] :: CustomFunctionNames -> Name
[cfnArgsName] :: CustomFunctionNames -> Name
data FunctionTrackedAs (b :: BackendType)
FTAComputedField :: ComputedFieldName -> SourceName -> TableName b -> FunctionTrackedAs (b :: BackendType)
FTACustomFunction :: CustomFunctionNames -> FunctionTrackedAs (b :: BackendType)
cfiDescription :: forall (b :: BackendType) f. Functor f => (Maybe Text -> f (Maybe Text)) -> ComputedFieldInfo b -> f (ComputedFieldInfo b)
cfiFunction :: forall (b :: BackendType) f. Functor f => (ComputedFieldFunction b -> f (ComputedFieldFunction b)) -> ComputedFieldInfo b -> f (ComputedFieldInfo b)
cfiName :: forall (b :: BackendType) f. Functor f => (ComputedFieldName -> f ComputedFieldName) -> ComputedFieldInfo b -> f (ComputedFieldInfo b)
cfiReturnType :: forall (b :: BackendType) f. Functor f => (ComputedFieldReturn b -> f (ComputedFieldReturn b)) -> ComputedFieldInfo b -> f (ComputedFieldInfo b)
cfiXComputedFieldInfo :: forall (b :: BackendType) f. Functor f => (XComputedField b -> f (XComputedField b)) -> ComputedFieldInfo b -> f (ComputedFieldInfo b)
computedFieldNameToText :: ComputedFieldName -> Text
fromComputedField :: ComputedFieldName -> FieldName

-- | Return all the computed fields in the given list that have numeric
--   types.
onlyNumComputedFields :: forall (b :: BackendType). Backend b => [ComputedFieldInfo b] -> [ComputedFieldInfo b]

-- | Check whether a computed field has a numeric type.
isNumComputedField :: forall (b :: BackendType). Backend b => ComputedFieldInfo b -> Bool

-- | Return all the computed fields in the given list that have numeric
--   types.
onlyComparableComputedFields :: forall (b :: BackendType). Backend b => [ComputedFieldInfo b] -> [ComputedFieldInfo b]

-- | Check whether a computed field has a numeric type.
isComparableComputedField :: forall (b :: BackendType). Backend b => ComputedFieldInfo b -> Bool

-- | Filter computed fields not returning rows of existing table
removeComputedFieldsReturningExistingTable :: forall (backend :: BackendType). Backend backend => [ComputedFieldInfo backend] -> [ComputedFieldInfo backend]
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.ComputedField.ComputedFieldFunction b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.ComputedField.ComputedFieldInfo b)
instance GHC.Classes.Eq Hasura.RQL.Types.ComputedField.CustomFunctionNames
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.ComputedField.FunctionTrackedAs b)
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.ComputedField.ComputedFieldFunction b)
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.ComputedField.ComputedFieldInfo b)
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.ComputedField.CustomFunctionNames
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.ComputedField.FunctionTrackedAs b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.ComputedField.ComputedFieldFunction b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.ComputedField.ComputedFieldInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.Types.ComputedField.ComputedFieldFunction b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.Types.ComputedField.ComputedFieldInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Ord (Hasura.RQL.Types.ComputedField.ComputedFieldFunction b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Ord (Hasura.RQL.Types.ComputedField.ComputedFieldInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.Types.ComputedField.ComputedFieldFunction b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.Types.ComputedField.ComputedFieldInfo b)
instance GHC.Internal.Show.Show Hasura.RQL.Types.ComputedField.CustomFunctionNames
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.Types.ComputedField.FunctionTrackedAs b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.ComputedField.ComputedFieldFunction b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.ComputedField.ComputedFieldInfo b)


-- | Boolean Expressions
--   
--   This module defines the IR representation of boolean expressions used
--   in <tt>_where</tt> clauses in GraphQL queries, permissions, and so on.
--   
--   The types in this module define a <i>generic</i> structure with
--   "holes" to be filled by each backend. Specifically, holes will include
--   things like types for table names, and backend field types.
module Hasura.RQL.IR.BoolExp

-- | This <tt>BoolExp</tt> type is a simple alias for the boolean
--   expressions used in permissions, that uses <a>ColExp</a> as the term
--   in GBoolExp.
newtype BoolExp (b :: BackendType)
BoolExp :: GBoolExp b ColExp -> BoolExp (b :: BackendType)
[unBoolExp] :: BoolExp (b :: BackendType) -> GBoolExp b ColExp

-- | We don't allow conditions across relationships in permissions: the
--   type we use as the terms in GBoolExp is this one, ColExp, which only
--   contains a FieldName and a JSON Value.
data ColExp
ColExp :: FieldName -> Value -> ColExp
[ceCol] :: ColExp -> FieldName
[ceVal] :: ColExp -> Value

-- | This type represents a boolean expression tree. It is parametric over
--   the actual implementation of the actual boolean term values. It
--   nonetheless leaks some information: "exists" is only used in
--   permissions, to add conditions based on another table.
--   
--   <ul>
--   <li>The <tt>backend</tt> parameter is used to find the
--   backend-specific type for table names in the <tt>BoolExists</tt>
--   constructor.</li>
--   <li>The <tt>field</tt> type represent the type of database-specific
--   field types.</li>
--   </ul>
data GBoolExp (backend :: BackendType) field
BoolAnd :: [GBoolExp backend field] -> GBoolExp (backend :: BackendType) field
BoolOr :: [GBoolExp backend field] -> GBoolExp (backend :: BackendType) field
BoolNot :: GBoolExp backend field -> GBoolExp (backend :: BackendType) field

-- | Represents a condition on an aribtrary table. since the
--   <tt>backend</tt> and <tt>field</tt> are the same, the table must be of
--   the same database type.
BoolExists :: GExists backend field -> GBoolExp (backend :: BackendType) field

-- | A column field
BoolField :: field -> GBoolExp (backend :: BackendType) field

-- | A default representation for a <tt>true</tt> boolean value.
gBoolExpTrue :: forall (backend :: BackendType) field. GBoolExp backend field

-- | Represents a condition on an aribtrary table. Used as part of our
--   permissions boolean expressions. See our documentation for more
--   information:
--   <a>https://hasura.io/docs/latest/graphql/core/auth/authorization/permission-rules.html#using-unrelated-tables-views</a>
data GExists (backend :: BackendType) field
GExists :: TableName backend -> GBoolExp backend field -> GExists (backend :: BackendType) field
[_geTable] :: GExists (backend :: BackendType) field -> TableName backend
[_geWhere] :: GExists (backend :: BackendType) field -> GBoolExp backend field

-- | Operand for STDWithin opoerator
data DWithinGeomOp field
DWithinGeomOp :: field -> field -> DWithinGeomOp field
[dwgeomDistance] :: DWithinGeomOp field -> field
[dwgeomFrom] :: DWithinGeomOp field -> field

-- | Operand for STDWithin opoerator
data DWithinGeogOp field
DWithinGeogOp :: field -> field -> field -> DWithinGeogOp field
[dwgeogDistance] :: DWithinGeogOp field -> field
[dwgeogFrom] :: DWithinGeogOp field -> field
[dwgeogUseSpheroid] :: DWithinGeogOp field -> field

-- | Operand for cast operator
type CastExp (backend :: BackendType) field = HashMap ScalarType backend [OpExpG backend field]

-- | This type represents the boolean operators that can be applied on
--   values of a column. This type only contains the common core, that we
--   expect to be ultimately entirely supported in most if not all
--   backends. Backends can extend this with the <tt>BooleanOperators</tt>
--   type in <tt>Backend</tt>.
data OpExpG (backend :: BackendType) field
ACast :: CastExp backend field -> OpExpG (backend :: BackendType) field
AEQ :: ComparisonNullability -> field -> OpExpG (backend :: BackendType) field
ANE :: ComparisonNullability -> field -> OpExpG (backend :: BackendType) field
AIN :: field -> OpExpG (backend :: BackendType) field
ANIN :: field -> OpExpG (backend :: BackendType) field
AGT :: field -> OpExpG (backend :: BackendType) field
ALT :: field -> OpExpG (backend :: BackendType) field
AGTE :: field -> OpExpG (backend :: BackendType) field
ALTE :: field -> OpExpG (backend :: BackendType) field
ALIKE :: field -> OpExpG (backend :: BackendType) field
ANLIKE :: field -> OpExpG (backend :: BackendType) field
CEQ :: RootOrCurrentColumn backend -> OpExpG (backend :: BackendType) field
CNE :: RootOrCurrentColumn backend -> OpExpG (backend :: BackendType) field
CGT :: RootOrCurrentColumn backend -> OpExpG (backend :: BackendType) field
CLT :: RootOrCurrentColumn backend -> OpExpG (backend :: BackendType) field
CGTE :: RootOrCurrentColumn backend -> OpExpG (backend :: BackendType) field
CLTE :: RootOrCurrentColumn backend -> OpExpG (backend :: BackendType) field
ANISNULL :: OpExpG (backend :: BackendType) field
ANISNOTNULL :: OpExpG (backend :: BackendType) field
ABackendSpecific :: BooleanOperators backend field -> OpExpG (backend :: BackendType) field
opExpDepCol :: forall (backend :: BackendType) field. OpExpG backend field -> Maybe (RootOrCurrentColumn backend)
data ComparisonNullability
NonNullableComparison :: ComparisonNullability
NullableComparison :: ComparisonNullability

-- | Operand for STIntersect
data STIntersectsNbandGeommin field
STIntersectsNbandGeommin :: field -> field -> STIntersectsNbandGeommin field
[singNband] :: STIntersectsNbandGeommin field -> field
[singGeommin] :: STIntersectsNbandGeommin field -> field

-- | Operand for STIntersect
data STIntersectsGeomminNband field
STIntersectsGeomminNband :: field -> Maybe field -> STIntersectsGeomminNband field
[signGeommin] :: STIntersectsGeomminNband field -> field
[signNband] :: STIntersectsGeomminNband field -> Maybe field

-- | This type is used to represent the kinds of boolean expression used
--   for computed fields based on the return type of the SQL function.
data ComputedFieldBoolExp (backend :: BackendType) scalar

-- | SQL function returning a scalar
CFBEScalar :: AnnRedactionExp backend scalar -> [OpExpG backend scalar] -> ComputedFieldBoolExp (backend :: BackendType) scalar

-- | SQL function returning SET OF table
CFBETable :: TableName backend -> AnnBoolExp backend scalar -> ComputedFieldBoolExp (backend :: BackendType) scalar

-- | Using a computed field in boolean expression. Example: A computed
--   field "full_name" ("first_name" || "last_name") is defined to the
--   "user" table. Boolean expression to filter whose "full_name" is LIKE
--   "%bob%" query { user(where: {full_name: {_like: "%bob%"}}){ id
--   first_name last_name full_name } } Limitation: We only support
--   computed fields in boolean expressions when they are functions with no
--   input arguments, because it is complex to generate schema for
--   <tt>where</tt> clauses for functions that have input arguments.
data AnnComputedFieldBoolExp (backend :: BackendType) scalar
AnnComputedFieldBoolExp :: XComputedField backend -> ComputedFieldName -> FunctionName backend -> FunctionArgsExp backend scalar -> ComputedFieldBoolExp backend scalar -> AnnComputedFieldBoolExp (backend :: BackendType) scalar
[_acfbXFieldInfo] :: AnnComputedFieldBoolExp (backend :: BackendType) scalar -> XComputedField backend
[_acfbName] :: AnnComputedFieldBoolExp (backend :: BackendType) scalar -> ComputedFieldName
[_acfbFunction] :: AnnComputedFieldBoolExp (backend :: BackendType) scalar -> FunctionName backend
[_acfbFunctionArgsExp] :: AnnComputedFieldBoolExp (backend :: BackendType) scalar -> FunctionArgsExp backend scalar
[_acfbBoolExp] :: AnnComputedFieldBoolExp (backend :: BackendType) scalar -> ComputedFieldBoolExp backend scalar

-- | This type is used for boolean terms in GBoolExp in the schema; there
--   are four kinds boolean terms: - operators on a column of the current
--   table, using the <a>OpExpG</a> kind of operators - arbitrary
--   expressions on columns of tables in relationships (in the same source)
--   - A computed field of the current table - aggregation operations on
--   array relationships on the current tables.
--   
--   This type is parameterized over the type of leaf values, the values on
--   which we operate.
data AnnBoolExpFld (backend :: BackendType) leaf
AVColumn :: ColumnInfo backend -> AnnRedactionExp backend leaf -> [OpExpG backend leaf] -> AnnBoolExpFld (backend :: BackendType) leaf
AVNestedObject :: NestedObjectInfo backend -> AnnBoolExp backend leaf -> AnnBoolExpFld (backend :: BackendType) leaf
AVRelationship :: RelInfo backend -> RelationshipFilters backend leaf -> AnnBoolExpFld (backend :: BackendType) leaf
AVComputedField :: AnnComputedFieldBoolExp backend leaf -> AnnBoolExpFld (backend :: BackendType) leaf
AVAggregationPredicates :: AggregationPredicates backend leaf -> AnnBoolExpFld (backend :: BackendType) leaf
AVRemoteRelationship :: RemoteRelPermBoolExp backend leaf -> AnnBoolExpFld (backend :: BackendType) leaf

-- | This type represents a boolean expression over a relationship. In
--   addition to the actual user-specified predicate, we need to also
--   consider the permissions of the target table.
--   
--   Because the permissions may include column-comparison-operators, they
--   need to be translated in the context of the table they apply to. Thus
--   we keep the permissions and filters separate.
data RelationshipFilters (backend :: BackendType) leaf
RelationshipFilters :: AnnBoolExp backend leaf -> AnnBoolExp backend leaf -> RelationshipFilters (backend :: BackendType) leaf
[rfTargetTablePermissions] :: RelationshipFilters (backend :: BackendType) leaf -> AnnBoolExp backend leaf
[rfFilter] :: RelationshipFilters (backend :: BackendType) leaf -> AnnBoolExp backend leaf

-- | A simple alias for the kind of boolean expressions used in the schema,
--   that ties together <a>GBoolExp</a>, <a>OpExpG</a>, and
--   <a>AnnBoolExpFld</a>.
type AnnBoolExp (backend :: BackendType) scalar = GBoolExp backend AnnBoolExpFld backend scalar
type AnnRedactionExpPartialSQL (b :: BackendType) = AnnRedactionExp b PartialSQLExp b
type AnnRedactionExpUnpreparedValue (b :: BackendType) = AnnRedactionExp b UnpreparedValue b

-- | This captures a boolean expression where, if it is false, some
--   associated data needs to be redacted (in practice, nulled out) because
--   the user doesn't have access to it. Alternatively, "no redaction" is
--   explicitly defined, which is used as an optimization to avoid
--   evaluating a boolexp if unnecessary (as opposed to defining a boolean
--   exp which always evaluates to true).
data AnnRedactionExp (b :: BackendType) v
NoRedaction :: AnnRedactionExp (b :: BackendType) v
RedactIfFalse :: GBoolExp b (AnnBoolExpFld b v) -> AnnRedactionExp (b :: BackendType) v
annBoolExpTrue :: forall (backend :: BackendType) scalar. AnnBoolExp backend scalar
andAnnBoolExps :: forall (backend :: BackendType) scalar. AnnBoolExp backend scalar -> AnnBoolExp backend scalar -> AnnBoolExp backend scalar
type AnnBoolExpFldSQL (backend :: BackendType) = AnnBoolExpFld backend SQLExpression backend
type AnnBoolExpSQL (backend :: BackendType) = AnnBoolExp backend SQLExpression backend

-- | Permissions get translated into boolean expressions that are threaded
--   throuhgout the parsers. For the leaf values of those permissions, we
--   use this type, which references but doesn't inline the session
--   variables.
data PartialSQLExp (backend :: BackendType)
PSESessVar :: SessionVarType backend -> SessionVariable -> PartialSQLExp (backend :: BackendType)
PSESession :: PartialSQLExp (backend :: BackendType)
PSESQLExp :: SQLExpression backend -> PartialSQLExp (backend :: BackendType)
isStaticValue :: forall (backend :: BackendType). PartialSQLExp backend -> Bool
hasStaticExp :: forall (b :: BackendType). Backend b => OpExpG b (PartialSQLExp b) -> Bool
type AnnBoolExpPartialSQL (backend :: BackendType) = AnnBoolExp backend PartialSQLExp backend
type PreSetColsG (b :: BackendType) v = HashMap Column b v
type PreSetColsPartial (b :: BackendType) = HashMap Column b PartialSQLExp b
data RootOrCurrentColumn (b :: BackendType)
RootOrCurrentColumn :: RootOrCurrent -> Column b -> RootOrCurrentColumn (b :: BackendType)

-- | The arguments of column-operators may refer to either the so-called
--   'root tabular value' or 'current tabular value'.
data RootOrCurrent
IsRoot :: RootOrCurrent
IsCurrent :: RootOrCurrent
data RemoteRelPermBoolExp (b :: BackendType) field
RemoteRelPermBoolExp :: (RelName, Value) -> (Column b, ColumnType b) -> AnyBackend (RemoteRelRHSFetchInfo field) -> RemoteRelPermBoolExp (b :: BackendType) field
[rawBoolExp] :: RemoteRelPermBoolExp (b :: BackendType) field -> (RelName, Value)
[lhsCol] :: RemoteRelPermBoolExp (b :: BackendType) field -> (Column b, ColumnType b)
[rhsFetchInfo] :: RemoteRelPermBoolExp (b :: BackendType) field -> AnyBackend (RemoteRelRHSFetchInfo field)
data RemoteRelRHSFetchInfo field (b :: BackendType)
RemoteRelRHSFetchInfo :: (ScalarType b, Column b) -> TableName b -> RemoteRelRHSFetchWhereExp (Column b) -> SourceName -> SourceConfig b -> RemoteRelRHSFetchInfo field (b :: BackendType)
[rrrfiColumn] :: RemoteRelRHSFetchInfo field (b :: BackendType) -> (ScalarType b, Column b)
[rrrfiTable] :: RemoteRelRHSFetchInfo field (b :: BackendType) -> TableName b
[rrrfiWhere] :: RemoteRelRHSFetchInfo field (b :: BackendType) -> RemoteRelRHSFetchWhereExp (Column b)
[rrrfiSource] :: RemoteRelRHSFetchInfo field (b :: BackendType) -> SourceName
[rrrfiSourceConfig] :: RemoteRelRHSFetchInfo field (b :: BackendType) -> SourceConfig b
instance GHC.Internal.Data.Data.Data Hasura.RQL.IR.BoolExp.ColExp
instance GHC.Internal.Data.Data.Data field => GHC.Internal.Data.Data.Data (Hasura.RQL.IR.BoolExp.DWithinGeogOp field)
instance GHC.Internal.Data.Data.Data field => GHC.Internal.Data.Data.Data (Hasura.RQL.IR.BoolExp.DWithinGeomOp field)
instance (Hasura.RQL.Types.Backend.Backend backend, GHC.Internal.Data.Data.Data field) => GHC.Internal.Data.Data.Data (Hasura.RQL.IR.BoolExp.GBoolExp backend field)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Data.Data.Data a) => GHC.Internal.Data.Data.Data (Hasura.RQL.IR.BoolExp.GExists b a)
instance GHC.Internal.Data.Data.Data field => GHC.Internal.Data.Data.Data (Hasura.RQL.IR.BoolExp.STIntersectsGeomminNband field)
instance GHC.Internal.Data.Data.Data field => GHC.Internal.Data.Data.Data (Hasura.RQL.IR.BoolExp.STIntersectsNbandGeommin field)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq a) => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnBoolExpFld b a)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq a) => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnComputedFieldBoolExp b a)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq v) => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnRedactionExp b v)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.BoolExp b)
instance GHC.Classes.Eq Hasura.RQL.IR.BoolExp.ColExp
instance GHC.Classes.Eq Hasura.RQL.IR.BoolExp.ComparisonNullability
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq a) => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.ComputedFieldBoolExp b a)
instance GHC.Classes.Eq field => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.DWithinGeogOp field)
instance GHC.Classes.Eq field => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.DWithinGeomOp field)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq a) => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.GBoolExp b a)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq a) => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.GExists b a)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq a) => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.OpExpG b a)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.PartialSQLExp b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq a) => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.RelationshipFilters b a)
instance GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.RemoteRelPermBoolExp b f)
instance GHC.Classes.Eq Hasura.RQL.IR.BoolExp.RootOrCurrent
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.RootOrCurrentColumn b)
instance GHC.Classes.Eq field => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.STIntersectsGeomminNband field)
instance GHC.Classes.Eq field => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.STIntersectsNbandGeommin field)
instance Hasura.RQL.Types.Backend.Backend backend => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.BoolExp.AnnBoolExpFld backend)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.BoolExp.AnnComputedFieldBoolExp b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.BoolExp.AnnRedactionExp b)
instance Hasura.RQL.Types.Backend.Backend backend => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.BoolExp.ComputedFieldBoolExp backend)
instance GHC.Internal.Data.Foldable.Foldable Hasura.RQL.IR.BoolExp.DWithinGeogOp
instance GHC.Internal.Data.Foldable.Foldable Hasura.RQL.IR.BoolExp.DWithinGeomOp
instance GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.BoolExp.GBoolExp backend)
instance GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.BoolExp.GExists backend)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.BoolExp.OpExpG b)
instance Hasura.RQL.Types.Backend.Backend backend => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.BoolExp.RelationshipFilters backend)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.BoolExp.RemoteRelPermBoolExp b)
instance GHC.Internal.Data.Foldable.Foldable Hasura.RQL.IR.BoolExp.STIntersectsGeomminNband
instance GHC.Internal.Data.Foldable.Foldable Hasura.RQL.IR.BoolExp.STIntersectsNbandGeommin
instance Data.Aeson.Extended.FromJSONKeyValue Hasura.RQL.IR.BoolExp.ColExp
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.IR.BoolExp.BoolExp b)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.IR.BoolExp.DWithinGeogOp a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.IR.BoolExp.DWithinGeomOp a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Extended.FromJSONKeyValue a) => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.IR.BoolExp.GBoolExp b a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Extended.FromJSONKeyValue a) => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.IR.BoolExp.GExists b a)
instance Data.Aeson.Types.FromJSON.FromJSON field => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.IR.BoolExp.STIntersectsGeomminNband field)
instance Data.Aeson.Types.FromJSON.FromJSON field => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.IR.BoolExp.STIntersectsNbandGeommin field)
instance Hasura.RQL.Types.Backend.Backend backend => GHC.Internal.Base.Functor (Hasura.RQL.IR.BoolExp.AnnBoolExpFld backend)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Base.Functor (Hasura.RQL.IR.BoolExp.AnnComputedFieldBoolExp b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Base.Functor (Hasura.RQL.IR.BoolExp.AnnRedactionExp b)
instance Hasura.RQL.Types.Backend.Backend backend => GHC.Internal.Base.Functor (Hasura.RQL.IR.BoolExp.ComputedFieldBoolExp backend)
instance GHC.Internal.Base.Functor Hasura.RQL.IR.BoolExp.DWithinGeogOp
instance GHC.Internal.Base.Functor Hasura.RQL.IR.BoolExp.DWithinGeomOp
instance GHC.Internal.Base.Functor (Hasura.RQL.IR.BoolExp.GBoolExp backend)
instance GHC.Internal.Base.Functor (Hasura.RQL.IR.BoolExp.GExists backend)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Base.Functor (Hasura.RQL.IR.BoolExp.OpExpG b)
instance Hasura.RQL.Types.Backend.Backend backend => GHC.Internal.Base.Functor (Hasura.RQL.IR.BoolExp.RelationshipFilters backend)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Base.Functor (Hasura.RQL.IR.BoolExp.RemoteRelPermBoolExp b)
instance GHC.Internal.Base.Functor Hasura.RQL.IR.BoolExp.STIntersectsGeomminNband
instance GHC.Internal.Base.Functor Hasura.RQL.IR.BoolExp.STIntersectsNbandGeommin
instance GHC.Internal.Generics.Generic (Hasura.RQL.IR.BoolExp.AnnBoolExpFld backend leaf)
instance GHC.Internal.Generics.Generic (Hasura.RQL.IR.BoolExp.AnnComputedFieldBoolExp backend scalar)
instance GHC.Internal.Generics.Generic (Hasura.RQL.IR.BoolExp.AnnRedactionExp b v)
instance GHC.Internal.Generics.Generic Hasura.RQL.IR.BoolExp.ColExp
instance GHC.Internal.Generics.Generic Hasura.RQL.IR.BoolExp.ComparisonNullability
instance GHC.Internal.Generics.Generic (Hasura.RQL.IR.BoolExp.ComputedFieldBoolExp backend scalar)
instance GHC.Internal.Generics.Generic (Hasura.RQL.IR.BoolExp.DWithinGeogOp field)
instance GHC.Internal.Generics.Generic (Hasura.RQL.IR.BoolExp.DWithinGeomOp field)
instance GHC.Internal.Generics.Generic (Hasura.RQL.IR.BoolExp.GBoolExp backend field)
instance GHC.Internal.Generics.Generic (Hasura.RQL.IR.BoolExp.GExists backend field)
instance GHC.Internal.Generics.Generic (Hasura.RQL.IR.BoolExp.OpExpG backend field)
instance GHC.Internal.Generics.Generic (Hasura.RQL.IR.BoolExp.PartialSQLExp backend)
instance GHC.Internal.Generics.Generic (Hasura.RQL.IR.BoolExp.RelationshipFilters backend leaf)
instance GHC.Internal.Generics.Generic (Hasura.RQL.IR.BoolExp.RemoteRelPermBoolExp b field)
instance GHC.Internal.Generics.Generic Hasura.RQL.IR.BoolExp.RootOrCurrent
instance GHC.Internal.Generics.Generic (Hasura.RQL.IR.BoolExp.RootOrCurrentColumn b)
instance GHC.Internal.Generics.Generic (Hasura.RQL.IR.BoolExp.STIntersectsGeomminNband field)
instance GHC.Internal.Generics.Generic (Hasura.RQL.IR.BoolExp.STIntersectsNbandGeommin field)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.IR.BoolExp.BoolExp b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq a, Data.Hashable.Class.Hashable a) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.AnnBoolExpFld b a)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq a, Data.Hashable.Class.Hashable a) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.AnnComputedFieldBoolExp b a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable v) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.AnnRedactionExp b v)
instance Data.Hashable.Class.Hashable Hasura.RQL.IR.BoolExp.ComparisonNullability
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq a, Data.Hashable.Class.Hashable a) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.ComputedFieldBoolExp b a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.DWithinGeogOp a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.DWithinGeomOp a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable a) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.GBoolExp b a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable a) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.GExists b a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable a) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.OpExpG b a)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.PartialSQLExp b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq a, Data.Hashable.Class.Hashable a) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.RelationshipFilters b a)
instance Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.RemoteRelPermBoolExp b a)
instance Data.Hashable.Class.Hashable Hasura.RQL.IR.BoolExp.RootOrCurrent
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.RootOrCurrentColumn b)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.STIntersectsGeomminNband a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.STIntersectsNbandGeommin a)
instance (Hasura.RQL.Types.Backend.Backend b, Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.AnnBoolExpFld b a)
instance (Hasura.RQL.Types.Backend.Backend b, Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.AnnComputedFieldBoolExp b a)
instance (Hasura.RQL.Types.Backend.Backend b, Control.DeepSeq.NFData v) => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.AnnRedactionExp b v)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.BoolExp b)
instance Control.DeepSeq.NFData Hasura.RQL.IR.BoolExp.ColExp
instance Control.DeepSeq.NFData Hasura.RQL.IR.BoolExp.ComparisonNullability
instance (Hasura.RQL.Types.Backend.Backend b, Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.ComputedFieldBoolExp b a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.DWithinGeogOp a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.DWithinGeomOp a)
instance (Hasura.RQL.Types.Backend.Backend b, Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.GBoolExp b a)
instance (Hasura.RQL.Types.Backend.Backend b, Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.GExists b a)
instance (Hasura.RQL.Types.Backend.Backend b, Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.OpExpG b a)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.PartialSQLExp b)
instance (Hasura.RQL.Types.Backend.Backend b, Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.RelationshipFilters b a)
instance Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.RemoteRelPermBoolExp b a)
instance Control.DeepSeq.NFData Hasura.RQL.IR.BoolExp.RootOrCurrent
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.RootOrCurrentColumn b)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.STIntersectsGeomminNband a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.STIntersectsNbandGeommin a)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Data.Data.Data a) => Control.Lens.Plated.Plated (Hasura.RQL.IR.BoolExp.GBoolExp b a)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Data.Data.Data a) => Control.Lens.Plated.Plated (Hasura.RQL.IR.BoolExp.GExists b a)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show a) => GHC.Internal.Show.Show (Hasura.RQL.IR.BoolExp.AnnBoolExpFld b a)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show a) => GHC.Internal.Show.Show (Hasura.RQL.IR.BoolExp.AnnComputedFieldBoolExp b a)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show v) => GHC.Internal.Show.Show (Hasura.RQL.IR.BoolExp.AnnRedactionExp b v)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.IR.BoolExp.BoolExp b)
instance GHC.Internal.Show.Show Hasura.RQL.IR.BoolExp.ColExp
instance GHC.Internal.Show.Show Hasura.RQL.IR.BoolExp.ComparisonNullability
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show a) => GHC.Internal.Show.Show (Hasura.RQL.IR.BoolExp.ComputedFieldBoolExp b a)
instance GHC.Internal.Show.Show field => GHC.Internal.Show.Show (Hasura.RQL.IR.BoolExp.DWithinGeogOp field)
instance GHC.Internal.Show.Show field => GHC.Internal.Show.Show (Hasura.RQL.IR.BoolExp.DWithinGeomOp field)
instance (Hasura.RQL.Types.Backend.Backend backend, GHC.Internal.Show.Show field) => GHC.Internal.Show.Show (Hasura.RQL.IR.BoolExp.GBoolExp backend field)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show a) => GHC.Internal.Show.Show (Hasura.RQL.IR.BoolExp.GExists b a)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show a) => GHC.Internal.Show.Show (Hasura.RQL.IR.BoolExp.OpExpG b a)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.IR.BoolExp.PartialSQLExp b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show a) => GHC.Internal.Show.Show (Hasura.RQL.IR.BoolExp.RelationshipFilters b a)
instance GHC.Internal.Show.Show (Hasura.RQL.IR.BoolExp.RemoteRelPermBoolExp b f)
instance GHC.Internal.Show.Show Hasura.RQL.IR.BoolExp.RootOrCurrent
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.IR.BoolExp.RootOrCurrentColumn b)
instance GHC.Internal.Show.Show field => GHC.Internal.Show.Show (Hasura.RQL.IR.BoolExp.STIntersectsGeomminNband field)
instance GHC.Internal.Show.Show field => GHC.Internal.Show.Show (Hasura.RQL.IR.BoolExp.STIntersectsNbandGeommin field)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.ToJSON.ToJSON a) => Data.Aeson.Extended.ToJSONKeyValue (Hasura.RQL.IR.BoolExp.AnnBoolExpFld b a)
instance Data.Aeson.Extended.ToJSONKeyValue Hasura.RQL.IR.BoolExp.ColExp
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.ToJSON.ToJSON a) => Data.Aeson.Extended.ToJSONKeyValue (Hasura.RQL.IR.BoolExp.OpExpG b a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.ToJSON.ToJSON v) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.AnnRedactionExp b v)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.BoolExp b)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.IR.BoolExp.ComparisonNullability
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.DWithinGeogOp a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.DWithinGeomOp a)
instance (Hasura.RQL.Types.Backend.Backend backend, Data.Aeson.Extended.ToJSONKeyValue field) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.GBoolExp backend field)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Extended.ToJSONKeyValue a) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.GExists b a)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.PartialSQLExp b)
instance (Hasura.RQL.Types.Backend.Backend backend, Data.Aeson.Types.ToJSON.ToJSON leaf) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.RelationshipFilters backend leaf)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.IR.BoolExp.RootOrCurrent
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.RootOrCurrentColumn b)
instance Data.Aeson.Types.ToJSON.ToJSON field => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.STIntersectsGeomminNband field)
instance Data.Aeson.Types.ToJSON.ToJSON field => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.STIntersectsNbandGeommin field)
instance Hasura.RQL.Types.Backend.Backend backend => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.BoolExp.AnnBoolExpFld backend)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.BoolExp.AnnComputedFieldBoolExp b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.BoolExp.AnnRedactionExp b)
instance Hasura.RQL.Types.Backend.Backend backend => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.BoolExp.ComputedFieldBoolExp backend)
instance GHC.Internal.Data.Traversable.Traversable Hasura.RQL.IR.BoolExp.DWithinGeogOp
instance GHC.Internal.Data.Traversable.Traversable Hasura.RQL.IR.BoolExp.DWithinGeomOp
instance GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.BoolExp.GBoolExp backend)
instance GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.BoolExp.GExists backend)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.BoolExp.OpExpG b)
instance Hasura.RQL.Types.Backend.Backend backend => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.BoolExp.RelationshipFilters backend)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.BoolExp.RemoteRelPermBoolExp b)
instance GHC.Internal.Data.Traversable.Traversable Hasura.RQL.IR.BoolExp.STIntersectsGeomminNband
instance GHC.Internal.Data.Traversable.Traversable Hasura.RQL.IR.BoolExp.STIntersectsNbandGeommin

module Hasura.RQL.Types.Permission
data DelPerm (b :: BackendType)
DelPerm :: BoolExp b -> Bool -> Maybe (ValidateInput InputWebhook) -> DelPerm (b :: BackendType)
[dcFilter] :: DelPerm (b :: BackendType) -> BoolExp b
[dcBackendOnly] :: DelPerm (b :: BackendType) -> Bool
[dcValidateInput] :: DelPerm (b :: BackendType) -> Maybe (ValidateInput InputWebhook)
type DelPermDef (b :: BackendType) = PermDef b DelPerm
data InsPerm (b :: BackendType)
InsPerm :: BoolExp b -> Maybe (ColumnValues b Value) -> Maybe (PermColSpec b) -> Bool -> Maybe (ValidateInput InputWebhook) -> InsPerm (b :: BackendType)
[ipCheck] :: InsPerm (b :: BackendType) -> BoolExp b
[ipSet] :: InsPerm (b :: BackendType) -> Maybe (ColumnValues b Value)
[ipColumns] :: InsPerm (b :: BackendType) -> Maybe (PermColSpec b)
[ipBackendOnly] :: InsPerm (b :: BackendType) -> Bool
[ipValidateInput] :: InsPerm (b :: BackendType) -> Maybe (ValidateInput InputWebhook)
type InsPermDef (b :: BackendType) = PermDef b InsPerm
data ValidateInput webhook
VIHttp :: ValidateInputHttpDefinition webhook -> ValidateInput webhook
data ValidateInputHttpDefinition webhook
ValidateInputHttpDefinition :: webhook -> [HeaderConf] -> Timeout -> Bool -> ValidateInputHttpDefinition webhook
[_vihdUrl] :: ValidateInputHttpDefinition webhook -> webhook
[_vihdHeaders] :: ValidateInputHttpDefinition webhook -> [HeaderConf]
[_vihdTimeout] :: ValidateInputHttpDefinition webhook -> Timeout
[_vihdForwardClientHeaders] :: ValidateInputHttpDefinition webhook -> Bool
data PermColSpec (b :: BackendType)
PCStar :: PermColSpec (b :: BackendType)
PCCols :: [Column b] -> PermColSpec (b :: BackendType)
data PermDef (b :: BackendType) (perm :: BackendType -> Type)
PermDef :: RoleName -> PermDefPermission b perm -> Maybe Text -> PermDef (b :: BackendType) (perm :: BackendType -> Type)
[_pdRole] :: PermDef (b :: BackendType) (perm :: BackendType -> Type) -> RoleName
[_pdPermission] :: PermDef (b :: BackendType) (perm :: BackendType -> Type) -> PermDefPermission b perm
[_pdComment] :: PermDef (b :: BackendType) (perm :: BackendType -> Type) -> Maybe Text
data PermType
PTInsert :: PermType
PTSelect :: PermType
PTUpdate :: PermType
PTDelete :: PermType
data SelPerm (b :: BackendType)
SelPerm :: PermColSpec b -> BoolExp b -> Maybe Int -> Bool -> [ComputedFieldName] -> AllowedRootFields QueryRootFieldType -> AllowedRootFields SubscriptionRootFieldType -> SelPerm (b :: BackendType)

-- | Allowed columns
[spColumns] :: SelPerm (b :: BackendType) -> PermColSpec b

-- | Filter expression
[spFilter] :: SelPerm (b :: BackendType) -> BoolExp b

-- | Limit value
[spLimit] :: SelPerm (b :: BackendType) -> Maybe Int

-- | Allow aggregation
[spAllowAggregations] :: SelPerm (b :: BackendType) -> Bool

-- | Allowed computed fields which should not include the fields returning
--   rows of existing table.
[spComputedFields] :: SelPerm (b :: BackendType) -> [ComputedFieldName]
[spAllowedQueryRootFields] :: SelPerm (b :: BackendType) -> AllowedRootFields QueryRootFieldType
[spAllowedSubscriptionRootFields] :: SelPerm (b :: BackendType) -> AllowedRootFields SubscriptionRootFieldType
type SelPermDef (b :: BackendType) = PermDef b SelPerm
data UpdPerm (b :: BackendType)
UpdPerm :: PermColSpec b -> Maybe (ColumnValues b Value) -> BoolExp b -> Maybe (BoolExp b) -> Bool -> Maybe (ValidateInput InputWebhook) -> UpdPerm (b :: BackendType)
[ucColumns] :: UpdPerm (b :: BackendType) -> PermColSpec b
[ucSet] :: UpdPerm (b :: BackendType) -> Maybe (ColumnValues b Value)
[ucFilter] :: UpdPerm (b :: BackendType) -> BoolExp b

-- | Check expression, which must be true after update. This is optional
--   because we don't want to break the v1 API but Nothing should be
--   equivalent to the expression which always returns true.
[ucCheck] :: UpdPerm (b :: BackendType) -> Maybe (BoolExp b)
[ucBackendOnly] :: UpdPerm (b :: BackendType) -> Bool
[ucValidateInput] :: UpdPerm (b :: BackendType) -> Maybe (ValidateInput InputWebhook)
type UpdPermDef (b :: BackendType) = PermDef b UpdPerm
pdComment :: forall (b :: BackendType) (perm :: BackendType -> Type) f. Functor f => (Maybe Text -> f (Maybe Text)) -> PermDef b perm -> f (PermDef b perm)
pdPermission :: forall (b1 :: BackendType) (perm1 :: BackendType -> Type) (b2 :: BackendType) (perm2 :: BackendType -> Type) f. Functor f => (PermDefPermission b1 perm1 -> f (PermDefPermission b2 perm2)) -> PermDef b1 perm1 -> f (PermDef b2 perm2)
pdRole :: forall (b :: BackendType) (perm :: BackendType -> Type) f. Functor f => (RoleName -> f RoleName) -> PermDef b perm -> f (PermDef b perm)
permTypeToCode :: PermType -> Text

-- | The permission data as it appears in a <a>PermDef</a>. Since this type
--   is a GADT it facilitates that values which are polymorphic may
--   re-discover its specific type of permission by case analysis.
--   
--   The fact that permission types are tracked in types are more
--   accidental than intentional and something we want to move away from,
--   see <a>https://github.com/hasura/graphql-engine-mono/issues/4076</a>.
data PermDefPermission (b :: BackendType) (perm :: BackendType -> Type)
[SelPerm'] :: forall (b :: BackendType). SelPerm b -> PermDefPermission b SelPerm
[InsPerm'] :: forall (b :: BackendType). InsPerm b -> PermDefPermission b InsPerm
[UpdPerm'] :: forall (b :: BackendType). UpdPerm b -> PermDefPermission b UpdPerm
[DelPerm'] :: forall (b :: BackendType). DelPerm b -> PermDefPermission b DelPerm
unPermDefPermission :: forall (b :: BackendType) perm. PermDefPermission b perm -> perm b
reflectPermDefPermission :: forall (b :: BackendType) (a :: BackendType -> Type). PermDefPermission b a -> PermType
data SubscriptionRootFieldType
SRFTSelect :: SubscriptionRootFieldType
SRFTSelectByPk :: SubscriptionRootFieldType
SRFTSelectAggregate :: SubscriptionRootFieldType
SRFTSelectStream :: SubscriptionRootFieldType
data QueryRootFieldType
QRFTSelect :: QueryRootFieldType
QRFTSelectByPk :: QueryRootFieldType
QRFTSelectAggregate :: QueryRootFieldType
data AllowedRootFields rootFieldType
ARFAllowAllRootFields :: AllowedRootFields rootFieldType
ARFAllowConfiguredRootFields :: HashSet rootFieldType -> AllowedRootFields rootFieldType
isRootFieldAllowed :: Eq rootField => rootField -> AllowedRootFields rootField -> Bool
instance GHC.Internal.Enum.Bounded Hasura.RQL.Types.Permission.QueryRootFieldType
instance GHC.Internal.Enum.Bounded Hasura.RQL.Types.Permission.SubscriptionRootFieldType
instance GHC.Internal.Enum.Enum Hasura.RQL.Types.Permission.QueryRootFieldType
instance GHC.Internal.Enum.Enum Hasura.RQL.Types.Permission.SubscriptionRootFieldType
instance GHC.Classes.Eq rootFieldType => GHC.Classes.Eq (Hasura.RQL.Types.Permission.AllowedRootFields rootFieldType)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Permission.DelPerm b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Permission.InsPerm b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Permission.PermColSpec b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Permission.PermDef b perm)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Permission.PermDefPermission b perm)
instance GHC.Classes.Eq Hasura.RQL.Types.Permission.PermType
instance GHC.Classes.Eq Hasura.RQL.Types.Permission.QueryRootFieldType
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Permission.SelPerm b)
instance GHC.Classes.Eq Hasura.RQL.Types.Permission.SubscriptionRootFieldType
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Permission.UpdPerm b)
instance GHC.Classes.Eq webhook => GHC.Classes.Eq (Hasura.RQL.Types.Permission.ValidateInput webhook)
instance GHC.Classes.Eq webhook => GHC.Classes.Eq (Hasura.RQL.Types.Permission.ValidateInputHttpDefinition webhook)
instance GHC.Internal.Data.Foldable.Foldable Hasura.RQL.Types.Permission.ValidateInput
instance GHC.Internal.Data.Foldable.Foldable Hasura.RQL.Types.Permission.ValidateInputHttpDefinition
instance Database.PG.Query.Class.FromCol Hasura.RQL.Types.Permission.PermType
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Permission.DelPerm b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Permission.InsPerm b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Permission.PermColSpec b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Permission.PermDef b Hasura.RQL.Types.Permission.SelPerm)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Permission.PermDef b Hasura.RQL.Types.Permission.InsPerm)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Permission.PermDef b Hasura.RQL.Types.Permission.UpdPerm)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Permission.PermDef b Hasura.RQL.Types.Permission.DelPerm)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Permission.PermDefPermission b Hasura.RQL.Types.Permission.SelPerm)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Permission.PermDefPermission b Hasura.RQL.Types.Permission.InsPerm)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Permission.PermDefPermission b Hasura.RQL.Types.Permission.UpdPerm)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Permission.PermDefPermission b Hasura.RQL.Types.Permission.DelPerm)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Permission.PermType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Permission.QueryRootFieldType
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Permission.SelPerm b)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Permission.SubscriptionRootFieldType
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Permission.UpdPerm b)
instance Data.Aeson.Types.FromJSON.FromJSON webhook => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Permission.ValidateInput webhook)
instance Data.Aeson.Types.FromJSON.FromJSON webhook => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Permission.ValidateInputHttpDefinition webhook)
instance GHC.Internal.Base.Functor Hasura.RQL.Types.Permission.ValidateInput
instance GHC.Internal.Base.Functor Hasura.RQL.Types.Permission.ValidateInputHttpDefinition
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Permission.AllowedRootFields rootFieldType)
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Permission.DelPerm b)
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Permission.InsPerm b)
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Permission.PermColSpec b)
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Permission.PermDef b perm)
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Permission.PermType
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Permission.QueryRootFieldType
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Permission.SelPerm b)
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Permission.SubscriptionRootFieldType
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Permission.UpdPerm b)
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Permission.ValidateInput webhook)
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Permission.ValidateInputHttpDefinition webhook)
instance (Data.Hashable.Class.Hashable rootFieldType, Autodocodec.Class.HasCodec rootFieldType) => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Permission.AllowedRootFields rootFieldType)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Permission.DelPerm b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Permission.InsPerm b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Permission.PermColSpec b)
instance (Hasura.RQL.Types.Backend.Backend b, Autodocodec.Class.HasCodec (perm b), Hasura.RQL.Types.Permission.IsPerm perm) => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Permission.PermDef b perm)
instance (Hasura.RQL.Types.Backend.Backend b, Autodocodec.Class.HasCodec (perm b), Hasura.RQL.Types.Permission.IsPerm perm) => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Permission.PermDefPermission b perm)
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Permission.QueryRootFieldType
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Permission.SelPerm b)
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Permission.SubscriptionRootFieldType
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Permission.UpdPerm b)
instance (Autodocodec.Class.HasCodec webhook, GHC.Internal.Data.Typeable.Internal.Typeable webhook) => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Permission.ValidateInput webhook)
instance Autodocodec.Class.HasCodec webhook => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Permission.ValidateInputHttpDefinition webhook)
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Permission.PermType
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Permission.QueryRootFieldType
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Permission.SubscriptionRootFieldType
instance Hasura.RQL.Types.Permission.IsPerm Hasura.RQL.Types.Permission.DelPerm
instance Hasura.RQL.Types.Permission.IsPerm Hasura.RQL.Types.Permission.InsPerm
instance Hasura.RQL.Types.Permission.IsPerm Hasura.RQL.Types.Permission.SelPerm
instance Hasura.RQL.Types.Permission.IsPerm Hasura.RQL.Types.Permission.UpdPerm
instance Control.DeepSeq.NFData rootFieldType => Control.DeepSeq.NFData (Hasura.RQL.Types.Permission.AllowedRootFields rootFieldType)
instance Control.DeepSeq.NFData Hasura.RQL.Types.Permission.PermType
instance Control.DeepSeq.NFData Hasura.RQL.Types.Permission.QueryRootFieldType
instance Control.DeepSeq.NFData Hasura.RQL.Types.Permission.SubscriptionRootFieldType
instance Control.DeepSeq.NFData webhook => Control.DeepSeq.NFData (Hasura.RQL.Types.Permission.ValidateInput webhook)
instance Control.DeepSeq.NFData webhook => Control.DeepSeq.NFData (Hasura.RQL.Types.Permission.ValidateInputHttpDefinition webhook)
instance GHC.Classes.Ord Hasura.RQL.Types.Permission.PermType
instance GHC.Internal.Base.Semigroup (Data.HashSet.Internal.HashSet rootFieldType) => GHC.Internal.Base.Semigroup (Hasura.RQL.Types.Permission.AllowedRootFields rootFieldType)
instance GHC.Internal.Show.Show rootFieldType => GHC.Internal.Show.Show (Hasura.RQL.Types.Permission.AllowedRootFields rootFieldType)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.Types.Permission.DelPerm b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.Types.Permission.InsPerm b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.Types.Permission.PermColSpec b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.Types.Permission.PermDef b perm)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.Types.Permission.PermDefPermission b perm)
instance GHC.Internal.Show.Show Hasura.RQL.Types.Permission.PermType
instance GHC.Internal.Show.Show Hasura.RQL.Types.Permission.QueryRootFieldType
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.Types.Permission.SelPerm b)
instance GHC.Internal.Show.Show Hasura.RQL.Types.Permission.SubscriptionRootFieldType
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.Types.Permission.UpdPerm b)
instance GHC.Internal.Show.Show webhook => GHC.Internal.Show.Show (Hasura.RQL.Types.Permission.ValidateInput webhook)
instance GHC.Internal.Show.Show webhook => GHC.Internal.Show.Show (Hasura.RQL.Types.Permission.ValidateInputHttpDefinition webhook)
instance Hasura.RQL.Types.Backend.Backend b => Hasura.RQL.Types.Common.ToAesonPairs (Hasura.RQL.Types.Permission.PermDef b perm)
instance Data.Aeson.Types.ToJSON.ToJSON rootFieldType => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Permission.AllowedRootFields rootFieldType)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Permission.DelPerm b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Permission.InsPerm b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Permission.PermColSpec b)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.ToJSON.ToJSON (perm b)) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Permission.PermDef b perm)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Permission.PermDefPermission b perm)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Permission.PermType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Permission.QueryRootFieldType
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Permission.SelPerm b)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Permission.SubscriptionRootFieldType
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Permission.UpdPerm b)
instance Data.Aeson.Types.ToJSON.ToJSON webhook => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Permission.ValidateInput webhook)
instance Data.Aeson.Types.ToJSON.ToJSON webhook => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Permission.ValidateInputHttpDefinition webhook)
instance GHC.Internal.Data.Traversable.Traversable Hasura.RQL.Types.Permission.ValidateInput
instance GHC.Internal.Data.Traversable.Traversable Hasura.RQL.Types.Permission.ValidateInputHttpDefinition

module Hasura.LogicalModelResolver.Metadata

-- | Description of an inline logical model to use in metadata (before
--   schema cache) this has no name - it is up to the resolving user (ie,
--   the Native Query, etc) to give the generated type a name
data InlineLogicalModelMetadata (b :: BackendType)
InlineLogicalModelMetadata :: InsOrdHashMap (Column b) (LogicalModelField b) -> InsOrdHashMap RoleName (SelPermDef b) -> InlineLogicalModelMetadata (b :: BackendType)
[_ilmmFields] :: InlineLogicalModelMetadata (b :: BackendType) -> InsOrdHashMap (Column b) (LogicalModelField b)
[_ilmmSelectPermissions] :: InlineLogicalModelMetadata (b :: BackendType) -> InsOrdHashMap RoleName (SelPermDef b)

-- | the name of a Logical Model, or an inline Logical Model
data LogicalModelIdentifier (b :: BackendType)
LMILogicalModelName :: LogicalModelName -> LogicalModelIdentifier (b :: BackendType)
LMIInlineLogicalModel :: InlineLogicalModelMetadata b -> LogicalModelIdentifier (b :: BackendType)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.LogicalModelResolver.Metadata.InlineLogicalModelMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.LogicalModelResolver.Metadata.LogicalModelIdentifier b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.LogicalModelResolver.Metadata.InlineLogicalModelMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.LogicalModelResolver.Metadata.LogicalModelIdentifier b)
instance GHC.Internal.Generics.Generic (Hasura.LogicalModelResolver.Metadata.InlineLogicalModelMetadata b)
instance GHC.Internal.Generics.Generic (Hasura.LogicalModelResolver.Metadata.LogicalModelIdentifier b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.LogicalModelResolver.Metadata.InlineLogicalModelMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.LogicalModelResolver.Metadata.LogicalModelIdentifier b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.LogicalModelResolver.Metadata.InlineLogicalModelMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.LogicalModelResolver.Metadata.LogicalModelIdentifier b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.LogicalModelResolver.Metadata.InlineLogicalModelMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.LogicalModelResolver.Metadata.LogicalModelIdentifier b)


-- | Metadata representation of a native query in the metadata, as well as
--   a parser and prettyprinter for the query code.
module Hasura.NativeQuery.Metadata
newtype NativeQueryName
NativeQueryName :: Name -> NativeQueryName
[getNativeQueryName] :: NativeQueryName -> Name

-- | The representation of native queries within the metadata structure.
data NativeQueryMetadata (b :: BackendType)
NativeQueryMetadata :: NativeQueryName -> InterpolatedQuery ArgumentName -> LogicalModelIdentifier b -> HashMap ArgumentName (NullableScalarType b) -> Relationships (RelDef (RelManualConfig b)) -> Relationships (RelDef (RelManualConfig b)) -> Maybe Text -> NativeQueryMetadata (b :: BackendType)
[_nqmRootFieldName] :: NativeQueryMetadata (b :: BackendType) -> NativeQueryName
[_nqmCode] :: NativeQueryMetadata (b :: BackendType) -> InterpolatedQuery ArgumentName
[_nqmReturns] :: NativeQueryMetadata (b :: BackendType) -> LogicalModelIdentifier b
[_nqmArguments] :: NativeQueryMetadata (b :: BackendType) -> HashMap ArgumentName (NullableScalarType b)
[_nqmArrayRelationships] :: NativeQueryMetadata (b :: BackendType) -> Relationships (RelDef (RelManualConfig b))
[_nqmObjectRelationships] :: NativeQueryMetadata (b :: BackendType) -> Relationships (RelDef (RelManualConfig b))
[_nqmDescription] :: NativeQueryMetadata (b :: BackendType) -> Maybe Text

-- | A name of an argument to a native query or stored procedure.
newtype ArgumentName
ArgumentName :: Text -> ArgumentName
[getArgumentName] :: ArgumentName -> Text

-- | A component of an interpolated query
data InterpolatedItem variable

-- | normal text
IIText :: Text -> InterpolatedItem variable

-- | a captured variable
IIVariable :: variable -> InterpolatedItem variable

-- | A list of stored procedure components representing a single stored
--   procedure, separating the variables from the text.
newtype InterpolatedQuery variable
InterpolatedQuery :: [InterpolatedItem variable] -> InterpolatedQuery variable
[getInterpolatedQuery] :: InterpolatedQuery variable -> [InterpolatedItem variable]

-- | extract all of the `{{ variable }}` inside our query string
parseInterpolatedQuery :: Text -> Either Text (InterpolatedQuery ArgumentName)

-- | A wrapper to tie something to a particular native query. Specifically,
--   it assumes the underlying <tt>_wlmInfo</tt> is represented as an
--   object, and adds two keys to that object: <tt>source</tt> and
--   <tt>root_field_name</tt>.
data WithNativeQuery a
WithNativeQuery :: SourceName -> NativeQueryName -> a -> WithNativeQuery a
[_wnqSource] :: WithNativeQuery a -> SourceName
[_wnqName] :: WithNativeQuery a -> NativeQueryName
[_wnqInfo] :: WithNativeQuery a -> a
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.NativeQuery.Metadata.NativeQueryMetadata b)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.NativeQuery.Metadata.WithNativeQuery a)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.NativeQuery.Metadata.NativeQueryMetadata b)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Hasura.NativeQuery.Metadata.WithNativeQuery a)
instance GHC.Internal.Generics.Generic (Hasura.NativeQuery.Metadata.NativeQueryMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.NativeQuery.Metadata.NativeQueryMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.NativeQuery.Metadata.NativeQueryMetadata b)
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (Hasura.NativeQuery.Metadata.WithNativeQuery a)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.NativeQuery.Metadata.NativeQueryMetadata b)
instance Hasura.RQL.Types.Common.ToAesonPairs a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.NativeQuery.Metadata.WithNativeQuery a)


-- | Generic validation of native queries while tracking them.
module Hasura.NativeQuery.Validation

-- | Check that the set of declared arguments and the set of used arguments
--   (in the code) is the same.
validateArgumentDeclaration :: forall m (b :: BackendType). (MonadIO m, MonadError QErr m) => NativeQueryMetadata b -> m ()


-- | The RQL IR representation of an invocation of a native query.
module Hasura.NativeQuery.IR

-- | The RQL IR representation of an invocation of a native query.
data NativeQuery (b :: BackendType) field
NativeQuery :: NativeQueryName -> InterpolatedQuery field -> LogicalModel b -> NativeQuery (b :: BackendType) field

-- | The graphql name of the native query.
[nqRootFieldName] :: NativeQuery (b :: BackendType) field -> NativeQueryName

-- | The raw sql to use in the query
[nqInterpolatedQuery] :: NativeQuery (b :: BackendType) field -> InterpolatedQuery field

-- | The return type of the native query
[nqLogicalModel] :: NativeQuery (b :: BackendType) field -> LogicalModel b
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq field) => GHC.Classes.Eq (Hasura.NativeQuery.IR.NativeQuery b field)
instance GHC.Internal.Data.Foldable.Foldable (Hasura.NativeQuery.IR.NativeQuery b)
instance GHC.Internal.Base.Functor (Hasura.NativeQuery.IR.NativeQuery b)
instance GHC.Internal.Generics.Generic (Hasura.NativeQuery.IR.NativeQuery b field)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show field) => GHC.Internal.Show.Show (Hasura.NativeQuery.IR.NativeQuery b field)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.ToJSON.ToJSON field, field GHC.Types.~ Hasura.LogicalModelResolver.Types.ArgumentName) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.NativeQuery.IR.NativeQuery b field)
instance GHC.Internal.Data.Traversable.Traversable (Hasura.NativeQuery.IR.NativeQuery b)

module Hasura.LogicalModelResolver.Lenses
ilmmFields :: forall (b :: BackendType) f. Functor f => (InsOrdHashMap (Column b) (LogicalModelField b) -> f (InsOrdHashMap (Column b) (LogicalModelField b))) -> InlineLogicalModelMetadata b -> f (InlineLogicalModelMetadata b)
ilmmSelectPermissions :: forall (b :: BackendType) f. Functor f => (InsOrdHashMap RoleName (SelPermDef b) -> f (InsOrdHashMap RoleName (SelPermDef b))) -> InlineLogicalModelMetadata b -> f (InlineLogicalModelMetadata b)
_LMIInlineLogicalModel :: forall (b1 :: BackendType) (b2 :: BackendType) p f. (Choice p, Applicative f) => p (InlineLogicalModelMetadata b1) (f (InlineLogicalModelMetadata b2)) -> p (LogicalModelIdentifier b1) (f (LogicalModelIdentifier b2))
_LMILogicalModelName :: forall (b :: BackendType) p f. (Choice p, Applicative f) => p LogicalModelName (f LogicalModelName) -> p (LogicalModelIdentifier b) (f (LogicalModelIdentifier b))

module Hasura.LogicalModel.Metadata

-- | Description of a logical model for use in metadata (before schema
--   cache)
data LogicalModelMetadata (b :: BackendType)
LogicalModelMetadata :: LogicalModelName -> LogicalModelFields b -> Maybe Text -> InsOrdHashMap RoleName (SelPermDef b) -> LogicalModelMetadata (b :: BackendType)
[_lmmName] :: LogicalModelMetadata (b :: BackendType) -> LogicalModelName
[_lmmFields] :: LogicalModelMetadata (b :: BackendType) -> LogicalModelFields b
[_lmmDescription] :: LogicalModelMetadata (b :: BackendType) -> Maybe Text
[_lmmSelectPermissions] :: LogicalModelMetadata (b :: BackendType) -> InsOrdHashMap RoleName (SelPermDef b)
newtype LogicalModelName
LogicalModelName :: Name -> LogicalModelName
[getLogicalModelName] :: LogicalModelName -> Name

-- | A wrapper to tie something to a particular native query. Specifically,
--   it assumes the underlying <a>_wlmInfo</a> is represented as an object,
--   and adds two keys to that object: <tt>source</tt> and
--   <tt>root_field_name</tt>.
data WithLogicalModel a
WithLogicalModel :: SourceName -> LogicalModelName -> a -> WithLogicalModel a
[_wlmSource] :: WithLogicalModel a -> SourceName
[_wlmName] :: WithLogicalModel a -> LogicalModelName
[_wlmInfo] :: WithLogicalModel a -> a
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.LogicalModel.Metadata.LogicalModelMetadata b)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.LogicalModel.Metadata.WithLogicalModel a)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.LogicalModel.Metadata.LogicalModelMetadata b)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Hasura.LogicalModel.Metadata.WithLogicalModel a)
instance GHC.Internal.Generics.Generic (Hasura.LogicalModel.Metadata.LogicalModelMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.LogicalModel.Metadata.LogicalModelMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.LogicalModel.Metadata.LogicalModelMetadata b)
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (Hasura.LogicalModel.Metadata.WithLogicalModel a)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.LogicalModel.Metadata.LogicalModelMetadata b)
instance Hasura.RQL.Types.Common.ToAesonPairs a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.LogicalModel.Metadata.WithLogicalModel a)

module Hasura.RQL.Types.Source.Table

-- | Table schema data from the <tt>SchemaResponse</tt>.
data SourceTableInfo (b :: BackendType)
SourceTableInfo :: TableName b -> SourceTableType -> [SourceColumnInfo b] -> [LogicalModelMetadata b] -> Maybe (NonEmpty (Column b)) -> SourceForeignKeys b -> Maybe Text -> Bool -> Bool -> Bool -> SourceTableInfo (b :: BackendType)
[_stiName] :: SourceTableInfo (b :: BackendType) -> TableName b
[_stiType] :: SourceTableInfo (b :: BackendType) -> SourceTableType
[_stiColumns] :: SourceTableInfo (b :: BackendType) -> [SourceColumnInfo b]
[_stiLogicalModels] :: SourceTableInfo (b :: BackendType) -> [LogicalModelMetadata b]
[_stiPrimaryKey] :: SourceTableInfo (b :: BackendType) -> Maybe (NonEmpty (Column b))
[_stiForeignKeys] :: SourceTableInfo (b :: BackendType) -> SourceForeignKeys b
[_stiDescription] :: SourceTableInfo (b :: BackendType) -> Maybe Text
[_stiInsertable] :: SourceTableInfo (b :: BackendType) -> Bool
[_stiUpdatable] :: SourceTableInfo (b :: BackendType) -> Bool
[_stiDeletable] :: SourceTableInfo (b :: BackendType) -> Bool
stiName :: forall (b :: BackendType) f. Functor f => (TableName b -> f (TableName b)) -> SourceTableInfo b -> f (SourceTableInfo b)
stiType :: forall (b :: BackendType) f. Functor f => (SourceTableType -> f SourceTableType) -> SourceTableInfo b -> f (SourceTableInfo b)
stiColumns :: forall (b :: BackendType) f. Functor f => ([SourceColumnInfo b] -> f [SourceColumnInfo b]) -> SourceTableInfo b -> f (SourceTableInfo b)
stiLogicalModels :: forall (b :: BackendType) f. Functor f => ([LogicalModelMetadata b] -> f [LogicalModelMetadata b]) -> SourceTableInfo b -> f (SourceTableInfo b)
stiPrimaryKey :: forall (b :: BackendType) f. Functor f => (Maybe (NonEmpty (Column b)) -> f (Maybe (NonEmpty (Column b)))) -> SourceTableInfo b -> f (SourceTableInfo b)
stiForeignKeys :: forall (b :: BackendType) f. Functor f => (SourceForeignKeys b -> f (SourceForeignKeys b)) -> SourceTableInfo b -> f (SourceTableInfo b)
stiDescription :: forall (b :: BackendType) f. Functor f => (Maybe Text -> f (Maybe Text)) -> SourceTableInfo b -> f (SourceTableInfo b)
stiInsertable :: forall (b :: BackendType) f. Functor f => (Bool -> f Bool) -> SourceTableInfo b -> f (SourceTableInfo b)
stiUpdatable :: forall (b :: BackendType) f. Functor f => (Bool -> f Bool) -> SourceTableInfo b -> f (SourceTableInfo b)
stiDeletable :: forall (b :: BackendType) f. Functor f => (Bool -> f Bool) -> SourceTableInfo b -> f (SourceTableInfo b)
data SourceTableType
Table :: SourceTableType
View :: SourceTableType
newtype SourceForeignKeys (b :: BackendType)
SourceForeignKeys :: HashMap (ConstraintName b) (SourceConstraint b) -> SourceForeignKeys (b :: BackendType)
[_unSourceForeignKeys] :: SourceForeignKeys (b :: BackendType) -> HashMap (ConstraintName b) (SourceConstraint b)
unSourceForeignKeys :: forall (b1 :: BackendType) (b2 :: BackendType) p f. (Profunctor p, Functor f) => p (HashMap (ConstraintName b1) (SourceConstraint b1)) (f (HashMap (ConstraintName b2) (SourceConstraint b2))) -> p (SourceForeignKeys b1) (f (SourceForeignKeys b2))
data SourceConstraint (b :: BackendType)
SourceConstraint :: TableName b -> RelMapping b -> SourceConstraint (b :: BackendType)
[_scForeignTable] :: SourceConstraint (b :: BackendType) -> TableName b
[_scColumnMapping] :: SourceConstraint (b :: BackendType) -> RelMapping b
scForeignTable :: forall (b :: BackendType) f. Functor f => (TableName b -> f (TableName b)) -> SourceConstraint b -> f (SourceConstraint b)
scColumnMapping :: forall (b :: BackendType) f. Functor f => (RelMapping b -> f (RelMapping b)) -> SourceConstraint b -> f (SourceConstraint b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Source.Table.SourceConstraint b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Source.Table.SourceForeignKeys b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Source.Table.SourceTableInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Source.Table.SourceConstraint b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Source.Table.SourceForeignKeys b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Source.Table.SourceTableInfo b)
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Source.Table.SourceConstraint b)
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Source.Table.SourceForeignKeys b)
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Source.Table.SourceTableInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Source.Table.SourceConstraint b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Source.Table.SourceForeignKeys b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Source.Table.SourceTableInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.Source.Table.SourceConstraint b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.Source.Table.SourceForeignKeys b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Ord (Hasura.RQL.Types.Source.Table.SourceConstraint b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Ord (Hasura.RQL.Types.Source.Table.SourceForeignKeys b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.Types.Source.Table.SourceConstraint b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.Types.Source.Table.SourceForeignKeys b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.Types.Source.Table.SourceTableInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Source.Table.SourceConstraint b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Source.Table.SourceForeignKeys b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Source.Table.SourceTableInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.OpenApi.Internal.Schema.ToSchema (Hasura.RQL.Types.Source.Table.SourceTableInfo b)


-- | Postgres Types CitusExtraTableMetadata
--   
--   Additional metadata information for Citus tables.
--   
--   See
--   <a>https://www.citusdata.com/blog/2017/07/27/database-table-types-with-citus-and-postgres/</a>
--   for more details on the Citus table types.
module Hasura.Backends.Postgres.Types.CitusExtraTableMetadata
data ExtraTableMetadata
Local :: SourceTableType -> ExtraTableMetadata
[tableType] :: ExtraTableMetadata -> SourceTableType
Reference :: SourceTableType -> ExtraTableMetadata
[tableType] :: ExtraTableMetadata -> SourceTableType
Distributed :: Text -> SourceTableType -> ExtraTableMetadata
instance GHC.Classes.Eq Hasura.Backends.Postgres.Types.CitusExtraTableMetadata.ExtraTableMetadata
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Types.CitusExtraTableMetadata.ExtraTableMetadata
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.Types.CitusExtraTableMetadata.ExtraTableMetadata
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Types.CitusExtraTableMetadata.ExtraTableMetadata
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Types.CitusExtraTableMetadata.ExtraTableMetadata
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Types.CitusExtraTableMetadata.ExtraTableMetadata
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Types.CitusExtraTableMetadata.ExtraTableMetadata


-- | Contains types that can be used by backends to structure updates to
--   batches of rows in a table
module Hasura.RQL.IR.Update.Batch

-- | Represents a set of update operations (<a>_ubOperations</a>) applied
--   to a batch of rows selected from a table by filtering it with a
--   boolean expression (<a>_ubWhere</a>).
--   
--   This type may be used by specific backends as a part their
--   <a>UpdateVariant</a>. See <a>PgUpdateVariant</a> for an example.
--   
--   The actual operators used to affect changes against columns in
--   <a>_ubOperations</a> are abstract here and are specified by the
--   specific backends based on what they actually support
data UpdateBatch (b :: BackendType) (updateOperators :: Type -> Type) v
UpdateBatch :: HashMap (Column b) (updateOperators v) -> AnnBoolExp b v -> UpdateBatch (b :: BackendType) (updateOperators :: Type -> Type) v
[_ubOperations] :: UpdateBatch (b :: BackendType) (updateOperators :: Type -> Type) v -> HashMap (Column b) (updateOperators v)
[_ubWhere] :: UpdateBatch (b :: BackendType) (updateOperators :: Type -> Type) v -> AnnBoolExp b v

-- | Are we actually updating anything in the batch?
updateBatchIsEmpty :: forall (b :: BackendType) (updateOperators :: Type -> Type) v. UpdateBatch b updateOperators v -> Bool
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq v, GHC.Classes.Eq (updateOperators v)) => GHC.Classes.Eq (Hasura.RQL.IR.Update.Batch.UpdateBatch b updateOperators v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Data.Foldable.Foldable updateOperators) => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.Update.Batch.UpdateBatch b updateOperators)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Base.Functor updateOperators) => GHC.Internal.Base.Functor (Hasura.RQL.IR.Update.Batch.UpdateBatch b updateOperators)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show v, GHC.Internal.Show.Show (updateOperators v)) => GHC.Internal.Show.Show (Hasura.RQL.IR.Update.Batch.UpdateBatch b updateOperators v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Data.Traversable.Traversable updateOperators) => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.Update.Batch.UpdateBatch b updateOperators)


-- | Postgres Types Update
--   
--   This module defines the Update-related IR types specific to Postgres.
module Hasura.Backends.Postgres.Types.Update

-- | The various <tt>update operators</tt> supported by PostgreSQL, i.e.
--   the <tt>_set</tt>, <tt>_inc</tt> operators that appear in the schema.
--   
--   See <a>Update Mutations User docs</a>
data UpdateOpExpression v
UpdateSet :: v -> UpdateOpExpression v
UpdateInc :: v -> UpdateOpExpression v
UpdateAppend :: v -> UpdateOpExpression v
UpdatePrepend :: v -> UpdateOpExpression v
UpdateDeleteKey :: v -> UpdateOpExpression v
UpdateDeleteElem :: v -> UpdateOpExpression v
UpdateDeleteAtPath :: [v] -> UpdateOpExpression v

-- | The different <tt>variants</tt> of updates that the Postgres backend
--   supports.
--   
--   This is parameterised over <tt>v</tt> which enables different phases
--   of IR transformation to maintain the overall structure while
--   enriching/transforming the data at the leaves.
data PgUpdateVariant (pgKind :: PostgresKind) v
SingleBatch :: UpdateBatch ('Postgres pgKind) UpdateOpExpression v -> PgUpdateVariant (pgKind :: PostgresKind) v
MultipleBatches :: [UpdateBatch ('Postgres pgKind) UpdateOpExpression v] -> PgUpdateVariant (pgKind :: PostgresKind) v

-- | Are we updating anything?
updateVariantIsEmpty :: forall (b :: PostgresKind) v. PgUpdateVariant b v -> Bool
instance GHC.Internal.Data.Data.Data v => GHC.Internal.Data.Data.Data (Hasura.Backends.Postgres.Types.Update.UpdateOpExpression v)
instance GHC.Classes.Eq (Hasura.RQL.IR.Update.Batch.UpdateBatch ('Hasura.RQL.Types.BackendType.Postgres pgKind) Hasura.Backends.Postgres.Types.Update.UpdateOpExpression v) => GHC.Classes.Eq (Hasura.Backends.Postgres.Types.Update.PgUpdateVariant pgKind v)
instance GHC.Classes.Eq v => GHC.Classes.Eq (Hasura.Backends.Postgres.Types.Update.UpdateOpExpression v)
instance Hasura.RQL.Types.Backend.Backend ('Hasura.RQL.Types.BackendType.Postgres pgKind) => GHC.Internal.Data.Foldable.Foldable (Hasura.Backends.Postgres.Types.Update.PgUpdateVariant pgKind)
instance GHC.Internal.Data.Foldable.Foldable Hasura.Backends.Postgres.Types.Update.UpdateOpExpression
instance Hasura.RQL.Types.Backend.Backend ('Hasura.RQL.Types.BackendType.Postgres pgKind) => GHC.Internal.Base.Functor (Hasura.Backends.Postgres.Types.Update.PgUpdateVariant pgKind)
instance GHC.Internal.Base.Functor Hasura.Backends.Postgres.Types.Update.UpdateOpExpression
instance GHC.Internal.Generics.Generic (Hasura.Backends.Postgres.Types.Update.UpdateOpExpression v)
instance GHC.Internal.Show.Show (Hasura.RQL.IR.Update.Batch.UpdateBatch ('Hasura.RQL.Types.BackendType.Postgres pgKind) Hasura.Backends.Postgres.Types.Update.UpdateOpExpression v) => GHC.Internal.Show.Show (Hasura.Backends.Postgres.Types.Update.PgUpdateVariant pgKind v)
instance GHC.Internal.Show.Show v => GHC.Internal.Show.Show (Hasura.Backends.Postgres.Types.Update.UpdateOpExpression v)
instance Hasura.RQL.Types.Backend.Backend ('Hasura.RQL.Types.BackendType.Postgres pgKind) => GHC.Internal.Data.Traversable.Traversable (Hasura.Backends.Postgres.Types.Update.PgUpdateVariant pgKind)
instance GHC.Internal.Data.Traversable.Traversable Hasura.Backends.Postgres.Types.Update.UpdateOpExpression


-- | Arbitrarily putting leaves from RQL.IR.Select into own files to
--   parallelise compilation
module Hasura.RQL.IR.Select.TablePerm
type TablePerm (b :: BackendType) = TablePermG b SQLExpression b
data TablePermG (b :: BackendType) v
TablePerm :: AnnBoolExp b v -> Maybe Int -> TablePermG (b :: BackendType) v
[_tpFilter] :: TablePermG (b :: BackendType) v -> AnnBoolExp b v
[_tpLimit] :: TablePermG (b :: BackendType) v -> Maybe Int
noTablePermissions :: forall (backend :: BackendType) v. TablePermG backend v
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq v) => GHC.Classes.Eq (Hasura.RQL.IR.Select.TablePerm.TablePermG b v)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.Select.TablePerm.TablePermG b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Base.Functor (Hasura.RQL.IR.Select.TablePerm.TablePermG b)
instance GHC.Internal.Generics.Generic (Hasura.RQL.IR.Select.TablePerm.TablePermG b v)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable v) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.Select.TablePerm.TablePermG b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show v) => GHC.Internal.Show.Show (Hasura.RQL.IR.Select.TablePerm.TablePermG b v)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.Select.TablePerm.TablePermG b)

module Hasura.RQL.IR.Select.OrderBy
data AnnotatedAggregateOrderBy (b :: BackendType) v
AAOCount :: AnnotatedAggregateOrderBy (b :: BackendType) v

-- | Order by an aggregate function applied to a column
AAOOp :: AggregateOrderByColumn b v -> AnnotatedAggregateOrderBy (b :: BackendType) v
data AggregateOrderByColumn (b :: BackendType) v
AggregateOrderByColumn :: Text -> ColumnType b -> ColumnInfo b -> AnnRedactionExp b v -> AggregateOrderByColumn (b :: BackendType) v
[_aobcAggregateFunctionName] :: AggregateOrderByColumn (b :: BackendType) v -> Text
[_aobcAggregateFunctionReturnType] :: AggregateOrderByColumn (b :: BackendType) v -> ColumnType b
[_aobcColumn] :: AggregateOrderByColumn (b :: BackendType) v -> ColumnInfo b

-- | This type is used to determine whether the column should be redacted
--   before being aggregated and then ordered over
[_aobcRedactionExpression] :: AggregateOrderByColumn (b :: BackendType) v -> AnnRedactionExp b v
data AnnotatedOrderByElement (b :: BackendType) v
AOCColumn :: ColumnInfo b -> AnnRedactionExp b v -> AnnotatedOrderByElement (b :: BackendType) v
AOCNestedObject :: NestedObjectInfo b -> AnnotatedOrderByElement b v -> AnnotatedOrderByElement (b :: BackendType) v
AOCObjectRelation :: RelInfo b -> AnnBoolExp b v -> AnnotatedOrderByElement b v -> AnnotatedOrderByElement (b :: BackendType) v
AOCArrayAggregation :: RelInfo b -> AnnBoolExp b v -> AnnotatedAggregateOrderBy b v -> AnnotatedOrderByElement (b :: BackendType) v
AOCComputedField :: ComputedFieldOrderBy b v -> AnnotatedOrderByElement (b :: BackendType) v
type AnnotatedOrderByItem (b :: BackendType) = AnnotatedOrderByItemG b SQLExpression b
type AnnotatedOrderByItemG (b :: BackendType) v = OrderByItemG b AnnotatedOrderByElement b v
data ComputedFieldOrderBy (b :: BackendType) v
ComputedFieldOrderBy :: XComputedField b -> ComputedFieldName -> FunctionName b -> FunctionArgsExp b v -> ComputedFieldOrderByElement b v -> ComputedFieldOrderBy (b :: BackendType) v
[_cfobXField] :: ComputedFieldOrderBy (b :: BackendType) v -> XComputedField b
[_cfobName] :: ComputedFieldOrderBy (b :: BackendType) v -> ComputedFieldName
[_cfobFunction] :: ComputedFieldOrderBy (b :: BackendType) v -> FunctionName b
[_cfobFunctionArgsExp] :: ComputedFieldOrderBy (b :: BackendType) v -> FunctionArgsExp b v
[_cfobOrderByElement] :: ComputedFieldOrderBy (b :: BackendType) v -> ComputedFieldOrderByElement b v

-- | The order by element for a computed field based on its return type
data ComputedFieldOrderByElement (b :: BackendType) v

-- | Sort by the scalar computed field
CFOBEScalar :: ScalarType b -> AnnRedactionExp b v -> ComputedFieldOrderByElement (b :: BackendType) v
CFOBETableAggregation :: TableName b -> AnnBoolExp b v -> AnnotatedAggregateOrderBy b v -> ComputedFieldOrderByElement (b :: BackendType) v
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq v) => GHC.Classes.Eq (Hasura.RQL.IR.Select.OrderBy.AggregateOrderByColumn b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq v) => GHC.Classes.Eq (Hasura.RQL.IR.Select.OrderBy.AnnotatedAggregateOrderBy b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq v) => GHC.Classes.Eq (Hasura.RQL.IR.Select.OrderBy.AnnotatedOrderByElement b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq v) => GHC.Classes.Eq (Hasura.RQL.IR.Select.OrderBy.ComputedFieldOrderBy b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq v) => GHC.Classes.Eq (Hasura.RQL.IR.Select.OrderBy.ComputedFieldOrderByElement b v)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.Select.OrderBy.AggregateOrderByColumn b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.Select.OrderBy.AnnotatedAggregateOrderBy b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.Select.OrderBy.AnnotatedOrderByElement b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.Select.OrderBy.ComputedFieldOrderBy b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.Select.OrderBy.ComputedFieldOrderByElement b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Base.Functor (Hasura.RQL.IR.Select.OrderBy.AggregateOrderByColumn b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Base.Functor (Hasura.RQL.IR.Select.OrderBy.AnnotatedAggregateOrderBy b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Base.Functor (Hasura.RQL.IR.Select.OrderBy.AnnotatedOrderByElement b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Base.Functor (Hasura.RQL.IR.Select.OrderBy.ComputedFieldOrderBy b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Base.Functor (Hasura.RQL.IR.Select.OrderBy.ComputedFieldOrderByElement b)
instance GHC.Internal.Generics.Generic (Hasura.RQL.IR.Select.OrderBy.AggregateOrderByColumn b v)
instance GHC.Internal.Generics.Generic (Hasura.RQL.IR.Select.OrderBy.AnnotatedAggregateOrderBy b v)
instance GHC.Internal.Generics.Generic (Hasura.RQL.IR.Select.OrderBy.AnnotatedOrderByElement b v)
instance GHC.Internal.Generics.Generic (Hasura.RQL.IR.Select.OrderBy.ComputedFieldOrderBy b v)
instance GHC.Internal.Generics.Generic (Hasura.RQL.IR.Select.OrderBy.ComputedFieldOrderByElement b v)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable v) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.Select.OrderBy.AggregateOrderByColumn b v)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable v) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.Select.OrderBy.AnnotatedAggregateOrderBy b v)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable v) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.Select.OrderBy.AnnotatedOrderByElement b v)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable v) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.Select.OrderBy.ComputedFieldOrderBy b v)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable v) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.Select.OrderBy.ComputedFieldOrderByElement b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show v) => GHC.Internal.Show.Show (Hasura.RQL.IR.Select.OrderBy.AggregateOrderByColumn b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show v) => GHC.Internal.Show.Show (Hasura.RQL.IR.Select.OrderBy.AnnotatedAggregateOrderBy b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show v) => GHC.Internal.Show.Show (Hasura.RQL.IR.Select.OrderBy.AnnotatedOrderByElement b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show v) => GHC.Internal.Show.Show (Hasura.RQL.IR.Select.OrderBy.ComputedFieldOrderBy b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show v) => GHC.Internal.Show.Show (Hasura.RQL.IR.Select.OrderBy.ComputedFieldOrderByElement b v)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.Select.OrderBy.AggregateOrderByColumn b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.Select.OrderBy.AnnotatedAggregateOrderBy b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.Select.OrderBy.AnnotatedOrderByElement b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.Select.OrderBy.ComputedFieldOrderBy b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.Select.OrderBy.ComputedFieldOrderByElement b)


-- | Removed from <a>Select</a> to speed up compilation
module Hasura.RQL.IR.Select.Args
type SelectArgs (b :: BackendType) = SelectArgsG b SQLExpression b
data SelectArgsG (b :: BackendType) v
SelectArgs :: Maybe (AnnBoolExp b v) -> Maybe (NonEmpty (AnnotatedOrderByItemG b v)) -> Maybe Int -> Maybe Int64 -> Maybe (NonEmpty (AnnDistinctColumn b v)) -> SelectArgsG (b :: BackendType) v
[_saWhere] :: SelectArgsG (b :: BackendType) v -> Maybe (AnnBoolExp b v)
[_saOrderBy] :: SelectArgsG (b :: BackendType) v -> Maybe (NonEmpty (AnnotatedOrderByItemG b v))
[_saLimit] :: SelectArgsG (b :: BackendType) v -> Maybe Int
[_saOffset] :: SelectArgsG (b :: BackendType) v -> Maybe Int64
[_saDistinct] :: SelectArgsG (b :: BackendType) v -> Maybe (NonEmpty (AnnDistinctColumn b v))
data AnnDistinctColumn (b :: BackendType) v
AnnDistinctColumn :: Column b -> AnnRedactionExp b v -> AnnDistinctColumn (b :: BackendType) v
[_adcColumn] :: AnnDistinctColumn (b :: BackendType) v -> Column b

-- | This type is used to determine whether the column should be redacted
--   before being distincted-upon
[_adcRedactionExpression] :: AnnDistinctColumn (b :: BackendType) v -> AnnRedactionExp b v
data SelectStreamArgsG (b :: BackendType) v
SelectStreamArgsG :: Maybe (AnnBoolExp b v) -> Int -> StreamCursorItem b v -> SelectStreamArgsG (b :: BackendType) v

-- | optional filter to filter the stream results
[_ssaWhere] :: SelectStreamArgsG (b :: BackendType) v -> Maybe (AnnBoolExp b v)

-- | maximum number of rows to be returned in a single fetch
[_ssaBatchSize] :: SelectStreamArgsG (b :: BackendType) v -> Int

-- | info related to the cursor column, a single item data type currently
--   because only single column cursors are supported
[_ssaCursorArg] :: SelectStreamArgsG (b :: BackendType) v -> StreamCursorItem b v
type SelectStreamArgs (b :: BackendType) = SelectStreamArgsG b SQLExpression b

-- | Cursor for streaming subscription
data StreamCursorItem (b :: BackendType) v
StreamCursorItem :: CursorOrdering -> ColumnInfo b -> AnnRedactionExp b v -> ColumnValue b -> StreamCursorItem (b :: BackendType) v

-- | Specifies how the cursor item should be ordered
[_sciOrdering] :: StreamCursorItem (b :: BackendType) v -> CursorOrdering

-- | Column info of the cursor item
[_sciColInfo] :: StreamCursorItem (b :: BackendType) v -> ColumnInfo b

-- | This type is used to determine whether the column should be redacted
--   before it is sorted upon
[_sciRedactionExpression] :: StreamCursorItem (b :: BackendType) v -> AnnRedactionExp b v

-- | Initial value of the cursor item from where the streaming should start
[_sciInitialValue] :: StreamCursorItem (b :: BackendType) v -> ColumnValue b
noSelectArgs :: forall (backend :: BackendType) v. SelectArgsG backend v
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq v) => GHC.Classes.Eq (Hasura.RQL.IR.Select.Args.AnnDistinctColumn b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq v) => GHC.Classes.Eq (Hasura.RQL.IR.Select.Args.SelectArgsG b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq v) => GHC.Classes.Eq (Hasura.RQL.IR.Select.Args.SelectStreamArgsG b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq v) => GHC.Classes.Eq (Hasura.RQL.IR.Select.Args.StreamCursorItem b v)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.Select.Args.AnnDistinctColumn b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.Select.Args.SelectArgsG b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.Select.Args.SelectStreamArgsG b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.Select.Args.StreamCursorItem b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Base.Functor (Hasura.RQL.IR.Select.Args.AnnDistinctColumn b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Base.Functor (Hasura.RQL.IR.Select.Args.SelectArgsG b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Base.Functor (Hasura.RQL.IR.Select.Args.SelectStreamArgsG b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Base.Functor (Hasura.RQL.IR.Select.Args.StreamCursorItem b)
instance GHC.Internal.Generics.Generic (Hasura.RQL.IR.Select.Args.AnnDistinctColumn b v)
instance GHC.Internal.Generics.Generic (Hasura.RQL.IR.Select.Args.SelectArgsG b v)
instance GHC.Internal.Generics.Generic (Hasura.RQL.IR.Select.Args.SelectStreamArgsG b v)
instance GHC.Internal.Generics.Generic (Hasura.RQL.IR.Select.Args.StreamCursorItem b v)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable v) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.Select.Args.AnnDistinctColumn b v)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable v) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.Select.Args.SelectArgsG b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show v) => GHC.Internal.Show.Show (Hasura.RQL.IR.Select.Args.AnnDistinctColumn b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show v) => GHC.Internal.Show.Show (Hasura.RQL.IR.Select.Args.SelectArgsG b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show v) => GHC.Internal.Show.Show (Hasura.RQL.IR.Select.Args.SelectStreamArgsG b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show v) => GHC.Internal.Show.Show (Hasura.RQL.IR.Select.Args.StreamCursorItem b v)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.Select.Args.AnnDistinctColumn b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.Select.Args.SelectArgsG b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.Select.Args.SelectStreamArgsG b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.Select.Args.StreamCursorItem b)

module Hasura.RQL.IR.Conflict
data OnConflictClause (b :: BackendType) v
OCCDoNothing :: Maybe (ConflictTarget b) -> OnConflictClause (b :: BackendType) v
OCCUpdate :: OnConflictClauseData b v -> OnConflictClause (b :: BackendType) v
data OnConflictClauseData (b :: BackendType) v
OnConflictClauseData :: ConflictTarget b -> [Column b] -> PreSetColsG b v -> AnnBoolExp b v -> OnConflictClauseData (b :: BackendType) v
[cp1udConflictTarget] :: OnConflictClauseData (b :: BackendType) v -> ConflictTarget b
[cp1udAffectedColumns] :: OnConflictClauseData (b :: BackendType) v -> [Column b]
[cp1udValues] :: OnConflictClauseData (b :: BackendType) v -> PreSetColsG b v
[cp1udFilter] :: OnConflictClauseData (b :: BackendType) v -> AnnBoolExp b v
data ConflictTarget (b :: BackendType)
CTColumn :: [Column b] -> ConflictTarget (b :: BackendType)
CTConstraint :: ConstraintName b -> ConflictTarget (b :: BackendType)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.IR.Conflict.ConflictTarget b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.Conflict.OnConflictClause b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.Conflict.OnConflictClauseData b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Base.Functor (Hasura.RQL.IR.Conflict.OnConflictClause b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Base.Functor (Hasura.RQL.IR.Conflict.OnConflictClauseData b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.IR.Conflict.ConflictTarget b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.Conflict.OnConflictClause b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.Conflict.OnConflictClauseData b)


-- | Postgres Types Insert
--   
--   This module defines the Insert-related IR types specific to Postgres.
module Hasura.Backends.Postgres.Types.Insert

-- | The PostgreSQL-specific data of an Insert expression.
--   
--   This is parameterised over <tt>v</tt> which enables different phases
--   of IR transformation to maintain the overall structure while
--   enriching/transforming the data at the leaves.
newtype BackendInsert (pgKind :: PostgresKind) v
BackendInsert :: Maybe (OnConflictClause ('Postgres pgKind) v) -> BackendInsert (pgKind :: PostgresKind) v
[_biConflictClause] :: BackendInsert (pgKind :: PostgresKind) v -> Maybe (OnConflictClause ('Postgres pgKind) v)
instance Hasura.RQL.Types.Backend.Backend ('Hasura.RQL.Types.BackendType.Postgres pgKind) => GHC.Internal.Data.Foldable.Foldable (Hasura.Backends.Postgres.Types.Insert.BackendInsert pgKind)
instance Hasura.RQL.Types.Backend.Backend ('Hasura.RQL.Types.BackendType.Postgres pgKind) => GHC.Internal.Base.Functor (Hasura.Backends.Postgres.Types.Insert.BackendInsert pgKind)
instance Hasura.RQL.Types.Backend.Backend ('Hasura.RQL.Types.BackendType.Postgres pgKind) => GHC.Internal.Data.Traversable.Traversable (Hasura.Backends.Postgres.Types.Insert.BackendInsert pgKind)

module Hasura.RQL.IR.BoolExp.Lenses
geWhere :: forall (backend :: BackendType) field1 field2 f. Functor f => (GBoolExp backend field1 -> f (GBoolExp backend field2)) -> GExists backend field1 -> f (GExists backend field2)
geTable :: forall (backend :: BackendType) field f. Functor f => (TableName backend -> f (TableName backend)) -> GExists backend field -> f (GExists backend field)
_BoolExists :: forall (backend :: BackendType) field p f. (Choice p, Applicative f) => p (GExists backend field) (f (GExists backend field)) -> p (GBoolExp backend field) (f (GBoolExp backend field))
_NoRedaction :: forall (b :: BackendType) v p f. (Choice p, Applicative f) => p () (f ()) -> p (AnnRedactionExp b v) (f (AnnRedactionExp b v))
_RedactIfFalse :: forall (b1 :: BackendType) v1 (b2 :: BackendType) v2 p f. (Choice p, Applicative f) => p (GBoolExp b1 (AnnBoolExpFld b1 v1)) (f (GBoolExp b2 (AnnBoolExpFld b2 v2))) -> p (AnnRedactionExp b1 v1) (f (AnnRedactionExp b2 v2))
instance (Hasura.RQL.IR.BoolExp.BoolExp b1 GHC.Types.~ t) => Control.Lens.Wrapped.Rewrapped (Hasura.RQL.IR.BoolExp.BoolExp b2) t
instance Control.Lens.Wrapped.Wrapped (Hasura.RQL.IR.BoolExp.BoolExp b)


-- | This module contains the default types and function that model
--   aggregation predicates.
module Hasura.RQL.IR.BoolExp.AggregationPredicates

-- | This type the default non-empty implementation of the
--   <tt>AggregationPredicates</tt> type family of 'class Backend'.
--   
--   This represents an _applied_ aggregation predicate, i.e. _not_ an
--   aggegation function in isolation.
--   
--   In the default schema implementation, this type results from parsing
--   graphql such as:
--   
--   table(_where( <a>relation</a>_aggregate: {<a>functionname</a>: {
--   arguments: <a>arguments</a>, predicate: <a>predicate</a>, distinct:
--   bool } } )) { ... }
--   
--   Note that we make no attempt at modelling window functions or
--   so-called <tt>analytical</tt> functions such as
--   <tt>percentile_cont</tt>.
data AggregationPredicatesImplementation (b :: BackendType) field
AggregationPredicatesImplementation :: RelInfo b -> AnnBoolExp b field -> AggregationPredicate b field -> AggregationPredicatesImplementation (b :: BackendType) field
[aggRelation] :: AggregationPredicatesImplementation (b :: BackendType) field -> RelInfo b
[aggRowPermission] :: AggregationPredicatesImplementation (b :: BackendType) field -> AnnBoolExp b field
[aggPredicate] :: AggregationPredicatesImplementation (b :: BackendType) field -> AggregationPredicate b field
data AggregationPredicate (b :: BackendType) field
AggregationPredicate :: Text -> Bool -> Maybe (AnnBoolExp b field) -> AggregationPredicateArguments b field -> [OpExpG b field] -> AggregationPredicate (b :: BackendType) field
[aggPredFunctionName] :: AggregationPredicate (b :: BackendType) field -> Text
[aggPredDistinct] :: AggregationPredicate (b :: BackendType) field -> Bool
[aggPredFilter] :: AggregationPredicate (b :: BackendType) field -> Maybe (AnnBoolExp b field)
[aggPredArguments] :: AggregationPredicate (b :: BackendType) field -> AggregationPredicateArguments b field
[aggPredPredicate] :: AggregationPredicate (b :: BackendType) field -> [OpExpG b field]
data AggregationPredicateArguments (b :: BackendType) field
AggregationPredicateArgumentsStar :: AggregationPredicateArguments (b :: BackendType) field
AggregationPredicateArguments :: NonEmpty (Column b, AnnRedactionExp b field) -> AggregationPredicateArguments (b :: BackendType) field
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq field) => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicate b field)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq field) => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicateArguments b field)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq field) => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicatesImplementation b field)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicate b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicateArguments b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicatesImplementation b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Base.Functor (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicate b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Base.Functor (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicateArguments b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Base.Functor (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicatesImplementation b)
instance GHC.Internal.Generics.Generic (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicate b field)
instance GHC.Internal.Generics.Generic (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicateArguments b field)
instance GHC.Internal.Generics.Generic (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicatesImplementation b field)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable field) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicate b field)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable field) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicateArguments b field)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable field) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicatesImplementation b field)
instance (Hasura.RQL.Types.Backend.Backend b, Control.DeepSeq.NFData field) => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicate b field)
instance (Hasura.RQL.Types.Backend.Backend b, Control.DeepSeq.NFData field) => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicateArguments b field)
instance (Hasura.RQL.Types.Backend.Backend b, Control.DeepSeq.NFData field) => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicatesImplementation b field)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show field) => GHC.Internal.Show.Show (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicate b field)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show field) => GHC.Internal.Show.Show (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicateArguments b field)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show field) => GHC.Internal.Show.Show (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicatesImplementation b field)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.ToJSON.ToJSON field) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicateArguments b field)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.ToJSON.ToJSON field) => Data.Aeson.Extended.ToJSONKeyValue (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicate b field)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.ToJSON.ToJSON field) => Data.Aeson.Extended.ToJSONKeyValue (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicatesImplementation b field)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicate b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicateArguments b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicatesImplementation b)


-- | Postgres Types BoolExp
--   
--   Postgres-specific <tt>BooleanOperator</tt> extensions.
module Hasura.Backends.Postgres.Types.BoolExp
data BooleanOperators a
AILIKE :: a -> BooleanOperators a
ANILIKE :: a -> BooleanOperators a
ASIMILAR :: a -> BooleanOperators a
ANSIMILAR :: a -> BooleanOperators a
AREGEX :: a -> BooleanOperators a
AIREGEX :: a -> BooleanOperators a
ANREGEX :: a -> BooleanOperators a
ANIREGEX :: a -> BooleanOperators a
AContains :: a -> BooleanOperators a
AContainedIn :: a -> BooleanOperators a
AHasKey :: a -> BooleanOperators a
AHasKeysAny :: a -> BooleanOperators a
AHasKeysAll :: a -> BooleanOperators a
ASTContains :: a -> BooleanOperators a
ASTCrosses :: a -> BooleanOperators a
ASTEquals :: a -> BooleanOperators a
ASTIntersects :: a -> BooleanOperators a
AST3DIntersects :: a -> BooleanOperators a
ASTOverlaps :: a -> BooleanOperators a
ASTTouches :: a -> BooleanOperators a
ASTWithin :: a -> BooleanOperators a
ASTIntersectsRast :: a -> BooleanOperators a
ASTDWithinGeom :: DWithinGeomOp a -> BooleanOperators a
AST3DDWithinGeom :: DWithinGeomOp a -> BooleanOperators a
ASTDWithinGeog :: DWithinGeogOp a -> BooleanOperators a
ASTIntersectsGeomNband :: STIntersectsGeomminNband a -> BooleanOperators a
ASTIntersectsNbandGeom :: STIntersectsNbandGeommin a -> BooleanOperators a
AAncestor :: a -> BooleanOperators a
AAncestorAny :: a -> BooleanOperators a
ADescendant :: a -> BooleanOperators a
ADescendantAny :: a -> BooleanOperators a
AMatches :: a -> BooleanOperators a
AMatchesAny :: a -> BooleanOperators a
AMatchesFulltext :: a -> BooleanOperators a
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.Backends.Postgres.Types.BoolExp.BooleanOperators a)
instance GHC.Internal.Data.Foldable.Foldable Hasura.Backends.Postgres.Types.BoolExp.BooleanOperators
instance GHC.Internal.Base.Functor Hasura.Backends.Postgres.Types.BoolExp.BooleanOperators
instance GHC.Internal.Generics.Generic (Hasura.Backends.Postgres.Types.BoolExp.BooleanOperators a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.Backends.Postgres.Types.BoolExp.BooleanOperators a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.Backends.Postgres.Types.BoolExp.BooleanOperators a)
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (Hasura.Backends.Postgres.Types.BoolExp.BooleanOperators a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Extended.ToJSONKeyValue (Hasura.Backends.Postgres.Types.BoolExp.BooleanOperators a)
instance GHC.Internal.Data.Traversable.Traversable Hasura.Backends.Postgres.Types.BoolExp.BooleanOperators


-- | Postgres Types Functions
--   
--   Postgres specific types related to SQL functions
module Hasura.Backends.Postgres.Types.Function
data ArgumentExp a

-- | Table row accessor
AETableRow :: ArgumentExp a

-- | Hardcoded reference to
--   <tt>hdb_catalog.hdb_action_log.response_payload</tt>
AEActionResponsePayload :: ArgumentExp a

-- | JSON/JSONB hasura session variable object
AESession :: a -> ArgumentExp a
AEInput :: a -> ArgumentExp a

-- | Eliminate <a>ArgumentExp</a>
--   
--   Used to ensure that the right column is used for
--   <a>AEActionResponsePayload</a>.
onArgumentExp :: a -> (Text -> a) -> ArgumentExp a -> a

-- | Hardcoded <tt>hdb_catalog.hdb_action_log.response_payload</tt> column
--   name
actionResponsePayloadColumn :: Text
data FunctionArg
FunctionArg :: Maybe FunctionArgName -> QualifiedPGType -> HasDefault -> FunctionArg
[faName] :: FunctionArg -> Maybe FunctionArgName
[faType] :: FunctionArg -> QualifiedPGType
[faHasDefault] :: FunctionArg -> HasDefault
newtype HasDefault
HasDefault :: Bool -> HasDefault
[unHasDefault] :: HasDefault -> Bool
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.Backends.Postgres.Types.Function.ArgumentExp a)
instance GHC.Classes.Eq Hasura.Backends.Postgres.Types.Function.FunctionArg
instance GHC.Classes.Eq Hasura.Backends.Postgres.Types.Function.HasDefault
instance GHC.Internal.Data.Foldable.Foldable Hasura.Backends.Postgres.Types.Function.ArgumentExp
instance GHC.Internal.Base.Functor Hasura.Backends.Postgres.Types.Function.ArgumentExp
instance GHC.Internal.Generics.Generic (Hasura.Backends.Postgres.Types.Function.ArgumentExp a)
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.Types.Function.FunctionArg
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.Types.Function.HasDefault
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.Backends.Postgres.Types.Function.ArgumentExp a)
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Types.Function.FunctionArg
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Types.Function.HasDefault
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.Backends.Postgres.Types.Function.ArgumentExp a)
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Types.Function.FunctionArg
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Types.Function.HasDefault
instance GHC.Classes.Ord Hasura.Backends.Postgres.Types.Function.FunctionArg
instance GHC.Classes.Ord Hasura.Backends.Postgres.Types.Function.HasDefault
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (Hasura.Backends.Postgres.Types.Function.ArgumentExp a)
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Types.Function.FunctionArg
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Types.Function.HasDefault
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Types.Function.FunctionArg
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Types.Function.HasDefault
instance GHC.Internal.Data.Traversable.Traversable Hasura.Backends.Postgres.Types.Function.ArgumentExp


-- | Postgres types related to computed fields
module Hasura.Backends.Postgres.Types.ComputedField
data ComputedFieldDefinition
ComputedFieldDefinition :: QualifiedFunction -> Maybe FunctionArgName -> Maybe FunctionArgName -> ComputedFieldDefinition
[_cfdFunction] :: ComputedFieldDefinition -> QualifiedFunction
[_cfdTableArgument] :: ComputedFieldDefinition -> Maybe FunctionArgName
[_cfdSessionArgument] :: ComputedFieldDefinition -> Maybe FunctionArgName

-- | The function table argument is either the very first argument or the
--   named argument with an index. The index is 0 if the named argument is
--   the first.
data FunctionTableArgument
FTAFirst :: FunctionTableArgument
FTANamed :: FunctionArgName -> Int -> FunctionTableArgument

-- | The session argument, which passes Hasura session variables to a SQL
--   function as a JSON object.
data FunctionSessionArgument
FunctionSessionArgument :: FunctionArgName -> Int -> FunctionSessionArgument
data ComputedFieldImplicitArguments
ComputedFieldImplicitArguments :: FunctionTableArgument -> Maybe FunctionSessionArgument -> ComputedFieldImplicitArguments
[_cffaTableArgument] :: ComputedFieldImplicitArguments -> FunctionTableArgument
[_cffaSessionArgument] :: ComputedFieldImplicitArguments -> Maybe FunctionSessionArgument
fromComputedFieldImplicitArguments :: v -> ComputedFieldImplicitArguments -> [ArgumentExp v]
data ComputedFieldReturn
CFRScalar :: PGScalarType -> ComputedFieldReturn
CFRSetofTable :: QualifiedTable -> ComputedFieldReturn
_CFRScalar :: Prism' ComputedFieldReturn PGScalarType
_CFRSetofTable :: Prism' ComputedFieldReturn QualifiedTable
instance GHC.Classes.Eq Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldDefinition
instance GHC.Classes.Eq Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldImplicitArguments
instance GHC.Classes.Eq Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldReturn
instance GHC.Classes.Eq Hasura.Backends.Postgres.Types.ComputedField.FunctionSessionArgument
instance GHC.Classes.Eq Hasura.Backends.Postgres.Types.ComputedField.FunctionTableArgument
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldDefinition
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldDefinition
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldImplicitArguments
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldReturn
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.Types.ComputedField.FunctionSessionArgument
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.Types.ComputedField.FunctionTableArgument
instance Autodocodec.Class.HasCodec Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldDefinition
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldDefinition
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldImplicitArguments
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldReturn
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Types.ComputedField.FunctionSessionArgument
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Types.ComputedField.FunctionTableArgument
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldDefinition
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldImplicitArguments
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldReturn
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Types.ComputedField.FunctionSessionArgument
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Types.ComputedField.FunctionTableArgument
instance GHC.Classes.Ord Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldImplicitArguments
instance GHC.Classes.Ord Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldReturn
instance GHC.Classes.Ord Hasura.Backends.Postgres.Types.ComputedField.FunctionSessionArgument
instance GHC.Classes.Ord Hasura.Backends.Postgres.Types.ComputedField.FunctionTableArgument
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldDefinition
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldImplicitArguments
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldReturn
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Types.ComputedField.FunctionSessionArgument
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Types.ComputedField.FunctionTableArgument
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldDefinition
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldImplicitArguments
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldReturn
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Types.ComputedField.FunctionSessionArgument
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Types.ComputedField.FunctionTableArgument


-- | Postgres SQL DML
--   
--   Provide types and combinators for defining Postgres SQL queries and
--   mutations.
module Hasura.Backends.Postgres.SQL.DML

-- | Represents an alias assignment for a column
newtype ColumnAlias
ColumnAlias :: Identifier -> ColumnAlias
[getColumnAlias] :: ColumnAlias -> Identifier

-- | Represents an alias assignment for a table, relation or row
newtype TableAlias
TableAlias :: Identifier -> TableAlias
[getTableAlias] :: TableAlias -> Identifier
data BinOp
AndOp :: BinOp
OrOp :: BinOp
data BoolExp
BELit :: Bool -> BoolExp
BEBin :: BinOp -> BoolExp -> BoolExp -> BoolExp
BENot :: BoolExp -> BoolExp
BECompare :: CompareOp -> SQLExp -> SQLExp -> BoolExp
BECompareAny :: CompareOp -> SQLExp -> SQLExp -> BoolExp
BENull :: SQLExp -> BoolExp
BENotNull :: SQLExp -> BoolExp
BEExists :: Select -> BoolExp
BEIN :: SQLExp -> [SQLExp] -> BoolExp
BEExp :: SQLExp -> BoolExp

-- | Top-level Common Table Expression statement.
--   
--   A top level CTE can be a query or a mutation statement.
--   
--   Postgres supports mutations only in top-level CTEs. See
--   <a>https://www.postgresql.org/docs/current/queries-with.html#QUERIES-WITH-MODIFYING</a>
data TopLevelCTE
CTESelect :: Select -> TopLevelCTE
CTEInsert :: SQLInsert -> TopLevelCTE
CTEUpdate :: SQLUpdate -> TopLevelCTE
CTEDelete :: SQLDelete -> TopLevelCTE
CTEUnsafeRawSQL :: InterpolatedQuery SQLExp -> TopLevelCTE

-- | Represents a common table expresion that can be used in nested
--   selects.
data InnerCTE
ICTESelect :: Select -> InnerCTE
ICTEUnsafeRawSQL :: InterpolatedQuery SQLExp -> InnerCTE
data CompareOp
SEQ :: CompareOp
SGT :: CompareOp
SLT :: CompareOp
SNE :: CompareOp
SGTE :: CompareOp
SLTE :: CompareOp
SLIKE :: CompareOp
SNLIKE :: CompareOp
SILIKE :: CompareOp
SNILIKE :: CompareOp
SSIMILAR :: CompareOp
SNSIMILAR :: CompareOp
SREGEX :: CompareOp
SIREGEX :: CompareOp
SNREGEX :: CompareOp
SNIREGEX :: CompareOp
SContains :: CompareOp
SContainedIn :: CompareOp
SHasKey :: CompareOp
SHasKeysAny :: CompareOp
SHasKeysAll :: CompareOp
SMatchesFulltext :: CompareOp
data CountType columnType
CTStar :: CountType columnType
CTSimple :: [columnType] -> CountType columnType
CTDistinct :: [columnType] -> CountType columnType
data DistinctExpr
DistinctSimple :: DistinctExpr
DistinctOn :: [SQLExp] -> DistinctExpr

-- | Extractor can be used to apply Postgres alias to a column
data Extractor
Extractor :: SQLExp -> Maybe ColumnAlias -> Extractor
newtype FromExp
FromExp :: [FromItem] -> FromExp

-- | See <tt>from_item</tt> in
--   <a>https://www.postgresql.org/docs/current/sql-select.html</a>
data FromItem

-- | A simple table
FISimple :: QualifiedTable -> Maybe TableAlias -> FromItem

-- | An identifier (from CTEs)
FIIdentifier :: TableIdentifier -> FromItem

-- | A function call (that should return a relation (<tt>SETOF</tt>) and
--   not a scalar)
FIFunc :: FunctionExp -> FromItem

-- | <tt>unnest</tt> converts (an) array(s) to a relation.
--   
--   We have: * The unnest function arguments * The relation alias * A list
--   of column aliases
--   
--   See <tt>unnest</tt> in
--   <a>https://www.postgresql.org/docs/current/functions-array.html</a>.
FIUnnest :: [SQLExp] -> TableAlias -> [ColumnAlias] -> FromItem
FISelect :: Lateral -> Select -> TableAlias -> FromItem
FISelectWith :: Lateral -> SelectWithG Select -> TableAlias -> FromItem
FIValues :: ValuesExp -> TableAlias -> Maybe [ColumnAlias] -> FromItem
FIJoin :: JoinExpr -> FromItem

-- | We can alias the result of a function call that returns a <tt>SETOF
--   RECORD</tt> by naming the result relation, and the columns and their
--   types. For example:
--   
--   <pre>
--   SELECT * FROM
--   function_returns_record(arg1, arg2 ...) AS relation_name(column_1 column_1_type, column_2 column_2_type, ...)
--   </pre>
--   
--   Note: a function that returns a table (instead of a record) cannot
--   name the types as seen in the above example.
data FunctionAlias
FunctionAlias :: TableAlias -> Maybe [FunctionDefinitionListItem] -> FunctionAlias
data FunctionDefinitionListItem
FunctionDefinitionListItem :: ColumnAlias -> PGScalarType -> FunctionDefinitionListItem
[_dliColumn] :: FunctionDefinitionListItem -> ColumnAlias
[_dliType] :: FunctionDefinitionListItem -> PGScalarType
data FunctionArgs
FunctionArgs :: [SQLExp] -> HashMap Text SQLExp -> FunctionArgs

-- | A function call
data FunctionExp
FunctionExp :: QualifiedFunction -> FunctionArgs -> Maybe FunctionAlias -> FunctionExp
newtype GroupByExp
GroupByExp :: [SQLExp] -> GroupByExp
newtype HavingExp
HavingExp :: BoolExp -> HavingExp
data JoinCond
JoinOn :: BoolExp -> JoinCond
JoinUsing :: [Identifier] -> JoinCond
data JoinExpr
JoinExpr :: FromItem -> JoinType -> FromItem -> JoinCond -> JoinExpr
data JoinType
Inner :: JoinType
LeftOuter :: JoinType
newtype Lateral
Lateral :: Bool -> Lateral
newtype LimitExp
LimitExp :: SQLExp -> LimitExp
data NullsOrder
NullsFirst :: NullsOrder
NullsLast :: NullsOrder
newtype OffsetExp
OffsetExp :: SQLExp -> OffsetExp
newtype OrderByExp
OrderByExp :: NonEmpty OrderByItem -> OrderByExp
data OrderByItem
OrderByItem :: SQLExp -> Maybe OrderType -> Maybe NullsOrder -> OrderByItem

-- | Order by ascending or descending
data OrderType
OTAsc :: OrderType
OTDesc :: OrderType
data QIdentifier
QIdentifier :: Qual -> Identifier -> QIdentifier
data Qual
QualifiedIdentifier :: TableIdentifier -> Maybe TypeAnn -> Qual
QualTable :: QualifiedTable -> Qual
QualVar :: Text -> Qual
newtype RetExp
RetExp :: [Extractor] -> RetExp
data SQLConflict
DoNothing :: Maybe SQLConflictTarget -> SQLConflict
Update :: SQLConflictTarget -> SetExp -> Maybe WhereFrag -> SQLConflict
data SQLConflictTarget
SQLColumn :: [PGCol] -> SQLConflictTarget
SQLConstraint :: ConstraintName -> SQLConflictTarget
data SQLDelete
SQLDelete :: QualifiedTable -> Maybe UsingExp -> Maybe WhereFrag -> Maybe RetExp -> SQLDelete
data SQLExp
SEPrep :: Int -> SQLExp
SENull :: SQLExp
SELit :: Text -> SQLExp
SEUnsafe :: Text -> SQLExp
SESelect :: Select -> SQLExp

-- | all fields (<tt>*</tt>) or all fields from relation (<tt>iden.*</tt>)
SEStar :: Maybe Qual -> SQLExp

-- | A column name
SEIdentifier :: Identifier -> SQLExp

-- | SEIdentifier and SERowIdentifier are distinguished for easier rewrite
--   rules
SERowIdentifier :: Identifier -> SQLExp

-- | A qualified column name
SEQIdentifier :: QIdentifier -> SQLExp

-- | this is used to apply a sql function to an expression. The <a>Text</a>
--   is the function name
SEFnApp :: Text -> [SQLExp] -> Maybe OrderByExp -> SQLExp
SEOpApp :: SQLOp -> [SQLExp] -> SQLExp
SETyAnn :: SQLExp -> TypeAnn -> SQLExp
SECond :: BoolExp -> SQLExp -> SQLExp -> SQLExp
SEBool :: BoolExp -> SQLExp
SEExcluded :: Identifier -> SQLExp
SEArray :: [SQLExp] -> SQLExp
SEArrayIndex :: SQLExp -> SQLExp -> SQLExp
SETuple :: TupleExp -> SQLExp
SECount :: CountType QIdentifier -> SQLExp
SENamedArg :: Identifier -> SQLExp -> SQLExp
SEFunction :: FunctionExp -> SQLExp
data SQLInsert
SQLInsert :: QualifiedTable -> [PGCol] -> ValuesExp -> Maybe SQLConflict -> Maybe RetExp -> SQLInsert
[siTable] :: SQLInsert -> QualifiedTable
[siCols] :: SQLInsert -> [PGCol]
[siValues] :: SQLInsert -> ValuesExp
[siConflict] :: SQLInsert -> Maybe SQLConflict
[siRet] :: SQLInsert -> Maybe RetExp
newtype SQLOp
SQLOp :: Text -> SQLOp
data ColumnOp
ColumnOp :: SQLOp -> SQLExp -> ColumnOp
[_colOp] :: ColumnOp -> SQLOp
[_colExp] :: ColumnOp -> SQLExp
data SQLUpdate
SQLUpdate :: QualifiedTable -> SetExp -> Maybe FromExp -> Maybe WhereFrag -> Maybe RetExp -> SQLUpdate
[upTable] :: SQLUpdate -> QualifiedTable
[upSet] :: SQLUpdate -> SetExp
[upFrom] :: SQLUpdate -> Maybe FromExp
[upWhere] :: SQLUpdate -> Maybe WhereFrag
[upRet] :: SQLUpdate -> Maybe RetExp

-- | An select statement that does not require mutation CTEs.
--   
--   See <a>SelectWithG</a> or <a>SelectWith</a> for select statements with
--   mutations as CTEs.
data Select
Select :: [(TableAlias, InnerCTE)] -> Maybe DistinctExpr -> [Extractor] -> Maybe FromExp -> Maybe WhereFrag -> Maybe GroupByExp -> Maybe HavingExp -> Maybe OrderByExp -> Maybe LimitExp -> Maybe OffsetExp -> Select

-- | A top-level select with CTEs.
type SelectWith = SelectWithG TopLevelCTE

-- | A <tt>SELECT</tt> statement with Common Table Expressions.
--   <a>https://www.postgresql.org/docs/current/queries-with.html</a>
--   
--   These CTEs are determined by the <tt>statement</tt> parameter.
--   Currently they are either <a>TopLevelCTE</a>, which allow for a query
--   or mutation statement, or <a>Select</a>, which only allow for querying
--   results.
--   
--   The distinction is required because Postgres only supports mutations
--   in CTEs at the top level. See
--   <a>https://www.postgresql.org/docs/current/queries-with.html#QUERIES-WITH-MODIFYING</a>
data SelectWithG statement
SelectWith :: [(TableAlias, statement)] -> Select -> SelectWithG statement
[swCTEs] :: SelectWithG statement -> [(TableAlias, statement)]
[swSelect] :: SelectWithG statement -> Select
newtype SetExp
SetExp :: [SetExpItem] -> SetExp
newtype SetExpItem
SetExpItem :: (PGCol, SQLExp) -> SetExpItem
newtype TupleExp
TupleExp :: [SQLExp] -> TupleExp
newtype TypeAnn
TypeAnn :: Text -> TypeAnn
newtype ValuesExp
ValuesExp :: [TupleExp] -> ValuesExp
newtype WhereFrag
WhereFrag :: BoolExp -> WhereFrag

-- | A dummy select list to avoid an empty select list, which doesn't work
--   for cockroach db. This is just the value <tt>1</tt> without an alias.
dummySelectList :: [Extractor]
applyJsonBuildArray :: [SQLExp] -> SQLExp
applyJsonBuildObj :: [SQLExp] -> SQLExp
applyRowToJson :: [Extractor] -> SQLExp
applyUppercase :: SQLExp -> SQLExp
boolTypeAnn :: TypeAnn
buildUpsertSetExp :: [PGCol] -> HashMap PGCol SQLExp -> SetExp
columnDefaultValue :: SQLExp
countStar :: SQLExp
handleIfNull :: SQLExp -> SQLExp -> SQLExp
incOp :: SQLOp
int64ToSQLExp :: Int64 -> SQLExp
intToSQLExp :: Int -> SQLExp
intTypeAnn :: TypeAnn
jsonTypeAnn :: TypeAnn
jsonbConcatOp :: SQLOp
jsonbDeleteAtPathOp :: SQLOp
jsonbDeleteOp :: SQLOp
jsonbPathOp :: SQLOp
jsonbTypeAnn :: TypeAnn
mkExists :: FromItem -> BoolExp -> BoolExp
mkExtr :: IsIdentifier a => a -> Extractor

-- | Construct a function alias which represents the "relation signature"
--   for the function invocation, Using the function name as the relation
--   name, and the columns as the relation schema.
mkFunctionAlias :: QualifiedObject FunctionName -> Maybe [(ColumnAlias, PGScalarType)] -> FunctionAlias
mkIdenFromExp :: TableIdentifier -> FromExp
mkLateralFromItem :: Select -> TableAlias -> FromItem
mkQIdenExp :: IsIdentifier b => TableIdentifier -> b -> SQLExp
mkQIdentifier :: IsIdentifier b => TableIdentifier -> b -> QIdentifier
mkQIdentifierTable :: IsIdentifier a => QualifiedTable -> a -> QIdentifier
mkQual :: QualifiedTable -> Qual
mkRowExp :: [Extractor] -> SQLExp
mkIdentifierSQLExp :: IsIdentifier a => Qual -> a -> SQLExp
mkSIdenExp :: IsIdentifier a => a -> SQLExp
mkSQLOpExp :: SQLOp -> SQLExp -> SQLExp -> SQLExp
mkSelFromExp :: Bool -> Select -> TableName -> FromItem
mkSelFromItem :: Select -> TableAlias -> FromItem

-- | An empty select statement.
mkSelect :: Select
mkSelectWithFromItem :: SelectWithG Select -> TableAlias -> FromItem
mkSimpleFromExp :: QualifiedTable -> FromExp
mkTypeAnn :: CollectableType PGScalarType -> TypeAnn
mulOp :: SQLOp
numericTypeAnn :: TypeAnn
returningStar :: RetExp
selectStar :: Extractor
selectStar' :: Qual -> Extractor
simplifyBoolExp :: BoolExp -> BoolExp
textArrTypeAnn :: TypeAnn
textTypeAnn :: TypeAnn
mkColumnAlias :: Text -> ColumnAlias

-- | Create a table alias.
mkTableAlias :: Text -> TableAlias
toTableAlias :: IsIdentifier a => a -> TableAlias

-- | Create a table identifier from a table alias.
tableAliasToIdentifier :: TableAlias -> TableIdentifier
toColumnAlias :: IsIdentifier a => a -> ColumnAlias
tableIdentifierToColumnAlias :: TableIdentifier -> ColumnAlias
instance GHC.Internal.Data.Data.Data Hasura.Backends.Postgres.SQL.DML.BinOp
instance GHC.Internal.Data.Data.Data Hasura.Backends.Postgres.SQL.DML.BoolExp
instance GHC.Internal.Data.Data.Data Hasura.Backends.Postgres.SQL.DML.ColumnAlias
instance GHC.Internal.Data.Data.Data Hasura.Backends.Postgres.SQL.DML.ColumnOp
instance GHC.Internal.Data.Data.Data Hasura.Backends.Postgres.SQL.DML.CompareOp
instance GHC.Internal.Data.Data.Data columnType => GHC.Internal.Data.Data.Data (Hasura.Backends.Postgres.SQL.DML.CountType columnType)
instance GHC.Internal.Data.Data.Data Hasura.Backends.Postgres.SQL.DML.DistinctExpr
instance GHC.Internal.Data.Data.Data Hasura.Backends.Postgres.SQL.DML.Extractor
instance GHC.Internal.Data.Data.Data Hasura.Backends.Postgres.SQL.DML.FromExp
instance GHC.Internal.Data.Data.Data Hasura.Backends.Postgres.SQL.DML.FromItem
instance GHC.Internal.Data.Data.Data Hasura.Backends.Postgres.SQL.DML.FunctionAlias
instance GHC.Internal.Data.Data.Data Hasura.Backends.Postgres.SQL.DML.FunctionArgs
instance GHC.Internal.Data.Data.Data Hasura.Backends.Postgres.SQL.DML.FunctionDefinitionListItem
instance GHC.Internal.Data.Data.Data Hasura.Backends.Postgres.SQL.DML.FunctionExp
instance GHC.Internal.Data.Data.Data Hasura.Backends.Postgres.SQL.DML.GroupByExp
instance GHC.Internal.Data.Data.Data Hasura.Backends.Postgres.SQL.DML.HavingExp
instance GHC.Internal.Data.Data.Data Hasura.Backends.Postgres.SQL.DML.InnerCTE
instance GHC.Internal.Data.Data.Data Hasura.Backends.Postgres.SQL.DML.JoinCond
instance GHC.Internal.Data.Data.Data Hasura.Backends.Postgres.SQL.DML.JoinExpr
instance GHC.Internal.Data.Data.Data Hasura.Backends.Postgres.SQL.DML.JoinType
instance GHC.Internal.Data.Data.Data Hasura.Backends.Postgres.SQL.DML.Lateral
instance GHC.Internal.Data.Data.Data Hasura.Backends.Postgres.SQL.DML.LimitExp
instance GHC.Internal.Data.Data.Data Hasura.Backends.Postgres.SQL.DML.NullsOrder
instance GHC.Internal.Data.Data.Data Hasura.Backends.Postgres.SQL.DML.OffsetExp
instance GHC.Internal.Data.Data.Data Hasura.Backends.Postgres.SQL.DML.OrderByExp
instance GHC.Internal.Data.Data.Data Hasura.Backends.Postgres.SQL.DML.OrderByItem
instance GHC.Internal.Data.Data.Data Hasura.Backends.Postgres.SQL.DML.OrderType
instance GHC.Internal.Data.Data.Data Hasura.Backends.Postgres.SQL.DML.QIdentifier
instance GHC.Internal.Data.Data.Data Hasura.Backends.Postgres.SQL.DML.Qual
instance GHC.Internal.Data.Data.Data Hasura.Backends.Postgres.SQL.DML.SQLExp
instance GHC.Internal.Data.Data.Data Hasura.Backends.Postgres.SQL.DML.SQLOp
instance GHC.Internal.Data.Data.Data Hasura.Backends.Postgres.SQL.DML.Select
instance GHC.Internal.Data.Data.Data statement => GHC.Internal.Data.Data.Data (Hasura.Backends.Postgres.SQL.DML.SelectWithG statement)
instance GHC.Internal.Data.Data.Data Hasura.Backends.Postgres.SQL.DML.TableAlias
instance GHC.Internal.Data.Data.Data Hasura.Backends.Postgres.SQL.DML.TupleExp
instance GHC.Internal.Data.Data.Data Hasura.Backends.Postgres.SQL.DML.TypeAnn
instance GHC.Internal.Data.Data.Data Hasura.Backends.Postgres.SQL.DML.ValuesExp
instance GHC.Internal.Data.Data.Data Hasura.Backends.Postgres.SQL.DML.WhereFrag
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.BinOp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.BoolExp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.ColumnAlias
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.ColumnOp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.CompareOp
instance GHC.Classes.Eq columnType => GHC.Classes.Eq (Hasura.Backends.Postgres.SQL.DML.CountType columnType)
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.DistinctExpr
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.Extractor
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.FromExp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.FromItem
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.FunctionAlias
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.FunctionArgs
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.FunctionDefinitionListItem
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.FunctionExp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.GroupByExp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.HavingExp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.InnerCTE
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.JoinCond
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.JoinExpr
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.JoinType
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.Lateral
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.LimitExp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.NullsOrder
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.OffsetExp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.OrderByExp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.OrderByItem
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.OrderType
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.QIdentifier
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.Qual
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.RetExp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.SQLConflict
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.SQLConflictTarget
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.SQLDelete
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.SQLExp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.SQLInsert
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.SQLOp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.SQLUpdate
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.Select
instance GHC.Classes.Eq statement => GHC.Classes.Eq (Hasura.Backends.Postgres.SQL.DML.SelectWithG statement)
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.SetExp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.SetExpItem
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.TableAlias
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.TopLevelCTE
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.TupleExp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.TypeAnn
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.UsingExp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.ValuesExp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.WhereFrag
instance GHC.Internal.Data.Foldable.Foldable Hasura.Backends.Postgres.SQL.DML.CountType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.SQL.DML.NullsOrder
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.SQL.DML.OrderType
instance GHC.Internal.Base.Functor Hasura.Backends.Postgres.SQL.DML.CountType
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.SQL.DML.BinOp
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.SQL.DML.BoolExp
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.SQL.DML.ColumnOp
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.SQL.DML.CompareOp
instance GHC.Internal.Generics.Generic (Hasura.Backends.Postgres.SQL.DML.CountType columnType)
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.SQL.DML.DistinctExpr
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.SQL.DML.Extractor
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.SQL.DML.FromItem
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.SQL.DML.FunctionAlias
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.SQL.DML.FunctionArgs
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.SQL.DML.FunctionDefinitionListItem
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.SQL.DML.FunctionExp
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.SQL.DML.InnerCTE
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.SQL.DML.JoinCond
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.SQL.DML.JoinExpr
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.SQL.DML.JoinType
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.SQL.DML.NullsOrder
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.SQL.DML.OrderByItem
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.SQL.DML.OrderType
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.SQL.DML.QIdentifier
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.SQL.DML.Qual
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.SQL.DML.SQLExp
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.SQL.DML.Select
instance GHC.Internal.Generics.Generic (Hasura.Backends.Postgres.SQL.DML.SelectWithG statement)
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.SQL.DML.TableAlias
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.BinOp
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.BoolExp
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.ColumnAlias
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.ColumnOp
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.CompareOp
instance Data.Hashable.Class.Hashable columnType => Data.Hashable.Class.Hashable (Hasura.Backends.Postgres.SQL.DML.CountType columnType)
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.DistinctExpr
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.Extractor
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.FromExp
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.FromItem
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.FunctionAlias
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.FunctionArgs
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.FunctionDefinitionListItem
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.FunctionExp
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.GroupByExp
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.HavingExp
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.InnerCTE
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.JoinCond
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.JoinExpr
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.JoinType
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.Lateral
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.LimitExp
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.NullsOrder
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.OffsetExp
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.OrderByExp
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.OrderByItem
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.OrderType
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.QIdentifier
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.Qual
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.SQLExp
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.SQLOp
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.Select
instance Data.Hashable.Class.Hashable v => Data.Hashable.Class.Hashable (Hasura.Backends.Postgres.SQL.DML.SelectWithG v)
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.TableAlias
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.TupleExp
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.TypeAnn
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.ValuesExp
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.WhereFrag
instance Hasura.Backends.Postgres.SQL.Types.IsIdentifier Hasura.Backends.Postgres.SQL.DML.ColumnAlias
instance Hasura.Backends.Postgres.SQL.Types.IsIdentifier Hasura.Backends.Postgres.SQL.DML.TableAlias
instance GHC.Internal.Data.String.IsString Hasura.Backends.Postgres.SQL.DML.ColumnAlias
instance GHC.Internal.Data.String.IsString Hasura.Backends.Postgres.SQL.DML.TableAlias
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.BinOp
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.BoolExp
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.ColumnAlias
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.ColumnOp
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.CompareOp
instance Control.DeepSeq.NFData columnType => Control.DeepSeq.NFData (Hasura.Backends.Postgres.SQL.DML.CountType columnType)
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.DistinctExpr
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.Extractor
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.FromExp
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.FromItem
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.FunctionAlias
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.FunctionArgs
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.FunctionDefinitionListItem
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.FunctionExp
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.GroupByExp
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.HavingExp
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.InnerCTE
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.JoinCond
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.JoinExpr
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.JoinType
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.Lateral
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.LimitExp
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.NullsOrder
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.OffsetExp
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.OrderByExp
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.OrderByItem
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.OrderType
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.QIdentifier
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.Qual
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.SQLExp
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.SQLOp
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.Select
instance Control.DeepSeq.NFData v => Control.DeepSeq.NFData (Hasura.Backends.Postgres.SQL.DML.SelectWithG v)
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.TableAlias
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.TupleExp
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.TypeAnn
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.ValuesExp
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.WhereFrag
instance GHC.Internal.Base.Semigroup Hasura.Backends.Postgres.SQL.DML.ColumnAlias
instance GHC.Internal.Base.Semigroup Hasura.Backends.Postgres.SQL.DML.TableAlias
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.DML.BinOp
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.DML.BoolExp
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.DML.ColumnAlias
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.DML.ColumnOp
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.DML.CompareOp
instance GHC.Internal.Show.Show columnType => GHC.Internal.Show.Show (Hasura.Backends.Postgres.SQL.DML.CountType columnType)
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.DML.DistinctExpr
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.DML.Extractor
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.DML.FromExp
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.DML.FromItem
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.DML.FunctionAlias
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.DML.FunctionArgs
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.DML.FunctionDefinitionListItem
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.DML.FunctionExp
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.DML.GroupByExp
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.DML.HavingExp
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.DML.InnerCTE
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.DML.JoinCond
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.DML.JoinExpr
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.DML.JoinType
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.DML.Lateral
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.DML.LimitExp
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.DML.NullsOrder
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.DML.OffsetExp
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.DML.OrderByExp
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.DML.OrderByItem
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.DML.OrderType
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.DML.QIdentifier
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.DML.Qual
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.DML.RetExp
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.DML.SQLConflict
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.DML.SQLConflictTarget
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.DML.SQLDelete
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.DML.SQLExp
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.DML.SQLInsert
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.DML.SQLOp
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.DML.SQLUpdate
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.DML.Select
instance GHC.Internal.Show.Show statement => GHC.Internal.Show.Show (Hasura.Backends.Postgres.SQL.DML.SelectWithG statement)
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.DML.SetExp
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.DML.SetExpItem
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.DML.TableAlias
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.DML.TopLevelCTE
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.DML.TupleExp
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.DML.TypeAnn
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.DML.UsingExp
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.DML.ValuesExp
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.DML.WhereFrag
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.DML.NullsOrder
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.DML.OrderType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.DML.SQLExp
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.BinOp
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.BoolExp
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.CompareOp
instance Hasura.SQL.Types.ToSQL (Hasura.Backends.Postgres.SQL.DML.CountType Hasura.Backends.Postgres.SQL.DML.QIdentifier)
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.DistinctExpr
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.Extractor
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.FromExp
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.FromItem
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.FunctionAlias
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.FunctionArgs
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.FunctionDefinitionListItem
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.FunctionExp
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.GroupByExp
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.HavingExp
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.JoinCond
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.JoinExpr
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.JoinType
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.Lateral
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.LimitExp
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.NullsOrder
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.OffsetExp
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.OrderByExp
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.OrderByItem
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.OrderType
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.QIdentifier
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.Qual
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.RetExp
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.SQLConflict
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.SQLConflictTarget
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.SQLDelete
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.SQLExp
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.SQLInsert
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.SQLUpdate
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.Select
instance Hasura.SQL.Types.ToSQL v => Hasura.SQL.Types.ToSQL (Hasura.Backends.Postgres.SQL.DML.SelectWithG v)
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.SetExp
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.SetExpItem
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.TopLevelCTE
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.TupleExp
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.TypeAnn
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.UsingExp
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.ValuesExp
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.WhereFrag
instance GHC.Internal.Data.Traversable.Traversable Hasura.Backends.Postgres.SQL.DML.CountType

module Hasura.Backends.Postgres.Types.Aggregates

-- | This newtype allows us to reuse <a>CountType</a> for the
--   <a>CountType</a> type family We reuse the overall structure, but our
--   column type is a PGCol column name, plus the column redaction
--   expression used by inherited roles. See [SQL generation for inherited
--   roles] for more information about column redaction
newtype CountAggregate (pgKind :: PostgresKind) v
CountAggregate :: CountType (PGCol, AnnRedactionExp ('Postgres pgKind) v) -> CountAggregate (pgKind :: PostgresKind) v
[getCountType] :: CountAggregate (pgKind :: PostgresKind) v -> CountType (PGCol, AnnRedactionExp ('Postgres pgKind) v)
instance (Hasura.RQL.Types.Backend.Backend ('Hasura.RQL.Types.BackendType.Postgres pgKind), GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnRedactionExp ('Hasura.RQL.Types.BackendType.Postgres pgKind) v), GHC.Classes.Eq v) => GHC.Classes.Eq (Hasura.Backends.Postgres.Types.Aggregates.CountAggregate pgKind v)
instance Hasura.RQL.Types.Backend.Backend ('Hasura.RQL.Types.BackendType.Postgres pgKind) => GHC.Internal.Data.Foldable.Foldable (Hasura.Backends.Postgres.Types.Aggregates.CountAggregate pgKind)
instance Hasura.RQL.Types.Backend.Backend ('Hasura.RQL.Types.BackendType.Postgres pgKind) => GHC.Internal.Base.Functor (Hasura.Backends.Postgres.Types.Aggregates.CountAggregate pgKind)
instance GHC.Internal.Generics.Generic (Hasura.Backends.Postgres.Types.Aggregates.CountAggregate pgKind v)
instance (Hasura.RQL.Types.Backend.Backend ('Hasura.RQL.Types.BackendType.Postgres pgKind), GHC.Internal.Show.Show (Hasura.RQL.IR.BoolExp.AnnRedactionExp ('Hasura.RQL.Types.BackendType.Postgres pgKind) v), GHC.Internal.Show.Show v) => GHC.Internal.Show.Show (Hasura.Backends.Postgres.Types.Aggregates.CountAggregate pgKind v)
instance Hasura.RQL.Types.Backend.Backend ('Hasura.RQL.Types.BackendType.Postgres pgKind) => GHC.Internal.Data.Traversable.Traversable (Hasura.Backends.Postgres.Types.Aggregates.CountAggregate pgKind)


-- | Postgres SQL Value
--   
--   Deals with Postgres scalar values, converting them to and from
--   <a>Text</a>, and to JSON <a>Value</a>.
module Hasura.Backends.Postgres.SQL.Value
data PGScalarValue
PGValInteger :: Int32 -> PGScalarValue
PGValSmallInt :: Int16 -> PGScalarValue
PGValBigInt :: Int64 -> PGScalarValue
PGValFloat :: Float -> PGScalarValue
PGValDouble :: Double -> PGScalarValue
PGValNumeric :: Scientific -> PGScalarValue
PGValMoney :: Scientific -> PGScalarValue
PGValBoolean :: Bool -> PGScalarValue
PGValChar :: Char -> PGScalarValue
PGValVarchar :: Text -> PGScalarValue
PGValText :: Text -> PGScalarValue
PGValCitext :: Text -> PGScalarValue
PGValDate :: Day -> PGScalarValue
PGValTimeStamp :: LocalTime -> PGScalarValue
PGValTimeStampTZ :: UTCTime -> PGScalarValue
PGValTimeTZ :: ZonedTimeOfDay -> PGScalarValue
PGNull :: PGScalarType -> PGScalarValue
PGValJSON :: JSON -> PGScalarValue
PGValJSONB :: JSONB -> PGScalarValue
PGValGeo :: GeometryWithCRS -> PGScalarValue
PGValRaster :: RasterWKB -> PGScalarValue
PGValUUID :: UUID -> PGScalarValue
PGValLtree :: Ltree -> PGScalarValue
PGValLquery :: Text -> PGScalarValue
PGValLtxtquery :: Text -> PGScalarValue
PGValUnknown :: Text -> PGScalarValue
PGValArray :: [PGScalarValue] -> PGScalarValue
pgScalarValueToJson :: PGScalarValue -> Value
withConstructorFn :: PGScalarType -> SQLExp -> SQLExp
parsePGValue :: PGScalarType -> Value -> Parser PGScalarValue
scientificToInteger :: (Integral i, Bounded i) => Scientific -> Parser i
scientificToFloat :: RealFloat f => Scientific -> Parser f
textToScalarValue :: Maybe Text -> PGScalarValue
data TxtEncodedVal
TENull :: TxtEncodedVal
TELit :: !Text -> TxtEncodedVal
txtEncodedVal :: PGScalarValue -> TxtEncodedVal
binEncoder :: PGScalarValue -> PrepArg
txtEncoder :: PGScalarValue -> SQLExp
toPrepParam :: Int -> PGScalarType -> SQLExp
withScalarTypeAnn :: PGScalarType -> SQLExp -> SQLExp
withTypeAnn :: CollectableType PGScalarType -> SQLExp -> SQLExp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Value.Ltree
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Value.PGScalarValue
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Value.RasterWKB
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.SQL.Value.Ltree
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.SQL.Value.RasterWKB
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.Value.Ltree
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.Value.PGScalarValue
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.Value.RasterWKB
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.Value.Ltree
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.Value.RasterWKB


-- | <h1>Reasonably efficient PostgreSQL live queries</h1>
--   
--   The module implements <i>query multiplexing</i>, which is our
--   implementation strategy for live queries (i.e. GraphQL subscriptions)
--   made against Postgres. Fundamentally, our implementation is built
--   around polling, which is never ideal, but it’s a lot easier to
--   implement than trying to do something event-based. To minimize the
--   resource cost of polling, we use <i>multiplexing</i>, which is
--   essentially a two-tier batching strategy.
--   
--   <h2>The high-level idea</h2>
--   
--   The objective is to minimize the number of concurrent polling workers
--   to reduce database load as much as possible. A very naïve strategy
--   would be to group identical queries together so we only have one
--   poller per <i>unique</i> active subscription. That’s a good start, but
--   of course, in practice, most queries differ slightly. However, it
--   happens that they very frequently /only differ in their variables/
--   (that is, GraphQL query variables and session variables), and in those
--   cases, we try to generated parameterized SQL. This means that the same
--   prepared SQL query can be reused, just with a different set of
--   variables.
--   
--   To give a concrete example, consider the following query:
--   
--   <pre>
--   subscription vote_count($post_id: Int!) {
--     vote_count(where: {post_id: {_eq: $post_id}}) {
--       votes
--     }
--   }
--   </pre>
--   
--   No matter what the client provides for <tt>$post_id</tt>, we will
--   always generate the same SQL:
--   
--   <pre>
--   SELECT votes FROM vote_count WHERE post_id = $1
--   </pre>
--   
--   If multiple clients subscribe to <tt>vote_count</tt>, we can certainly
--   reuse the same prepared query. For example, imagine we had 10
--   concurrent subscribers, each listening on a distinct
--   <tt>$post_id</tt>:
--   
--   <pre>
--   let postIds = [3, 11, 32, 56, 13, 97, 24, 43, 109, 48]
--   </pre>
--   
--   We could iterate over <tt>postIds</tt> in Haskell, executing the same
--   prepared query 10 times:
--   
--   <pre>
--   for postIds $ \postId -&gt;
--     PG.withQE defaultTxErrorHandler preparedQuery (Identity postId) True
--   </pre>
--   
--   Sadly, that on its own isn’t good enough. The overhead of running each
--   query is large enough that Postgres becomes overwhelmed if we have to
--   serve lots of concurrent subscribers. Therefore, what we want to be
--   able to do is somehow make one query instead of ten.
--   
--   <h3>Multiplexing</h3>
--   
--   This is where multiplexing comes in. By taking advantage of Postgres
--   <a>lateral joins</a>, we can do the iteration in Postgres rather than
--   in Haskell, allowing us to pay the query overhead just once for all
--   ten subscribers. Essentially, lateral joins add <a>map</a>-like
--   functionality to SQL, so we can run our query once per
--   <tt>$post_id</tt>:
--   
--   <pre>
--   SELECT results.votes
--   FROM unnest($1::integer[]) query_variables (post_id)
--   LEFT JOIN LATERAL (
--     SELECT coalesce(json_agg(votes), '[]')
--     FROM vote_count WHERE vote_count.post_id = query_variables.post_id
--   ) results ON true
--   </pre>
--   
--   If we generalize this approach just a little bit more, we can apply
--   this transformation to arbitrary queries parameterized over arbitrary
--   session and query variables!
--   
--   <h2>Implementation overview</h2>
--   
--   To support query multiplexing, we maintain a tree of the following
--   types, where <tt>&gt;</tt> should be read as “contains”:
--   
--   <pre>
--   <tt>SubscriptionsState</tt> &gt; <tt>Poller</tt> &gt; <tt>Cohort</tt> &gt; <tt>Subscriber</tt>
--   </pre>
--   
--   Here’s a brief summary of each type’s role:
--   
--   <ul>
--   <li>A <tt>Subscriber</tt> is an actual client with an open websocket
--   connection.</li>
--   <li>A <tt>Cohort</tt> is a set of <tt>Subscriber</tt>s that are all
--   subscribed to the same query /with the exact same variables/. (By
--   batching these together, we can do better than multiplexing, since we
--   can just query the data once.)</li>
--   <li>A <tt>Poller</tt> is a worker thread for a single, multiplexed
--   query. It fetches data for a set of <tt>Cohort</tt>s that all use the
--   same parameterized query, but have different sets of variables.</li>
--   <li>Finally, the <tt>SubscriptionsState</tt> is the top-level
--   container that holds all the active <tt>Poller</tt>s.</li>
--   </ul>
--   
--   Additional details are provided by the documentation for individual
--   bindings.
module Hasura.GraphQL.Execute.Subscription.Plan
data CohortId
dummyCohortId :: CohortId
newCohortId :: MonadIO m => m CohortId
newtype CohortIdArray
CohortIdArray :: [CohortId] -> CohortIdArray
[unCohortIdArray] :: CohortIdArray -> [CohortId]
newtype CohortVariablesArray
CohortVariablesArray :: [CohortVariables] -> CohortVariablesArray
[unCohortVariablesArray] :: CohortVariablesArray -> [CohortVariables]
data CohortVariables

-- | Cursor variables contain the latest value of the cursor. The value of
--   the cursor variables are updated after every poll. If the value has
--   been changed - see [Streaming subscription polling]. Cursor variables
--   are only used in the case of streaming subscriptions, for live queries
--   it will be empty.
_cvCursorVariables :: CohortVariables -> ValidatedCursorVariables

-- | Builds a cohort's variables by only using the session variables that
--   are required for the subscription
mkCohortVariables :: HashSet SessionVariable -> SessionVariables -> ValidatedQueryVariables -> ValidatedSyntheticVariables -> ValidatedCursorVariables -> CohortVariables

-- | When running multiplexed queries, we have to be especially careful
--   about user input, since invalid values will cause the query to fail,
--   causing collateral damage for anyone else multiplexed into the same
--   query. Therefore, we pre-validate variables against Postgres by
--   executing a no-op query of the shape
--   
--   <pre>
--   SELECT 'v1'::t1, 'v2'::t2, ..., 'vn'::tn
--   </pre>
--   
--   so if any variable values are invalid, the error will be caught early.
newtype ValidatedVariables (f :: Type -> Type)
ValidatedVariables :: f TxtEncodedVal -> ValidatedVariables (f :: Type -> Type)
[_unValidatedVariables] :: ValidatedVariables (f :: Type -> Type) -> f TxtEncodedVal
mkUnsafeValidateVariables :: f TxtEncodedVal -> ValidatedVariables f
modifyCursorCohortVariables :: ValidatedCursorVariables -> CohortVariables -> CohortVariables
type ValidatedQueryVariables = ValidatedVariables HashMap Name
type ValidatedSyntheticVariables = ValidatedVariables []
type ValidatedCursorVariables = ValidatedVariables HashMap Name

-- | A self-contained, ready-to-execute subscription plan. Contains enough
--   information to find an existing poller that this can be added to
--   <i>or</i> to create a new poller if necessary.
data SubscriptionQueryPlan (b :: BackendType) q
SubscriptionQueryPlan :: ParameterizedSubscriptionQueryPlan b q -> SourceConfig b -> CohortId -> ResolvedConnectionTemplate b -> CohortVariables -> Maybe Name -> SubscriptionQueryPlan (b :: BackendType) q
[_sqpParameterizedPlan] :: SubscriptionQueryPlan (b :: BackendType) q -> ParameterizedSubscriptionQueryPlan b q
[_sqpSourceConfig] :: SubscriptionQueryPlan (b :: BackendType) q -> SourceConfig b
[_sqpCohortId] :: SubscriptionQueryPlan (b :: BackendType) q -> CohortId
[_sqpResolvedConnectionTemplate] :: SubscriptionQueryPlan (b :: BackendType) q -> ResolvedConnectionTemplate b
[_sqpVariables] :: SubscriptionQueryPlan (b :: BackendType) q -> CohortVariables

-- | We need to know if the source has a namespace so that we can wrap it
--   around the response from the DB
[_sqpNamespace] :: SubscriptionQueryPlan (b :: BackendType) q -> Maybe Name
data SubscriptionQueryPlanExplanation
SubscriptionQueryPlanExplanation :: !Text -> ![Text] -> !CohortVariables -> SubscriptionQueryPlanExplanation
[_sqpeSql] :: SubscriptionQueryPlanExplanation -> !Text
[_sqpePlan] :: SubscriptionQueryPlanExplanation -> ![Text]
[_sqpeVariables] :: SubscriptionQueryPlanExplanation -> !CohortVariables
data ParameterizedSubscriptionQueryPlan (b :: BackendType) q
ParameterizedSubscriptionQueryPlan :: !RoleName -> !q -> ParameterizedSubscriptionQueryPlan (b :: BackendType) q
[_plqpRole] :: ParameterizedSubscriptionQueryPlan (b :: BackendType) q -> !RoleName
[_plqpQuery] :: ParameterizedSubscriptionQueryPlan (b :: BackendType) q -> !q
newtype CursorVariableValues
CursorVariableValues :: HashMap Name TxtEncodedVal -> CursorVariableValues
cvSessionVariables :: Lens' CohortVariables SessionVariables
cvCursorVariables :: Lens' CohortVariables ValidatedCursorVariables
cvQueryVariables :: Lens' CohortVariables ValidatedQueryVariables
cvSyntheticVariables :: Lens' CohortVariables ValidatedSyntheticVariables
unValidatedVariables :: forall f1 f2 p f3. (Profunctor p, Functor f3) => p (f1 TxtEncodedVal) (f3 (f2 TxtEncodedVal)) -> p (ValidatedVariables f1) (f3 (ValidatedVariables f2))
applyModifier :: Maybe (Endo Value) -> ByteString -> ByteString
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Plan.CohortId
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Plan.CohortIdArray
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Plan.CohortVariables
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Plan.CohortVariablesArray
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Plan.CursorVariableValues
instance GHC.Classes.Eq (f Hasura.SQL.Value.TxtEncodedVal) => GHC.Classes.Eq (Hasura.GraphQL.Execute.Subscription.Plan.ValidatedVariables f)
instance Database.PG.Query.Class.FromCol Hasura.GraphQL.Execute.Subscription.Plan.CohortId
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Execute.Subscription.Plan.CohortId
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Execute.Subscription.Plan.CursorVariableValues
instance GHC.Internal.Generics.Generic Hasura.GraphQL.Execute.Subscription.Plan.CohortVariables
instance Data.Hashable.Class.Hashable Hasura.GraphQL.Execute.Subscription.Plan.CohortId
instance Data.Hashable.Class.Hashable Hasura.GraphQL.Execute.Subscription.Plan.CohortVariables
instance Data.Hashable.Class.Hashable (f Hasura.SQL.Value.TxtEncodedVal) => Data.Hashable.Class.Hashable (Hasura.GraphQL.Execute.Subscription.Plan.ValidatedVariables f)
instance GHC.Internal.Base.Monoid (f Hasura.SQL.Value.TxtEncodedVal) => GHC.Internal.Base.Monoid (Hasura.GraphQL.Execute.Subscription.Plan.ValidatedVariables f)
instance GHC.Internal.Base.Semigroup (f Hasura.SQL.Value.TxtEncodedVal) => GHC.Internal.Base.Semigroup (Hasura.GraphQL.Execute.Subscription.Plan.ValidatedVariables f)
instance GHC.Internal.Show.Show Hasura.GraphQL.Execute.Subscription.Plan.CohortId
instance GHC.Internal.Show.Show Hasura.GraphQL.Execute.Subscription.Plan.CohortIdArray
instance GHC.Internal.Show.Show Hasura.GraphQL.Execute.Subscription.Plan.CohortVariables
instance GHC.Internal.Show.Show Hasura.GraphQL.Execute.Subscription.Plan.CohortVariablesArray
instance GHC.Internal.Show.Show Hasura.GraphQL.Execute.Subscription.Plan.CursorVariableValues
instance GHC.Internal.Show.Show q => GHC.Internal.Show.Show (Hasura.GraphQL.Execute.Subscription.Plan.ParameterizedSubscriptionQueryPlan b q)
instance GHC.Internal.Show.Show Hasura.GraphQL.Execute.Subscription.Plan.SubscriptionQueryPlanExplanation
instance GHC.Internal.Show.Show (f Hasura.SQL.Value.TxtEncodedVal) => GHC.Internal.Show.Show (Hasura.GraphQL.Execute.Subscription.Plan.ValidatedVariables f)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Subscription.Plan.CohortId
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Subscription.Plan.CohortVariables
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Subscription.Plan.CursorVariableValues
instance Data.Aeson.Types.ToJSON.ToJSON q => Data.Aeson.Types.ToJSON.ToJSON (Hasura.GraphQL.Execute.Subscription.Plan.ParameterizedSubscriptionQueryPlan b q)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Subscription.Plan.SubscriptionQueryPlanExplanation
instance Data.Aeson.Types.ToJSON.ToJSON (f Hasura.SQL.Value.TxtEncodedVal) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.GraphQL.Execute.Subscription.Plan.ValidatedVariables f)
instance Database.PG.Query.Class.ToPrepArg Hasura.GraphQL.Execute.Subscription.Plan.CohortIdArray
instance Database.PG.Query.Class.ToPrepArg Hasura.GraphQL.Execute.Subscription.Plan.CohortVariablesArray


-- | Postgres SQL Rename Identifiers
--   
--   <ol>
--   <li>Prefix table names with underscores to avoid issues where column
--   names and tables conflict. This can happen because we give columns and
--   tables the name <tt>root</tt> for some reason, and that can trip up
--   <tt>row_to_json</tt>. See
--   <a>https://github.com/PostgREST/postgrest/issues/993#issuecomment-340377813</a>.
--   An alternative solution would be to not create a <tt>TableAlias</tt>
--   with the name <tt>root</tt>, but that seemed a bit complicated for me
--   to do at the time.</li>
--   <li>Bypass the Postgres limitation of truncating identifiers to 63
--   characters long by prepending they identifier's md5 hash when they are
--   longer than 63 characters.</li>
--   </ol>
--   
--   We do both operations in the same traversal for performance reasons,
--   but a simpler implementation of (1) would be <tt>transformBi
--   prefixHash</tt> from the uniplate or the generic-plate package.
--   
--   See Postgres docs:
--   <a>https://www.postgresql.org/docs/current/sql-syntax-lexical.html#SQL-SYNTAX-IDENTIFIERS</a>
module Hasura.Backends.Postgres.SQL.RenameIdentifiers

-- | Prefix table names with undescores and rename long identifiers.
renameIdentifiers :: Select -> Select

-- | prefix table names with undescores and rename long identifiers.
renameIdentifiersSelectWith :: SelectWithG Select -> SelectWithG Select

-- | prefix table names with undescores and rename long identifiers.
renameIdentifiersSelectWithTopLevelCTE :: SelectWithG TopLevelCTE -> SelectWithG TopLevelCTE
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.RenameIdentifiers.TableNames
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.SQL.RenameIdentifiers.TableNames


-- | MSSQL Types Internal
--   
--   Types for Transact-SQL aka T-SQL; the language of SQL Server.
--   
--   In this module we define various MS SQL Server specific data types
--   used for T-SQL generation.
--   
--   These types are also used as underlying types in the <tt>Backend
--   'MSSQL</tt> instance which is defined in
--   <a>Hasura.Backends.MSSQL.Instances.Types</a>.
--   
--   We convert RQL IR ASTs to types defined here in the
--   <a>Hasura.Backends.MSSQL.FromIr</a> module, and we implement
--   pretty-printing for these types in the
--   <a>Hasura.Backends.MSSQL.ToQuery</a> module.
--   
--   NOTE: Various type class instances (including simple once such as Eq
--   and Show) are implemented in the
--   <a>Hasura.Backends.MSSQL.Types.Instances</a> module.
module Hasura.Backends.MSSQL.Types.Internal
data Aggregate
CountAggregate :: Countable Expression -> Aggregate
OpAggregate :: Text -> [Expression] -> Aggregate
TextAggregate :: Text -> Aggregate
data Aliased a
Aliased :: a -> Text -> Aliased a
[aliasedThing] :: Aliased a -> a
[aliasedAlias] :: Aliased a -> Text
data BooleanOperators a
ASTContains :: a -> BooleanOperators a
ASTCrosses :: a -> BooleanOperators a
ASTEquals :: a -> BooleanOperators a
ASTIntersects :: a -> BooleanOperators a
ASTOverlaps :: a -> BooleanOperators a
ASTTouches :: a -> BooleanOperators a
ASTWithin :: a -> BooleanOperators a
type Column (b :: BackendType) = ColumnName
data Declare
Declare :: Text -> ScalarType -> Expression -> Declare
[dName] :: Declare -> Text
[dType] :: Declare -> ScalarType
[dValue] :: Declare -> Expression

-- | Column name of some database table -- this differs to FieldName that
--   is used for referring to things within a query.
newtype ColumnName
ColumnName :: Text -> ColumnName
[columnNameText] :: ColumnName -> Text
columnNameToFieldName :: ColumnName -> EntityAlias -> FieldName
type ColumnType (b :: BackendType) = ScalarType
data Comment
DueToPermission :: Comment
RequestedSingleObject :: Comment
newtype ConstraintName
ConstraintName :: Text -> ConstraintName
[constraintNameText] :: ConstraintName -> Text
data Countable name
StarCountable :: Countable name
NonNullFieldCountable :: name -> Countable name
DistinctCountable :: name -> Countable name
newtype CountType field
CountType :: Countable (ColumnName, AnnRedactionExp 'MSSQL field) -> CountType field
[getCountType] :: CountType field -> Countable (ColumnName, AnnRedactionExp 'MSSQL field)

-- | Data type describing the length of a datatype. Used in
--   <a>CastExpression</a>s.
data DataLength
DataLengthUnspecified :: DataLength
DataLengthInt :: Int -> DataLength
DataLengthMax :: DataLength
data Delete
Delete :: Aliased TableName -> DeleteOutput -> TempTable -> Where -> Delete
[deleteTable] :: Delete -> Aliased TableName
[deleteOutput] :: Delete -> DeleteOutput
[deleteTempTable] :: Delete -> TempTable
[deleteWhere] :: Delete -> Where
type DeleteOutput = Output Deleted
newtype EntityAlias
EntityAlias :: Text -> EntityAlias
[entityAliasText] :: EntityAlias -> Text

-- | Extract the name bound in a <a>From</a> clause as an
--   <a>EntityAlias</a>.
fromAlias :: From -> EntityAlias
data Expression
ValueExpression :: Value -> Expression
AndExpression :: [Expression] -> Expression
OrExpression :: [Expression] -> Expression
NotExpression :: Expression -> Expression
ExistsExpression :: Select -> Expression
SelectExpression :: Select -> Expression
IsNullExpression :: Expression -> Expression
IsNotNullExpression :: Expression -> Expression
ColumnExpression :: FieldName -> Expression

-- | This one acts like a "cast to JSON" and makes SQL Server behave like
--   it knows your field is JSON and not double-encode it.
JsonQueryExpression :: Expression -> Expression
ToStringExpression :: Expression -> Expression
MethodApplicationExpression :: Expression -> MethodApplicationExpression -> Expression
FunctionApplicationExpression :: FunctionApplicationExpression -> Expression

-- | This is for getting actual atomic values out of a JSON string.
JsonValueExpression :: Expression -> JsonPath -> Expression
OpExpression :: Op -> Expression -> Expression -> Expression
ListExpression :: [Expression] -> Expression
STOpExpression :: SpatialOp -> Expression -> Expression -> Expression
CastExpression :: Expression -> ScalarType -> DataLength -> Expression

-- | "CASE WHEN (expression) THEN (expression) ELSE (expression) END"
ConditionalExpression :: Expression -> Expression -> Expression -> Expression

-- | The <tt>DEFAULT</tt> value. TODO: Make this as a part of
--   @<a>Value</a>.
DefaultExpression :: Expression
data FieldName
FieldName :: Text -> Text -> FieldName
[fieldName] :: FieldName -> Text
[fieldNameEntity] :: FieldName -> Text
data For
JsonFor :: ForJson -> For
NoFor :: For
data ForJson
ForJson :: JsonCardinality -> Root -> ForJson
[jsonCardinality] :: ForJson -> JsonCardinality
[jsonRoot] :: ForJson -> Root
data From
FromQualifiedTable :: Aliased TableName -> From
FromOpenJson :: Aliased OpenJson -> From
FromSelect :: Aliased Select -> From
FromIdentifier :: Text -> From
FromTempTable :: Aliased TempTableName -> From

-- | SQL functions application: <tt>some_function(e1, e2, ..)</tt>.
data FunctionApplicationExpression
FunExpISNULL :: Expression -> Expression -> FunctionApplicationExpression
data FunctionName
FunctionName :: Text -> SchemaName -> FunctionName
[functionName] :: FunctionName -> Text
[functionSchema] :: FunctionName -> SchemaName

-- | The <tt>USING</tt> section of a <tt>MERGE</tt> statement. Specifies
--   the temp table schema where the input values are.
data MergeUsing
MergeUsing :: TempTableName -> [ColumnName] -> MergeUsing
[mergeUsingTempTable] :: MergeUsing -> TempTableName
[mergeUsingColumns] :: MergeUsing -> [ColumnName]

-- | The <tt>ON</tt> section of a <tt>MERGE</tt> statement. Which columns
--   to match on?
data MergeOn
MergeOn :: [ColumnName] -> MergeOn
[mergeOnColumns] :: MergeOn -> [ColumnName]

-- | The <tt>WHEN MATCHED</tt> section of a <tt>MERGE</tt> statement. Which
--   columns to update when <tt>match_columns</tt> match (including
--   presets), and on which condition to actually update the values.
data MergeWhenMatched
MergeWhenMatched :: [ColumnName] -> Expression -> HashMap ColumnName Expression -> MergeWhenMatched
[mwmUpdateColumns] :: MergeWhenMatched -> [ColumnName]
[mwmCondition] :: MergeWhenMatched -> Expression
[mwmUpdatePreset] :: MergeWhenMatched -> HashMap ColumnName Expression

-- | The <tt>WHEN MATCHED</tt> section of a <tt>MERGE</tt> statement. Which
--   columns to insert?
newtype MergeWhenNotMatched
MergeWhenNotMatched :: [ColumnName] -> MergeWhenNotMatched
[mergeWhenNotMatchedInsertColumns] :: MergeWhenNotMatched -> [ColumnName]

-- | MERGE statement. Used for upserts and is responsible for actually
--   inserting or updating the data in the table.
data Merge
Merge :: TableName -> MergeUsing -> MergeOn -> MergeWhenMatched -> MergeWhenNotMatched -> InsertOutput -> TempTable -> Merge
[mergeTargetTable] :: Merge -> TableName
[mergeUsing] :: Merge -> MergeUsing
[mergeOn] :: Merge -> MergeOn
[mergeWhenMatched] :: Merge -> MergeWhenMatched
[mergeWhenNotMatched] :: Merge -> MergeWhenNotMatched
[mergeInsertOutput] :: Merge -> InsertOutput
[mergeOutputTempTable] :: Merge -> TempTable
data Insert
Insert :: TableName -> [ColumnName] -> InsertOutput -> TempTable -> [Values] -> Insert
[insertTable] :: Insert -> TableName
[insertColumns] :: Insert -> [ColumnName]
[insertOutput] :: Insert -> InsertOutput
[insertTempTable] :: Insert -> TempTable
[insertValues] :: Insert -> [Values]
type InsertOutput = Output Inserted
data Join
Join :: JoinSource -> JoinAlias -> Where -> Join
[joinSource] :: Join -> JoinSource
[joinJoinAlias] :: Join -> JoinAlias
[joinWhere] :: Join -> Where
data JoinAlias
JoinAlias :: Text -> Maybe Text -> JoinAlias
[joinAliasEntity] :: JoinAlias -> Text
[joinAliasField] :: JoinAlias -> Maybe Text
data JoinSource
JoinSelect :: Select -> JoinSource
JoinReselect :: Reselect -> JoinSource
data JsonCardinality
JsonArray :: JsonCardinality
JsonSingleton :: JsonCardinality
data JsonFieldSpec
ScalarField :: ScalarType -> DataLength -> Text -> Maybe JsonPath -> JsonFieldSpec
JsonField :: Text -> Maybe JsonPath -> JsonFieldSpec
StringField :: Text -> Maybe JsonPath -> JsonFieldSpec
data JsonPath
RootPath :: JsonPath
FieldPath :: JsonPath -> Text -> JsonPath
IndexPath :: JsonPath -> Integer -> JsonPath

-- | Object expression method application: <tt>(expression).text(e1, e2,
--   ..)</tt>
data MethodApplicationExpression
MethExpSTAsText :: MethodApplicationExpression
data NullsOrder
NullsFirst :: NullsOrder
NullsLast :: NullsOrder
NullsAnyOrder :: NullsOrder
data Op
LT :: Op
LTE :: Op
GT :: Op
GTE :: Op
IN :: Op
LIKE :: Op
NLIKE :: Op
NIN :: Op
EQ' :: Op
NEQ' :: Op
data OpenJson
OpenJson :: Expression -> Maybe (NonEmpty JsonFieldSpec) -> OpenJson
[openJsonExpression] :: OpenJson -> Expression
[openJsonWith] :: OpenJson -> Maybe (NonEmpty JsonFieldSpec)
data Order
AscOrder :: Order
DescOrder :: Order
data OrderBy
OrderBy :: Expression -> Order -> NullsOrder -> Maybe ScalarType -> OrderBy
[orderByExpression] :: OrderBy -> Expression
[orderByOrder] :: OrderBy -> Order
[orderByNullsOrder] :: OrderBy -> NullsOrder
[orderByType] :: OrderBy -> Maybe ScalarType
newtype OutputColumn
OutputColumn :: ColumnName -> OutputColumn
[unOutputColumn] :: OutputColumn -> ColumnName
data Inserted
Inserted :: Inserted
data Deleted
Deleted :: Deleted
data Output t
Output :: t -> [OutputColumn] -> Output t
[outputType] :: Output t -> t
[outputColumns] :: Output t -> [OutputColumn]
data Projection
ExpressionProjection :: Aliased Expression -> Projection
FieldNameProjection :: Aliased FieldName -> Projection
AggregateProjection :: Aliased Aggregate -> Projection
StarProjection :: Projection

-- | type for a query generated from IR along with any DDL actions
data QueryWithDDL a
QueryWithDDL :: [TempTableDDL] -> a -> [TempTableDDL] -> QueryWithDDL a
[qwdBeforeSteps] :: QueryWithDDL a -> [TempTableDDL]
[qwdQuery] :: QueryWithDDL a -> a
[qwdAfterSteps] :: QueryWithDDL a -> [TempTableDDL]

-- | A version of <a>Select</a> without a <tt>FROM</tt> clause. This means
--   it can only project expressions already selected in adjacent join
--   clauses, hence the name <tt>reselect</tt>.
data Reselect
Reselect :: [Projection] -> For -> Where -> Reselect
[reselectProjections] :: Reselect -> [Projection]
[reselectFor] :: Reselect -> For
[reselectWhere] :: Reselect -> Where
data Root
NoRoot :: Root
Root :: Text -> Root

-- | Derived from the odbc package.
data ScalarType
CharType :: ScalarType
NumericType :: ScalarType
DecimalType :: ScalarType
IntegerType :: ScalarType
SmallintType :: ScalarType
FloatType :: ScalarType
RealType :: ScalarType
DateType :: ScalarType
Ss_time2Type :: ScalarType
VarcharType :: ScalarType
WcharType :: ScalarType
WvarcharType :: ScalarType
WtextType :: ScalarType
TimestampType :: ScalarType
TextType :: ScalarType
BinaryType :: ScalarType
VarbinaryType :: ScalarType
BigintType :: ScalarType
TinyintType :: ScalarType
BitType :: ScalarType
GuidType :: ScalarType
GeographyType :: ScalarType
GeometryType :: ScalarType
UnknownType :: Text -> ScalarType
newtype SchemaName
SchemaName :: Text -> SchemaName
[_unSchemaName] :: SchemaName -> Text
data Select
Select :: Maybe With -> Top -> [Projection] -> Maybe From -> [Join] -> Where -> For -> Maybe (NonEmpty OrderBy) -> Maybe Expression -> Select
[selectWith] :: Select -> Maybe With
[selectTop] :: Select -> Top
[selectProjections] :: Select -> [Projection]
[selectFrom] :: Select -> Maybe From
[selectJoins] :: Select -> [Join]
[selectWhere] :: Select -> Where
[selectFor] :: Select -> For
[selectOrderBy] :: Select -> Maybe (NonEmpty OrderBy)
[selectOffset] :: Select -> Maybe Expression
data SetIdentityInsert
SetIdentityInsert :: SomeTableName -> SetValue -> SetIdentityInsert
[setTable] :: SetIdentityInsert -> SomeTableName
[setValue] :: SetIdentityInsert -> SetValue

-- | Extra query steps that can be emitted from the main query to do things
--   like setup temp tables
data TempTableDDL

-- | create a temp table
TempTableCreate :: TempTableName -> [UnifiedColumn] -> TempTableDDL

-- | insert output of a statement into a temp table
TempTableInsert :: TempTableName -> [Declare] -> InterpolatedQuery Expression -> TempTableDDL

-- | Drop a temp table
TempTableDrop :: TempTableName -> TempTableDDL

-- | A temporary table name is prepended by a hash-sign
newtype TempTableName
TempTableName :: Text -> TempTableName

-- | A name of a regular table or temporary table
data SomeTableName
RegularTableName :: TableName -> SomeTableName
TemporaryTableName :: TempTableName -> SomeTableName
data TempTable
TempTable :: TempTableName -> [ColumnName] -> TempTable
[ttName] :: TempTable -> TempTableName
[ttColumns] :: TempTable -> [ColumnName]
data SetValue
SetON :: SetValue
SetOFF :: SetValue

-- | SELECT INTO temporary table statement without values. Used to create a
--   temporary table with the same schema as an existing table.
data SelectIntoTempTable
SelectIntoTempTable :: TempTableName -> [UnifiedColumn] -> TableName -> SITTConstraints -> SelectIntoTempTable
[sittTempTableName] :: SelectIntoTempTable -> TempTableName
[sittColumns] :: SelectIntoTempTable -> [UnifiedColumn]
[sittFromTableName] :: SelectIntoTempTable -> TableName
[sittConstraints] :: SelectIntoTempTable -> SITTConstraints

-- | When creating a temporary table from an existing table schema, what
--   should we do with the constraints (such as <tt>IDENTITY</tt>?)
data SITTConstraints
KeepConstraints :: SITTConstraints
RemoveConstraints :: SITTConstraints

-- | Simple insert into a temporary table.
data InsertValuesIntoTempTable
InsertValuesIntoTempTable :: TempTableName -> [ColumnName] -> [Values] -> InsertValuesIntoTempTable
[ivittTempTableName] :: InsertValuesIntoTempTable -> TempTableName
[ivittColumns] :: InsertValuesIntoTempTable -> [ColumnName]
[ivittValues] :: InsertValuesIntoTempTable -> [Values]

-- | Supported operations for spatial data types
data SpatialOp
STEquals :: SpatialOp
STContains :: SpatialOp
STCrosses :: SpatialOp
STIntersects :: SpatialOp
STOverlaps :: SpatialOp
STWithin :: SpatialOp
STTouches :: SpatialOp
data TableName
TableName :: Text -> SchemaName -> TableName
[tableName] :: TableName -> Text
[tableSchema] :: TableName -> SchemaName
data Top
NoTop :: Top
Top :: Int -> Top
data UnifiedArrayRelationship
UnifiedArrayRelationship :: UnifiedUsing -> Text -> UnifiedArrayRelationship
[using] :: UnifiedArrayRelationship -> UnifiedUsing
[name] :: UnifiedArrayRelationship -> Text
data UnifiedColumn
UnifiedColumn :: ColumnName -> ScalarType -> UnifiedColumn
[name] :: UnifiedColumn -> ColumnName
[type'] :: UnifiedColumn -> ScalarType
data UnifiedObjectRelationship
UnifiedObjectRelationship :: UnifiedUsing -> Text -> UnifiedObjectRelationship
[using] :: UnifiedObjectRelationship -> UnifiedUsing
[name] :: UnifiedObjectRelationship -> Text
data UnifiedOn
UnifiedOn :: UnifiedTableName -> Text -> UnifiedOn
[table] :: UnifiedOn -> UnifiedTableName
[column] :: UnifiedOn -> Text
data UnifiedTableName
UnifiedTableName :: Text -> Text -> UnifiedTableName
[schema] :: UnifiedTableName -> Text
[name] :: UnifiedTableName -> Text
newtype UnifiedUsing
UnifiedUsing :: UnifiedOn -> UnifiedUsing
[foreign_key_constraint_on] :: UnifiedUsing -> UnifiedOn
type Value = Value
newtype Values
Values :: [Expression] -> Values
newtype Where
Where :: [Expression] -> Where
newtype With
With :: NonEmpty (Aliased CTEBody) -> With

-- | Something that can appear in a CTE body.
data CTEBody
CTESelect :: Select -> CTEBody
CTEUnsafeRawSQL :: InterpolatedQuery Expression -> CTEBody
emptySelect :: Select
geoTypes :: [ScalarType]
getGQLTableName :: TableName -> Either QErr Name
getGQLFunctionName :: FunctionName -> Either QErr Name
getTableIdentifier :: TableName -> Either QErr GQLNameIdentifier
isComparableType :: ScalarType -> Bool
isNumType :: ScalarType -> Bool
mkMSSQLScalarTypeName :: MonadError QErr m => ScalarType -> m Name
parseScalarValue :: ScalarType -> Value -> Either QErr Value
parseScalarType :: Text -> ScalarType
scalarTypeDBName :: DataLength -> ScalarType -> Text
snakeCaseName :: Text -> SchemaName -> Text
stringTypes :: [ScalarType]
namingConventionSupport :: SupportedNamingCase
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.SchemaName
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.Backends.MSSQL.Types.Internal.BooleanOperators a)
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.SchemaName
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.Backends.MSSQL.Types.Internal.ConstraintName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Types.Internal.SchemaName
instance GHC.Internal.Base.Functor Hasura.Backends.MSSQL.Types.Internal.Countable
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.SchemaName
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.SchemaName
instance GHC.Internal.Data.String.IsString Hasura.Backends.MSSQL.Types.Internal.SchemaName
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.MSSQL.Types.Internal.SchemaName
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.SchemaName
instance GHC.Classes.Ord Hasura.Backends.MSSQL.Types.Internal.SchemaName
instance GHC.Internal.Base.Semigroup Hasura.Backends.MSSQL.Types.Internal.With
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.SchemaName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.MSSQL.Types.Internal.ConstraintName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MSSQL.Types.Internal.SchemaName


-- | MSSQL Types Instances
--   
--   Instances for types from <a>Hasura.Backends.MSSQL.Types.Internal</a>
--   that're slow to compile.
module Hasura.Backends.MSSQL.Types.Instances
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.Aggregate
instance GHC.Internal.Data.Data.Data a => GHC.Internal.Data.Data.Data (Hasura.Backends.MSSQL.Types.Internal.Aliased a)
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.CTEBody
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.ColumnName
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.ConstraintName
instance GHC.Internal.Data.Data.Data n => GHC.Internal.Data.Data.Data (Hasura.Backends.MSSQL.Types.Internal.Countable n)
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.DataLength
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.Delete
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.Deleted
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.EntityAlias
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.Expression
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.FieldName
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.For
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.ForJson
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.From
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.FunctionApplicationExpression
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.FunctionName
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.Insert
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.InsertValuesIntoTempTable
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.Inserted
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.Join
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.JoinAlias
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.JoinSource
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.JsonCardinality
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.JsonFieldSpec
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.JsonPath
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.Merge
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.MergeOn
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.MergeUsing
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.MergeWhenMatched
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.MergeWhenNotMatched
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.MethodApplicationExpression
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.NullsOrder
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.Op
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.OpenJson
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.Order
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.OrderBy
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.InsertOutput
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.DeleteOutput
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.OutputColumn
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.Projection
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.Reselect
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.Root
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.SITTConstraints
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.ScalarType
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.Select
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.SelectIntoTempTable
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.SomeTableName
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.SpatialOp
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.TableName
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.TempTable
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.TempTableName
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.Top
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.UnifiedArrayRelationship
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.UnifiedColumn
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.UnifiedObjectRelationship
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.UnifiedOn
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.UnifiedTableName
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.UnifiedUsing
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.Values
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.Where
instance GHC.Internal.Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.With
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.Aggregate
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.Backends.MSSQL.Types.Internal.Aliased a)
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.CTEBody
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.ColumnName
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.ConstraintName
instance (Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.MSSQL, GHC.Classes.Eq n) => GHC.Classes.Eq (Hasura.Backends.MSSQL.Types.Internal.CountType n)
instance GHC.Classes.Eq n => GHC.Classes.Eq (Hasura.Backends.MSSQL.Types.Internal.Countable n)
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.DataLength
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.Delete
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.Deleted
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.EntityAlias
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.Expression
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.FieldName
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.For
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.ForJson
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.From
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.FunctionApplicationExpression
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.FunctionName
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.Insert
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.InsertValuesIntoTempTable
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.Inserted
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.Join
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.JoinAlias
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.JoinSource
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.JsonCardinality
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.JsonFieldSpec
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.JsonPath
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.Merge
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.MergeOn
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.MergeUsing
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.MergeWhenMatched
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.MergeWhenNotMatched
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.MethodApplicationExpression
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.NullsOrder
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.Op
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.OpenJson
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.Order
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.OrderBy
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.InsertOutput
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.DeleteOutput
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.OutputColumn
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.Projection
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.Reselect
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.Root
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.SITTConstraints
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.ScalarType
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.Select
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.SelectIntoTempTable
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.SomeTableName
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.SpatialOp
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.TableName
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.TempTable
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.TempTableName
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.Top
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.UnifiedArrayRelationship
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.UnifiedColumn
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.UnifiedObjectRelationship
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.UnifiedOn
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.UnifiedTableName
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.UnifiedUsing
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.Values
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.Where
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.With
instance GHC.Internal.Data.Foldable.Foldable Hasura.Backends.MSSQL.Types.Internal.BooleanOperators
instance GHC.Internal.Data.Foldable.Foldable Hasura.Backends.MSSQL.Types.Internal.Countable
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.Backends.MSSQL.Types.Internal.ColumnName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Types.Internal.ColumnName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Types.Internal.ConstraintName
instance Data.Aeson.Types.FromJSON.FromJSON n => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Backends.MSSQL.Types.Internal.Countable n)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Types.Internal.FieldName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Types.Internal.FunctionName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Types.Internal.NullsOrder
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Types.Internal.Order
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Types.Internal.ScalarType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Types.Internal.SomeTableName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Types.Internal.TableName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Types.Internal.TempTableName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Types.Internal.UnifiedArrayRelationship
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Types.Internal.UnifiedColumn
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Types.Internal.UnifiedObjectRelationship
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Types.Internal.UnifiedOn
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Types.Internal.UnifiedTableName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Types.Internal.UnifiedUsing
instance GHC.Internal.Base.Functor Hasura.Backends.MSSQL.Types.Internal.Aliased
instance GHC.Internal.Base.Functor Hasura.Backends.MSSQL.Types.Internal.BooleanOperators
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.Aggregate
instance GHC.Internal.Generics.Generic (Hasura.Backends.MSSQL.Types.Internal.Aliased a)
instance GHC.Internal.Generics.Generic (Hasura.Backends.MSSQL.Types.Internal.BooleanOperators a)
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.CTEBody
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.ColumnName
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.ConstraintName
instance GHC.Internal.Generics.Generic (Hasura.Backends.MSSQL.Types.Internal.CountType n)
instance GHC.Internal.Generics.Generic (Hasura.Backends.MSSQL.Types.Internal.Countable n)
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.DataLength
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.Delete
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.Deleted
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.EntityAlias
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.Expression
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.FieldName
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.For
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.ForJson
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.From
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.FunctionApplicationExpression
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.FunctionName
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.Insert
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.InsertValuesIntoTempTable
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.Inserted
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.Join
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.JoinAlias
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.JoinSource
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.JsonCardinality
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.JsonFieldSpec
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.JsonPath
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.Merge
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.MergeOn
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.MergeUsing
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.MergeWhenMatched
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.MergeWhenNotMatched
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.MethodApplicationExpression
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.NullsOrder
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.Op
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.OpenJson
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.Order
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.OrderBy
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.InsertOutput
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.DeleteOutput
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.OutputColumn
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.Projection
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.Reselect
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.Root
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.SITTConstraints
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.ScalarType
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.Select
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.SelectIntoTempTable
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.SomeTableName
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.SpatialOp
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.TableName
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.TempTable
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.TempTableName
instance GHC.Internal.Generics.Generic Data.Time.LocalTime.Internal.TimeZone.TimeZone
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.Top
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.UnifiedArrayRelationship
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.UnifiedColumn
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.UnifiedObjectRelationship
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.UnifiedOn
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.UnifiedTableName
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.UnifiedUsing
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.Values
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.Where
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.With
instance Autodocodec.Class.HasCodec Hasura.Backends.MSSQL.Types.Internal.ColumnName
instance Autodocodec.Class.HasCodec Hasura.Backends.MSSQL.Types.Internal.FunctionName
instance Autodocodec.Class.HasCodec Hasura.Backends.MSSQL.Types.Internal.ScalarType
instance Autodocodec.Class.HasCodec Hasura.Backends.MSSQL.Types.Internal.SchemaName
instance Autodocodec.Class.HasCodec Hasura.Backends.MSSQL.Types.Internal.TableName
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.Aggregate
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.Backends.MSSQL.Types.Internal.Aliased a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.Backends.MSSQL.Types.Internal.BooleanOperators a)
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.CTEBody
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.ColumnName
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.ConstraintName
instance Data.Hashable.Class.Hashable n => Data.Hashable.Class.Hashable (Hasura.Backends.MSSQL.Types.Internal.Countable n)
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.DataLength
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.Delete
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.Deleted
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.EntityAlias
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.Expression
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.FieldName
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.For
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.ForJson
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.From
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.FunctionApplicationExpression
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.FunctionName
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.Insert
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.InsertValuesIntoTempTable
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.Inserted
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.Join
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.JoinAlias
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.JoinSource
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.JsonCardinality
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.JsonFieldSpec
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.JsonPath
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.Merge
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.MergeOn
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.MergeUsing
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.MergeWhenMatched
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.MergeWhenNotMatched
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.MethodApplicationExpression
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.NullsOrder
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.Op
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.OpenJson
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.Order
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.OrderBy
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.InsertOutput
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.DeleteOutput
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.OutputColumn
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.Projection
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.Reselect
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.Root
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.SITTConstraints
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.ScalarType
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.Select
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.SelectIntoTempTable
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.SomeTableName
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.SpatialOp
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.TableName
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.TempTable
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.TempTableName
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.Top
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.UnifiedArrayRelationship
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.UnifiedColumn
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.UnifiedObjectRelationship
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.UnifiedOn
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.UnifiedTableName
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.UnifiedUsing
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.Values
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.Where
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.With
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.MSSQL.Types.Internal.FunctionName
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.MSSQL.Types.Internal.NullsOrder
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.MSSQL.Types.Internal.Order
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.MSSQL.Types.Internal.TableName
instance GHC.Internal.Base.Monoid Hasura.Backends.MSSQL.Types.Internal.Top
instance GHC.Internal.Base.Monoid Hasura.Backends.MSSQL.Types.Internal.Where
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.Aggregate
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.Backends.MSSQL.Types.Internal.Aliased a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.Backends.MSSQL.Types.Internal.BooleanOperators a)
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.CTEBody
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.ColumnName
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.ConstraintName
instance Control.DeepSeq.NFData n => Control.DeepSeq.NFData (Hasura.Backends.MSSQL.Types.Internal.Countable n)
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.DataLength
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.Delete
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.Deleted
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.EntityAlias
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.Expression
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.FieldName
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.For
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.ForJson
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.From
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.FunctionApplicationExpression
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.FunctionName
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.Insert
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.InsertValuesIntoTempTable
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.Inserted
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.Join
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.JoinAlias
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.JoinSource
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.JsonCardinality
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.JsonFieldSpec
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.JsonPath
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.Merge
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.MergeOn
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.MergeUsing
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.MergeWhenMatched
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.MergeWhenNotMatched
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.MethodApplicationExpression
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.NullsOrder
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.Op
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.OpenJson
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.Order
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.OrderBy
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.InsertOutput
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.DeleteOutput
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.OutputColumn
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.Projection
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.Reselect
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.Root
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.SITTConstraints
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.ScalarType
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.Select
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.SelectIntoTempTable
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.SomeTableName
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.SpatialOp
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.TableName
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.TempTable
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.TempTableName
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.Top
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.UnifiedArrayRelationship
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.UnifiedColumn
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.UnifiedObjectRelationship
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.UnifiedOn
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.UnifiedTableName
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.UnifiedUsing
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.Values
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.Where
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.With
instance GHC.Classes.Ord Hasura.Backends.MSSQL.Types.Internal.ColumnName
instance GHC.Classes.Ord Hasura.Backends.MSSQL.Types.Internal.ConstraintName
instance GHC.Classes.Ord Hasura.Backends.MSSQL.Types.Internal.FunctionName
instance GHC.Classes.Ord Hasura.Backends.MSSQL.Types.Internal.ScalarType
instance GHC.Classes.Ord Hasura.Backends.MSSQL.Types.Internal.SomeTableName
instance GHC.Classes.Ord Hasura.Backends.MSSQL.Types.Internal.TableName
instance GHC.Classes.Ord Hasura.Backends.MSSQL.Types.Internal.TempTableName
instance GHC.Classes.Ord Hasura.Backends.MSSQL.Types.Internal.UnifiedArrayRelationship
instance GHC.Classes.Ord Hasura.Backends.MSSQL.Types.Internal.UnifiedColumn
instance GHC.Classes.Ord Hasura.Backends.MSSQL.Types.Internal.UnifiedObjectRelationship
instance GHC.Classes.Ord Hasura.Backends.MSSQL.Types.Internal.UnifiedOn
instance GHC.Classes.Ord Hasura.Backends.MSSQL.Types.Internal.UnifiedTableName
instance GHC.Classes.Ord Hasura.Backends.MSSQL.Types.Internal.UnifiedUsing
instance GHC.Internal.Base.Semigroup Hasura.Backends.MSSQL.Types.Internal.Top
instance GHC.Internal.Base.Semigroup Hasura.Backends.MSSQL.Types.Internal.Where
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.Aggregate
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (Hasura.Backends.MSSQL.Types.Internal.Aliased a)
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (Hasura.Backends.MSSQL.Types.Internal.BooleanOperators a)
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.CTEBody
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.ColumnName
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.ConstraintName
instance GHC.Internal.Show.Show n => GHC.Internal.Show.Show (Hasura.Backends.MSSQL.Types.Internal.Countable n)
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.DataLength
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.Delete
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.Deleted
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.EntityAlias
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.Expression
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.FieldName
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.For
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.ForJson
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.From
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.FunctionApplicationExpression
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.FunctionName
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.Insert
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.InsertValuesIntoTempTable
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.Inserted
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.Join
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.JoinAlias
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.JoinSource
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.JsonCardinality
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.JsonFieldSpec
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.JsonPath
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.Merge
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.MergeOn
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.MergeUsing
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.MergeWhenMatched
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.MergeWhenNotMatched
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.MethodApplicationExpression
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.NullsOrder
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.Op
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.OpenJson
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.Order
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.OrderBy
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.InsertOutput
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.DeleteOutput
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.OutputColumn
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.Projection
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.Reselect
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.Root
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.SITTConstraints
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.ScalarType
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.Select
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.SelectIntoTempTable
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.SomeTableName
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.SpatialOp
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.TableName
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.TempTable
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.TempTableName
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.Top
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.UnifiedArrayRelationship
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.UnifiedColumn
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.UnifiedObjectRelationship
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.UnifiedOn
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.UnifiedTableName
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.UnifiedUsing
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.Values
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.Where
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Types.Internal.With
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.MSSQL.Types.Internal.ColumnName
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.MSSQL.Types.Internal.ConstraintName
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.MSSQL.Types.Internal.FunctionName
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.MSSQL.Types.Internal.ScalarType
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.MSSQL.Types.Internal.TableName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.MSSQL.Types.Internal.ColumnName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.MSSQL.Types.Internal.FunctionName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.MSSQL.Types.Internal.ScalarType
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.MSSQL.Types.Internal.TableName
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Extended.ToJSONKeyValue (Hasura.Backends.MSSQL.Types.Internal.BooleanOperators a)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MSSQL.Types.Internal.ColumnName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MSSQL.Types.Internal.ConstraintName
instance Data.Aeson.Types.ToJSON.ToJSON n => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Backends.MSSQL.Types.Internal.Countable n)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MSSQL.Types.Internal.FieldName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MSSQL.Types.Internal.FunctionName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MSSQL.Types.Internal.NullsOrder
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MSSQL.Types.Internal.Order
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MSSQL.Types.Internal.ScalarType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MSSQL.Types.Internal.TableName
instance Data.Text.Extended.ToTxt Hasura.Backends.MSSQL.Types.Internal.ColumnName
instance Data.Text.Extended.ToTxt Hasura.Backends.MSSQL.Types.Internal.ConstraintName
instance Data.Text.Extended.ToTxt Hasura.Backends.MSSQL.Types.Internal.FunctionName
instance Data.Text.Extended.ToTxt Hasura.Backends.MSSQL.Types.Internal.ScalarType
instance Data.Text.Extended.ToTxt Hasura.Backends.MSSQL.Types.Internal.TableName
instance GHC.Internal.Data.Traversable.Traversable Hasura.Backends.MSSQL.Types.Internal.BooleanOperators
instance GHC.Internal.Data.Traversable.Traversable Hasura.Backends.MSSQL.Types.Internal.Countable


-- | MSSQL Types Update
--   
--   This module defines the Update-related IR types specific to MSSQL.
module Hasura.Backends.MSSQL.Types.Update

-- | The various <tt>update operators</tt> supported by MSSQL, i.e. the
--   <tt>_set</tt>, <tt>_inc</tt> operators that appear in the schema.
--   
--   TODO: Docs for MSSQL! See <a>Update Mutations User docs</a>
data UpdateOperator v
UpdateSet :: v -> UpdateOperator v
UpdateInc :: v -> UpdateOperator v

-- | UPDATE [table_alias] SET [table_alias].column = <tt>value</tt> OUTPUT
--   INSERTED.column INTO #updated FROM [table_name] AS [table_alias] WHERE
--   <a>filter-expression</a>
data Update
Update :: Aliased TableName -> UpdateSet -> UpdateOutput -> TempTable -> Where -> Update
[updateTable] :: Update -> Aliased TableName
[updateSet] :: Update -> UpdateSet
[updateOutput] :: Update -> UpdateOutput
[updateTempTable] :: Update -> TempTable
[updateWhere] :: Update -> Where
type UpdateSet = HashMap ColumnName UpdateOperator Expression
type UpdateOutput = Output Inserted
instance GHC.Internal.Data.Data.Data v => GHC.Internal.Data.Data.Data (Hasura.Backends.MSSQL.Types.Update.UpdateOperator v)
instance GHC.Classes.Eq v => GHC.Classes.Eq (Hasura.Backends.MSSQL.Types.Update.UpdateOperator v)
instance GHC.Internal.Data.Foldable.Foldable Hasura.Backends.MSSQL.Types.Update.UpdateOperator
instance GHC.Internal.Base.Functor Hasura.Backends.MSSQL.Types.Update.UpdateOperator
instance GHC.Internal.Generics.Generic (Hasura.Backends.MSSQL.Types.Update.UpdateOperator v)
instance GHC.Internal.Show.Show v => GHC.Internal.Show.Show (Hasura.Backends.MSSQL.Types.Update.UpdateOperator v)
instance GHC.Internal.Data.Traversable.Traversable Hasura.Backends.MSSQL.Types.Update.UpdateOperator


-- | MSSQL Types Insert
--   
--   Types for MSSQL Insert IR.
module Hasura.Backends.MSSQL.Types.Insert

-- | Defines the part in insert mutation that is unique for MSSQL the
--   <tt>if_matched</tt> clause.
data BackendInsert v
BackendInsert :: Maybe (IfMatched v) -> BackendInsert v

-- | <tt>if_matched</tt> can be omitted (and in that case will be
--   <tt>Nothing</tt>). If omitted, we only insert new rows (without
--   upserting).
[_biIfMatched] :: BackendInsert v -> Maybe (IfMatched v)

-- | The IR data representing an <tt>if_matched</tt> clause, which handles
--   upserts.
data IfMatched v
IfMatched :: [Column 'MSSQL] -> [Column 'MSSQL] -> AnnBoolExp 'MSSQL v -> HashMap ColumnName v -> IfMatched v

-- | Columns to compare when checking if there's a match
[_imMatchColumns] :: IfMatched v -> [Column 'MSSQL]

-- | Columns to update when there's a match
[_imUpdateColumns] :: IfMatched v -> [Column 'MSSQL]

-- | A condition for updating columns in case of a match
[_imConditions] :: IfMatched v -> AnnBoolExp 'MSSQL v

-- | Default values (presets) for some columns
[_imColumnPresets] :: IfMatched v -> HashMap ColumnName v
instance Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.MSSQL => GHC.Internal.Data.Foldable.Foldable Hasura.Backends.MSSQL.Types.Insert.BackendInsert
instance Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.MSSQL => GHC.Internal.Data.Foldable.Foldable Hasura.Backends.MSSQL.Types.Insert.IfMatched
instance Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.MSSQL => GHC.Internal.Base.Functor Hasura.Backends.MSSQL.Types.Insert.BackendInsert
instance Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.MSSQL => GHC.Internal.Base.Functor Hasura.Backends.MSSQL.Types.Insert.IfMatched
instance (Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.MSSQL, GHC.Internal.Show.Show (Hasura.Backends.MSSQL.Types.Insert.IfMatched v), GHC.Internal.Show.Show v) => GHC.Internal.Show.Show (Hasura.Backends.MSSQL.Types.Insert.BackendInsert v)
instance (Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.MSSQL, GHC.Internal.Show.Show (Hasura.RQL.IR.BoolExp.AnnBoolExp 'Hasura.RQL.Types.BackendType.MSSQL v), GHC.Internal.Show.Show v) => GHC.Internal.Show.Show (Hasura.Backends.MSSQL.Types.Insert.IfMatched v)
instance Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.MSSQL => GHC.Internal.Data.Traversable.Traversable Hasura.Backends.MSSQL.Types.Insert.BackendInsert
instance Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.MSSQL => GHC.Internal.Data.Traversable.Traversable Hasura.Backends.MSSQL.Types.Insert.IfMatched


-- | This module exports modules <tt>Hasura.Backends.MSSQL.Types.*</tt>.
--   
--   The types in <a>Hasura.Backends.MSSQL.Types.Internal</a> define types
--   which represent T-SQL AST.
--   
--   The other modules such as <a>Hasura.Backends.MSSQL.Types.Insert</a>
--   and <a>Hasura.Backends.MSSQL.Types.Update</a> represent GraphQL AST
--   parts that are unique for MSSQL.
module Hasura.Backends.MSSQL.Types


-- | MSSQL ToQuery
--   
--   Convert the simple T-SQL AST to an SQL query, ready to be passed to
--   the odbc package's query/exec functions.
--   
--   We define a custom prettyprinter with the type <a>Printer</a>.
--   
--   If you'd like to trace and see what a <a>Printer</a> looks like as
--   SQL, you can use something like: &gt; ltraceM "sql" (ODBC.renderQuery
--   (toQueryPretty myPrinter))
module Hasura.Backends.MSSQL.ToQuery
fromSelect :: Select -> Printer
fromReselect :: Reselect -> Printer

-- | Pretty-prints a <a>Printer</a> as one line, converting
--   <a>NewlinePrinter</a> to space.
toQueryFlat :: Printer -> Query

-- | Pretty-prints a <a>Printer</a> as multiple lines as defined by the
--   printer.
toQueryPretty :: Printer -> Query
fromInsert :: Insert -> Printer

-- | Generate a MERGE SQL statement
fromMerge :: Merge -> Printer
fromTempTableDDL :: TempTableDDL -> Printer
fromSetIdentityInsert :: SetIdentityInsert -> Printer

-- | Generate a delete statement
--   
--   <pre>
--   Delete
--     (Aliased (TableName "table" "schema") "alias")
--     [ColumnName "id", ColumnName "name"]
--     (Where [OpExpression EQ' (ValueExpression (IntValue 1)) (ValueExpression (IntValue 1))])
--   </pre>
--   
--   Becomes:
--   
--   <pre>
--   DELETE [alias] OUTPUT DELETED.[id], DELETED.[name] INTO #deleted([id], [name]) FROM [schema].[table] AS [alias] WHERE ((1) = (1))
--   </pre>
fromDelete :: Delete -> Printer

-- | Generate an update statement
--   
--   <pre>
--   Update
--      (Aliased (TableName "table" "schema") "alias")
--      (fromList [(ColumnName "name", ValueExpression (TextValue "updated_name"))])
--      (Output Inserted)
--      (TempTable (TempTableName "updated") [ColumnName "id", ColumnName "name"])
--      (Where [OpExpression EQ' (ColumnName "id") (ValueExpression (IntValue 1))])
--   </pre>
--   
--   Becomes:
--   
--   <pre>
--   UPDATE [alias] SET [alias].[name] = 'updated_name' OUTPUT INSERTED.[id], INSERTED.[name] INTO
--   #updated([id], [name]) FROM [schema].[table] AS [alias] WHERE (id = 1)
--   </pre>
fromUpdate :: Update -> Printer

-- | Converts <a>SelectIntoTempTable</a>.
--   
--   <pre>
--   SelectIntoTempTable (TempTableName "deleted")  [UnifiedColumn "id" IntegerType, UnifiedColumn "name" TextType] (TableName "table" "schema")
--   </pre>
--   
--   Becomes:
--   
--   <pre>
--   SELECT [id], [name] INTO #deleted([id], [name]) FROM [schema].[table] WHERE (1&lt;&gt;1) UNION ALL SELECT [id], [name] FROM [schema].[table];
--   </pre>
--   
--   We add the `UNION ALL` part to avoid copying identity constraints, and
--   we cast columns with types such as <tt>timestamp</tt> which are
--   non-insertable to a different type.
fromSelectIntoTempTable :: SelectIntoTempTable -> Printer

-- | Generate a statement to insert values into temporary table.
fromInsertValuesIntoTempTable :: InsertValuesIntoTempTable -> Printer

-- | @TempTableName "temp_table" is converted to "DROP TABLE #temp_table"
dropTempTableQuery :: TempTableName -> Printer
fromRawUnescapedText :: Text -> Printer
fromTableName :: TableName -> Printer
(<+>) :: Printer -> Printer -> Printer
data Printer
SeqPrinter :: [Printer] -> Printer
SepByPrinter :: Printer -> [Printer] -> Printer
NewlinePrinter :: Printer
QueryPrinter :: Query -> Printer
IndentPrinter :: Int -> Printer -> Printer
instance GHC.Classes.Eq Hasura.Backends.MSSQL.ToQuery.Printer
instance GHC.Internal.Data.String.IsString Hasura.Backends.MSSQL.ToQuery.Printer
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.ToQuery.Printer
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MSSQL.Types.Internal.Expression


-- | MSSQL Instances Types
--   
--   Defines a <a>Backend</a> type class instance for MSSQL.
module Hasura.Backends.MSSQL.Instances.Types
instance Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.MSSQL
instance GHC.Internal.Data.Foldable.Foldable Hasura.Backends.MSSQL.Types.Internal.CountType
instance GHC.Internal.Base.Functor Hasura.Backends.MSSQL.Types.Internal.CountType
instance Hasura.RQL.Types.SourceConfiguration.HasSourceConfiguration 'Hasura.RQL.Types.BackendType.MSSQL
instance GHC.Internal.Show.Show n => GHC.Internal.Show.Show (Hasura.Backends.MSSQL.Types.Internal.CountType n)
instance GHC.Internal.Data.Traversable.Traversable Hasura.Backends.MSSQL.Types.Internal.CountType


-- | This module contains supporting definitions for building temporary
--   tables based off of the schema of other tables. This is used in
--   mutations to capture the data of rows that are affected.
module Hasura.Backends.MSSQL.FromIr.SelectIntoTempTable

-- | Create a temporary table with the same schema as the given table.
toSelectIntoTempTable :: TempTableName -> TableName -> [ColumnInfo 'MSSQL] -> SITTConstraints -> SelectIntoTempTable


-- | This module provides constants that are either:
--   
--   <ul>
--   <li>Simply in common user</li>
--   <li>Define names that that multiple pieces of code reference.</li>
--   </ul>
module Hasura.Backends.MSSQL.FromIr.Constants
trueExpression :: Expression
nullExpression :: Expression
emptyArrayExpression :: Expression
jsonFieldName :: Text
aggSubselectName :: Text
existsFieldName :: Text
aggFieldName :: Text
tempTableNameInserted :: TempTableName
tempTableNameValues :: TempTableName
tempTableNameDeleted :: TempTableName
tempTableNameUpdated :: TempTableName

module Hasura.Backends.DataConnector.Adapter.Types.Mutations

-- | The Data Connector-specific data of an Insert expression. Currently,
--   we don't have any.
--   
--   This is parameterised over <tt>v</tt> which enables different phases
--   of IR transformation to maintain the overall structure while
--   enriching/transforming the data at the leaves.
data BackendInsert v
BackendInsert :: BackendInsert v
data DataConnectorUpdateVariant v
SingleBatch :: UpdateBatch 'DataConnector UpdateOperator v -> DataConnectorUpdateVariant v
MultipleBatches :: [UpdateBatch 'DataConnector UpdateOperator v] -> DataConnectorUpdateVariant v

-- | The operators that are used to mutate specific columns on a table
data UpdateOperator v
UpdateSet :: v -> UpdateOperator v
UpdateCustomOperator :: UpdateColumnOperatorName -> v -> UpdateOperator v
instance (Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.DataConnector, GHC.Classes.Eq v) => GHC.Classes.Eq (Hasura.Backends.DataConnector.Adapter.Types.Mutations.DataConnectorUpdateVariant v)
instance GHC.Classes.Eq v => GHC.Classes.Eq (Hasura.Backends.DataConnector.Adapter.Types.Mutations.UpdateOperator v)
instance GHC.Internal.Data.Foldable.Foldable Hasura.Backends.DataConnector.Adapter.Types.Mutations.BackendInsert
instance Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.DataConnector => GHC.Internal.Data.Foldable.Foldable Hasura.Backends.DataConnector.Adapter.Types.Mutations.DataConnectorUpdateVariant
instance GHC.Internal.Data.Foldable.Foldable Hasura.Backends.DataConnector.Adapter.Types.Mutations.UpdateOperator
instance GHC.Internal.Base.Functor Hasura.Backends.DataConnector.Adapter.Types.Mutations.BackendInsert
instance Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.DataConnector => GHC.Internal.Base.Functor Hasura.Backends.DataConnector.Adapter.Types.Mutations.DataConnectorUpdateVariant
instance GHC.Internal.Base.Functor Hasura.Backends.DataConnector.Adapter.Types.Mutations.UpdateOperator
instance (Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.DataConnector, GHC.Internal.Show.Show v) => GHC.Internal.Show.Show (Hasura.Backends.DataConnector.Adapter.Types.Mutations.DataConnectorUpdateVariant v)
instance GHC.Internal.Show.Show v => GHC.Internal.Show.Show (Hasura.Backends.DataConnector.Adapter.Types.Mutations.UpdateOperator v)
instance GHC.Internal.Data.Traversable.Traversable Hasura.Backends.DataConnector.Adapter.Types.Mutations.BackendInsert
instance Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.DataConnector => GHC.Internal.Data.Traversable.Traversable Hasura.Backends.DataConnector.Adapter.Types.Mutations.DataConnectorUpdateVariant
instance GHC.Internal.Data.Traversable.Traversable Hasura.Backends.DataConnector.Adapter.Types.Mutations.UpdateOperator

module Hasura.Backends.DataConnector.Adapter.Types
data ConnSourceConfig
ConnSourceConfig :: Config -> Maybe Text -> Maybe (HashMap TemplateVariableName TemplateVariableSource) -> Maybe SourceTimeout -> ConnSourceConfig

-- | An arbitrary JSON payload to be passed to the agent in a header. HGE
--   validates this against the OpenAPI Spec provided by the agent.
[_cscValue] :: ConnSourceConfig -> Config

-- | Kriti Template for transforming the supplied <a>Config</a> value.
[_cscTemplate] :: ConnSourceConfig -> Maybe Text

-- | Definitions of variables that can be accessed in the Kriti template
--   via $vars
[_cscTemplateVariables] :: ConnSourceConfig -> Maybe (HashMap TemplateVariableName TemplateVariableSource)

-- | Timeout setting for HTTP requests to the agent. -- TODO: verify with
--   lyndon
[_cscTimeout] :: ConnSourceConfig -> Maybe SourceTimeout
newtype TemplateVariableName
TemplateVariableName :: Text -> TemplateVariableName
[unTemplateVariableName] :: TemplateVariableName -> Text
data TemplateVariableSource
TemplateVariableDynamicFromFile :: FilePath -> TemplateVariableSource
data SourceTimeout
sourceTimeoutMicroseconds :: SourceTimeout -> Int
data SourceConfig
SourceConfig :: BaseUrl -> Config -> Maybe Text -> HashMap TemplateVariableName TemplateVariableSource -> Capabilities -> Manager -> Maybe Int -> DataConnectorName -> Environment -> SourceConfig
[_scEndpoint] :: SourceConfig -> BaseUrl
[_scConfig] :: SourceConfig -> Config
[_scTemplate] :: SourceConfig -> Maybe Text
[_scTemplateVariables] :: SourceConfig -> HashMap TemplateVariableName TemplateVariableSource
[_scCapabilities] :: SourceConfig -> Capabilities
[_scManager] :: SourceConfig -> Manager
[_scTimeoutMicroseconds] :: SourceConfig -> Maybe Int
[_scDataConnectorName] :: SourceConfig -> DataConnectorName
[_scEnvironment] :: SourceConfig -> Environment
scCapabilities :: Lens' SourceConfig Capabilities
scConfig :: Lens' SourceConfig Config
scDataConnectorName :: Lens' SourceConfig DataConnectorName
scEndpoint :: Lens' SourceConfig BaseUrl
scManager :: Lens' SourceConfig Manager
scTemplate :: Lens' SourceConfig (Maybe Text)
scTemplateVariables :: Lens' SourceConfig (HashMap TemplateVariableName TemplateVariableSource)
scTimeoutMicroseconds :: Lens' SourceConfig (Maybe Int)
scEnvironment :: Lens' SourceConfig Environment
data DataConnectorOptions
DataConnectorOptions :: BaseUrl -> Maybe Text -> DataConnectorOptions
[_dcoUri] :: DataConnectorOptions -> BaseUrl
[_dcoDisplayName] :: DataConnectorOptions -> Maybe Text
data DataConnectorInfo
DataConnectorInfo :: DataConnectorOptions -> Capabilities -> ConfigSchemaResponse -> Maybe Text -> Maybe Text -> DataConnectorInfo
[_dciOptions] :: DataConnectorInfo -> DataConnectorOptions
[_dciCapabilities] :: DataConnectorInfo -> Capabilities
[_dciConfigSchemaResponse] :: DataConnectorInfo -> ConfigSchemaResponse
[_dciDisplayName] :: DataConnectorInfo -> Maybe Text
[_dciReleaseName] :: DataConnectorInfo -> Maybe Text

-- | The fully qualified name of a table. The last element in the list is
--   the table name and all other elements represent namespacing of the
--   table name. For example, for a database that has schemas, the name
--   would be '[<a>schema</a>,<a>name</a>]'
newtype TableName
TableName :: NonEmpty Text -> TableName
[unTableName] :: TableName -> NonEmpty Text
newtype ConstraintName
ConstraintName :: Text -> ConstraintName
[unConstraintName] :: ConstraintName -> Text
newtype ColumnName
ColumnName :: Text -> ColumnName
[unColumnName] :: ColumnName -> Text
data ColumnPath
CPPath :: NonEmpty ColumnName -> ColumnPath
CPColumn :: ColumnName -> ColumnPath
newtype FunctionName
FunctionName :: NonEmpty Text -> FunctionName
[unFunctionName] :: FunctionName -> NonEmpty Text

-- | This represents what information can be known about the return type of
--   a user-defined function. For now, either the return type will be the
--   name of a table that exists in the schema, or <a>Unknown</a> -
--   implying that this information can be derived from another source, or
--   if there is no other source, then it is an error. In future, this type
--   may be extended with additional constructors including scalar and row
--   types from the Logical Models feature.
--   
--   Note: This is very similar to ComputedFieldReturnType defined above.
--   The two types may be unified in future.
data FunctionReturnType
FunctionReturnsTable :: TableName -> FunctionReturnType
FunctionReturnsUnknown :: FunctionReturnType
data CountAggregate v
StarCount :: CountAggregate v
ColumnCount :: (ColumnName, AnnRedactionExp 'DataConnector v) -> CountAggregate v
ColumnDistinctCount :: (ColumnName, AnnRedactionExp 'DataConnector v) -> CountAggregate v
data Literal
ValueLiteral :: ScalarType -> Value -> Literal
ArrayLiteral :: ScalarType -> [Value] -> Literal
data OrderDirection
Ascending :: OrderDirection
Descending :: OrderDirection
data GraphQLType
GraphQLInt :: GraphQLType
GraphQLFloat :: GraphQLType
GraphQLString :: GraphQLType
GraphQLBoolean :: GraphQLType
GraphQLID :: GraphQLType
newtype ScalarType
ScalarType :: Text -> ScalarType
[unScalarType] :: ScalarType -> Text
data ArgumentExp a

-- | Table row accessor AETableRow | -- | Hardcoded reference to
--   <tt>hdb_catalog.hdb_action_log.response_payload</tt>
--   AEActionResponsePayload | -- | JSON/JSONB hasura session variable
--   object AESession a |
AEInput :: a -> ArgumentExp a
fromGQLType :: Name -> ScalarType

-- | This type captures backend-specific "extra" information about tables
--   and is used on types like <tt>DBTableMetadata</tt>
data ExtraTableMetadata
ExtraTableMetadata :: TableType -> HashMap ColumnName ExtraColumnMetadata -> ExtraTableMetadata
[_etmTableType] :: ExtraTableMetadata -> TableType
[_etmExtraColumnMetadata] :: ExtraTableMetadata -> HashMap ColumnName ExtraColumnMetadata
data ExtraColumnMetadata
ExtraColumnMetadata :: Maybe ColumnValueGenerationStrategy -> ExtraColumnMetadata
[_ecmValueGenerated] :: ExtraColumnMetadata -> Maybe ColumnValueGenerationStrategy
instance GHC.Internal.Data.Data.Data Hasura.Backends.DataConnector.Adapter.Types.ColumnName
instance GHC.Internal.Data.Data.Data Hasura.Backends.DataConnector.Adapter.Types.ConstraintName
instance (Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.DataConnector, GHC.Internal.Data.Data.Data (Hasura.RQL.IR.BoolExp.AnnRedactionExp 'Hasura.RQL.Types.BackendType.DataConnector v), GHC.Internal.Data.Data.Data v) => GHC.Internal.Data.Data.Data (Hasura.Backends.DataConnector.Adapter.Types.CountAggregate v)
instance GHC.Internal.Data.Data.Data Hasura.Backends.DataConnector.Adapter.Types.FunctionName
instance GHC.Internal.Data.Data.Data Hasura.Backends.DataConnector.Adapter.Types.OrderDirection
instance GHC.Internal.Data.Data.Data Hasura.Backends.DataConnector.Adapter.Types.TableName
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.Backends.DataConnector.Adapter.Types.ArgumentExp a)
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Adapter.Types.ColumnName
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Adapter.Types.ColumnPath
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Adapter.Types.ConnSourceConfig
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Adapter.Types.ConstraintName
instance (Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.DataConnector, GHC.Classes.Eq v) => GHC.Classes.Eq (Hasura.Backends.DataConnector.Adapter.Types.CountAggregate v)
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Adapter.Types.DataConnectorInfo
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Adapter.Types.DataConnectorOptions
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Adapter.Types.ExtraColumnMetadata
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Adapter.Types.ExtraTableMetadata
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Adapter.Types.FunctionName
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Adapter.Types.FunctionReturnType
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Adapter.Types.Literal
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Adapter.Types.OrderDirection
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Adapter.Types.ScalarType
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Adapter.Types.SourceConfig
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Adapter.Types.SourceTimeout
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Adapter.Types.TableName
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Adapter.Types.TemplateVariableName
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Adapter.Types.TemplateVariableSource
instance GHC.Internal.Data.Foldable.Foldable Hasura.Backends.DataConnector.Adapter.Types.ArgumentExp
instance Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.DataConnector => GHC.Internal.Data.Foldable.Foldable Hasura.Backends.DataConnector.Adapter.Types.CountAggregate
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.Backends.DataConnector.Adapter.Types.ColumnName
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.Backends.DataConnector.Adapter.Types.ColumnPath
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.Backends.DataConnector.Adapter.Types.ConstraintName
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.Backends.DataConnector.Adapter.Types.ScalarType
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.Backends.DataConnector.Adapter.Types.TemplateVariableName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.DataConnector.Adapter.Types.ColumnName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.DataConnector.Adapter.Types.ColumnPath
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.DataConnector.Adapter.Types.ConnSourceConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.DataConnector.Adapter.Types.ConstraintName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.DataConnector.Adapter.Types.DataConnectorInfo
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.DataConnector.Adapter.Types.DataConnectorOptions
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.DataConnector.Adapter.Types.ExtraColumnMetadata
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.DataConnector.Adapter.Types.ExtraTableMetadata
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.DataConnector.Adapter.Types.FunctionName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.DataConnector.Adapter.Types.FunctionReturnType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.DataConnector.Adapter.Types.ScalarType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.DataConnector.Adapter.Types.SourceTimeout
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.DataConnector.Adapter.Types.TableName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.DataConnector.Adapter.Types.TemplateVariableName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.DataConnector.Adapter.Types.TemplateVariableSource
instance Witch.From.From Hasura.Backends.DataConnector.API.V0.Column.ColumnName Hasura.Backends.DataConnector.Adapter.Types.ColumnName
instance Witch.From.From Hasura.Backends.DataConnector.Adapter.Types.ColumnName Hasura.Backends.DataConnector.API.V0.Column.ColumnName
instance Witch.From.From Hasura.Backends.DataConnector.Adapter.Types.ColumnName Hasura.Backends.DataConnector.Adapter.Types.ColumnPath
instance Witch.From.From Hasura.Backends.DataConnector.Adapter.Types.ColumnPath Hasura.Backends.DataConnector.API.V0.Column.ColumnSelector
instance Witch.From.From Hasura.Backends.DataConnector.API.V0.Column.ColumnSelector Hasura.Backends.DataConnector.Adapter.Types.ColumnPath
instance Witch.From.From Hasura.Backends.DataConnector.Adapter.Types.ConstraintName Hasura.Backends.DataConnector.API.V0.Table.ConstraintName
instance Witch.From.From Hasura.Backends.DataConnector.API.V0.Table.ConstraintName Hasura.Backends.DataConnector.Adapter.Types.ConstraintName
instance Witch.From.From Hasura.Backends.DataConnector.API.V0.Function.FunctionName Hasura.Backends.DataConnector.Adapter.Types.FunctionName
instance Witch.From.From Hasura.Backends.DataConnector.Adapter.Types.FunctionName Hasura.Backends.DataConnector.API.V0.Function.FunctionName
instance Witch.From.From (GHC.Internal.Base.NonEmpty Data.Text.Internal.Text) Hasura.Backends.DataConnector.Adapter.Types.FunctionName
instance Witch.From.From Hasura.Backends.DataConnector.Adapter.Types.OrderDirection Hasura.Backends.DataConnector.API.V0.OrderBy.OrderDirection
instance Witch.From.From Hasura.Backends.DataConnector.API.V0.OrderBy.OrderDirection Hasura.Backends.DataConnector.Adapter.Types.OrderDirection
instance Witch.From.From Hasura.Backends.DataConnector.API.V0.Scalar.ScalarType Hasura.Backends.DataConnector.Adapter.Types.ScalarType
instance Witch.From.From Hasura.Backends.DataConnector.Adapter.Types.ScalarType Hasura.Backends.DataConnector.API.V0.Scalar.ScalarType
instance Witch.From.From Hasura.Backends.DataConnector.Adapter.Types.TableName Hasura.Backends.DataConnector.API.V0.Table.TableName
instance Witch.From.From Hasura.Backends.DataConnector.API.V0.Table.TableName Hasura.Backends.DataConnector.Adapter.Types.TableName
instance GHC.Internal.Base.Functor Hasura.Backends.DataConnector.Adapter.Types.ArgumentExp
instance Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.DataConnector => GHC.Internal.Base.Functor Hasura.Backends.DataConnector.Adapter.Types.CountAggregate
instance GHC.Internal.Generics.Generic (Hasura.Backends.DataConnector.Adapter.Types.ArgumentExp a)
instance GHC.Internal.Generics.Generic Hasura.Backends.DataConnector.Adapter.Types.ColumnName
instance GHC.Internal.Generics.Generic Hasura.Backends.DataConnector.Adapter.Types.ColumnPath
instance GHC.Internal.Generics.Generic Hasura.Backends.DataConnector.Adapter.Types.ConnSourceConfig
instance GHC.Internal.Generics.Generic Hasura.Backends.DataConnector.Adapter.Types.ConstraintName
instance GHC.Internal.Generics.Generic (Hasura.Backends.DataConnector.Adapter.Types.CountAggregate v)
instance GHC.Internal.Generics.Generic Hasura.Backends.DataConnector.Adapter.Types.DataConnectorInfo
instance GHC.Internal.Generics.Generic Hasura.Backends.DataConnector.Adapter.Types.DataConnectorOptions
instance GHC.Internal.Generics.Generic Hasura.Backends.DataConnector.Adapter.Types.ExtraColumnMetadata
instance GHC.Internal.Generics.Generic Hasura.Backends.DataConnector.Adapter.Types.ExtraTableMetadata
instance GHC.Internal.Generics.Generic Hasura.Backends.DataConnector.Adapter.Types.FunctionName
instance GHC.Internal.Generics.Generic Hasura.Backends.DataConnector.Adapter.Types.FunctionReturnType
instance GHC.Internal.Generics.Generic Hasura.Backends.DataConnector.Adapter.Types.Literal
instance GHC.Internal.Generics.Generic Hasura.Backends.DataConnector.Adapter.Types.OrderDirection
instance GHC.Internal.Generics.Generic Hasura.Backends.DataConnector.Adapter.Types.ScalarType
instance GHC.Internal.Generics.Generic Hasura.Backends.DataConnector.Adapter.Types.SourceTimeout
instance GHC.Internal.Generics.Generic Hasura.Backends.DataConnector.Adapter.Types.TableName
instance GHC.Internal.Generics.Generic Hasura.Backends.DataConnector.Adapter.Types.TemplateVariableName
instance GHC.Internal.Generics.Generic Hasura.Backends.DataConnector.Adapter.Types.TemplateVariableSource
instance Autodocodec.Class.HasCodec Hasura.Backends.DataConnector.Adapter.Types.ColumnName
instance Autodocodec.Class.HasCodec Hasura.Backends.DataConnector.Adapter.Types.ColumnPath
instance Autodocodec.Class.HasCodec Hasura.Backends.DataConnector.Adapter.Types.ConnSourceConfig
instance Autodocodec.Class.HasCodec Hasura.Backends.DataConnector.Adapter.Types.DataConnectorOptions
instance Autodocodec.Class.HasCodec Hasura.Backends.DataConnector.Adapter.Types.FunctionName
instance Autodocodec.Class.HasCodec Hasura.Backends.DataConnector.Adapter.Types.FunctionReturnType
instance Autodocodec.Class.HasCodec Hasura.Backends.DataConnector.Adapter.Types.ScalarType
instance Autodocodec.Class.HasCodec Hasura.Backends.DataConnector.Adapter.Types.SourceTimeout
instance Autodocodec.Class.HasCodec Hasura.Backends.DataConnector.Adapter.Types.TableName
instance Autodocodec.Class.HasCodec Hasura.Backends.DataConnector.Adapter.Types.TemplateVariableName
instance Autodocodec.Class.HasCodec Hasura.Backends.DataConnector.Adapter.Types.TemplateVariableSource
instance Data.Has.Has Hasura.Backends.DataConnector.API.V0.Capabilities.ScalarTypesCapabilities Hasura.Backends.DataConnector.Adapter.Types.SourceConfig
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.Backends.DataConnector.Adapter.Types.ArgumentExp a)
instance Data.Hashable.Class.Hashable Hasura.Backends.DataConnector.Adapter.Types.ColumnName
instance Data.Hashable.Class.Hashable Hasura.Backends.DataConnector.Adapter.Types.ColumnPath
instance Data.Hashable.Class.Hashable Hasura.Backends.DataConnector.Adapter.Types.ConnSourceConfig
instance Data.Hashable.Class.Hashable Hasura.Backends.DataConnector.Adapter.Types.ConstraintName
instance Data.Hashable.Class.Hashable Hasura.Backends.DataConnector.Adapter.Types.ExtraColumnMetadata
instance Data.Hashable.Class.Hashable Hasura.Backends.DataConnector.Adapter.Types.ExtraTableMetadata
instance Data.Hashable.Class.Hashable Hasura.Backends.DataConnector.Adapter.Types.FunctionName
instance Data.Hashable.Class.Hashable Hasura.Backends.DataConnector.Adapter.Types.FunctionReturnType
instance Data.Hashable.Class.Hashable Hasura.Backends.DataConnector.Adapter.Types.Literal
instance Data.Hashable.Class.Hashable Hasura.Backends.DataConnector.Adapter.Types.OrderDirection
instance Data.Hashable.Class.Hashable Hasura.Backends.DataConnector.Adapter.Types.ScalarType
instance Data.Hashable.Class.Hashable Hasura.Backends.DataConnector.Adapter.Types.SourceTimeout
instance Data.Hashable.Class.Hashable Hasura.Backends.DataConnector.Adapter.Types.TableName
instance Data.Hashable.Class.Hashable Hasura.Backends.DataConnector.Adapter.Types.TemplateVariableName
instance Data.Hashable.Class.Hashable Hasura.Backends.DataConnector.Adapter.Types.TemplateVariableSource
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.Backends.DataConnector.Adapter.Types.ArgumentExp a)
instance Control.DeepSeq.NFData Hasura.Backends.DataConnector.Adapter.Types.ColumnName
instance Control.DeepSeq.NFData Hasura.Backends.DataConnector.Adapter.Types.ColumnPath
instance Control.DeepSeq.NFData Hasura.Backends.DataConnector.Adapter.Types.ConnSourceConfig
instance Control.DeepSeq.NFData Hasura.Backends.DataConnector.Adapter.Types.ConstraintName
instance Control.DeepSeq.NFData Hasura.Backends.DataConnector.Adapter.Types.ExtraColumnMetadata
instance Control.DeepSeq.NFData Hasura.Backends.DataConnector.Adapter.Types.ExtraTableMetadata
instance Control.DeepSeq.NFData Hasura.Backends.DataConnector.Adapter.Types.FunctionName
instance Control.DeepSeq.NFData Hasura.Backends.DataConnector.Adapter.Types.FunctionReturnType
instance Control.DeepSeq.NFData Hasura.Backends.DataConnector.Adapter.Types.Literal
instance Control.DeepSeq.NFData Hasura.Backends.DataConnector.Adapter.Types.OrderDirection
instance Control.DeepSeq.NFData Hasura.Backends.DataConnector.Adapter.Types.ScalarType
instance Control.DeepSeq.NFData Hasura.Backends.DataConnector.Adapter.Types.SourceTimeout
instance Control.DeepSeq.NFData Hasura.Backends.DataConnector.Adapter.Types.TableName
instance Control.DeepSeq.NFData Hasura.Backends.DataConnector.Adapter.Types.TemplateVariableName
instance Control.DeepSeq.NFData Hasura.Backends.DataConnector.Adapter.Types.TemplateVariableSource
instance GHC.Classes.Ord Hasura.Backends.DataConnector.Adapter.Types.ColumnName
instance GHC.Classes.Ord Hasura.Backends.DataConnector.Adapter.Types.ColumnPath
instance GHC.Classes.Ord Hasura.Backends.DataConnector.Adapter.Types.ConnSourceConfig
instance GHC.Classes.Ord Hasura.Backends.DataConnector.Adapter.Types.ConstraintName
instance GHC.Classes.Ord Hasura.Backends.DataConnector.Adapter.Types.DataConnectorOptions
instance GHC.Classes.Ord Hasura.Backends.DataConnector.Adapter.Types.FunctionName
instance GHC.Classes.Ord Hasura.Backends.DataConnector.Adapter.Types.Literal
instance GHC.Classes.Ord Hasura.Backends.DataConnector.Adapter.Types.OrderDirection
instance GHC.Classes.Ord Hasura.Backends.DataConnector.Adapter.Types.ScalarType
instance GHC.Classes.Ord Hasura.Backends.DataConnector.Adapter.Types.SourceTimeout
instance GHC.Classes.Ord Hasura.Backends.DataConnector.Adapter.Types.TableName
instance GHC.Classes.Ord Hasura.Backends.DataConnector.Adapter.Types.TemplateVariableName
instance GHC.Classes.Ord Hasura.Backends.DataConnector.Adapter.Types.TemplateVariableSource
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (Hasura.Backends.DataConnector.Adapter.Types.ArgumentExp a)
instance GHC.Internal.Show.Show Hasura.Backends.DataConnector.Adapter.Types.ColumnName
instance GHC.Internal.Show.Show Hasura.Backends.DataConnector.Adapter.Types.ColumnPath
instance GHC.Internal.Show.Show Hasura.Backends.DataConnector.Adapter.Types.ConnSourceConfig
instance GHC.Internal.Show.Show Hasura.Backends.DataConnector.Adapter.Types.ConstraintName
instance (Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.DataConnector, GHC.Internal.Show.Show v) => GHC.Internal.Show.Show (Hasura.Backends.DataConnector.Adapter.Types.CountAggregate v)
instance GHC.Internal.Show.Show Hasura.Backends.DataConnector.Adapter.Types.DataConnectorInfo
instance GHC.Internal.Show.Show Hasura.Backends.DataConnector.Adapter.Types.DataConnectorOptions
instance GHC.Internal.Show.Show Hasura.Backends.DataConnector.Adapter.Types.ExtraColumnMetadata
instance GHC.Internal.Show.Show Hasura.Backends.DataConnector.Adapter.Types.ExtraTableMetadata
instance GHC.Internal.Show.Show Hasura.Backends.DataConnector.Adapter.Types.FunctionName
instance GHC.Internal.Show.Show Hasura.Backends.DataConnector.Adapter.Types.FunctionReturnType
instance GHC.Internal.Show.Show Hasura.Backends.DataConnector.Adapter.Types.Literal
instance GHC.Internal.Show.Show Hasura.Backends.DataConnector.Adapter.Types.OrderDirection
instance GHC.Internal.Show.Show Hasura.Backends.DataConnector.Adapter.Types.ScalarType
instance GHC.Internal.Show.Show Hasura.Backends.DataConnector.Adapter.Types.SourceConfig
instance GHC.Internal.Show.Show Hasura.Backends.DataConnector.Adapter.Types.SourceTimeout
instance GHC.Internal.Show.Show Hasura.Backends.DataConnector.Adapter.Types.TableName
instance GHC.Internal.Show.Show Hasura.Backends.DataConnector.Adapter.Types.TemplateVariableName
instance GHC.Internal.Show.Show Hasura.Backends.DataConnector.Adapter.Types.TemplateVariableSource
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.DataConnector.Adapter.Types.ColumnName
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.DataConnector.Adapter.Types.ConstraintName
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.DataConnector.Adapter.Types.FunctionName
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.DataConnector.Adapter.Types.ScalarType
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.DataConnector.Adapter.Types.TableName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.DataConnector.Adapter.Types.ColumnName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.DataConnector.Adapter.Types.ColumnPath
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.DataConnector.Adapter.Types.ConstraintName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.DataConnector.Adapter.Types.FunctionName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.DataConnector.Adapter.Types.ScalarType
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.DataConnector.Adapter.Types.TableName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.DataConnector.Adapter.Types.TemplateVariableName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.Adapter.Types.ColumnName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.Adapter.Types.ColumnPath
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.Adapter.Types.ConnSourceConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.Adapter.Types.ConstraintName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.Adapter.Types.DataConnectorInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.Adapter.Types.DataConnectorOptions
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.Adapter.Types.ExtraColumnMetadata
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.Adapter.Types.ExtraTableMetadata
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.Adapter.Types.FunctionName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.Adapter.Types.FunctionReturnType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.Adapter.Types.Literal
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.Adapter.Types.OrderDirection
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.Adapter.Types.ScalarType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.Adapter.Types.SourceConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.Adapter.Types.SourceTimeout
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.Adapter.Types.TableName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.Adapter.Types.TemplateVariableName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.Adapter.Types.TemplateVariableSource
instance Data.OpenApi.Internal.Schema.ToSchema Hasura.Backends.DataConnector.Adapter.Types.ColumnPath
instance Data.OpenApi.Internal.Schema.ToSchema Hasura.Backends.DataConnector.Adapter.Types.FunctionReturnType
instance Data.Text.Extended.ToTxt Hasura.Backends.DataConnector.Adapter.Types.ColumnName
instance Data.Text.Extended.ToTxt Hasura.Backends.DataConnector.Adapter.Types.ConstraintName
instance Data.Text.Extended.ToTxt Hasura.Backends.DataConnector.Adapter.Types.FunctionName
instance Data.Text.Extended.ToTxt Hasura.Backends.DataConnector.Adapter.Types.ScalarType
instance Data.Text.Extended.ToTxt Hasura.Backends.DataConnector.Adapter.Types.TableName
instance GHC.Internal.Data.Traversable.Traversable Hasura.Backends.DataConnector.Adapter.Types.ArgumentExp
instance Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.DataConnector => GHC.Internal.Data.Traversable.Traversable Hasura.Backends.DataConnector.Adapter.Types.CountAggregate

module Hasura.Backends.DataConnector.Adapter.ConfigTransform
transformSourceConfig :: (MonadError QErr m, MonadIO m) => SourceConfig -> Maybe SessionVariables -> m SourceConfig

-- | Apply a transformation to a <a>ConnSourceConfig</a> and validate the
--   result.
validateConnSourceConfig :: (MonadError QErr m, MonadIO m) => DataConnectorName -> SourceName -> ConfigSchemaResponse -> ConnSourceConfig -> Maybe SessionVariables -> Environment -> m ()

module Hasura.Backends.DataConnector.Adapter.Backend
data CustomBooleanOperator a
CustomBooleanOperator :: Text -> Maybe a -> CustomBooleanOperator a
[_cboName] :: CustomBooleanOperator a -> Text
[_cboRHS] :: CustomBooleanOperator a -> Maybe a
columnTypeToScalarType :: ColumnType 'DataConnector -> ScalarType
parseValue :: ScalarTypesCapabilities -> ScalarType -> Value -> Parser Value
lookupGraphQLType :: ScalarTypesCapabilities -> ScalarType -> Maybe GraphQLType
instance Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.DataConnector
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.Backends.DataConnector.Adapter.Backend.CustomBooleanOperator a)
instance GHC.Internal.Data.Foldable.Foldable Hasura.Backends.DataConnector.Adapter.Backend.CustomBooleanOperator
instance GHC.Internal.Base.Functor Hasura.Backends.DataConnector.Adapter.Backend.CustomBooleanOperator
instance GHC.Internal.Generics.Generic (Hasura.Backends.DataConnector.Adapter.Backend.CustomBooleanOperator a)
instance Hasura.RQL.Types.SourceConfiguration.HasSourceConfiguration 'Hasura.RQL.Types.BackendType.DataConnector
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.Backends.DataConnector.Adapter.Backend.CustomBooleanOperator a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.Backends.DataConnector.Adapter.Backend.CustomBooleanOperator a)
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (Hasura.Backends.DataConnector.Adapter.Backend.CustomBooleanOperator a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Extended.ToJSONKeyValue (Hasura.Backends.DataConnector.Adapter.Backend.CustomBooleanOperator a)
instance GHC.Internal.Data.Traversable.Traversable Hasura.Backends.DataConnector.Adapter.Backend.CustomBooleanOperator


-- | Types for BigQuery
module Hasura.Backends.BigQuery.Types
data Aggregate
CountAggregate :: Countable Expression -> Aggregate
OpAggregates :: Text -> NonEmpty (Text, Expression) -> Aggregate
OpAggregate :: Text -> Expression -> Aggregate
TextAggregate :: Text -> Aggregate
data Aliased a
Aliased :: a -> Text -> Aliased a
[aliasedThing] :: Aliased a -> a
[aliasedAlias] :: Aliased a -> Text
data ArrayAgg
ArrayAgg :: NonEmpty Projection -> Maybe (NonEmpty OrderBy) -> Top -> ArrayAgg
[arrayAggProjections] :: ArrayAgg -> NonEmpty Projection
[arrayAggOrderBy] :: ArrayAgg -> Maybe (NonEmpty OrderBy)
[arrayAggTop] :: ArrayAgg -> Top

-- | A base-64 encoded binary string.
data Base64

-- | BigQuery's conception of a "big" fixed precision decimal.
newtype BigDecimal
BigDecimal :: Text -> BigDecimal
data BooleanOperators a
ASTContains :: a -> BooleanOperators a
ASTEquals :: a -> BooleanOperators a
ASTTouches :: a -> BooleanOperators a
ASTWithin :: a -> BooleanOperators a
ASTIntersects :: a -> BooleanOperators a
ASTDWithin :: DWithinGeogOp a -> BooleanOperators a
data Cardinality
Many :: Cardinality
One :: Cardinality
newtype ColumnName
ColumnName :: Text -> ColumnName
data Countable fieldname
StarCountable :: Countable fieldname
NonNullFieldCountable :: NonEmpty fieldname -> Countable fieldname
DistinctCountable :: NonEmpty fieldname -> Countable fieldname
newtype CountType field
CountType :: Countable (ColumnName, AnnRedactionExp 'BigQuery field) -> CountType field
[getCountType] :: CountType field -> Countable (ColumnName, AnnRedactionExp 'BigQuery field)

-- | BigQuery's conception of a date.
newtype Date
Date :: Text -> Date

-- | BigQuery's conception of a datetime.
newtype Datetime
Datetime :: Text -> Datetime

-- | BigQuery's conception of a fixed precision decimal.
newtype Decimal
Decimal :: Text -> Decimal
newtype EntityAlias
EntityAlias :: Text -> EntityAlias
[entityAliasText] :: EntityAlias -> Text
data ExecutionStatistics
ExecutionStatistics :: Job -> ExecutionStatistics
[_esJob] :: ExecutionStatistics -> Job
data Expression
ValueExpression :: TypedValue -> Expression
InExpression :: Expression -> TypedValue -> Expression
AndExpression :: [Expression] -> Expression
OrExpression :: [Expression] -> Expression
NotExpression :: Expression -> Expression
ExistsExpression :: Select -> Expression
SelectExpression :: Select -> Expression
IsNullExpression :: Expression -> Expression
IsNotNullExpression :: Expression -> Expression
ColumnExpression :: FieldName -> Expression
EqualExpression :: Expression -> Expression -> Expression
NotEqualExpression :: Expression -> Expression -> Expression

-- | This one acts like a "cast to JSON" and makes SQL Server behave like
--   it knows your field is JSON and not double-encode it.
JsonQueryExpression :: Expression -> Expression
ToStringExpression :: Expression -> Expression

-- | This is for getting actual atomic values out of a JSON string.
JsonValueExpression :: Expression -> JsonPath -> Expression
OpExpression :: Op -> Expression -> Expression -> Expression
ListExpression :: [Expression] -> Expression
CastExpression :: Expression -> ScalarType -> Expression
FunctionExpression :: FunctionName -> [Expression] -> Expression
ConditionalProjection :: Expression -> FieldName -> Expression

-- | A function input argument expression with argument name
--   <tt>argument_name</tt> =&gt; <tt>argument_value</tt>
FunctionNamedArgument :: Text -> Expression -> Expression
data FieldName
FieldName :: Text -> Text -> FieldName
[fieldName] :: FieldName -> Text
[fieldNameEntity] :: FieldName -> Text
data FieldOrigin
NoOrigin :: FieldOrigin
AggregateOrigin :: [Aliased Aggregate] -> FieldOrigin

-- | BigQuery's conception of a fixed precision decimal.
data Float64
data From
FromQualifiedTable :: Aliased TableName -> From
FromSelect :: Aliased Select -> From
FromSelectJson :: Aliased SelectJson -> From
FromFunction :: Aliased SelectFromFunction -> From
FromNativeQuery :: Aliased NativeQueryName -> From
data SelectFromFunction
SelectFromFunction :: FunctionName -> [Expression] -> SelectFromFunction
[sffFunctionName] :: SelectFromFunction -> FunctionName
[sffArguments] :: SelectFromFunction -> [Expression]
newtype Geography
Geography :: Text -> Geography

-- | BigQuery's conception of an INTEGER/INT64 (they are the same).
newtype Int64
Int64 :: Text -> Int64
data Job
Job :: Text -> Text -> Text -> Job
[state] :: Job -> Text
[jobId] :: Job -> Text
[location] :: Job -> Text
data Join
Join :: JoinSource -> EntityAlias -> [(FieldName, FieldName)] -> JoinProvenance -> Text -> Maybe Text -> EntityAlias -> JoinType -> Join
[joinSource] :: Join -> JoinSource
[joinAlias] :: Join -> EntityAlias
[joinOn] :: Join -> [(FieldName, FieldName)]
[joinProvenance] :: Join -> JoinProvenance
[joinFieldName] :: Join -> Text
[joinExtractPath] :: Join -> Maybe Text
[joinRightTable] :: Join -> EntityAlias
[joinType] :: Join -> JoinType
data JoinProvenance
OrderByJoinProvenance :: JoinProvenance
ObjectJoinProvenance :: [Text] -> JoinProvenance
ArrayAggregateJoinProvenance :: [(Text, FieldOrigin)] -> JoinProvenance
ArrayJoinProvenance :: [Text] -> JoinProvenance
data JoinSource
JoinSelect :: Select -> JoinSource
data JoinType
LeftOuter :: JoinType
Inner :: JoinType
data JsonPath
RootPath :: JsonPath
FieldPath :: JsonPath -> Text -> JsonPath
IndexPath :: JsonPath -> Integer -> JsonPath
data NullsOrder
NullsFirst :: NullsOrder
NullsLast :: NullsOrder
NullsAnyOrder :: NullsOrder
data Op
LessOp :: Op
LessOrEqualOp :: Op
MoreOp :: Op
MoreOrEqualOp :: Op
InOp :: Op
NotInOp :: Op
LikeOp :: Op
NotLikeOp :: Op
data Order
AscOrder :: Order
DescOrder :: Order
data OrderBy
OrderBy :: Expression -> FieldName -> Order -> NullsOrder -> OrderBy
[orderByExpression] :: OrderBy -> Expression
[orderByFieldName] :: OrderBy -> FieldName
[orderByOrder] :: OrderBy -> Order
[orderByNullsOrder] :: OrderBy -> NullsOrder
data Projection
ExpressionProjection :: Aliased Expression -> Projection
FieldNameProjection :: Aliased FieldName -> Projection
AggregateProjections :: Aliased (NonEmpty (Aliased Aggregate)) -> Projection
AggregateProjection :: Aliased Aggregate -> Projection
StarProjection :: Projection
ArrayAggProjection :: Aliased ArrayAgg -> Projection
EntityProjection :: Aliased [(FieldName, FieldOrigin)] -> Projection
ArrayEntityProjection :: EntityAlias -> Aliased [FieldName] -> Projection
WindowProjection :: Aliased WindowFunction -> Projection
data Reselect
Reselect :: NonEmpty Projection -> Where -> Reselect
[reselectProjections] :: Reselect -> NonEmpty Projection
[reselectWhere] :: Reselect -> Where
data ScalarType
StringScalarType :: ScalarType
BytesScalarType :: ScalarType
IntegerScalarType :: ScalarType
FloatScalarType :: ScalarType
BoolScalarType :: ScalarType
TimestampScalarType :: ScalarType
DateScalarType :: ScalarType
TimeScalarType :: ScalarType
DatetimeScalarType :: ScalarType
GeographyScalarType :: ScalarType
DecimalScalarType :: ScalarType
BigDecimalScalarType :: ScalarType
JsonScalarType :: ScalarType
StructScalarType :: ScalarType
data Select
Select :: Maybe With -> Top -> AsStruct -> NonEmpty Projection -> From -> [Join] -> Where -> Maybe (NonEmpty OrderBy) -> Maybe Expression -> [FieldName] -> Maybe [Text] -> Cardinality -> Select
[selectWith] :: Select -> Maybe With
[selectTop] :: Select -> Top
[selectAsStruct] :: Select -> AsStruct
[selectProjections] :: Select -> NonEmpty Projection
[selectFrom] :: Select -> From
[selectJoins] :: Select -> [Join]
[selectWhere] :: Select -> Where
[selectOrderBy] :: Select -> Maybe (NonEmpty OrderBy)
[selectOffset] :: Select -> Maybe Expression
[selectGroupBy] :: Select -> [FieldName]
[selectFinalWantedFields] :: Select -> Maybe [Text]
[selectCardinality] :: Select -> Cardinality
data AsStruct
NoAsStruct :: AsStruct
AsStruct :: AsStruct

-- | Helper type allowing addition of extra fields used in PARTITION BY.
--   
--   The main purpose of this type is sumulation of DISTINCT ON implemented
--   in Hasura.Backends.BigQuery.FromIr.simulateDistinctOn
data PartitionableSelect
PartitionableSelect :: (Maybe [FieldName] -> Select) -> From -> PartitionableSelect
[pselectFinalize] :: PartitionableSelect -> Maybe [FieldName] -> Select
[pselectFrom] :: PartitionableSelect -> From
noExtraPartitionFields :: PartitionableSelect -> Select
withExtraPartitionFields :: PartitionableSelect -> [FieldName] -> Select
simpleSelect :: Select -> PartitionableSelect
data SelectJson
SelectJson :: Expression -> [(ColumnName, ScalarType)] -> SelectJson
[selectJsonBody] :: SelectJson -> Expression
[selectJsonFields] :: SelectJson -> [(ColumnName, ScalarType)]
data TableName
TableName :: Text -> Text -> TableName
[tableName] :: TableName -> Text
[tableNameSchema] :: TableName -> Text

-- | BigQuery's conception of a time.
newtype Time
Time :: Text -> Time

-- | BigQuery's conception of a timestamp.
newtype Timestamp
Timestamp :: Text -> Timestamp
data Top
NoTop :: Top
Top :: Int64 -> Top
data TypedValue
TypedValue :: ScalarType -> Value -> TypedValue
[tvType] :: TypedValue -> ScalarType
[tvValue] :: TypedValue -> Value

-- | Source for this represenation type:
--   
--   
--   <a>https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#google.protobuf.Value</a>
--   
--   BigQuery results come in via the REST API as one of these simply
--   types.
--   
--   TODO: This omits StructValue -- do we need it?
data Value
NullValue :: Value

-- | 64-bit
--   <a>https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#integer_type</a>
IntegerValue :: Int64 -> Value

-- | Fixed precision
--   <a>https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#decimal_types</a>
DecimalValue :: Decimal -> Value

-- | Fixed precision
--   <a>https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#decimal_types</a>
BigDecimalValue :: BigDecimal -> Value

-- | Floating point
--   <a>https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#floating_point_types</a>
FloatValue :: Float64 -> Value
GeographyValue :: Geography -> Value
StringValue :: Text -> Value
BytesValue :: Base64 -> Value
BoolValue :: Bool -> Value
ArrayValue :: Vector Value -> Value
TimestampValue :: Timestamp -> Value
DateValue :: Date -> Value
TimeValue :: Time -> Value
JsonValue :: Value -> Value
DatetimeValue :: Datetime -> Value
newtype Where
Where :: [Expression] -> Where

-- | A Common Table Expression clause.
newtype With
With :: NonEmpty (Aliased (InterpolatedQuery Expression)) -> With
data WindowFunction

-- | ROW_NUMBER() OVER(PARTITION BY field)
RowNumberOverPartitionBy :: NonEmpty FieldName -> Maybe (NonEmpty OrderBy) -> WindowFunction
aggregateProjectionsFieldOrigin :: Projection -> FieldOrigin
doubleToBigDecimal :: Double -> BigDecimal
doubleToFloat64 :: Double -> Float64
getGQLTableName :: TableName -> Either QErr Name
intToInt64 :: Int64 -> Int64
int64Expr :: Int64 -> Expression
isComparableType :: ScalarType -> Bool
isNumType :: ScalarType -> Bool
parseScalarValue :: ScalarType -> Value -> Either QErr Value
projectionAlias :: Projection -> Maybe Text

-- | Convert <a>Scientific</a> to <a>Text</a>
scientificToText :: Scientific -> Text
columnToFieldName :: EntityAlias -> ColumnName -> FieldName
data FunctionName
FunctionName :: Text -> Maybe Text -> FunctionName
[functionName] :: FunctionName -> Text

-- | System functions like "unnest" don't have schema/dataset
[functionNameSchema] :: FunctionName -> Maybe Text

-- | The metadata required to define a computed field for a BigQuery table
data ComputedFieldDefinition
ComputedFieldDefinition :: FunctionName -> Maybe TableName -> HashMap FunctionArgName ColumnName -> ComputedFieldDefinition

-- | Name of the user defined routine
[_bqcfdFunction] :: ComputedFieldDefinition -> FunctionName

-- | Name of the table which the function returns. If not provided the
--   return table schema is inferred from the routine API metadata.
[_bqcfdReturnTable] :: ComputedFieldDefinition -> Maybe TableName

-- | A mapping context to determine argument value from table column
[_bqcfdArgumentMapping] :: ComputedFieldDefinition -> HashMap FunctionArgName ColumnName

-- | A argument expression for SQL functions
data ArgumentExp v

-- | Value coming from user's input through GraphQL query
AEInput :: v -> ArgumentExp v

-- | For computed fields, value of column from the table
AETableColumn :: ColumnName -> ArgumentExp v
type ComputedFieldImplicitArguments = HashMap FunctionArgName ColumnName

-- | Returning type of the function underlying a computed field
data ComputedFieldReturn

-- | Returns existing table, needs to be present in the metadata
ReturnExistingTable :: TableName -> ComputedFieldReturn

-- | An arbitrary table schema specified by column name and type pairs
ReturnTableSchema :: [(ColumnName, Name, ScalarType)] -> ComputedFieldReturn

-- | Function input argument specification
data FunctionArgument
FunctionArgument :: FunctionArgName -> ScalarType -> FunctionArgument

-- | Argument name of a table valued function is required Ref:
--   <a>https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language#create_table_function_statement</a>
[_faName] :: FunctionArgument -> FunctionArgName

-- | The data type of the argument
[_faType] :: FunctionArgument -> ScalarType
instance GHC.Internal.Enum.Bounded Hasura.Backends.BigQuery.Types.ScalarType
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Types.Aggregate
instance GHC.Internal.Data.Data.Data a => GHC.Internal.Data.Data.Data (Hasura.Backends.BigQuery.Types.Aliased a)
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Types.ArrayAgg
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Types.AsStruct
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Types.Base64
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Types.BigDecimal
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Types.Cardinality
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Types.ColumnName
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Types.Comment
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Types.ComputedFieldDefinition
instance GHC.Internal.Data.Data.Data fieldname => GHC.Internal.Data.Data.Data (Hasura.Backends.BigQuery.Types.Countable fieldname)
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Types.Date
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Types.Datetime
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Types.Decimal
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Types.EntityAlias
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Types.Expression
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Types.FieldName
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Types.FieldOrigin
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Types.Float64
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Types.From
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Types.FunctionName
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Types.Geography
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Types.Int64
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Types.Join
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Types.JoinProvenance
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Types.JoinSource
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Types.JoinType
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Types.JsonFieldSpec
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Types.JsonPath
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Types.NullsOrder
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Types.Op
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Types.OpenJson
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Types.Order
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Types.OrderBy
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Types.Projection
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Types.Reselect
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Types.ScalarType
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Types.Select
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Types.SelectFromFunction
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Types.SelectJson
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Types.TableName
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Types.Time
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Types.Timestamp
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Types.Top
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Types.TypedValue
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Types.Value
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Types.Where
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Types.WindowFunction
instance GHC.Internal.Data.Data.Data Hasura.Backends.BigQuery.Types.With
instance GHC.Internal.Enum.Enum Hasura.Backends.BigQuery.Types.ScalarType
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Aggregate
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.Backends.BigQuery.Types.Aliased a)
instance GHC.Classes.Eq v => GHC.Classes.Eq (Hasura.Backends.BigQuery.Types.ArgumentExp v)
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.ArrayAgg
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.AsStruct
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Base64
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.BigDecimal
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.Backends.BigQuery.Types.BooleanOperators a)
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Cardinality
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.ColumnName
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Comment
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.ComputedFieldDefinition
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.ComputedFieldReturn
instance (Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.BigQuery, GHC.Classes.Eq field) => GHC.Classes.Eq (Hasura.Backends.BigQuery.Types.CountType field)
instance GHC.Classes.Eq fieldname => GHC.Classes.Eq (Hasura.Backends.BigQuery.Types.Countable fieldname)
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Date
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Datetime
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Decimal
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.EntityAlias
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Expression
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.FieldName
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.FieldOrigin
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Float64
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.From
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.FunctionArgument
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.FunctionName
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Geography
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Int64
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Join
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.JoinProvenance
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.JoinSource
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.JoinType
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.JsonFieldSpec
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.JsonPath
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.NullsOrder
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Op
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.OpenJson
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Order
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.OrderBy
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Projection
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Reselect
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.ScalarType
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Select
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.SelectFromFunction
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.SelectJson
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.TableName
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Time
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Timestamp
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Top
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.TypedValue
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.UnifiedArrayRelationship
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.UnifiedColumn
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.UnifiedMetadata
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.UnifiedObjectRelationship
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.UnifiedOn
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.UnifiedTableMetadata
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.UnifiedTableName
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.UnifiedUsing
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Value
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Where
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.WindowFunction
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.With
instance GHC.Internal.Data.Foldable.Foldable Hasura.Backends.BigQuery.Types.ArgumentExp
instance GHC.Internal.Data.Foldable.Foldable Hasura.Backends.BigQuery.Types.BooleanOperators
instance GHC.Internal.Data.Foldable.Foldable Hasura.Backends.BigQuery.Types.Countable
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.Backends.BigQuery.Types.ColumnName
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Backends.BigQuery.Types.Aliased a)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.AsStruct
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Base64
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.BigDecimal
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Cardinality
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.ColumnName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Comment
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.ComputedFieldDefinition
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Backends.BigQuery.Types.Countable a)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Date
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Datetime
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Decimal
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.EntityAlias
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.FieldName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Float64
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.FunctionName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Geography
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Int64
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Job
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.JoinType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.JsonFieldSpec
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.JsonPath
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.NullsOrder
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Op
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Order
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.ScalarType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.TableName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Time
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Timestamp
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Top
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Value
instance GHC.Internal.Base.Functor Hasura.Backends.BigQuery.Types.Aliased
instance GHC.Internal.Base.Functor Hasura.Backends.BigQuery.Types.ArgumentExp
instance GHC.Internal.Base.Functor Hasura.Backends.BigQuery.Types.BooleanOperators
instance GHC.Internal.Base.Functor Hasura.Backends.BigQuery.Types.Countable
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Types.Aggregate
instance GHC.Internal.Generics.Generic (Hasura.Backends.BigQuery.Types.Aliased a)
instance GHC.Internal.Generics.Generic (Hasura.Backends.BigQuery.Types.ArgumentExp v)
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Types.ArrayAgg
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Types.AsStruct
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Types.Base64
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Types.BigDecimal
instance GHC.Internal.Generics.Generic (Hasura.Backends.BigQuery.Types.BooleanOperators a)
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Types.Cardinality
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Types.ColumnName
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Types.Comment
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Types.ComputedFieldDefinition
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Types.ComputedFieldReturn
instance GHC.Internal.Generics.Generic (Hasura.Backends.BigQuery.Types.Countable fieldname)
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Types.Date
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Types.Datetime
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Types.Decimal
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Types.EntityAlias
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Types.ExecutionStatistics
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Types.Expression
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Types.FieldName
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Types.FieldOrigin
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Types.Float64
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Types.From
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Types.FunctionArgument
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Types.FunctionName
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Types.Geography
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Types.Int64
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Types.Join
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Types.JoinProvenance
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Types.JoinSource
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Types.JoinType
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Types.JsonFieldSpec
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Types.JsonPath
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Types.NullsOrder
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Types.Op
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Types.OpenJson
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Types.Order
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Types.OrderBy
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Types.Projection
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Types.Reselect
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Types.ScalarType
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Types.Select
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Types.SelectFromFunction
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Types.SelectJson
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Types.TableName
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Types.Time
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Types.Timestamp
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Types.Top
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Types.TypedValue
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Types.Value
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Types.Where
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Types.WindowFunction
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Types.With
instance Autodocodec.Class.HasCodec Hasura.Backends.BigQuery.Types.ColumnName
instance Autodocodec.Class.HasCodec Hasura.Backends.BigQuery.Types.ComputedFieldDefinition
instance Autodocodec.Class.HasCodec Hasura.Backends.BigQuery.Types.FunctionName
instance Autodocodec.Class.HasCodec Hasura.Backends.BigQuery.Types.ScalarType
instance Autodocodec.Class.HasCodec Hasura.Backends.BigQuery.Types.TableName
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Aggregate
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.Backends.BigQuery.Types.Aliased a)
instance Data.Hashable.Class.Hashable v => Data.Hashable.Class.Hashable (Hasura.Backends.BigQuery.Types.ArgumentExp v)
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.ArrayAgg
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.AsStruct
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Base64
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.BigDecimal
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.Backends.BigQuery.Types.BooleanOperators a)
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Cardinality
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.ColumnName
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Comment
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.ComputedFieldDefinition
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.ComputedFieldReturn
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.Backends.BigQuery.Types.Countable a)
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Date
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Datetime
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Decimal
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.EntityAlias
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Expression
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.FieldName
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.FieldOrigin
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Float64
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.From
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.FunctionArgument
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.FunctionName
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Geography
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Int64
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Join
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.JoinProvenance
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.JoinSource
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.JoinType
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.JsonFieldSpec
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.JsonPath
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.NullsOrder
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Op
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.OpenJson
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Order
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.OrderBy
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Projection
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Reselect
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.ScalarType
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Select
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.SelectFromFunction
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.SelectJson
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.TableName
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Time
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Timestamp
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Top
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.TypedValue
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Value
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Where
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.WindowFunction
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.With
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Aggregate
instance Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift (Hasura.Backends.BigQuery.Types.Aliased a)
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.ArrayAgg
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.AsStruct
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Base64
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.BigDecimal
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Cardinality
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.ColumnName
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Comment
instance Language.Haskell.TH.Syntax.Lift fieldname => Language.Haskell.TH.Syntax.Lift (Hasura.Backends.BigQuery.Types.Countable fieldname)
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Date
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Datetime
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Decimal
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.EntityAlias
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Expression
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.FieldName
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.FieldOrigin
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Float64
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.From
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.FunctionName
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Geography
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Int64
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Join
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.JoinProvenance
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.JoinSource
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.JoinType
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.JsonFieldSpec
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.JsonPath
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.NullsOrder
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Op
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.OpenJson
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Order
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.OrderBy
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Projection
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Reselect
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.ScalarType
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Select
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.SelectFromFunction
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.SelectJson
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.TableName
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Time
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Timestamp
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Top
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.TypedValue
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Value
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Where
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.WindowFunction
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.With
instance GHC.Internal.Base.Monoid Hasura.Backends.BigQuery.Types.Top
instance GHC.Internal.Base.Monoid Hasura.Backends.BigQuery.Types.Where
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Aggregate
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.Backends.BigQuery.Types.Aliased a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.Backends.BigQuery.Types.ArgumentExp a)
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.ArrayAgg
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.AsStruct
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Base64
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.BigDecimal
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.Backends.BigQuery.Types.BooleanOperators a)
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Cardinality
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.ColumnName
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Comment
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.ComputedFieldDefinition
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.ComputedFieldReturn
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.Backends.BigQuery.Types.Countable a)
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Date
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Datetime
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Decimal
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.EntityAlias
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Expression
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.FieldName
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.FieldOrigin
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Float64
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.From
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.FunctionArgument
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.FunctionName
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Geography
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Int64
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Join
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.JoinProvenance
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.JoinSource
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.JoinType
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.JsonFieldSpec
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.JsonPath
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.NullsOrder
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Op
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.OpenJson
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Order
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.OrderBy
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Projection
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Reselect
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.ScalarType
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Select
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.SelectFromFunction
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.SelectJson
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.TableName
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Time
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Timestamp
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Top
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.TypedValue
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Value
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Where
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.WindowFunction
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.With
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Aggregate
instance GHC.Classes.Ord a => GHC.Classes.Ord (Hasura.Backends.BigQuery.Types.Aliased a)
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.ArrayAgg
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.AsStruct
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Base64
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.BigDecimal
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Cardinality
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.ColumnName
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Comment
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.ComputedFieldDefinition
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.ComputedFieldReturn
instance GHC.Classes.Ord fieldname => GHC.Classes.Ord (Hasura.Backends.BigQuery.Types.Countable fieldname)
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Date
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Datetime
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Decimal
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.EntityAlias
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Expression
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.FieldName
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.FieldOrigin
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Float64
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.From
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.FunctionArgument
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.FunctionName
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Geography
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Int64
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Join
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.JoinProvenance
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.JoinSource
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.JoinType
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.JsonFieldSpec
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.JsonPath
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.NullsOrder
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Op
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.OpenJson
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Order
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.OrderBy
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Projection
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Reselect
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.ScalarType
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Select
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.SelectFromFunction
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.SelectJson
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.TableName
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Time
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Timestamp
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Top
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.TypedValue
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.UnifiedArrayRelationship
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.UnifiedColumn
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.UnifiedMetadata
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.UnifiedObjectRelationship
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.UnifiedOn
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.UnifiedTableMetadata
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.UnifiedTableName
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.UnifiedUsing
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Value
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Where
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.WindowFunction
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.With
instance GHC.Internal.Base.Semigroup Hasura.Backends.BigQuery.Types.Top
instance GHC.Internal.Base.Semigroup Hasura.Backends.BigQuery.Types.Where
instance GHC.Internal.Base.Semigroup Hasura.Backends.BigQuery.Types.With
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.Aggregate
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (Hasura.Backends.BigQuery.Types.Aliased a)
instance GHC.Internal.Show.Show v => GHC.Internal.Show.Show (Hasura.Backends.BigQuery.Types.ArgumentExp v)
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.ArrayAgg
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.AsStruct
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.Base64
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.BigDecimal
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (Hasura.Backends.BigQuery.Types.BooleanOperators a)
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.Cardinality
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.ColumnName
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.Comment
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.ComputedFieldDefinition
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.ComputedFieldReturn
instance (Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.BigQuery, GHC.Internal.Show.Show field) => GHC.Internal.Show.Show (Hasura.Backends.BigQuery.Types.CountType field)
instance GHC.Internal.Show.Show fieldname => GHC.Internal.Show.Show (Hasura.Backends.BigQuery.Types.Countable fieldname)
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.Date
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.Datetime
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.Decimal
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.EntityAlias
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.Expression
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.FieldName
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.FieldOrigin
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.Float64
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.From
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.FunctionArgument
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.FunctionName
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.Geography
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.Int64
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.Job
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.Join
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.JoinProvenance
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.JoinSource
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.JoinType
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.JsonFieldSpec
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.JsonPath
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.NullsOrder
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.Op
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.OpenJson
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.Order
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.OrderBy
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.Projection
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.Reselect
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.ScalarType
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.Select
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.SelectFromFunction
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.SelectJson
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.TableName
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.Time
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.Timestamp
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.Top
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.TypedValue
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.UnifiedArrayRelationship
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.UnifiedColumn
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.UnifiedMetadata
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.UnifiedObjectRelationship
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.UnifiedOn
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.UnifiedTableMetadata
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.UnifiedTableName
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.UnifiedUsing
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.Value
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.Where
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.WindowFunction
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Types.With
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.BigQuery.Types.ColumnName
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.BigQuery.Types.FunctionName
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.BigQuery.Types.ScalarType
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.BigQuery.Types.TableName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.BigQuery.Types.ColumnName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.BigQuery.Types.FunctionName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.BigQuery.Types.ScalarType
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.BigQuery.Types.TableName
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Extended.ToJSONKeyValue (Hasura.Backends.BigQuery.Types.BooleanOperators a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Backends.BigQuery.Types.Aliased a)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.AsStruct
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.Base64
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.BigDecimal
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.Cardinality
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.ColumnName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.Comment
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.ComputedFieldDefinition
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.ComputedFieldReturn
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Backends.BigQuery.Types.Countable a)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.Date
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.Datetime
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.Decimal
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.EntityAlias
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.ExecutionStatistics
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.FieldName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.Float64
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.FunctionArgument
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.FunctionName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.Geography
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.Int64
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.Job
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.JoinType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.JsonFieldSpec
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.JsonPath
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.NullsOrder
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.Op
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.Order
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.ScalarType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.TableName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.Time
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.Timestamp
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.Top
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.Value
instance Data.Text.Extended.ToTxt Hasura.Backends.BigQuery.Types.ColumnName
instance Data.Text.Extended.ToTxt Hasura.Backends.BigQuery.Types.FunctionName
instance Data.Text.Extended.ToTxt Hasura.Backends.BigQuery.Types.ScalarType
instance Data.Text.Extended.ToTxt Hasura.Backends.BigQuery.Types.TableName
instance GHC.Internal.Data.Traversable.Traversable Hasura.Backends.BigQuery.Types.ArgumentExp
instance GHC.Internal.Data.Traversable.Traversable Hasura.Backends.BigQuery.Types.BooleanOperators
instance GHC.Internal.Data.Traversable.Traversable Hasura.Backends.BigQuery.Types.Countable


-- | Convert the simple BigQuery AST to an SQL query, ready to be passed to
--   the odbc package's query/exec functions.
module Hasura.Backends.BigQuery.ToQuery
fromSelect :: Select -> Printer
fromReselect :: Reselect -> Printer
fromExpression :: Expression -> Printer
toBuilderFlat :: Printer -> Builder
toBuilderPretty :: Printer -> Builder
toTextFlat :: Printer -> Text
toTextPretty :: Printer -> Text
data Printer
SeqPrinter :: [Printer] -> Printer
SepByPrinter :: Printer -> [Printer] -> Printer
NewlinePrinter :: Printer
UnsafeTextPrinter :: Text -> Printer
IndentPrinter :: Int -> Printer -> Printer
ValuePrinter :: TypedValue -> Printer

-- | Produces a query with holes, and a mapping for each
renderBuilderFlat :: Printer -> (Builder, InsOrdHashMap Int TypedValue)

-- | Produces a query with holes, and a mapping for each
renderBuilderPretty :: Printer -> (Builder, InsOrdHashMap Int TypedValue)
paramName :: Int -> Builder
instance GHC.Classes.Eq Hasura.Backends.BigQuery.ToQuery.Printer
instance GHC.Internal.Data.String.IsString Hasura.Backends.BigQuery.ToQuery.Printer
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.ToQuery.Printer
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.Expression


-- | This module defines the scalars we use specific to the BigQuery
--   schema.
--   
--   An idiosyncracy of BigQuery is that numbers serialized via JSON uses
--   string literals instead of number literals, because BigQuery handles
--   wider-bit numbers than JSON/JavaScript does.
--   
--   Therefore, the BigQuery Backend uses bespoke parsers for numeric
--   scalar input, which accept string literals as well as number literals,
--   such that we preserve symmetry with with output formats.
module Hasura.Backends.BigQuery.Parser.Scalars
bqInt64 :: forall origin (m :: Type -> Type). MonadParse m => Parser origin 'Both m Int64
bqFloat64 :: forall origin (m :: Type -> Type). MonadParse m => Parser origin 'Both m Float64
bqDecimal :: forall (m :: Type -> Type) origin. MonadParse m => Parser origin 'Both m Decimal
bqBigDecimal :: forall (m :: Type -> Type) origin. MonadParse m => Parser origin 'Both m BigDecimal

module Hasura.Backends.BigQuery.Meta
data MetadataError
RestProblem :: RestProblem -> MetadataError

-- | Get all tables from all specified data sets.
getTables :: MonadIO m => BigQuerySourceConfig -> m (Either RestProblem [RestTable])
data RestTableReference
RestTableReference :: Text -> Text -> Text -> RestTableReference
[datasetId] :: RestTableReference -> Text
[projectId] :: RestTableReference -> Text
[tableId] :: RestTableReference -> Text
data RestTable
RestTable :: RestTableReference -> RestTableSchema -> RestTable
[tableReference] :: RestTable -> RestTableReference
[schema] :: RestTable -> RestTableSchema
data RestTableSchema
RestTableSchema :: [RestFieldSchema] -> RestTableSchema
[fields] :: RestTableSchema -> [RestFieldSchema]
data RestFieldSchema
RestFieldSchema :: Text -> RestType -> Mode -> RestFieldSchema
[name] :: RestFieldSchema -> Text

-- | The field data type. Possible values include STRING, BYTES, INTEGER,
--   INT64 (same as INTEGER), FLOAT, FLOAT64 (same as FLOAT), BOOLEAN, BOOL
--   (same as BOOLEAN), TIMESTAMP, DATE, TIME, DATETIME, GEOGRAPHY,
--   NUMERIC, RECORD (where RECORD indicates that the field contains a
--   nested schema) or STRUCT (same as RECORD).
[type'] :: RestFieldSchema -> RestType
[mode] :: RestFieldSchema -> Mode
data RestType
STRING :: RestType
BYTES :: RestType
INTEGER :: RestType
FLOAT :: RestType
BOOL :: RestType
TIMESTAMP :: RestType
DATE :: RestType
TIME :: RestType
DATETIME :: RestType
GEOGRAPHY :: RestType
DECIMAL :: RestType
BIGDECIMAL :: RestType
JSON :: RestType
STRUCT :: RestType
data Mode
Nullable :: Mode
Required :: Mode
Repeated :: Mode

-- | The fine-grained type of the routine Ref:
--   <a>https://cloud.google.com/bigquery/docs/reference/rest/v2/routines#RoutineType</a>
data RestRoutineType
ROUTINE_TYPE_UNSPECIFIED :: RestRoutineType
SCALAR_FUNCTION :: RestRoutineType
PROCEDURE :: RestRoutineType
TABLE_VALUED_FUNCTION :: RestRoutineType

-- | Input argument of a function/routine. Ref:
--   <a>https://cloud.google.com/bigquery/docs/reference/rest/v2/routines#Argument</a>
data RestArgument
RestArgument :: Maybe Text -> Maybe RestType -> RestArgument

-- | The name of this argument. Can be absent for function return argument.
[_raName] :: RestArgument -> Maybe Text
[_raDataType] :: RestArgument -> Maybe RestType

-- | A field or a column. Ref:
--   <a>https://cloud.google.com/bigquery/docs/reference/rest/v2/StandardSqlField</a>
data RestStandardSqlField
RestStandardSqlField :: Maybe Text -> Maybe RestType -> RestStandardSqlField

-- | The field name is optional and is absent for fields with STRUCT type.
[_rssfName] :: RestStandardSqlField -> Maybe Text
[_rssType] :: RestStandardSqlField -> Maybe RestType

-- | A table type, which has only list of columns with names and types.
--   Ref:
--   <a>https://cloud.google.com/bigquery/docs/reference/rest/v2/routines#StandardSqlTableType</a>
data RestStandardSqlTableType
RestStandardSqlTableType :: [RestStandardSqlField] -> RestStandardSqlTableType
[_rrttColumns] :: RestStandardSqlTableType -> [RestStandardSqlField]

-- | Id path of a routine. Ref:
--   <a>https://cloud.google.com/bigquery/docs/reference/rest/v2/routines#RoutineReference</a>
data RestRoutineReference
RestRoutineReference :: Text -> Text -> Text -> RestRoutineReference
[datasetId] :: RestRoutineReference -> Text
[projectId] :: RestRoutineReference -> Text
[routineId] :: RestRoutineReference -> Text
routineReferenceToFunctionName :: RestRoutineReference -> FunctionName

-- | A user-defined function. Ref:
--   <a>https://cloud.google.com/bigquery/docs/reference/rest/v2/routines#Routine</a>
data RestRoutine
RestRoutine :: RestRoutineReference -> RestRoutineType -> Maybe [RestArgument] -> Maybe RestStandardSqlTableType -> RestRoutine

-- | Reference describing the ID of this routine
[routineReference] :: RestRoutine -> RestRoutineReference

-- | The type of routine
[routineType] :: RestRoutine -> RestRoutineType

-- | List of arguments defined
[arguments] :: RestRoutine -> Maybe [RestArgument]

-- | Routines defined with 'RETURNS TABLE' clause has this information
[returnTableType] :: RestRoutine -> Maybe RestStandardSqlTableType

-- | Get all routines from all specified data sets.
getRoutines :: MonadIO m => BigQuerySourceConfig -> m (Either RestProblem [RestRoutine])
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Meta.RestArgument
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Meta.RestRoutine
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Meta.RestRoutineReference
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Meta.RestRoutineType
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Meta.RestStandardSqlField
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Meta.RestStandardSqlTableType
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Meta.RestType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Meta.Mode
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Meta.RestArgument
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Meta.RestFieldSchema
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Meta.RestRoutine
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Meta.RestRoutineList
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Meta.RestRoutineReference
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Meta.RestRoutineType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Meta.RestStandardSqlField
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Meta.RestStandardSqlTableType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Meta.RestTable
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Meta.RestTableBrief
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Meta.RestTableList
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Meta.RestTableReference
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Meta.RestTableSchema
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Meta.RestType
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Meta.RestArgument
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Meta.RestFieldSchema
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Meta.RestRoutine
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Meta.RestRoutineReference
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Meta.RestRoutineType
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Meta.RestStandardSqlField
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Meta.RestStandardSqlTableType
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Meta.RestTable
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Meta.RestTableBrief
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Meta.RestTableReference
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Meta.RestTableSchema
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Meta.MetadataError
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Meta.Mode
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Meta.RestArgument
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Meta.RestFieldSchema
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Meta.RestProblem
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Meta.RestRoutine
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Meta.RestRoutineList
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Meta.RestRoutineReference
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Meta.RestRoutineType
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Meta.RestStandardSqlField
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Meta.RestStandardSqlTableType
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Meta.RestTable
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Meta.RestTableBrief
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Meta.RestTableList
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Meta.RestTableReference
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Meta.RestTableSchema
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Meta.RestType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Meta.RestArgument
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Meta.RestRoutine
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Meta.RestRoutineReference
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Meta.RestRoutineType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Meta.RestStandardSqlField
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Meta.RestStandardSqlTableType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Meta.RestType

module Hasura.Backends.BigQuery.Instances.Types
instance Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.BigQuery
instance GHC.Internal.Data.Foldable.Foldable Hasura.Backends.BigQuery.Types.CountType
instance GHC.Internal.Base.Functor Hasura.Backends.BigQuery.Types.CountType
instance Hasura.RQL.Types.SourceConfiguration.HasSourceConfiguration 'Hasura.RQL.Types.BackendType.BigQuery
instance GHC.Internal.Data.Traversable.Traversable Hasura.Backends.BigQuery.Types.CountType

module Hasura.Backends.Postgres.Execute.ConnectionTemplate

-- | This connection tag represents primary database connection
data PrimaryTag
PrimaryTag :: PrimaryTag

-- | This connection tag represents default behaviour of database
--   connections.
--   
--   For example, if read replica is set, then it will redirect GQL queries
--   to read replicas and mutations to the primary connection
data DefaultTag
DefaultTag :: DefaultTag

-- | This connection tag represents read replica database connection
data ReadReplicasTag
ReadReplicasTag :: ReadReplicasTag

-- | Data type for single member in connection_set for connection template
--   context
data ConnectionSetMemberTemplateContext
ConnectionSetMemberTemplateContext :: ConnectionSetTemplateContextType -> PostgresConnectionSetMemberName -> ConnectionSetMemberTemplateContext
[_cseType] :: ConnectionSetMemberTemplateContext -> ConnectionSetTemplateContextType
[_cseName] :: ConnectionSetMemberTemplateContext -> PostgresConnectionSetMemberName

-- | Headers information for the connection template context
data RequestContextHeaders
RequestContextHeaders :: HashMap Text Text -> RequestContextHeaders

-- | Data type for connection_set for connection template context
data ConnectionSetTemplateContext

-- | Query information (operation name and operation type) for connection
--   template context
data QueryContext
QueryContext :: Maybe Name -> QueryOperationType -> QueryContext
[_qcOperationName] :: QueryContext -> Maybe Name
[_qcOperationType] :: QueryContext -> QueryOperationType

-- | Request information for connection template context
data RequestContext
RequestContext :: RequestContextHeaders -> SessionVariables -> Maybe QueryContext -> RequestContext
[_rcHeaders] :: RequestContext -> RequestContextHeaders
[_rcSession] :: RequestContext -> SessionVariables
[_rcQuery] :: RequestContext -> Maybe QueryContext

-- | The complete connection template context used for resolving connection
--   template
data PostgresConnectionTemplateContext
PostgresConnectionTemplateContext :: RequestContext -> PrimaryTag -> ReadReplicasTag -> DefaultTag -> ConnectionSetTemplateContext -> PostgresConnectionTemplateContext
[_pctcRequest] :: PostgresConnectionTemplateContext -> RequestContext
[_pctcPrimary] :: PostgresConnectionTemplateContext -> PrimaryTag
[_pctcReadReplicas] :: PostgresConnectionTemplateContext -> ReadReplicasTag
[_pctcDefault] :: PostgresConnectionTemplateContext -> DefaultTag
[_pctcConnectionSet] :: PostgresConnectionTemplateContext -> ConnectionSetTemplateContext

-- | Outcome of the connection template resolution
data PostgresResolvedConnectionTemplate
PCTODefault :: DefaultTag -> PostgresResolvedConnectionTemplate
PCTOPrimary :: PrimaryTag -> PostgresResolvedConnectionTemplate
PCTOReadReplicas :: ReadReplicasTag -> PostgresResolvedConnectionTemplate
PCTOConnectionSet :: PostgresConnectionSetMemberName -> PostgresResolvedConnectionTemplate
newtype QueryOperationType
QueryOperationType :: OperationType -> QueryOperationType
mkConnectionSetMemberTemplateContext :: PostgresConnectionSetMemberName -> ConnectionSetMemberTemplateContext

-- | Construct template context
makeConnectionTemplateContext :: RequestContext -> [PostgresConnectionSetMemberName] -> PostgresConnectionTemplateContext
makeRequestContext :: Maybe QueryContext -> [Header] -> SessionVariables -> RequestContext

-- | We should move this to Data.Aeson.Kriti.Functions
runKritiEval :: PostgresConnectionTemplateContext -> KritiTemplate -> Either EvalError Value
instance GHC.Classes.Eq Hasura.Backends.Postgres.Execute.ConnectionTemplate.ConnectionSetMemberTemplateContext
instance GHC.Classes.Eq Hasura.Backends.Postgres.Execute.ConnectionTemplate.ConnectionSetTemplateContextType
instance GHC.Classes.Eq Hasura.Backends.Postgres.Execute.ConnectionTemplate.DefaultTag
instance GHC.Classes.Eq Hasura.Backends.Postgres.Execute.ConnectionTemplate.PostgresResolvedConnectionTemplate
instance GHC.Classes.Eq Hasura.Backends.Postgres.Execute.ConnectionTemplate.PrimaryTag
instance GHC.Classes.Eq Hasura.Backends.Postgres.Execute.ConnectionTemplate.ReadReplicasTag
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Execute.ConnectionTemplate.ConnectionSetMemberTemplateContext
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Execute.ConnectionTemplate.ConnectionSetTemplateContext
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Execute.ConnectionTemplate.ConnectionSetTemplateContextType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Execute.ConnectionTemplate.DefaultTag
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Execute.ConnectionTemplate.PostgresConnectionTemplateContext
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Execute.ConnectionTemplate.PostgresResolvedConnectionTemplate
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Execute.ConnectionTemplate.PrimaryTag
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Execute.ConnectionTemplate.QueryContext
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Execute.ConnectionTemplate.QueryOperationType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Execute.ConnectionTemplate.ReadReplicasTag
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Execute.ConnectionTemplate.RequestContext
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Execute.ConnectionTemplate.RequestContextHeaders
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.Execute.ConnectionTemplate.ConnectionSetMemberTemplateContext
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.Execute.ConnectionTemplate.ConnectionSetTemplateContextType
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.Execute.ConnectionTemplate.DefaultTag
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.Execute.ConnectionTemplate.PostgresConnectionTemplateContext
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.Execute.ConnectionTemplate.PostgresResolvedConnectionTemplate
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.Execute.ConnectionTemplate.PrimaryTag
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.Execute.ConnectionTemplate.QueryContext
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.Execute.ConnectionTemplate.ReadReplicasTag
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.Execute.ConnectionTemplate.RequestContext
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.Execute.ConnectionTemplate.RequestContextHeaders
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Execute.ConnectionTemplate.ConnectionSetMemberTemplateContext
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Execute.ConnectionTemplate.ConnectionSetTemplateContextType
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Execute.ConnectionTemplate.DefaultTag
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Execute.ConnectionTemplate.PostgresResolvedConnectionTemplate
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Execute.ConnectionTemplate.PrimaryTag
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Execute.ConnectionTemplate.ReadReplicasTag
instance GHC.Internal.Base.Monoid Hasura.Backends.Postgres.Execute.ConnectionTemplate.ConnectionSetTemplateContext
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Execute.ConnectionTemplate.ConnectionSetMemberTemplateContext
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Execute.ConnectionTemplate.ConnectionSetTemplateContextType
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Execute.ConnectionTemplate.DefaultTag
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Execute.ConnectionTemplate.PostgresResolvedConnectionTemplate
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Execute.ConnectionTemplate.PrimaryTag
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Execute.ConnectionTemplate.ReadReplicasTag
instance GHC.Internal.Base.Semigroup Hasura.Backends.Postgres.Execute.ConnectionTemplate.ConnectionSetTemplateContext
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Execute.ConnectionTemplate.ConnectionSetMemberTemplateContext
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Execute.ConnectionTemplate.ConnectionSetTemplateContext
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Execute.ConnectionTemplate.ConnectionSetTemplateContextType
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Execute.ConnectionTemplate.DefaultTag
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Execute.ConnectionTemplate.PostgresConnectionTemplateContext
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Execute.ConnectionTemplate.PostgresResolvedConnectionTemplate
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Execute.ConnectionTemplate.PrimaryTag
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Execute.ConnectionTemplate.QueryContext
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Execute.ConnectionTemplate.QueryOperationType
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Execute.ConnectionTemplate.ReadReplicasTag
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Execute.ConnectionTemplate.RequestContext
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Execute.ConnectionTemplate.RequestContextHeaders
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Execute.ConnectionTemplate.ConnectionSetMemberTemplateContext
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Execute.ConnectionTemplate.ConnectionSetTemplateContext
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Execute.ConnectionTemplate.ConnectionSetTemplateContextType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Execute.ConnectionTemplate.DefaultTag
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Execute.ConnectionTemplate.PostgresConnectionTemplateContext
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Execute.ConnectionTemplate.PostgresResolvedConnectionTemplate
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Execute.ConnectionTemplate.PrimaryTag
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Execute.ConnectionTemplate.QueryContext
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Execute.ConnectionTemplate.QueryOperationType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Execute.ConnectionTemplate.ReadReplicasTag
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Execute.ConnectionTemplate.RequestContext
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Execute.ConnectionTemplate.RequestContextHeaders


-- | Postgres Execute Types
--   
--   Execution context and source configuration for Postgres databases.
--   Provides support for things such as read-only transactions and read
--   replicas.
module Hasura.Backends.Postgres.Execute.Types
data PGExecCtx
PGExecCtx :: (PGExecCtxInfo -> RunTx) -> IO () -> (ServerReplicas -> IO SourceResizePoolSummary) -> PGExecCtx

-- | Run a PG transaction using the information provided by PGExecCtxInfo
[_pecRunTx] :: PGExecCtx -> PGExecCtxInfo -> RunTx

-- | Destroy connection pools
[_pecDestroyConnections] :: PGExecCtx -> IO ()

-- | Resize pools based on number of server instances and return the
--   summary
[_pecResizePools] :: PGExecCtx -> ServerReplicas -> IO SourceResizePoolSummary

-- | The level from where the transaction is being run
data PGExecFrom

-- | transaction initated via a GraphQLRequest
GraphQLQuery :: Maybe PostgresResolvedConnectionTemplate -> PGExecFrom

-- | transaction initiated during run_sql
RunSQLQuery :: PGExecFrom

-- | custom transaction Hasura runs on the database. This is usually used
--   in event_trigger and actions
InternalRawQuery :: PGExecFrom

-- | transactions initiated via other API's other than <tt>run_sql</tt> in
--   <i>v1</i>query or <i>v2</i>query
LegacyRQLQuery :: PGExecFrom

-- | Holds the information required to exceute a PG transaction
data PGExecCtxInfo
PGExecCtxInfo :: PGExecTxType -> PGExecFrom -> PGExecCtxInfo

-- | The tranasction mode for executing the transaction
[_peciTxType] :: PGExecCtxInfo -> PGExecTxType

-- | The level from where the PG transaction is being executed from
[_peciFrom] :: PGExecCtxInfo -> PGExecFrom

-- | The tranasction mode (isolation level, transaction access) for
--   executing the transaction
data PGExecTxType

-- | a transaction without an explicit tranasction block
NoTxRead :: PGExecTxType

-- | a transaction block with custom transaction access and isolation
--   level. Choose defaultIsolationLevel defined in
--   <tt>SourceConnConfiguration</tt> if <a>Nothing</a> is provided for
--   isolation level.
Tx :: TxAccess -> Maybe TxIsolation -> PGExecTxType

-- | Creates a Postgres execution context for a single Postgres master pool
mkPGExecCtx :: TxIsolation -> PGPool -> ResizePoolStrategy -> PGExecCtx

-- | Constructs a transaction error handler given a predicate that
--   determines which errors are expected and should be reported to the
--   user. All other errors are considered internal errors.
mkTxErrorHandler :: (PGErrorType -> Bool) -> PGTxErr -> QErr
defaultTxErrorHandler :: PGTxErr -> QErr

-- | Constructs a transaction error handler tailored for the needs of RQL's
--   DML.
dmlTxErrorHandler :: PGTxErr -> QErr

-- | Resize Postgres pool by setting the number of connections equal to
--   allowed maximum connections across all server instances divided by
--   number of instances
resizePostgresPool :: PGPool -> Int -> ServerReplicas -> IO ()

-- | Outcome of the connection template resolution
data PostgresResolvedConnectionTemplate
PCTODefault :: DefaultTag -> PostgresResolvedConnectionTemplate
PCTOPrimary :: PrimaryTag -> PostgresResolvedConnectionTemplate
PCTOReadReplicas :: ReadReplicasTag -> PostgresResolvedConnectionTemplate
PCTOConnectionSet :: PostgresConnectionSetMemberName -> PostgresResolvedConnectionTemplate
data PGSourceConfig
PGSourceConfig :: PGExecCtx -> ConnInfo -> Maybe (NonEmpty ConnInfo) -> IO () -> ExtensionsSchema -> HashMap PostgresConnectionSetMemberName ConnInfo -> ConnectionTemplateConfig -> PGSourceConfig
[_pscExecCtx] :: PGSourceConfig -> PGExecCtx
[_pscConnInfo] :: PGSourceConfig -> ConnInfo
[_pscReadReplicaConnInfos] :: PGSourceConfig -> Maybe (NonEmpty ConnInfo)
[_pscPostDropHook] :: PGSourceConfig -> IO ()
[_pscExtensionsSchema] :: PGSourceConfig -> ExtensionsSchema
[_pscConnectionSet] :: PGSourceConfig -> HashMap PostgresConnectionSetMemberName ConnInfo
[_pscConnectionTemplateConfig] :: PGSourceConfig -> ConnectionTemplateConfig
data ConnectionTemplateConfig

-- | Connection templates are disabled for Hasura CE
ConnTemplate_NotApplicable :: ConnectionTemplateConfig
ConnTemplate_NotConfigured :: ConnectionTemplateConfig
ConnTemplate_Resolver :: ValueExt -> ConnectionTemplateResolver -> ConnectionTemplateConfig
connectionTemplateConfigResolver :: ConnectionTemplateConfig -> Maybe ConnectionTemplateResolver

-- | A hook to resolve connection template
newtype ConnectionTemplateResolver
ConnectionTemplateResolver :: (forall (m :: Type -> Type). MonadError QErr m => SessionVariables -> [Header] -> Maybe QueryContext -> m PostgresResolvedConnectionTemplate) -> ConnectionTemplateResolver

-- | Runs the connection template resolver.
[_runResolver] :: ConnectionTemplateResolver -> forall (m :: Type -> Type). MonadError QErr m => SessionVariables -> [Header] -> Maybe QueryContext -> m PostgresResolvedConnectionTemplate
runPgSourceReadTx :: (MonadIO m, MonadBaseControl IO m) => PGSourceConfig -> TxET QErr m a -> m (Either QErr a)
runPgSourceWriteTx :: (MonadIO m, MonadBaseControl IO m) => PGSourceConfig -> PGExecFrom -> TxET QErr m a -> m (Either QErr a)

-- | Resolve connection templates only for non-admin roles
applyConnectionTemplateResolverNonAdmin :: MonadError QErr m => Maybe ConnectionTemplateResolver -> UserInfo -> [Header] -> Maybe QueryContext -> m (Maybe PostgresResolvedConnectionTemplate)
pgResolveConnectionTemplate :: MonadError QErr m => PGSourceConfig -> RequestContext -> Maybe ConnectionTemplate -> m EncJSON
resolvePostgresConnectionTemplate :: MonadError QErr m => ConnectionTemplate -> [PostgresConnectionSetMemberName] -> SessionVariables -> [Header] -> Maybe QueryContext -> m PostgresResolvedConnectionTemplate
sourceConfigNumReadReplicas :: PGSourceConfig -> Int
sourceConfigConnectonTemplate :: PGSourceConfig -> Maybe ValueExt
getPGColValues :: (MonadIO m, MonadError QErr m) => SessionVariables -> SourceName -> PGSourceConfig -> QualifiedTable -> (PGScalarType, PGCol) -> (PGCol, [RemoteRelSupportedOp RemoteRelSessionVariableORLiteralValue]) -> m [Text]
instance GHC.Classes.Eq Hasura.Backends.Postgres.Execute.Types.PGSourceConfig
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.Execute.Types.PGSourceConfig
instance Data.Has.Has () Hasura.Backends.Postgres.Execute.Types.PGSourceConfig
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Execute.Types.PGSourceConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Execute.Types.PGSourceConfig

module Hasura.ClientCredentials
data EEClientCredentials
EEClientCredentials :: EEClientId -> Text -> EEClientCredentials
[eccClientId] :: EEClientCredentials -> EEClientId
[eccClientSecret] :: EEClientCredentials -> Text
newtype EEClientId
EEClientId :: Text -> EEClientId
[_getEEClientId] :: EEClientId -> Text
getEEClientCredentialsTx :: TxE QErr (Maybe EEClientCredentials)
setEEClientCredentialsTx :: EEClientCredentials -> TxE QErr ()

module Hasura.Server.Version
data Version
VersionDev :: Text -> Version
VersionRelease :: Version -> Version
VersionCE :: Text -> Version
currentVersion :: Version

-- | A version-based string used to form the CDN URL for fetching console
--   assets.
consoleAssetsVersion :: Text
versionToAssetsVersion :: Version -> Text
instance GHC.Classes.Eq Hasura.Server.Version.Version
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Version.Version
instance Data.Text.Conversions.FromText Hasura.Server.Version.Version
instance GHC.Internal.Show.Show Hasura.Server.Version.Version
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Version.Version
instance Data.Text.Conversions.ToText Hasura.Server.Version.Version

module Hasura.HTTP
wreqOptions :: Manager -> [Header] -> Options
newtype HttpException
HttpException :: HttpException -> HttpException
[unHttpException] :: HttpException -> HttpException
hdrsToText :: [Header] -> [(Text, Text)]
textToHdrs :: [(Text, Text)] -> [Header]
addDefaultHeaders :: [Header] -> [Header]
defaultHeaders :: [Header]
data HttpResponse a
HttpResponse :: !a -> !ResponseHeaders -> HttpResponse a
[_hrBody] :: HttpResponse a -> !a
[_hrHeaders] :: HttpResponse a -> !ResponseHeaders
addHttpResponseHeaders :: ResponseHeaders -> HttpResponse a -> HttpResponse a
getHTTPExceptionStatus :: HttpException -> Maybe Int
serializeHTTPExceptionMessage :: HttpException -> Text
newtype ShowHeadersAndEnvVarInfo
ShowHeadersAndEnvVarInfo :: Bool -> ShowHeadersAndEnvVarInfo
[unShowHeadersAndEnvVarInfo] :: ShowHeadersAndEnvVarInfo -> Bool
serializeHTTPExceptionWithErrorMessage :: ShowHeadersAndEnvVarInfo -> HttpException -> Text
serializeHTTPExceptionMessageForDebugging :: HttpException -> Text
encodeHTTPRequestJSON :: Request -> Value
newtype ShowErrorInfo
ShowErrorInfo :: Bool -> ShowErrorInfo
[unShowErrorInfo] :: ShowErrorInfo -> Bool
getHttpExceptionJson :: ShowErrorInfo -> HttpException -> Value
serializeServantClientErrorMessage :: ClientError -> Text
serializeServantClientErrorMessageForDebugging :: ClientError -> Text
instance GHC.Classes.Eq Hasura.HTTP.ShowErrorInfo
instance GHC.Classes.Eq Hasura.HTTP.ShowHeadersAndEnvVarInfo
instance GHC.Internal.Data.Foldable.Foldable Hasura.HTTP.HttpResponse
instance GHC.Internal.Base.Functor Hasura.HTTP.HttpResponse
instance GHC.Internal.Show.Show Hasura.HTTP.HttpException
instance GHC.Internal.Show.Show Hasura.HTTP.ShowErrorInfo
instance GHC.Internal.Show.Show Hasura.HTTP.ShowHeadersAndEnvVarInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.HTTP.HttpException
instance GHC.Internal.Data.Traversable.Traversable Hasura.HTTP.HttpResponse


-- | Types for stored procedures.
module Hasura.StoredProcedure.Types

-- | A ScalarType that can be nullable with an optional description
data NullableScalarType (b :: BackendType)
NullableScalarType :: ScalarType b -> Bool -> Maybe Text -> NullableScalarType (b :: BackendType)
[nstType] :: NullableScalarType (b :: BackendType) -> ScalarType b
[nstNullable] :: NullableScalarType (b :: BackendType) -> Bool
[nstDescription] :: NullableScalarType (b :: BackendType) -> Maybe Text
nullableScalarTypeMapCodec :: forall (b :: BackendType). Backend b => Codec Value (InsOrdHashMap (Column b) (NullableScalarType b)) (InsOrdHashMap (Column b) (NullableScalarType b))

-- | Tracked stored procedure configuration, and payload of the
--   'pg_track_stored procedure'.
data StoredProcedureConfig
StoredProcedureConfig :: StoredProcedureExposedAs -> Maybe Name -> StoredProcedureConfig

-- | In which top-level field should we expose this stored procedure?
[_spcExposedAs] :: StoredProcedureConfig -> StoredProcedureExposedAs
[_spcCustomName] :: StoredProcedureConfig -> Maybe Name

-- | Indicates whether the user requested the corresponding stored
--   procedure to be tracked as a mutation or a query, in
--   <tt>track_stored_procedure</tt>. currently only query is supported.
data StoredProcedureExposedAs
SPEAQuery :: StoredProcedureExposedAs
instance GHC.Classes.Eq Hasura.StoredProcedure.Types.StoredProcedureConfig
instance GHC.Classes.Eq Hasura.StoredProcedure.Types.StoredProcedureExposedAs
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.StoredProcedure.Types.StoredProcedureConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.StoredProcedure.Types.StoredProcedureExposedAs
instance GHC.Internal.Generics.Generic Hasura.StoredProcedure.Types.StoredProcedureConfig
instance GHC.Internal.Generics.Generic Hasura.StoredProcedure.Types.StoredProcedureExposedAs
instance Autodocodec.Class.HasCodec Hasura.StoredProcedure.Types.StoredProcedureConfig
instance Autodocodec.Class.HasCodec Hasura.StoredProcedure.Types.StoredProcedureExposedAs
instance Control.DeepSeq.NFData Hasura.StoredProcedure.Types.StoredProcedureConfig
instance Control.DeepSeq.NFData Hasura.StoredProcedure.Types.StoredProcedureExposedAs
instance GHC.Internal.Show.Show Hasura.StoredProcedure.Types.StoredProcedureConfig
instance GHC.Internal.Show.Show Hasura.StoredProcedure.Types.StoredProcedureExposedAs
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.StoredProcedure.Types.StoredProcedureConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.StoredProcedure.Types.StoredProcedureExposedAs


-- | Metadata representation of a stored procedure in the metadata, as well
--   as a parser and prettyprinter for the query code.
module Hasura.StoredProcedure.Metadata

-- | The representation of stored procedures within the metadata structure.
data StoredProcedureMetadata (b :: BackendType)
StoredProcedureMetadata :: FunctionName b -> StoredProcedureConfig -> LogicalModelName -> HashMap ArgumentName (NullableScalarType b) -> Maybe Text -> StoredProcedureMetadata (b :: BackendType)
[_spmStoredProcedure] :: StoredProcedureMetadata (b :: BackendType) -> FunctionName b
[_spmConfig] :: StoredProcedureMetadata (b :: BackendType) -> StoredProcedureConfig
[_spmReturns] :: StoredProcedureMetadata (b :: BackendType) -> LogicalModelName
[_spmArguments] :: StoredProcedureMetadata (b :: BackendType) -> HashMap ArgumentName (NullableScalarType b)
[_spmDescription] :: StoredProcedureMetadata (b :: BackendType) -> Maybe Text
spmStoredProcedure :: forall (b :: BackendType) f. Functor f => (FunctionName b -> f (FunctionName b)) -> StoredProcedureMetadata b -> f (StoredProcedureMetadata b)
spmConfig :: forall (b :: BackendType) f. Functor f => (StoredProcedureConfig -> f StoredProcedureConfig) -> StoredProcedureMetadata b -> f (StoredProcedureMetadata b)
spmArguments :: forall (b :: BackendType) f. Functor f => (HashMap ArgumentName (NullableScalarType b) -> f (HashMap ArgumentName (NullableScalarType b))) -> StoredProcedureMetadata b -> f (StoredProcedureMetadata b)
spmDescription :: forall (b :: BackendType) f. Functor f => (Maybe Text -> f (Maybe Text)) -> StoredProcedureMetadata b -> f (StoredProcedureMetadata b)
spmReturns :: forall (b :: BackendType) f. Functor f => (LogicalModelName -> f LogicalModelName) -> StoredProcedureMetadata b -> f (StoredProcedureMetadata b)

-- | A name of an argument to a native query or stored procedure.
newtype ArgumentName
ArgumentName :: Text -> ArgumentName
[getArgumentName] :: ArgumentName -> Text

-- | A ScalarType that can be nullable with an optional description
data NullableScalarType (b :: BackendType)
NullableScalarType :: ScalarType b -> Bool -> Maybe Text -> NullableScalarType (b :: BackendType)
[nstType] :: NullableScalarType (b :: BackendType) -> ScalarType b
[nstNullable] :: NullableScalarType (b :: BackendType) -> Bool
[nstDescription] :: NullableScalarType (b :: BackendType) -> Maybe Text
nullableScalarTypeMapCodec :: forall (b :: BackendType). Backend b => Codec Value (InsOrdHashMap (Column b) (NullableScalarType b)) (InsOrdHashMap (Column b) (NullableScalarType b))

-- | Tracked stored procedure configuration, and payload of the
--   'pg_track_stored procedure'.
data StoredProcedureConfig
StoredProcedureConfig :: StoredProcedureExposedAs -> Maybe Name -> StoredProcedureConfig

-- | In which top-level field should we expose this stored procedure?
[_spcExposedAs] :: StoredProcedureConfig -> StoredProcedureExposedAs
[_spcCustomName] :: StoredProcedureConfig -> Maybe Name
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.StoredProcedure.Metadata.StoredProcedureMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.StoredProcedure.Metadata.StoredProcedureMetadata b)
instance GHC.Internal.Generics.Generic (Hasura.StoredProcedure.Metadata.StoredProcedureMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.StoredProcedure.Metadata.StoredProcedureMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.StoredProcedure.Metadata.StoredProcedureMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.StoredProcedure.Metadata.StoredProcedureMetadata b)


-- | The RQL IR representation of an invocation of a stored procedure.
module Hasura.StoredProcedure.IR

-- | The RQL IR representation of an invocation of a stored procedure.
data StoredProcedure (b :: BackendType) field
StoredProcedure :: FunctionName b -> Name -> HashMap ArgumentName (ScalarType b, field) -> LogicalModel b -> StoredProcedure (b :: BackendType) field

-- | The SQL name of the stored procedure.
[spStoredProcedure] :: StoredProcedure (b :: BackendType) field -> FunctionName b

-- | The graphql name of the stored procedure.
[spGraphqlName] :: StoredProcedure (b :: BackendType) field -> Name

-- | The arguments passed to the query, if any.
[spArgs] :: StoredProcedure (b :: BackendType) field -> HashMap ArgumentName (ScalarType b, field)

-- | The return type of the stored procedure
[spLogicalModel] :: StoredProcedure (b :: BackendType) field -> LogicalModel b
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq field) => GHC.Classes.Eq (Hasura.StoredProcedure.IR.StoredProcedure b field)
instance GHC.Internal.Data.Foldable.Foldable (Hasura.StoredProcedure.IR.StoredProcedure b)
instance GHC.Internal.Base.Functor (Hasura.StoredProcedure.IR.StoredProcedure b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show field) => GHC.Internal.Show.Show (Hasura.StoredProcedure.IR.StoredProcedure b field)
instance GHC.Internal.Data.Traversable.Traversable (Hasura.StoredProcedure.IR.StoredProcedure b)


-- | More leaves peeled from <a>Select</a> for compilation speed
module Hasura.RQL.IR.Select.From

-- | Identifier used exclusively as the argument to <a>FromIdentifier</a>
newtype FIIdentifier
FIIdentifier :: Text -> FIIdentifier
[unFIIdentifier] :: FIIdentifier -> Text
type SelectFrom (b :: BackendType) = SelectFromG b SQLExpression b
data SelectFromG (b :: BackendType) v
FromTable :: TableName b -> SelectFromG (b :: BackendType) v
FromIdentifier :: FIIdentifier -> SelectFromG (b :: BackendType) v
FromFunction :: FunctionName b -> FunctionArgsExp b v -> Maybe [(Column b, ScalarType b)] -> SelectFromG (b :: BackendType) v
FromNativeQuery :: NativeQuery b v -> SelectFromG (b :: BackendType) v
FromStoredProcedure :: StoredProcedure b v -> SelectFromG (b :: BackendType) v
instance GHC.Classes.Eq Hasura.RQL.IR.Select.From.FIIdentifier
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq v, GHC.Classes.Eq (Hasura.RQL.Types.Backend.FunctionArgumentExp b v), GHC.Classes.Eq (Hasura.NativeQuery.IR.NativeQuery b v), GHC.Classes.Eq (Hasura.StoredProcedure.IR.StoredProcedure b v)) => GHC.Classes.Eq (Hasura.RQL.IR.Select.From.SelectFromG b v)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.Select.From.SelectFromG b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Base.Functor (Hasura.RQL.IR.Select.From.SelectFromG b)
instance GHC.Internal.Generics.Generic Hasura.RQL.IR.Select.From.FIIdentifier
instance GHC.Internal.Generics.Generic (Hasura.RQL.IR.Select.From.SelectFromG b v)
instance Data.Hashable.Class.Hashable Hasura.RQL.IR.Select.From.FIIdentifier
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable v, Data.Hashable.Class.Hashable (Hasura.RQL.Types.Backend.FunctionArgumentExp b v), Data.Hashable.Class.Hashable (Hasura.NativeQuery.IR.NativeQuery b v), Data.Hashable.Class.Hashable (Hasura.StoredProcedure.IR.StoredProcedure b v)) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.Select.From.SelectFromG b v)
instance Hasura.Backends.Postgres.SQL.Types.IsIdentifier Hasura.RQL.IR.Select.From.FIIdentifier
instance GHC.Internal.Show.Show Hasura.RQL.IR.Select.From.FIIdentifier
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show v, GHC.Internal.Show.Show (Hasura.RQL.Types.Backend.FunctionArgumentExp b v), GHC.Internal.Show.Show (Hasura.NativeQuery.IR.NativeQuery b v), GHC.Internal.Show.Show (Hasura.StoredProcedure.IR.StoredProcedure b v)) => GHC.Internal.Show.Show (Hasura.RQL.IR.Select.From.SelectFromG b v)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.Select.From.SelectFromG b)


-- | More leaves from <a>Select</a>
module Hasura.RQL.IR.Select.AnnSelectG
data AnnSelectG (b :: BackendType) (f :: Type -> Type) v
AnnSelectG :: Fields (f v) -> SelectFromG b v -> TablePermG b v -> SelectArgsG b v -> StringifyNumbers -> Maybe NamingCase -> AnnSelectG (b :: BackendType) (f :: Type -> Type) v
[_asnFields] :: AnnSelectG (b :: BackendType) (f :: Type -> Type) v -> Fields (f v)
[_asnFrom] :: AnnSelectG (b :: BackendType) (f :: Type -> Type) v -> SelectFromG b v
[_asnPerm] :: AnnSelectG (b :: BackendType) (f :: Type -> Type) v -> TablePermG b v
[_asnArgs] :: AnnSelectG (b :: BackendType) (f :: Type -> Type) v -> SelectArgsG b v
[_asnStrfyNum] :: AnnSelectG (b :: BackendType) (f :: Type -> Type) v -> StringifyNumbers
[_asnNamingConvention] :: AnnSelectG (b :: BackendType) (f :: Type -> Type) v -> Maybe NamingCase

-- | IR type representing nodes for streaming subscriptions
data AnnSelectStreamG (b :: BackendType) (f :: Type -> Type) v
AnnSelectStreamG :: XStreamingSubscription b -> Fields (f v) -> SelectFromG b v -> TablePermG b v -> SelectStreamArgsG b v -> StringifyNumbers -> AnnSelectStreamG (b :: BackendType) (f :: Type -> Type) v

-- | type to indicate if streaming subscription has been enabled in the
--   <a>BackendType</a>. This type helps avoiding missing case match
--   patterns for backends where it's disabled.
[_assnXStreamingSubscription] :: AnnSelectStreamG (b :: BackendType) (f :: Type -> Type) v -> XStreamingSubscription b

-- | output selection fields
[_assnFields] :: AnnSelectStreamG (b :: BackendType) (f :: Type -> Type) v -> Fields (f v)

-- | table information to select from
[_assnFrom] :: AnnSelectStreamG (b :: BackendType) (f :: Type -> Type) v -> SelectFromG b v

-- | select permissions
[_assnPerm] :: AnnSelectStreamG (b :: BackendType) (f :: Type -> Type) v -> TablePermG b v

-- | streaming arguments
[_assnArgs] :: AnnSelectStreamG (b :: BackendType) (f :: Type -> Type) v -> SelectStreamArgsG b v
[_assnStrfyNum] :: AnnSelectStreamG (b :: BackendType) (f :: Type -> Type) v -> StringifyNumbers
bifoldMapAnnSelectStreamG :: forall (b :: BackendType) (f :: BackendType -> Type -> Type -> Type) m r v. (Backend b, Bifoldable (f b), Monoid m) => (r -> m) -> (v -> m) -> AnnSelectStreamG b (f b r) v -> m

-- | We can't write a Bifoldable instance for AnnSelectG because the types
--   don't line up. Instead, we provide this function which can be used to
--   help define Bifoldable instances of other types containing AnnSelectG
--   values.
bifoldMapAnnSelectG :: forall (b :: BackendType) (f :: BackendType -> Type -> Type -> Type) m r v. (Backend b, Bifoldable (f b), Monoid m) => (r -> m) -> (v -> m) -> AnnSelectG b (f b r) v -> m
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (f v), GHC.Classes.Eq v) => GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnSelectG.AnnSelectG b f v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq v, GHC.Classes.Eq (f v)) => GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnSelectG.AnnSelectStreamG b f v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Data.Foldable.Foldable f) => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.Select.AnnSelectG.AnnSelectG b f)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Data.Foldable.Foldable f) => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.Select.AnnSelectG.AnnSelectStreamG b f)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Base.Functor f) => GHC.Internal.Base.Functor (Hasura.RQL.IR.Select.AnnSelectG.AnnSelectG b f)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Base.Functor f) => GHC.Internal.Base.Functor (Hasura.RQL.IR.Select.AnnSelectG.AnnSelectStreamG b f)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show (f v), GHC.Internal.Show.Show v) => GHC.Internal.Show.Show (Hasura.RQL.IR.Select.AnnSelectG.AnnSelectG b f v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show v, GHC.Internal.Show.Show (f v)) => GHC.Internal.Show.Show (Hasura.RQL.IR.Select.AnnSelectG.AnnSelectStreamG b f v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Data.Traversable.Traversable f) => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.Select.AnnSelectG.AnnSelectG b f)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Data.Traversable.Traversable f) => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.Select.AnnSelectG.AnnSelectStreamG b f)

module Hasura.Tracing.Sampling

-- | B3 propagation sampling state.
--   
--   Debug sampling state not represented.
data SamplingState
SamplingDefer :: SamplingState
SamplingDeny :: SamplingState
SamplingAccept :: SamplingState

-- | Convert a sampling state to a value for the X-B3-Sampled header. A
--   return value of Nothing indicates that the header should not be set.
samplingStateToHeader :: IsString s => SamplingState -> Maybe s

-- | Convert a X-B3-Sampled header value to a sampling state. An input of
--   Nothing indicates that the header was not set.
samplingStateFromHeader :: (IsString s, Eq s) => Maybe s -> SamplingState

-- | A local decision about whether or not to sample spans.
data SamplingDecision
SampleNever :: SamplingDecision
SampleAlways :: SamplingDecision

-- | An IO action for deciding whether or not to sample a trace.
--   
--   Currently restricted to deny access to the B3 sampling state, but we
--   may want to be more flexible in the future.
type SamplingPolicy = IO SamplingDecision
sampleNever :: SamplingPolicy
sampleAlways :: SamplingPolicy
sampleRandomly :: Double -> SamplingPolicy
sampleOneInN :: Refined Positive Int -> SamplingPolicy
instance GHC.Classes.Eq Hasura.Tracing.Sampling.SamplingState
instance GHC.Internal.Show.Show Hasura.Tracing.Sampling.SamplingState

module Hasura.Tracing.TraceId

-- | 128-bit trace identifiers.
--   
--   <a>TraceId</a>s are guaranteed to have at least one non-zero bit.
data TraceId
randomTraceId :: MonadIO m => m TraceId

-- | Create a <a>TraceId</a> from a <a>ByteString</a>.
--   
--   Fails if the <a>ByteString</a> is not exactly 16 bytes long, or if it
--   contains only zero bytes.
traceIdFromBytes :: ByteString -> Maybe TraceId

-- | Convert a <a>TraceId</a> to a <a>ByteString</a> of 16 bytes.
traceIdToBytes :: TraceId -> ByteString

-- | Parse a <a>TraceId</a> from the standard ASCII-encoded hex string
--   format.
--   
--   Fails if the <a>ByteString</a> is not exactly 32 characters long, or
--   if it contains only zero characters.
traceIdFromHex :: ByteString -> Maybe TraceId

-- | Serialize a <a>TraceId</a> to the standard ASCII-encoded hex
--   representation.
traceIdToHex :: TraceId -> ByteString

-- | 64-bit span identifiers
--   
--   <a>SpanId</a>s are guaranteed to have at least one non-zero bit.
data SpanId
randomSpanId :: MonadIO m => m SpanId

-- | Create a <a>SpanId</a> from a <a>ByteString</a>.
--   
--   Fails if the <a>ByteString</a> is not exactly 8 bytes long, or if it
--   contains only zero bytes.
spanIdFromBytes :: ByteString -> Maybe SpanId

-- | Convert a <a>SpanId</a> to a <a>ByteString</a> of 8 bytes.
spanIdToBytes :: SpanId -> ByteString

-- | Parse a <a>SpanId</a> from the standard ASCII-encoded hex string
--   format.
--   
--   Fails if the <a>ByteString</a> is not exactly 16 characters long, or
--   if it contains only zero characters.
spanIdFromHex :: ByteString -> Maybe SpanId

-- | Serialize a <a>SpanId</a> to the standard ASCII-encoded hex
--   representation.
spanIdToHex :: SpanId -> ByteString
instance GHC.Classes.Eq Hasura.Tracing.TraceId.SpanId
instance GHC.Classes.Eq Hasura.Tracing.TraceId.TraceId
instance GHC.Internal.Show.Show Hasura.Tracing.TraceId.SpanId
instance GHC.Internal.Show.Show Hasura.Tracing.TraceId.TraceId
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Tracing.TraceId.SpanId
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Tracing.TraceId.TraceId

module Hasura.Tracing.TraceState

-- | Data structure compliant with the storage and serialization needs of
--   the W3C tracestate header.
--   <a>https://www.w3.org/TR/trace-context/#tracestate-header</a>
data TraceState
newtype Key
Key :: Text -> Key
newtype Value
Value :: Text -> Value

-- | An empty <a>TraceState</a> key-value pair dictionary
emptyTraceState :: TraceState

-- | Convert the <a>TraceState</a> to a list.
toTraceStateList :: TraceState -> [(Key, Value)]
decodeTraceStateHeader :: ByteString -> Maybe TraceState
instance GHC.Classes.Eq Hasura.Tracing.TraceState.Key
instance GHC.Classes.Eq Hasura.Tracing.TraceState.TraceState
instance GHC.Classes.Eq Hasura.Tracing.TraceState.Value
instance GHC.Classes.Ord Hasura.Tracing.TraceState.Key
instance GHC.Classes.Ord Hasura.Tracing.TraceState.TraceState
instance GHC.Classes.Ord Hasura.Tracing.TraceState.Value
instance GHC.Internal.Show.Show Hasura.Tracing.TraceState.Key
instance GHC.Internal.Show.Show Hasura.Tracing.TraceState.TraceState
instance GHC.Internal.Show.Show Hasura.Tracing.TraceState.Value

module Hasura.Tracing.Context

-- | A trace context records the current active trace, the active span
--   within that trace, and the span's parent, unless the current span is
--   the root. This is like a call stack.
data TraceContext
TraceContext :: TraceId -> SpanId -> Maybe SpanId -> SamplingState -> TraceState -> TraceContext
[tcCurrentTrace] :: TraceContext -> TraceId
[tcCurrentSpan] :: TraceContext -> SpanId
[tcCurrentParent] :: TraceContext -> Maybe SpanId
[tcSamplingState] :: TraceContext -> SamplingState
[tcStateState] :: TraceContext -> TraceState

-- | Any additional human-readable key-value pairs relevant to the
--   execution of a span.
--   
--   When the Open Telemetry exporter is in use these become attributes.
--   Where possible and appropriate, consider using key names from the
--   documented OT semantic conventions here:
--   <a>https://opentelemetry.io/docs/reference/specification/trace/semantic_conventions/</a>
--   This can serve to document the metadata, even for users not using open
--   telemetry.
--   
--   We may make this type more closely align with the OT data model in the
--   future (e.g. supporting int, etc)
type TraceMetadata = [(Text, Text)]
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Tracing.Context.TraceContext

module Hasura.Tracing.Reporter
newtype Reporter
Reporter :: (forall (m :: Type -> Type) a. (MonadIO m, MonadBaseControl IO m) => TraceContext -> Text -> IO TraceMetadata -> m a -> m a) -> Reporter
[runReporter] :: Reporter -> forall (m :: Type -> Type) a. (MonadIO m, MonadBaseControl IO m) => TraceContext -> Text -> IO TraceMetadata -> m a -> m a
noReporter :: Reporter

module Hasura.Tracing.Propagator

-- | A carrier is the medium used by Propagators to read values from and
--   write values to. Each specific Propagator type defines its expected
--   carrier type, such as a string map or a byte array.
data Propagator inboundCarrier outboundCarrier
Propagator :: (inboundCarrier -> SpanId -> Maybe TraceContext) -> (TraceContext -> outboundCarrier -> outboundCarrier) -> Propagator inboundCarrier outboundCarrier
[extractor] :: Propagator inboundCarrier outboundCarrier -> inboundCarrier -> SpanId -> Maybe TraceContext
[injector] :: Propagator inboundCarrier outboundCarrier -> TraceContext -> outboundCarrier -> outboundCarrier
type HttpPropagator = Propagator RequestHeaders ResponseHeaders

-- | Extracts the value from an incoming request. For example, from the
--   headers of an HTTP request.
--   
--   If a value can not be parsed from the carrier, for a cross-cutting
--   concern, the implementation MUST NOT throw an exception and MUST NOT
--   store a new value in the Context, in order to preserve any previously
--   existing valid value.
extract :: MonadIO m => Propagator i o -> i -> m TraceContext

-- | Injects the value into a carrier. For example, into the headers of an
--   HTTP request.
inject :: Propagator i o -> TraceContext -> o -> o
instance GHC.Internal.Base.Semigroup o => GHC.Internal.Base.Monoid (Hasura.Tracing.Propagator.Propagator i o)
instance GHC.Internal.Base.Semigroup o => GHC.Internal.Base.Semigroup (Hasura.Tracing.Propagator.Propagator i o)


-- | This module provides support for tracing context propagation in
--   accordance with the W3C tracing context propagation specifications:
--   <a>https://www.w3.org/TR/trace-context/</a>
module Hasura.Tracing.Propagator.W3CTraceContext

-- | Propagate trace context information via headers using the w3c
--   specification format
w3cTraceContextPropagator :: Propagator RequestHeaders ResponseHeaders
instance GHC.Classes.Eq Hasura.Tracing.Propagator.W3CTraceContext.TraceFlags
instance GHC.Classes.Ord Hasura.Tracing.Propagator.W3CTraceContext.TraceFlags
instance GHC.Internal.Show.Show Hasura.Tracing.Propagator.W3CTraceContext.TraceFlags
instance GHC.Internal.Show.Show Hasura.Tracing.Propagator.W3CTraceContext.TraceParent


-- | B3 Propagation is a specification for the header "b3" and those that
--   start with "x-b3-". These headers are used for trace context
--   propagation across service boundaries.
--   <a>https://github.com/openzipkin/b3-propagation</a>
--   <a>https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/context/api-propagators.md#b3-requirements</a>
module Hasura.Tracing.Propagator.B3
b3TraceContextPropagator :: Propagator RequestHeaders ResponseHeaders


-- | Defines the Tracing API.
--   
--   The <a>MonadTrace</a> class defines the "public API" of this
--   component.
module Hasura.Tracing.Class
class MonadTraceContext m => MonadTrace (m :: Type -> Type)

-- | Trace the execution of a block of code, attaching a human-readable
--   name. This starts a new trace and its corresponding root span, to
--   which subsequent spans will be attached.
newTraceWith :: MonadTrace m => TraceContext -> SamplingPolicy -> Text -> m a -> m a

-- | Starts a new span within the current trace. No-op if there's no
--   current trace.
--   
--   TODO: we could rewrite this to start a new trace if there isn't one,
--   using the default reporter and policy? This would guarantee that no
--   span is ever lost, but would also risk reporting undesired spans.
newSpanWith :: MonadTrace m => SpanId -> Text -> m a -> m a

-- | Log some arbitrary metadata to be attached to the current span, if
--   any.
attachMetadata :: MonadTrace m => TraceMetadata -> m ()

-- | Access to the current tracing context, factored out of
--   <a>MonadTrace</a> so we can use it separately and dispatch the
--   constraint in cases outside of a MonadTrace context.
class Monad m => MonadTraceContext (m :: Type -> Type)

-- | Ask for the current tracing context, so that we can provide it to any
--   downstream services, e.g. in HTTP headers. Returns <a>Nothing</a> if
--   we're not currently tracing anything.
currentContext :: MonadTraceContext m => m (Maybe TraceContext)

-- | Provide an empty <a>TraceContext</a> where we aren't in a
--   <a>MonadTrace</a> context.
runNoMonadTraceContext :: NoMonadTraceContext f a -> f a

-- | Create a new trace using a randomly-generated context.
newTrace :: (MonadIO m, MonadTrace m) => SamplingPolicy -> Text -> m a -> m a

-- | Create a new span with a randomly-generated id.
newSpan :: (MonadIO m, MonadTrace m) => Text -> m a -> m a
instance GHC.Internal.Base.Applicative f => GHC.Internal.Base.Applicative (Hasura.Tracing.Class.NoMonadTraceContext f)
instance GHC.Internal.Base.Functor f => GHC.Internal.Base.Functor (Hasura.Tracing.Class.NoMonadTraceContext f)
instance Control.Monad.IO.Class.MonadIO f => Control.Monad.IO.Class.MonadIO (Hasura.Tracing.Class.NoMonadTraceContext f)
instance GHC.Internal.Base.Monad f => GHC.Internal.Base.Monad (Hasura.Tracing.Class.NoMonadTraceContext f)
instance Hasura.Tracing.Class.MonadTraceContext m => Hasura.Tracing.Class.MonadTraceContext (Control.Monad.Trans.Except.ExceptT e m)
instance Hasura.Tracing.Class.MonadTraceContext m => Hasura.Tracing.Class.MonadTraceContext (Control.Monad.Trans.Maybe.MaybeT m)
instance GHC.Internal.Base.Monad m => Hasura.Tracing.Class.MonadTraceContext (Hasura.Tracing.Class.NoMonadTraceContext m)
instance Hasura.Tracing.Class.MonadTraceContext m => Hasura.Tracing.Class.MonadTraceContext (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.Tracing.Class.MonadTraceContext m => Hasura.Tracing.Class.MonadTraceContext (Control.Monad.Trans.State.Strict.StateT e m)
instance Hasura.Tracing.Class.MonadTrace m => Hasura.Tracing.Class.MonadTrace (Control.Monad.Trans.Except.ExceptT e m)
instance Hasura.Tracing.Class.MonadTrace m => Hasura.Tracing.Class.MonadTrace (Control.Monad.Trans.Maybe.MaybeT m)
instance Hasura.Tracing.Class.MonadTrace m => Hasura.Tracing.Class.MonadTrace (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.Tracing.Class.MonadTrace m => Hasura.Tracing.Class.MonadTrace (Control.Monad.Trans.State.Strict.StateT e m)

module Hasura.Tracing.Monad

-- | TraceT is the standard implementation of <a>MonadTrace</a>. Via a
--   <a>Reader</a>, it keeps track of the default policy and reporter to
--   use thoughout the stack, as well as the current trace.
newtype TraceT (m :: Type -> Type) a
TraceT :: ReaderT (Reporter, Maybe TraceEnv) m a -> TraceT (m :: Type -> Type) a

-- | Runs the <a>TraceT</a> monad, by providing the default reporter. This
--   does NOT start a trace.
--   
--   TODO: we could change this to always start a trace with a default
--   name? This would allow us to guarantee that there is always a current
--   trace, but this might not always be the correct behaviour: in
--   practice, we would end up generating one that spans the entire
--   lifetime of the engine if <a>runTraceT</a> were to be used from
--   <tt>main</tt>.
runTraceT :: Reporter -> TraceT m a -> m a

-- | Run the <a>TraceT</a> monad, but without actually tracing anything: no
--   report will be emitted, even if calls to <a>newTraceWith</a> force the
--   trace to be sampled.
ignoreTraceT :: TraceT m a -> m a
instance GHC.Internal.Base.Applicative m => GHC.Internal.Base.Applicative (Hasura.Tracing.Monad.TraceT m)
instance GHC.Internal.Base.Functor m => GHC.Internal.Base.Functor (Hasura.Tracing.Monad.TraceT m)
instance Control.Monad.Trans.Control.MonadBaseControl b m => Control.Monad.Trans.Control.MonadBaseControl b (Hasura.Tracing.Monad.TraceT m)
instance Control.Monad.Base.MonadBase b m => Control.Monad.Base.MonadBase b (Hasura.Tracing.Monad.TraceT m)
instance Control.Monad.Catch.MonadCatch m => Control.Monad.Catch.MonadCatch (Hasura.Tracing.Monad.TraceT m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Hasura.Tracing.Monad.TraceT m)
instance GHC.Internal.Control.Monad.Fail.MonadFail m => GHC.Internal.Control.Monad.Fail.MonadFail (Hasura.Tracing.Monad.TraceT m)
instance GHC.Internal.Control.Monad.Fix.MonadFix m => GHC.Internal.Control.Monad.Fix.MonadFix (Hasura.Tracing.Monad.TraceT m)
instance Hasura.Server.Types.MonadGetPolicies m => Hasura.Server.Types.MonadGetPolicies (Hasura.Tracing.Monad.TraceT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Hasura.Tracing.Monad.TraceT m)
instance Control.Monad.Catch.MonadMask m => Control.Monad.Catch.MonadMask (Hasura.Tracing.Monad.TraceT m)
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (Hasura.Tracing.Monad.TraceT m)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (Hasura.Tracing.Monad.TraceT m)
instance Control.Monad.Catch.MonadThrow m => Control.Monad.Catch.MonadThrow (Hasura.Tracing.Monad.TraceT m)
instance (Control.Monad.IO.Class.MonadIO m, Control.Monad.Trans.Control.MonadBaseControl GHC.Types.IO m) => Hasura.Tracing.Class.MonadTraceContext (Hasura.Tracing.Monad.TraceT m)
instance GHC.Internal.Base.Monad m => GHC.Internal.Base.Monad (Hasura.Tracing.Monad.TraceT m)
instance (Control.Monad.IO.Class.MonadIO m, Control.Monad.Trans.Control.MonadBaseControl GHC.Types.IO m) => Hasura.Tracing.Class.MonadTrace (Hasura.Tracing.Monad.TraceT m)
instance Control.Monad.Trans.Class.MonadTrans Hasura.Tracing.Monad.TraceT
instance Hasura.Authentication.User.UserInfoM m => Hasura.Authentication.User.UserInfoM (Hasura.Tracing.Monad.TraceT m)

module Hasura.Logging
data LoggerSettings
LoggerSettings :: !Bool -> !Maybe TimeZone -> !LogLevel -> LoggerSettings

-- | should current time be cached (refreshed every sec)
[_lsCachedTimestamp] :: LoggerSettings -> !Bool
[_lsTimeZone] :: LoggerSettings -> !Maybe TimeZone
[_lsLevel] :: LoggerSettings -> !LogLevel
defaultLoggerSettings :: Bool -> LogLevel -> LoggerSettings

-- | A family of EngineLogType types
data family EngineLogType impl
data Hasura
data InternalLogTypes

-- | mostly for debug logs - see <tt>debugT</tt>, <tt>debugBS</tt> and
--   <tt>debugLBS</tt> functions
ILTUnstructured :: InternalLogTypes
ILTUnhandledInternalError :: InternalLogTypes
ILTEventTrigger :: InternalLogTypes
ILTEventTriggerProcess :: InternalLogTypes
ILTScheduledTrigger :: InternalLogTypes
ILTScheduledTriggerProcess :: InternalLogTypes
ILTCronEventGeneratorProcess :: InternalLogTypes

-- | internal logs for the websocket server
ILTWsServer :: InternalLogTypes
ILTPgClient :: InternalLogTypes

-- | log type for logging metadata related actions; currently used in
--   logging inconsistent metadata
ILTMetadata :: InternalLogTypes
ILTTelemetry :: InternalLogTypes
ILTSchemaSync :: InternalLogTypes
ILTSourceCatalogMigration :: InternalLogTypes
ILTStoredIntrospection :: InternalLogTypes
ILTStoredIntrospectionStorage :: InternalLogTypes
ILTModelInfo :: InternalLogTypes

-- | This is the top-level log type emitted for OSS and on-prem enterprise.
--   It is built from the output of <a>toEngineLog</a>
data EngineLog impl
EngineLog :: !FormattedTime -> !LogLevel -> !EngineLogType impl -> !Value -> !Maybe TraceId -> !Maybe SpanId -> EngineLog impl
[_elTimestamp] :: EngineLog impl -> !FormattedTime
[_elLevel] :: EngineLog impl -> !LogLevel
[_elType] :: EngineLog impl -> !EngineLogType impl
[_elDetail] :: EngineLog impl -> !Value

-- | The trace context in which this log message was emitted, if any. See
--   <a>unLoggerTracing</a>.
[_elTraceId] :: EngineLog impl -> !Maybe TraceId

-- | The span context in which this log message was emitted, if any. See
--   <a>unLoggerTracing</a>.
[_elSpanId] :: EngineLog impl -> !Maybe SpanId

-- | A zoned timestamp with defined serialized format (via the ToJSON
--   instance)
--   
--   Internals not exported. Construct with <a>getFormattedTime</a>
data FormattedTime

-- | Timestamp as uniz epoch time, in nanoseconds.
toPOSIX_ns :: FormattedTime -> Word64
userAllowedLogTypes :: [EngineLogType Hasura]

-- | Typeclass representing any data type that can be converted to
--   <tt>EngineLog</tt> for the purpose of logging
class EnabledLogTypes impl => ToEngineLog a impl
toEngineLog :: ToEngineLog a impl => a -> (LogLevel, EngineLogType impl, Value)
debugT :: Text -> UnstructuredLog
debugBS :: ByteString -> UnstructuredLog
debugLBS :: ByteString -> UnstructuredLog
data UnstructuredLog
UnstructuredLog :: !LogLevel -> !SerializableBlob -> UnstructuredLog
[_ulLevel] :: UnstructuredLog -> !LogLevel
[_ulPayload] :: UnstructuredLog -> !SerializableBlob

-- | A callback capable of actually emitting a log line (e.g. to stdout).
--   If not in a <tt>MonadTrace</tt> context you can make use of the old
--   API via <a>Logger</a> and <a>unLogger</a>.
newtype Logger impl
LoggerTracing :: (forall a (m :: Type -> Type). (ToEngineLog a impl, MonadTraceContext m, MonadIO m) => a -> m ()) -> Logger impl
[unLoggerTracing] :: Logger impl -> forall a (m :: Type -> Type). (ToEngineLog a impl, MonadTraceContext m, MonadIO m) => a -> m ()

-- | This is kept for compatibility with the old interface, which didn't
--   require a <tt>MonadTraceContext</tt> environment
pattern Logger :: (forall a (m :: Type -> Type). (ToEngineLog a impl, MonadIO m) => a -> m ()) -> Logger impl
data LogLevel
LevelDebug :: LogLevel
LevelInfo :: LogLevel
LevelWarn :: LogLevel
LevelError :: LogLevel
LevelOther :: Text -> LogLevel

-- | Human-readable LogLevel, as serialized for end-users
prettyLogLevel :: LogLevel -> Text

-- | We expect situations where there are code paths that should not occur
--   and we throw an <a>error</a> on this code paths. If our assumptions
--   are incorrect and infact these errors do occur, we want to log them.
newtype UnhandledInternalErrorLog
UnhandledInternalErrorLog :: ErrorCall -> UnhandledInternalErrorLog
mkLogger :: ToJSON (EngineLogType impl) => LoggerCtx impl -> Logger impl
nullLogger :: Logger Hasura

-- | Abstract. Constructed with <a>mkLoggerCtx</a>.
data LoggerCtx impl
getLoggerSet :: LoggerCtx impl -> LoggerSet
getTimeGetter :: LoggerCtx impl -> IO FormattedTime
getLogLevel :: LoggerCtx impl -> LogLevel
getEnabledLogTypes :: LoggerCtx impl -> HashSet (EngineLogType impl)
getLogsExporter :: LoggerCtx impl -> IO (EngineLog impl -> IO ())

-- | <a>mkLoggerCtxOTLP</a> but with no otlp log shipping, for
--   compatibility
mkLoggerCtx :: forall (io :: Type -> Type) impl. (MonadIO io, MonadBaseControl IO io) => LoggerSettings -> HashSet (EngineLogType impl) -> ManagedT io (LoggerCtx impl)

-- | Creates a new <a>LoggerCtx</a>, optionally fanning out to an OTLP
--   endpoint (while enabled) as well.
--   
--   The underlying <tt>LoggerSet</tt> is bound to the <a>ManagedT</a>
--   context: when it exits, the log will be flushed and cleared regardless
--   of whether it was exited properly or not (<a>ManagedT</a> uses
--   <tt>bracket</tt> underneath). This guarantees that the logs will
--   always be flushed, even in case of error, avoiding a repeat of
--   <a>https://github.com/hasura/graphql-engine/issues/4772</a>.
mkLoggerCtxOTLP :: forall (io :: Type -> Type) impl. (MonadIO io, MonadBaseControl IO io) => IO (EngineLog impl -> IO ()) -> LoggerSettings -> HashSet (EngineLogType impl) -> ManagedT io (LoggerCtx impl)
cleanLoggerCtx :: LoggerCtx a -> IO ()
eventTriggerLogType :: EngineLogType Hasura
eventTriggerProcessLogType :: EngineLogType Hasura
scheduledTriggerLogType :: EngineLogType Hasura
scheduledTriggerProcessLogType :: EngineLogType Hasura
cronEventGeneratorProcessType :: EngineLogType Hasura
sourceCatalogMigrationLogType :: EngineLogType Hasura

-- | Typeclass representing any type which can be parsed into a list of
--   enabled log types, and has a <tt>Set</tt> of default enabled log
--   types, and can find out if a log type is enabled
class (Eq EngineLogType impl, Hashable EngineLogType impl) => EnabledLogTypes impl
parseEnabledLogTypes :: EnabledLogTypes impl => String -> Either String [EngineLogType impl]
defaultEnabledLogTypes :: EnabledLogTypes impl => HashSet (EngineLogType impl)
isLogTypeEnabled :: EnabledLogTypes impl => HashSet (EngineLogType impl) -> EngineLogType impl -> Bool
defaultEnabledEngineLogTypes :: HashSet (EngineLogType Hasura)
isEngineLogTypeEnabled :: HashSet (EngineLogType Hasura) -> EngineLogType Hasura -> Bool
readLogTypes :: String -> Either String [EngineLogType Hasura]

-- | Get the current time, formatted with the current or specified timezone
getFormattedTime :: Maybe TimeZone -> IO FormattedTime

-- | A logger useful for accumulating and logging stats, in tight polling
--   loops. It also debounces to not flood with excessive logs. Use
--   @<a>logStats</a> to record statistics for logging.
createStatsLogger :: (MonadIO m, ToEngineLog stats impl, Monoid stats) => Logger impl -> m (Trigger stats stats)

-- | Safely close the statistics logger. When occurred, exception is
--   logged.
closeStatsLogger :: (MonadIO m, EnabledLogTypes impl) => EngineLogType impl -> Logger impl -> Trigger stats stats -> m ()

-- | This won't log the given stats immediately. The stats are accumulated
--   over the specific timeframe and logged only once. See
--   @<a>createStatsLogger</a> for more details.
logStats :: MonadIO m => Trigger stats stats -> stats -> m ()

-- | Emit when stored introspection is used
data StoredIntrospectionLog
StoredIntrospectionLog :: Text -> QErr -> StoredIntrospectionLog
[silMessage] :: StoredIntrospectionLog -> Text

-- | upstream data source errors
[silSourceError] :: StoredIntrospectionLog -> QErr

-- | Logs related to errors while interacting with the stored introspection
--   storage
data StoredIntrospectionStorageLog
StoredIntrospectionStorageLog :: Text -> QErr -> StoredIntrospectionStorageLog
[sislMessage] :: StoredIntrospectionStorageLog -> Text
[sislError] :: StoredIntrospectionStorageLog -> QErr
instance Hasura.Logging.EnabledLogTypes Hasura.Logging.Hasura
instance GHC.Classes.Eq (Hasura.Logging.EngineLogType impl) => GHC.Classes.Eq (Hasura.Logging.EngineLog impl)
instance GHC.Classes.Eq (Hasura.Logging.EngineLogType Hasura.Logging.Hasura)
instance GHC.Classes.Eq Hasura.Logging.FormattedTime
instance GHC.Classes.Eq Hasura.Logging.InternalLogTypes
instance GHC.Classes.Eq Hasura.Logging.LogLevel
instance GHC.Classes.Eq Hasura.Logging.LoggerSettings
instance Witch.From.From (Hasura.Logging.EngineLogType Hasura.Logging.Hasura) Data.Text.Internal.Text
instance Witch.From.From Hasura.Logging.InternalLogTypes Data.Text.Internal.Text
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.Logging.EngineLogType Hasura.Logging.Hasura)
instance GHC.Internal.Generics.Generic (Hasura.Logging.EngineLog impl)
instance GHC.Internal.Generics.Generic (Hasura.Logging.EngineLogType Hasura.Logging.Hasura)
instance GHC.Internal.Generics.Generic Hasura.Logging.InternalLogTypes
instance GHC.Internal.Generics.Generic Hasura.Logging.StoredIntrospectionLog
instance GHC.Internal.Generics.Generic Hasura.Logging.StoredIntrospectionStorageLog
instance Data.Hashable.Class.Hashable (Hasura.Logging.EngineLogType Hasura.Logging.Hasura)
instance Data.Hashable.Class.Hashable Hasura.Logging.InternalLogTypes
instance GHC.Classes.Ord Hasura.Logging.LogLevel
instance GHC.Internal.Show.Show (Hasura.Logging.EngineLogType impl) => GHC.Internal.Show.Show (Hasura.Logging.EngineLog impl)
instance GHC.Internal.Show.Show (Hasura.Logging.EngineLogType Hasura.Logging.Hasura)
instance GHC.Internal.Show.Show Hasura.Logging.FormattedTime
instance GHC.Internal.Show.Show Hasura.Logging.InternalLogTypes
instance GHC.Internal.Show.Show Hasura.Logging.LogLevel
instance GHC.Internal.Show.Show Hasura.Logging.LoggerSettings
instance GHC.Internal.Show.Show Hasura.Logging.UnstructuredLog
instance Hasura.Logging.ToEngineLog Hasura.Logging.StoredIntrospectionLog Hasura.Logging.Hasura
instance Hasura.Logging.ToEngineLog Hasura.Logging.StoredIntrospectionStorageLog Hasura.Logging.Hasura
instance Hasura.Logging.EnabledLogTypes impl => Hasura.Logging.ToEngineLog (Control.FoldDebounce.OpException, Hasura.Logging.EngineLogType impl) impl
instance Hasura.Logging.ToEngineLog Hasura.Logging.UnhandledInternalErrorLog Hasura.Logging.Hasura
instance Hasura.Logging.ToEngineLog Hasura.Logging.UnstructuredLog Hasura.Logging.Hasura
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.Logging.EngineLogType impl) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Logging.EngineLog impl)
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.Logging.EngineLogType Hasura.Logging.Hasura)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Logging.FormattedTime
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Logging.InternalLogTypes
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Logging.LogLevel
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Logging.StoredIntrospectionLog
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Logging.StoredIntrospectionStorageLog

module Hasura.Server.Auth.JWT.Logging
data JwkRefreshLog
JwkRefreshLog :: !LogLevel -> !Maybe Text -> !Maybe JwkFetchError -> JwkRefreshLog
[jrlLogLevel] :: JwkRefreshLog -> !LogLevel
[jrlMessage] :: JwkRefreshLog -> !Maybe Text
[jrlError] :: JwkRefreshLog -> !Maybe JwkFetchError

-- | Possible errors during fetching and parsing JWK (the <a>Text</a> type
--   at the end is a friendly error message)
data JwkFetchError

-- | Exception while making the HTTP request
JFEHttpException :: !HttpException -> !Text -> JwkFetchError

-- | Non-2xx HTTP errors from the upstream server
JFEHttpError :: !URI -> !Status -> !ByteString -> !Text -> JwkFetchError

-- | Error parsing the JWK response itself
JFEJwkParseError :: !Text -> !Text -> JwkFetchError

-- | Error parsing the expiry of the JWK
JFEExpiryParseError :: !Maybe Text -> Text -> JwkFetchError
instance GHC.Internal.Show.Show Hasura.Server.Auth.JWT.Logging.JwkFetchError
instance GHC.Internal.Show.Show Hasura.Server.Auth.JWT.Logging.JwkRefreshLog
instance Hasura.Logging.ToEngineLog Hasura.Server.Auth.JWT.Logging.JwkRefreshLog Hasura.Logging.Hasura
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Auth.JWT.Logging.JwkFetchError
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Auth.JWT.Logging.JwkRefreshLog


-- | This module implements the bulk of Hasura's JWT capabilities and
--   interactions. Its main point of non-testing invocation is <a>Auth</a>.
--   
--   It exports both <a>processJwt</a> and <a>processJwt_</a> with
--   <a>processJwt_</a> being the majority of the implementation with the
--   JWT Token processing function passed in as an argument in order to
--   enable mocking in test-code.
--   
--   In <a>processJwt_</a>, prior to validation of the token, first the
--   token locations and issuers are reconciled. Locations are either
--   specified as auth or cookie (with cookie name) or assumed to be auth.
--   Issuers can be omitted or specified, where an omitted configured
--   issuer can match any issuer specified by a request.
--   
--   If none match, then this is considered an no-auth request, if one
--   matches, then normal token auth is performed, and if multiple match,
--   then this is considered an ambiguity error.
module Hasura.Server.Auth.JWT

-- | Process the request headers to verify the JWT and extract UserInfo
--   from it From the JWT config, we check which header to expect, it can
--   be the <a>Authorization</a> or <a>Cookie</a> header
--   
--   If no <a>Authorization</a>/<a>Cookie</a> header was passed, we will
--   fall back to the unauthenticated user role [1], if one was configured
--   at server start.
--   
--   When no 'x-hasura-user-role' is specified in the request, the
--   mandatory 'x-hasura-default-role' [2] from the JWT claims will be
--   used.
processJwt :: (MonadIO m, MonadError QErr m) => [JWTCtx] -> RequestHeaders -> Maybe RoleName -> m (UserInfo, Maybe UTCTime, [Header], Maybe JWTCtx)
data RawJWT

-- | Hashable Wrapper for constructing a HashMap of JWTConfigs
newtype StringOrURI
StringOrURI :: StringOrURI -> StringOrURI
[unStringOrURI] :: StringOrURI -> StringOrURI

-- | The JWT configuration we got from the user.
data JWTConfig
JWTConfig :: !Either JWK URI -> !Maybe Audience -> !Maybe StringOrURI -> !JWTClaims -> !Maybe NominalDiffTime -> !Maybe JWTHeader -> JWTConfig
[jcKeyOrUrl] :: JWTConfig -> !Either JWK URI
[jcAudience] :: JWTConfig -> !Maybe Audience
[jcIssuer] :: JWTConfig -> !Maybe StringOrURI
[jcClaims] :: JWTConfig -> !JWTClaims
[jcAllowedSkew] :: JWTConfig -> !Maybe NominalDiffTime
[jcHeader] :: JWTConfig -> !Maybe JWTHeader

-- | The validated runtime JWT configuration returned by <tt>mkJwtCtx</tt>
--   in <tt>setupAuthMode</tt>.
data JWTCtx
JWTCtx :: !Maybe URI -> !IORef (JWKSet, Maybe UTCTime) -> !Maybe Audience -> !Maybe StringOrURI -> !JWTClaims -> !Maybe NominalDiffTime -> !JWTHeader -> JWTCtx
[jcxUrl] :: JWTCtx -> !Maybe URI

-- | This needs to be a mutable variable for <a>fetchJwk</a>. | We add the
--   expiry time of the JWK to the IORef, to determine | if the JWK has
--   expired and needs to be refreshed.
[jcxKeyConfig] :: JWTCtx -> !IORef (JWKSet, Maybe UTCTime)
[jcxAudience] :: JWTCtx -> !Maybe Audience
[jcxIssuer] :: JWTCtx -> !Maybe StringOrURI
[jcxClaims] :: JWTCtx -> !JWTClaims
[jcxAllowedSkew] :: JWTCtx -> !Maybe NominalDiffTime
[jcxHeader] :: JWTCtx -> !JWTHeader

-- | RFC 7517 §5. JWK Set Format
newtype JWKSet
JWKSet :: [JWK] -> JWKSet
data JWTClaimsFormat
JCFJson :: JWTClaimsFormat
JCFStringifiedJson :: JWTClaimsFormat
data JWTClaims
JCNamespace :: !JWTNamespace -> !JWTClaimsFormat -> JWTClaims
JCMap :: !JWTCustomClaimsMap -> JWTClaims

-- | Possible errors during fetching and parsing JWK (the <a>Text</a> type
--   at the end is a friendly error message)
data JwkFetchError

-- | Exception while making the HTTP request
JFEHttpException :: !HttpException -> !Text -> JwkFetchError

-- | Non-2xx HTTP errors from the upstream server
JFEHttpError :: !URI -> !Status -> !ByteString -> !Text -> JwkFetchError

-- | Error parsing the JWK response itself
JFEJwkParseError :: !Text -> !Text -> JwkFetchError

-- | Error parsing the expiry of the JWK
JFEExpiryParseError :: !Maybe Text -> Text -> JwkFetchError
data JWTHeader
JHAuthorization :: JWTHeader
JHCookie :: Text -> JWTHeader
JHCustomHeader :: Text -> JWTHeader

-- | JWTNamespace is used to locate the claims map within the JWT token.
--   The location can be either provided via a JSON path or the name of the
--   key in the JWT token.
data JWTNamespace
ClaimNsPath :: JSONPath -> JWTNamespace
ClaimNs :: Text -> JWTNamespace
type JWTCustomClaimsMapDefaultRole = JWTCustomClaimsMapValueG RoleName
type JWTCustomClaimsMapAllowedRoles = JWTCustomClaimsMapValueG [RoleName]
type JWTCustomClaimsMapValue = JWTCustomClaimsMapValueG SessionVariableValue
type ClaimsMap = HashMap SessionVariable Value

-- | An action that fetches the JWKs and updates the expiry time and JWKs
--   in the IORef
fetchAndUpdateJWKs :: (MonadIO m, MonadBaseControl IO m) => Logger Hasura -> Manager -> URI -> IORef (JWKSet, Maybe UTCTime) -> m ()

-- | Given a JWK url, fetch JWK from it
fetchJwk :: (MonadIO m, MonadBaseControl IO m, MonadError JwkFetchError m) => Logger Hasura -> Manager -> URI -> m (JWKSet, ResponseHeaders)
defaultClaimsFormat :: JWTClaimsFormat
defaultClaimsNamespace :: Text
processJwt_ :: MonadError QErr m => (JWTCtx -> ByteString -> m (ClaimsMap, Maybe UTCTime)) -> (RawJWT -> Maybe StringOrURI) -> (JWTCtx -> JWTHeader) -> [JWTCtx] -> RequestHeaders -> Maybe RoleName -> m (UserInfo, Maybe UTCTime, [Header], Maybe JWTCtx)

-- | Extract the issuer from a bearer tokena _without_ verifying it.
tokenIssuer :: RawJWT -> Maybe StringOrURI
allowedRolesClaim :: SessionVariable
defaultRoleClaim :: SessionVariable

-- | parse the claims map from the JWT token or custom claims from the JWT
--   config
parseClaimsMap :: MonadError QErr m => ClaimsSet -> JWTClaims -> m ClaimsMap

-- | Parses a JSON key-value object, including only x-hasura claims
parseObjectAsClaims :: KeyMap v -> HashMap SessionVariable v

-- | <a>JWTCustomClaimsMapValueG</a> is used to represent a single value of
--   the <a>JWTCustomClaimsMap</a>. A <a>JWTCustomClaimsMapValueG</a> can
--   either be an JSON object or the literal value of the claim. If the
--   value is an JSON object, then it should contain a key <tt>path</tt>,
--   which is the JSON path to the claim value in the JWT token. There's
--   also an option to specify a default value in the map via the 'default'
--   key, which will be used when a peek at the JWT token using the JSON
--   path fails (key does not exist).
data JWTCustomClaimsMapValueG v

-- | JSONPath to the key in the claims map, in case the key doesn't exist
--   in the claims map then the default value will be used (if provided)
JWTCustomClaimsMapJSONPath :: !JSONPath -> !Maybe v -> JWTCustomClaimsMapValueG v
JWTCustomClaimsMapStatic :: !v -> JWTCustomClaimsMapValueG v

-- | JWTClaimsMap is an option to provide a custom JWT claims map. The
--   JWTClaimsMap should be specified in the
--   <tt>HASURA_GRAPHQL_JWT_SECRET</tt> in the <tt>claims_map</tt>. The
--   JWTClaimsMap, if specified, requires two mandatory fields, namely,
--   `x-hasura-allowed-roles` and the `x-hasura-default-role`, other claims
--   may also be provided in the claims map.
data JWTCustomClaimsMap
JWTCustomClaimsMap :: !JWTCustomClaimsMapDefaultRole -> !JWTCustomClaimsMapAllowedRoles -> !CustomClaimsMap -> JWTCustomClaimsMap
[jcmDefaultRole] :: JWTCustomClaimsMap -> !JWTCustomClaimsMapDefaultRole
[jcmAllowedRoles] :: JWTCustomClaimsMap -> !JWTCustomClaimsMapAllowedRoles
[jcmCustomClaims] :: JWTCustomClaimsMap -> !CustomClaimsMap

-- | First check for Cache-Control header, if not found, look for Expires
--   header
determineJwkExpiryLifetime :: (MonadIO m, MonadError JwkFetchError m) => m UTCTime -> Logger Hasura -> ResponseHeaders -> m (Maybe UTCTime)
instance GHC.Classes.Eq Hasura.Server.Auth.JWT.HasuraClaims
instance GHC.Classes.Eq Hasura.Server.Auth.JWT.JWTClaims
instance GHC.Classes.Eq Hasura.Server.Auth.JWT.JWTClaimsFormat
instance GHC.Classes.Eq Hasura.Server.Auth.JWT.JWTConfig
instance GHC.Classes.Eq Hasura.Server.Auth.JWT.JWTCtx
instance GHC.Classes.Eq Hasura.Server.Auth.JWT.JWTCustomClaimsMap
instance GHC.Classes.Eq v => GHC.Classes.Eq (Hasura.Server.Auth.JWT.JWTCustomClaimsMapValueG v)
instance GHC.Classes.Eq Hasura.Server.Auth.JWT.JWTHeader
instance GHC.Classes.Eq Hasura.Server.Auth.JWT.JWTNamespace
instance GHC.Classes.Eq Hasura.Server.Auth.JWT.StringOrURI
instance GHC.Internal.Data.Foldable.Foldable Hasura.Server.Auth.JWT.JWTCustomClaimsMapValueG
instance Data.Aeson.Types.FromJSON.FromJSONKey (GHC.Internal.Maybe.Maybe Hasura.Server.Auth.JWT.StringOrURI)
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.Server.Auth.JWT.StringOrURI
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Auth.JWT.HasuraClaims
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Auth.JWT.JWTClaimsFormat
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Auth.JWT.JWTConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Auth.JWT.JWTCustomClaimsMap
instance Data.Aeson.Types.FromJSON.FromJSON v => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Server.Auth.JWT.JWTCustomClaimsMapValueG v)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Auth.JWT.JWTHeader
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Auth.JWT.StringOrURI
instance GHC.Internal.Base.Functor Hasura.Server.Auth.JWT.JWTCustomClaimsMapValueG
instance GHC.Internal.Generics.Generic Hasura.Server.Auth.JWT.HasuraClaims
instance GHC.Internal.Generics.Generic Hasura.Server.Auth.JWT.JWTClaimsFormat
instance GHC.Internal.Generics.Generic Hasura.Server.Auth.JWT.JWTHeader
instance Data.Hashable.Class.Hashable Hasura.Server.Auth.JWT.JWTHeader
instance Data.Hashable.Class.Hashable Hasura.Server.Auth.JWT.StringOrURI
instance GHC.Internal.Show.Show Hasura.Server.Auth.JWT.HasuraClaims
instance GHC.Internal.Show.Show Hasura.Server.Auth.JWT.JWTClaims
instance GHC.Internal.Show.Show Hasura.Server.Auth.JWT.JWTClaimsFormat
instance GHC.Internal.Show.Show Hasura.Server.Auth.JWT.JWTConfig
instance GHC.Internal.Show.Show Hasura.Server.Auth.JWT.JWTCtx
instance GHC.Internal.Show.Show Hasura.Server.Auth.JWT.JWTCustomClaimsMap
instance GHC.Internal.Show.Show v => GHC.Internal.Show.Show (Hasura.Server.Auth.JWT.JWTCustomClaimsMapValueG v)
instance GHC.Internal.Show.Show Hasura.Server.Auth.JWT.JWTHeader
instance GHC.Internal.Show.Show Hasura.Server.Auth.JWT.JWTNamespace
instance GHC.Internal.Show.Show Hasura.Server.Auth.JWT.StringOrURI
instance Data.Aeson.Types.ToJSON.ToJSONKey (GHC.Internal.Maybe.Maybe Hasura.Server.Auth.JWT.StringOrURI)
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Server.Auth.JWT.StringOrURI
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Auth.JWT.HasuraClaims
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Auth.JWT.JWTClaimsFormat
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Auth.JWT.JWTConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Auth.JWT.JWTCustomClaimsMap
instance Data.Aeson.Types.ToJSON.ToJSON v => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Server.Auth.JWT.JWTCustomClaimsMapValueG v)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Auth.JWT.JWTHeader
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Auth.JWT.JWTNamespace
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Auth.JWT.StringOrURI
instance GHC.Internal.Data.Traversable.Traversable Hasura.Server.Auth.JWT.JWTCustomClaimsMapValueG

module Control.Concurrent.Extended

-- | A <a>ThreadId</a> is an abstract type representing a handle to a
--   thread. <a>ThreadId</a> is an instance of <a>Eq</a>, <a>Ord</a> and
--   <a>Show</a>, where the <a>Ord</a> instance implements an arbitrary
--   total ordering over <a>ThreadId</a>s. The <a>Show</a> instance lets
--   you convert an arbitrary-valued <a>ThreadId</a> to string form;
--   showing a <a>ThreadId</a> value is occasionally useful when debugging
--   or diagnosing the behaviour of a concurrent program.
--   
--   <i>Note</i>: in GHC, if you have a <a>ThreadId</a>, you essentially
--   have a pointer to the thread itself. This means the thread itself
--   can't be garbage collected until you drop the <a>ThreadId</a>. This
--   misfeature would be difficult to correct while continuing to support
--   <a>threadStatus</a>.
data ThreadId

-- | Creates a new thread to run the <a>IO</a> computation passed as the
--   first argument, and returns the <a>ThreadId</a> of the newly created
--   thread.
--   
--   The new thread will be a lightweight, <i>unbound</i> thread. Foreign
--   calls made by this thread are not guaranteed to be made by any
--   particular OS thread; if you need foreign calls to be made by a
--   particular OS thread, then use <a>forkOS</a> instead.
--   
--   The new thread inherits the <i>masked</i> state of the parent (see
--   <a>mask</a>).
--   
--   The newly created thread has an exception handler that discards the
--   exceptions <a>BlockedIndefinitelyOnMVar</a>,
--   <a>BlockedIndefinitelyOnSTM</a>, and <a>ThreadKilled</a>, and passes
--   all other exceptions to the uncaught exception handler.
--   
--   WARNING: Exceptions in the new thread will not be rethrown in the
--   thread that created it. This means that you might be completely
--   unaware of the problem if/when this happens. You may want to use the
--   <a>async</a> library instead.
forkIO :: IO () -> IO ThreadId

-- | Like <a>forkIO</a>, this sparks off a new thread to run the <a>IO</a>
--   computation passed as the first argument, and returns the
--   <a>ThreadId</a> of the newly created thread.
--   
--   However, <a>forkOS</a> creates a <i>bound</i> thread, which is
--   necessary if you need to call foreign (non-Haskell) libraries that
--   make use of thread-local state, such as OpenGL (see
--   <a>Control.Concurrent#boundthreads</a>).
--   
--   Using <a>forkOS</a> instead of <a>forkIO</a> makes no difference at
--   all to the scheduling behaviour of the Haskell runtime system. It is a
--   common misconception that you need to use <a>forkOS</a> instead of
--   <a>forkIO</a> to avoid blocking all the Haskell threads when making a
--   foreign call; this isn't the case. To allow foreign calls to be made
--   without blocking all the Haskell threads (with GHC), it is only
--   necessary to use the <tt>-threaded</tt> option when linking your
--   program, and to make sure the foreign import is not marked
--   <tt>unsafe</tt>.
forkOS :: IO () -> IO ThreadId

-- | Like <a>forkIO</a>, but lets you specify on which capability the
--   thread should run. Unlike a <a>forkIO</a> thread, a thread created by
--   <a>forkOn</a> will stay on the same capability for its entire lifetime
--   (<a>forkIO</a> threads can migrate between capabilities according to
--   the scheduling policy). <a>forkOn</a> is useful for overriding the
--   scheduling policy when you know in advance how best to distribute the
--   threads.
--   
--   The <a>Int</a> argument specifies a <i>capability number</i> (see
--   <a>getNumCapabilities</a>). Typically capabilities correspond to
--   physical processors, but the exact behaviour is
--   implementation-dependent. The value passed to <a>forkOn</a> is
--   interpreted modulo the total number of capabilities as returned by
--   <a>getNumCapabilities</a>.
--   
--   GHC note: the number of capabilities is specified by the <tt>+RTS
--   -N</tt> option when the program is started. Capabilities can be fixed
--   to actual processor cores with <tt>+RTS -qa</tt> if the underlying
--   operating system supports that, although in practice this is usually
--   unnecessary (and may actually degrade performance in some cases -
--   experimentation is recommended).
--   
--   @since base-4.4.0.0
forkOn :: Int -> IO () -> IO ThreadId

-- | Like <a>forkIO</a>, but the child thread is passed a function that can
--   be used to unmask asynchronous exceptions. This function is typically
--   used in the following way
--   
--   <pre>
--   ... mask_ $ forkIOWithUnmask $ \unmask -&gt;
--                  catch (unmask ...) handler
--   </pre>
--   
--   so that the exception handler in the child thread is established with
--   asynchronous exceptions masked, meanwhile the main body of the child
--   thread is executed in the unmasked state.
--   
--   Note that the unmask function passed to the child thread should only
--   be used in that thread; the behaviour is undefined if it is invoked in
--   a different thread.
--   
--   @since base-4.4.0.0
forkIOWithUnmask :: ((forall a. () => IO a -> IO a) -> IO ()) -> IO ThreadId

-- | Like <a>forkIOWithUnmask</a>, but the child thread is pinned to the
--   given CPU, as with <a>forkOn</a>.
--   
--   @since base-4.4.0.0
forkOnWithUnmask :: Int -> ((forall a. () => IO a -> IO a) -> IO ()) -> IO ThreadId

-- | Returns the <a>ThreadId</a> of the calling thread (GHC only).
myThreadId :: IO ThreadId

-- | An <a>MVar</a> (pronounced "em-var") is a synchronising variable, used
--   for communication between concurrent threads. It can be thought of as
--   a box, which may be empty or full.
data MVar a

-- | Create an <a>MVar</a> which is initially empty.
newEmptyMVar :: IO (MVar a)

-- | Create an <a>MVar</a> which contains the supplied value.
newMVar :: a -> IO (MVar a)

-- | Return the contents of the <a>MVar</a>. If the <a>MVar</a> is
--   currently empty, <a>takeMVar</a> will wait until it is full. After a
--   <a>takeMVar</a>, the <a>MVar</a> is left empty.
--   
--   There are two further important properties of <a>takeMVar</a>:
--   
--   <ul>
--   <li><a>takeMVar</a> is single-wakeup. That is, if there are multiple
--   threads blocked in <a>takeMVar</a>, and the <a>MVar</a> becomes full,
--   only one thread will be woken up. The runtime guarantees that the
--   woken thread completes its <a>takeMVar</a> operation.</li>
--   <li>When multiple threads are blocked on an <a>MVar</a>, they are
--   woken up in FIFO order. This is useful for providing fairness
--   properties of abstractions built using <a>MVar</a>s.</li>
--   </ul>
takeMVar :: MVar a -> IO a

-- | Atomically read the contents of an <a>MVar</a>. If the <a>MVar</a> is
--   currently empty, <a>readMVar</a> will wait until it is full.
--   <a>readMVar</a> is guaranteed to receive the next <a>putMVar</a>.
--   
--   <a>readMVar</a> is multiple-wakeup, so when multiple readers are
--   blocked on an <a>MVar</a>, all of them are woken up at the same time.
--   The runtime guarantees that all woken threads complete their
--   <a>readMVar</a> operation.
--   
--   <i>Compatibility note:</i> Prior to base 4.7, <a>readMVar</a> was a
--   combination of <a>takeMVar</a> and <a>putMVar</a>. This mean that in
--   the presence of other threads attempting to <a>putMVar</a>,
--   <a>readMVar</a> could block. Furthermore, <a>readMVar</a> would not
--   receive the next <a>putMVar</a> if there was already a pending thread
--   blocked on <a>takeMVar</a>. The old behavior can be recovered by
--   implementing 'readMVar as follows:
--   
--   <pre>
--   readMVar :: MVar a -&gt; IO a
--   readMVar m =
--     mask_ $ do
--       a &lt;- takeMVar m
--       putMVar m a
--       return a
--   </pre>
readMVar :: MVar a -> IO a

-- | Put a value into an <a>MVar</a>. If the <a>MVar</a> is currently full,
--   <a>putMVar</a> will wait until it becomes empty.
--   
--   There are two further important properties of <a>putMVar</a>:
--   
--   <ul>
--   <li><a>putMVar</a> is single-wakeup. That is, if there are multiple
--   threads blocked in <a>putMVar</a>, and the <a>MVar</a> becomes empty,
--   only one thread will be woken up. The runtime guarantees that the
--   woken thread completes its <a>putMVar</a> operation.</li>
--   <li>When multiple threads are blocked on an <a>MVar</a>, they are
--   woken up in FIFO order. This is useful for providing fairness
--   properties of abstractions built using <a>MVar</a>s.</li>
--   </ul>
putMVar :: MVar a -> a -> IO ()

-- | A non-blocking version of <a>takeMVar</a>. The <a>tryTakeMVar</a>
--   function returns immediately, with <a>Nothing</a> if the <a>MVar</a>
--   was empty, or <tt><a>Just</a> a</tt> if the <a>MVar</a> was full with
--   contents <tt>a</tt>. After <a>tryTakeMVar</a>, the <a>MVar</a> is left
--   empty.
tryTakeMVar :: MVar a -> IO (Maybe a)

-- | A non-blocking version of <a>putMVar</a>. The <a>tryPutMVar</a>
--   function attempts to put the value <tt>a</tt> into the <a>MVar</a>,
--   returning <a>True</a> if it was successful, or <a>False</a> otherwise.
tryPutMVar :: MVar a -> a -> IO Bool

-- | A non-blocking version of <a>readMVar</a>. The <a>tryReadMVar</a>
--   function returns immediately, with <a>Nothing</a> if the <a>MVar</a>
--   was empty, or <tt><a>Just</a> a</tt> if the <a>MVar</a> was full with
--   contents <tt>a</tt>.
--   
--   @since base-4.7.0.0
tryReadMVar :: MVar a -> IO (Maybe a)

-- | Check whether a given <a>MVar</a> is empty.
--   
--   Notice that the boolean value returned is just a snapshot of the state
--   of the MVar. By the time you get to react on its result, the MVar may
--   have been filled (or emptied) - so be extremely careful when using
--   this operation. Use <a>tryTakeMVar</a> instead if possible.
isEmptyMVar :: MVar a -> IO Bool
addMVarFinalizer :: MVar a -> IO () -> IO ()

-- | Returns the number of Haskell threads that can run truly
--   simultaneously (on separate physical processors) at any given time. To
--   change this value, use <a>setNumCapabilities</a>.
--   
--   @since base-4.4.0.0
getNumCapabilities :: IO Int

-- | Set the number of Haskell threads that can run truly simultaneously
--   (on separate physical processors) at any given time. The number passed
--   to <a>forkOn</a> is interpreted modulo this value. The initial value
--   is given by the <tt>+RTS -N</tt> runtime flag.
--   
--   This is also the number of threads that will participate in parallel
--   garbage collection. It is strongly recommended that the number of
--   capabilities is not set larger than the number of physical processor
--   cores, and it may often be beneficial to leave one or more cores free
--   to avoid contention with other processes in the machine.
--   
--   @since base-4.5.0.0
setNumCapabilities :: Int -> IO ()

-- | <a>killThread</a> raises the <a>ThreadKilled</a> exception in the
--   given thread (GHC only).
--   
--   <pre>
--   killThread tid = throwTo tid ThreadKilled
--   </pre>
killThread :: ThreadId -> IO ()

-- | <a>throwTo</a> raises an arbitrary exception in the target thread (GHC
--   only).
--   
--   Exception delivery synchronizes between the source and target thread:
--   <a>throwTo</a> does not return until the exception has been raised in
--   the target thread. The calling thread can thus be certain that the
--   target thread has received the exception. Exception delivery is also
--   atomic with respect to other exceptions. Atomicity is a useful
--   property to have when dealing with race conditions: e.g. if there are
--   two threads that can kill each other, it is guaranteed that only one
--   of the threads will get to kill the other.
--   
--   Whatever work the target thread was doing when the exception was
--   raised is not lost: the computation is suspended until required by
--   another thread.
--   
--   If the target thread is currently making a foreign call, then the
--   exception will not be raised (and hence <a>throwTo</a> will not
--   return) until the call has completed. This is the case regardless of
--   whether the call is inside a <a>mask</a> or not. However, in GHC a
--   foreign call can be annotated as <tt>interruptible</tt>, in which case
--   a <a>throwTo</a> will cause the RTS to attempt to cause the call to
--   return; see the GHC documentation for more details.
--   
--   Important note: the behaviour of <a>throwTo</a> differs from that
--   described in the paper "Asynchronous exceptions in Haskell"
--   (<a>http://research.microsoft.com/~simonpj/Papers/asynch-exns.htm</a>).
--   In the paper, <a>throwTo</a> is non-blocking; but the library
--   implementation adopts a more synchronous design in which
--   <a>throwTo</a> does not return until the exception is received by the
--   target thread. The trade-off is discussed in Section 9 of the paper.
--   Like any blocking operation, <a>throwTo</a> is therefore interruptible
--   (see Section 5.3 of the paper). Unlike other interruptible operations,
--   however, <a>throwTo</a> is <i>always</i> interruptible, even if it
--   does not actually block.
--   
--   There is no guarantee that the exception will be delivered promptly,
--   although the runtime will endeavour to ensure that arbitrary delays
--   don't occur. In GHC, an exception can only be raised when a thread
--   reaches a <i>safe point</i>, where a safe point is where memory
--   allocation occurs. Some loops do not perform any memory allocation
--   inside the loop and therefore cannot be interrupted by a
--   <a>throwTo</a>.
--   
--   If the target of <a>throwTo</a> is the calling thread, then the
--   behaviour is the same as <a>throwIO</a>, except that the exception is
--   thrown as an asynchronous exception. This means that if there is an
--   enclosing pure computation, which would be the case if the current IO
--   operation is inside <a>unsafePerformIO</a> or
--   <a>unsafeInterleaveIO</a>, that computation is not permanently
--   replaced by the exception, but is suspended as if it had received an
--   asynchronous exception.
--   
--   Note that if <a>throwTo</a> is called with the current thread as the
--   target, the exception will be thrown even if the thread is currently
--   inside <a>mask</a> or <a>uninterruptibleMask</a>.
throwTo :: Exception e => ThreadId -> e -> IO ()

-- | The <a>yield</a> action allows (forces, in a co-operative multitasking
--   implementation) a context-switch to any other currently runnable
--   threads (if any), and is occasionally useful when implementing
--   concurrency abstractions.
yield :: IO ()

-- | Returns the number of the capability on which the thread is currently
--   running, and a boolean indicating whether the thread is locked to that
--   capability or not. A thread is locked to a capability if it was
--   created with <tt>forkOn</tt>.
--   
--   @since base-4.4.0.0
threadCapability :: ThreadId -> IO (Int, Bool)

-- | Make a weak pointer to a <a>ThreadId</a>. It can be important to do
--   this if you want to hold a reference to a <a>ThreadId</a> while still
--   allowing the thread to receive the <tt>BlockedIndefinitely</tt> family
--   of exceptions (e.g. <a>BlockedIndefinitelyOnMVar</a>). Holding a
--   normal <a>ThreadId</a> reference will prevent the delivery of
--   <tt>BlockedIndefinitely</tt> exceptions because the reference could be
--   used as the target of <a>throwTo</a> at any time, which would unblock
--   the thread.
--   
--   Holding a <tt>Weak ThreadId</tt>, on the other hand, will not prevent
--   the thread from receiving <tt>BlockedIndefinitely</tt> exceptions. It
--   is still possible to throw an exception to a <tt>Weak ThreadId</tt>,
--   but the caller must use <tt>deRefWeak</tt> first to determine whether
--   the thread still exists.
--   
--   @since base-4.6.0.0
mkWeakThreadId :: ThreadId -> IO (Weak ThreadId)

-- | <a>withMVar</a> is an exception-safe wrapper for operating on the
--   contents of an <a>MVar</a>. This operation is exception-safe: it will
--   replace the original contents of the <a>MVar</a> if an exception is
--   raised (see <a>Control.Exception</a>). However, it is only atomic if
--   there are no other producers for this <a>MVar</a>. In other words, it
--   cannot guarantee that, by the time <a>withMVar</a> gets the chance to
--   write to the MVar, the value of the MVar has not been altered by a
--   write operation from another thread.
withMVar :: MVar a -> (a -> IO b) -> IO b

-- | An exception-safe wrapper for modifying the contents of an
--   <a>MVar</a>. Like <a>withMVar</a>, <a>modifyMVar</a> will replace the
--   original contents of the <a>MVar</a> if an exception is raised during
--   the operation. This function is only atomic if there are no other
--   producers for this <a>MVar</a>. In other words, it cannot guarantee
--   that, by the time <a>modifyMVar_</a> gets the chance to write to the
--   MVar, the value of the MVar has not been altered by a write operation
--   from another thread.
modifyMVar_ :: MVar a -> (a -> IO a) -> IO ()

-- | Take a value from an <a>MVar</a>, put a new value into the <a>MVar</a>
--   and return the value taken. This function is atomic only if there are
--   no other producers for this <a>MVar</a>. In other words, it cannot
--   guarantee that, by the time <a>swapMVar</a> gets the chance to write
--   to the MVar, the value of the MVar has not been altered by a write
--   operation from another thread.
swapMVar :: MVar a -> a -> IO a

-- | Like <a>withMVar</a>, but the <tt>IO</tt> action in the second
--   argument is executed with asynchronous exceptions masked.
--   
--   @since base-4.7.0.0
withMVarMasked :: MVar a -> (a -> IO b) -> IO b

-- | A slight variation on <a>modifyMVar_</a> that allows a value to be
--   returned (<tt>b</tt>) in addition to the modified value of the
--   <a>MVar</a>.
modifyMVar :: MVar a -> (a -> IO (a, b)) -> IO b

-- | Like <a>modifyMVar_</a>, but the <tt>IO</tt> action in the second
--   argument is executed with asynchronous exceptions masked.
--   
--   @since base-4.6.0.0
modifyMVarMasked_ :: MVar a -> (a -> IO a) -> IO ()

-- | Like <a>modifyMVar</a>, but the <tt>IO</tt> action in the second
--   argument is executed with asynchronous exceptions masked.
--   
--   @since base-4.6.0.0
modifyMVarMasked :: MVar a -> (a -> IO (a, b)) -> IO b

-- | Make a <a>Weak</a> pointer to an <a>MVar</a>, using the second
--   argument as a finalizer to run when the <a>MVar</a> is
--   garbage-collected
--   
--   @since base-4.6.0.0
mkWeakMVar :: MVar a -> IO () -> IO (Weak (MVar a))

-- | Block the current thread until data is available to read on the given
--   file descriptor (GHC only).
--   
--   This will throw an <a>IOError</a> if the file descriptor was closed
--   while this thread was blocked. To safely close a file descriptor that
--   has been used with <a>threadWaitRead</a>, use <a>closeFdWith</a>.
threadWaitRead :: Fd -> IO ()

-- | Block the current thread until data can be written to the given file
--   descriptor (GHC only).
--   
--   This will throw an <a>IOError</a> if the file descriptor was closed
--   while this thread was blocked. To safely close a file descriptor that
--   has been used with <a>threadWaitWrite</a>, use <a>closeFdWith</a>.
threadWaitWrite :: Fd -> IO ()

-- | Returns an STM action that can be used to wait for data to read from a
--   file descriptor. The second returned value is an IO action that can be
--   used to deregister interest in the file descriptor.
threadWaitReadSTM :: Fd -> IO (STM (), IO ())

-- | Returns an STM action that can be used to wait until data can be
--   written to a file descriptor. The second returned value is an IO
--   action that can be used to deregister interest in the file descriptor.
threadWaitWriteSTM :: Fd -> IO (STM (), IO ())

-- | <a>True</a> if bound threads are supported. If
--   <tt>rtsSupportsBoundThreads</tt> is <a>False</a>,
--   <a>isCurrentThreadBound</a> will always return <a>False</a> and both
--   <a>forkOS</a> and <a>runInBoundThread</a> will fail.
rtsSupportsBoundThreads :: Bool

-- | Like <a>forkIOWithUnmask</a>, but the child thread is a bound thread,
--   as with <a>forkOS</a>.
forkOSWithUnmask :: ((forall a. () => IO a -> IO a) -> IO ()) -> IO ThreadId

-- | Returns <a>True</a> if the calling thread is <i>bound</i>, that is, if
--   it is safe to use foreign libraries that rely on thread-local state
--   from the calling thread.
isCurrentThreadBound :: IO Bool

-- | Run the <a>IO</a> computation passed as the first argument. If the
--   calling thread is not <i>bound</i>, a bound thread is created
--   temporarily. <tt>runInBoundThread</tt> doesn't finish until the
--   <a>IO</a> computation finishes.
--   
--   You can wrap a series of foreign function calls that rely on
--   thread-local state with <tt>runInBoundThread</tt> so that you can use
--   them without knowing whether the current thread is <i>bound</i>.
runInBoundThread :: IO a -> IO a

-- | Run the <a>IO</a> computation passed as the first argument. If the
--   calling thread is <i>bound</i>, an unbound thread is created
--   temporarily using <a>forkIO</a>. <tt>runInBoundThread</tt> doesn't
--   finish until the <a>IO</a> computation finishes.
--   
--   Use this function <i>only</i> in the rare case that you have actually
--   observed a performance loss due to the use of bound threads. A program
--   that doesn't need its main thread to be bound and makes <i>heavy</i>
--   use of concurrency (e.g. a web server), might want to wrap its
--   <tt>main</tt> action in <tt>runInUnboundThread</tt>.
--   
--   Note that exceptions which are thrown to the current thread are thrown
--   in turn to the thread that is executing the given computation. This
--   ensures there's always a way of killing the forked thread.
runInUnboundThread :: IO a -> IO a

-- | <a>QSem</a> is a quantity semaphore in which the resource is acquired
--   and released in units of one. It provides guaranteed FIFO ordering for
--   satisfying blocked <a>waitQSem</a> calls.
--   
--   The pattern
--   
--   <pre>
--   bracket_ waitQSem signalQSem (...)
--   </pre>
--   
--   is safe; it never loses a unit of the resource.
data QSem

-- | Build a new <a>QSem</a> with a supplied initial quantity. The initial
--   quantity must be at least 0.
newQSem :: Int -> IO QSem

-- | Wait for a unit to become available.
waitQSem :: QSem -> IO ()

-- | Signal that a unit of the <a>QSem</a> is available.
signalQSem :: QSem -> IO ()

-- | <a>QSemN</a> is a quantity semaphore in which the resource is acquired
--   and released in arbitrary amounts. It provides guaranteed FIFO
--   ordering for satisfying blocked <a>waitQSemN</a> calls.
--   
--   The pattern
--   
--   <pre>
--   bracket_ (waitQSemN n) (signalQSemN n) (...)
--   </pre>
--   
--   is safe; it never loses any of the resource.
data QSemN

-- | Build a new <a>QSemN</a> with a supplied initial quantity. The initial
--   quantity must be at least 0.
newQSemN :: Int -> IO QSemN

-- | Wait for the specified quantity to become available.
waitQSemN :: QSemN -> Int -> IO ()

-- | Signal that a given quantity is now available from the <a>QSemN</a>.
signalQSemN :: QSemN -> Int -> IO ()

-- | <a>Chan</a> is an abstract type representing an unbounded FIFO
--   channel.
data Chan a

-- | Build and return a new instance of <a>Chan</a>.
newChan :: IO (Chan a)

-- | Write a value to a <a>Chan</a>.
writeChan :: Chan a -> a -> IO ()

-- | Read the next value from the <a>Chan</a>. Blocks when the channel is
--   empty. Since the read end of a channel is an <a>MVar</a>, this
--   operation inherits fairness guarantees of <a>MVar</a>s (e.g. threads
--   blocked in this operation are woken up in FIFO order).
--   
--   Throws <a>BlockedIndefinitelyOnMVar</a> when the channel is empty and
--   no other thread holds a reference to the channel.
readChan :: Chan a -> IO a

-- | Duplicate a <a>Chan</a>: the duplicate channel begins empty, but data
--   written to either channel from then on will be available from both.
--   Hence this creates a kind of broadcast channel, where data written by
--   anyone is seen by everyone else.
--   
--   (Note that a duplicated channel is not equal to its original. So:
--   <tt>fmap (c /=) $ dupChan c</tt> returns <tt>True</tt> for all
--   <tt>c</tt>.)
dupChan :: Chan a -> IO (Chan a)

-- | Return a lazy list representing the contents of the supplied
--   <a>Chan</a>, much like <a>hGetContents</a>.
getChanContents :: Chan a -> IO [a]

-- | Write an entire list of items to a <a>Chan</a>.
writeList2Chan :: Chan a -> [a] -> IO ()

-- | Fork a thread and call the supplied function when the thread is about
--   to terminate, with an exception or a returned value. The function is
--   called with asynchronous exceptions masked.
--   
--   <pre>
--   forkFinally action and_then =
--     mask $ \restore -&gt;
--       forkIO $ try (restore action) &gt;&gt;= and_then
--   </pre>
--   
--   This function is useful for informing the parent when a child
--   terminates, for example.
forkFinally :: IO a -> (Either SomeException a -> IO ()) -> IO ThreadId

-- | Like <a>threadDelay</a>, but takes a <a>DiffTime</a> instead of an
--   <a>Int</a> microseconds.
--   
--   NOTE: you cannot simply replace e.g. <tt>threadDelay 1000</tt> with
--   <tt>sleep 1000</tt> since those literals have different meanings!
sleep :: DiffTime -> IO ()

-- | Like <a>MonadIO</a> but constrained to stacks in which forking a new
--   thread is reasonable/safe. In particular <a>StateT</a> causes
--   problems.
--   
--   This is the constraint you can use for functions that call
--   <a>async</a>, or <tt>immortal</tt>.
type ForkableMonadIO (m :: Type -> Type) = (MonadIO m, MonadBaseControl IO m, Forall Pure m)

-- | Note: Please consider using <a>forkManagedT</a> instead to ensure
--   reliable resource cleanup.
forkImmortal :: ForkableMonadIO m => String -> Logger Hasura -> m Void -> m Thread

-- | This function pairs a call to <a>forkImmortal</a> with a finalizer
--   which stops the immortal thread.
forkManagedT :: ForkableMonadIO m => String -> Logger Hasura -> m Void -> ManagedT m Thread

-- | <tt>forkManagedTWithGracefulShutdown</tt> is an extension of the
--   <tt>forkManagedT</tt> function this function also attempts to
--   gracefully shutdown the thread. This function accepts a `m (Forever
--   m)` argument. The <tt>Forever</tt> type contains a function and an
--   argument to the function. The function supplied will be run repeatedly
--   until shutdown is initiated. The response of the function will be the
--   argument to the next iteration.
--   
--   For reference, this function is used to run the async actions
--   processor. Check <tt>asyncActionsProcessor</tt>
forkManagedTWithGracefulShutdown :: ForkableMonadIO m => String -> Logger Hasura -> ThreadShutdown m -> m (Forever m) -> ManagedT m Thread

-- | A somewhat wonky function for parallelizing <tt>for xs f</tt> where
--   <tt>f</tt> is <tt>(MonadIO m, MonadError e m)</tt>. This is equivalent
--   to <tt>for xs f</tt> modulo the IO effects (i.e. when the IO has no
--   real side effects we care about).
--   
--   This also takes a <tt>chunkSize</tt> argument so you can manipulate
--   the amount of work given to each thread.
forConcurrentlyEIO :: (MonadIO m, MonadError e m) => Int -> [a] -> (a -> ExceptT e IO b) -> m [b]
concurrentlyEIO :: (MonadIO m, MonadError e m) => ExceptT e IO a -> ExceptT e IO b -> m (a, b)
data ImmortalThreadLog

-- | Synchronous Exception
ImmortalThreadUnexpectedException :: String -> SomeException -> ImmortalThreadLog

-- | Asynchronous Exception about to be sent
ImmortalThreadStopping :: String -> ImmortalThreadLog
ImmortalThreadRestarted :: String -> ImmortalThreadLog
data ThreadState
ThreadForked :: ThreadState
ThreadBlocking :: ThreadState
ThreadShutdownInitiated :: ThreadState

-- | <tt>ThreadShutdown</tt> is a newtype wrapper over an action which is
--   intended to execute when a thread's shutdown is initiated before
--   killing the thread
newtype ThreadShutdown (m :: Type -> Type)
ThreadShutdown :: m () -> ThreadShutdown (m :: Type -> Type)
[tsThreadShutdown] :: ThreadShutdown (m :: Type -> Type) -> m ()

-- | The <tt>Forever</tt> type defines an infinite looping monadic action
--   (like <tt>m void</tt>), but allows the caller to control the recursion
--   or insert code before each iteration. The <tt>a</tt> is the initial
--   argument, and subsequent iterations will be fed the argument returned
--   by the previous one. See <tt>forkManagedTWithGracefulShutdown</tt> to
--   see how it's used
data Forever (m :: Type -> Type)
Forever :: a -> (a -> m a) -> Forever (m :: Type -> Type)
instance GHC.Classes.Eq Control.Concurrent.Extended.ThreadState
instance GHC.Internal.Show.Show Control.Concurrent.Extended.ThreadState
instance Hasura.Logging.ToEngineLog Control.Concurrent.Extended.ImmortalThreadLog Hasura.Logging.Hasura

module Hasura.ShutdownLatch

-- | A latch for the graceful shutdown of a server process.
data ShutdownLatch
newShutdownLatch :: IO ShutdownLatch

-- | Initiate a graceful shutdown of the server associated with the
--   provided latch.
shutdownGracefully :: ShutdownLatch -> IO ()

-- | Block the current thread, waiting on the latch.
waitForShutdown :: ShutdownLatch -> IO ()

-- | Returns True if the latch is set for shutdown and vice-versa
shuttingDown :: ShutdownLatch -> IO Bool

module Hasura.Server.CheckUpdates
checkForUpdates :: LoggerCtx a -> Manager -> IO void
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.CheckUpdates.UpdateInfo
instance GHC.Internal.Generics.Generic Hasura.Server.CheckUpdates.UpdateInfo
instance GHC.Internal.Show.Show Hasura.Server.CheckUpdates.UpdateInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.CheckUpdates.UpdateInfo


-- | This file contains types for both the websocket protocols (Apollo) and
--   (graphql-ws) | See Apollo:
--   <a>https://github.com/apollographql/subscriptions-transport-ws/blob/master/PROTOCOL.md</a>
--   | See graphql-ws:
--   <a>https://github.com/enisdenjo/graphql-ws/blob/master/PROTOCOL.md</a>
module Hasura.GraphQL.Transport.WebSocket.Protocol
data ClientMsg
CMConnInit :: !Maybe ConnParams -> ClientMsg
CMStart :: !StartMsg -> ClientMsg
CMStop :: !StopMsg -> ClientMsg
CMConnTerm :: ClientMsg
CMPing :: !Maybe PingPongPayload -> ClientMsg
CMPong :: !Maybe PingPongPayload -> ClientMsg
newtype CompletionMsg
CompletionMsg :: OperationId -> CompletionMsg
newtype ConnErrMsg
ConnErrMsg :: Text -> ConnErrMsg
[unConnErrMsg] :: ConnErrMsg -> Text
data ConnParams
data DataMsg
DataMsg :: !OperationId -> !GQResponse -> DataMsg
data ErrorMsg
ErrorMsg :: !OperationId -> !Encoding -> ErrorMsg
data OperationId
data PingPongPayload

-- | This is sent from the server to the client while closing the websocket
--   on encountering an error.
data ServerErrorCode
ProtocolError1002 :: ServerErrorCode
GenericError4400 :: !String -> ServerErrorCode
Unauthorized4401 :: ServerErrorCode
Forbidden4403 :: ServerErrorCode
ConnectionInitTimeout4408 :: ServerErrorCode
NonUniqueSubscription4409 :: !OperationId -> ServerErrorCode
TooManyRequests4429 :: ServerErrorCode
data ServerMsg
SMConnAck :: ServerMsg
SMConnKeepAlive :: ServerMsg
SMConnErr :: !ConnErrMsg -> ServerMsg
SMData :: !DataMsg -> ServerMsg
SMErr :: !ErrorMsg -> ServerMsg
SMComplete :: !CompletionMsg -> ServerMsg
SMNext :: !DataMsg -> ServerMsg
SMPing :: !Maybe PingPongPayload -> ServerMsg
SMPong :: !Maybe PingPongPayload -> ServerMsg
data ServerMsgType
SMT_GQL_CONNECTION_KEEP_ALIVE :: ServerMsgType
SMT_GQL_CONNECTION_ERROR :: ServerMsgType
SMT_GQL_DATA :: ServerMsgType
SMT_GQL_NEXT :: ServerMsgType
SMT_GQL_PING :: ServerMsgType
SMT_GQL_PONG :: ServerMsgType
SMT_GQL_CONNECTION_ACK :: ServerMsgType
SMT_GQL_ERROR :: ServerMsgType
SMT_GQL_COMPLETE :: ServerMsgType
data StartMsg
StartMsg :: !OperationId -> !GQLReqUnparsed -> StartMsg
data StopMsg
StopMsg :: OperationId -> StopMsg
data WSConnInitTimeoutStatus
Initialized :: WSConnInitTimeoutStatus
TimedOut :: WSConnInitTimeoutStatus
type WSConnInitTimeout = TMVar WSConnInitTimeoutStatus
data WSSubProtocol
Apollo :: WSSubProtocol
GraphQLWS :: WSSubProtocol
encodeServerErrorMsg :: ServerErrorCode -> ByteString
encodeServerMsg :: ServerMsg -> ByteString
keepAliveMessage :: PingPongPayload
showSubProtocol :: WSSubProtocol -> String
toWSSubProtocol :: String -> WSSubProtocol
newWSConnInitTimeout :: IO WSConnInitTimeout

-- | Run the timer for the given timeout duration
runTimer :: Seconds -> WSConnInitTimeout -> IO ()
unsafeMkOperationId :: Text -> OperationId
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.Protocol.ClientMsg
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.Protocol.CompletionMsg
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.Protocol.ConnErrMsg
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.Protocol.ConnParams
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.Protocol.ErrorMsg
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.Protocol.OperationId
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.Protocol.PingPongPayload
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.Protocol.ServerErrorMsg
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.Protocol.ServerMsgType
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.Protocol.StartMsg
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.Protocol.StopMsg
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.Protocol.SubscribeMsg
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.Protocol.WSConnInitTimeoutStatus
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.Protocol.WSSubProtocol
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Transport.WebSocket.Protocol.ClientMsg
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Transport.WebSocket.Protocol.CompletionMsg
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Transport.WebSocket.Protocol.ConnErrMsg
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Transport.WebSocket.Protocol.ConnParams
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Transport.WebSocket.Protocol.OperationId
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Transport.WebSocket.Protocol.PingPongPayload
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Transport.WebSocket.Protocol.ServerErrorMsg
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Transport.WebSocket.Protocol.StartMsg
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Transport.WebSocket.Protocol.StopMsg
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Transport.WebSocket.Protocol.SubscribeMsg
instance GHC.Internal.Generics.Generic Hasura.GraphQL.Transport.WebSocket.Protocol.ConnParams
instance GHC.Internal.Generics.Generic Hasura.GraphQL.Transport.WebSocket.Protocol.PingPongPayload
instance GHC.Internal.Generics.Generic Hasura.GraphQL.Transport.WebSocket.Protocol.ServerErrorMsg
instance GHC.Internal.Generics.Generic Hasura.GraphQL.Transport.WebSocket.Protocol.StartMsg
instance GHC.Internal.Generics.Generic Hasura.GraphQL.Transport.WebSocket.Protocol.StopMsg
instance GHC.Internal.Generics.Generic Hasura.GraphQL.Transport.WebSocket.Protocol.SubscribeMsg
instance Data.Hashable.Class.Hashable Hasura.GraphQL.Transport.WebSocket.Protocol.OperationId
instance GHC.Internal.Data.String.IsString Hasura.GraphQL.Transport.WebSocket.Protocol.ConnErrMsg
instance GHC.Internal.Data.String.IsString Hasura.GraphQL.Transport.WebSocket.Protocol.OperationId
instance GHC.Internal.Show.Show Hasura.GraphQL.Transport.WebSocket.Protocol.ClientMsg
instance GHC.Internal.Show.Show Hasura.GraphQL.Transport.WebSocket.Protocol.CompletionMsg
instance GHC.Internal.Show.Show Hasura.GraphQL.Transport.WebSocket.Protocol.ConnErrMsg
instance GHC.Internal.Show.Show Hasura.GraphQL.Transport.WebSocket.Protocol.ConnParams
instance GHC.Internal.Show.Show Hasura.GraphQL.Transport.WebSocket.Protocol.ErrorMsg
instance GHC.Internal.Show.Show Hasura.GraphQL.Transport.WebSocket.Protocol.OperationId
instance GHC.Internal.Show.Show Hasura.GraphQL.Transport.WebSocket.Protocol.PingPongPayload
instance GHC.Internal.Show.Show Hasura.GraphQL.Transport.WebSocket.Protocol.ServerErrorCode
instance GHC.Internal.Show.Show Hasura.GraphQL.Transport.WebSocket.Protocol.ServerErrorMsg
instance GHC.Internal.Show.Show Hasura.GraphQL.Transport.WebSocket.Protocol.ServerMsgType
instance GHC.Internal.Show.Show Hasura.GraphQL.Transport.WebSocket.Protocol.StartMsg
instance GHC.Internal.Show.Show Hasura.GraphQL.Transport.WebSocket.Protocol.StopMsg
instance GHC.Internal.Show.Show Hasura.GraphQL.Transport.WebSocket.Protocol.SubscribeMsg
instance GHC.Internal.Show.Show Hasura.GraphQL.Transport.WebSocket.Protocol.WSConnInitTimeoutStatus
instance GHC.Internal.Show.Show Hasura.GraphQL.Transport.WebSocket.Protocol.WSSubProtocol
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.Protocol.CompletionMsg
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.Protocol.ConnErrMsg
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.Protocol.ConnParams
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.Protocol.OperationId
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.Protocol.PingPongPayload
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.Protocol.ServerErrorMsg
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.Protocol.ServerMsgType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.Protocol.StartMsg
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.Protocol.StopMsg
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.Protocol.SubscribeMsg

module Hasura.GC

-- | The RTS's idle GC doesn't work for us:
--   
--   <ul>
--   <li>when `-I` is too low it may fire continuously causing scary high
--   CPU when idle among other issues (see #2565)</li>
--   <li>when we set it higher it won't run at all leading to memory being
--   retained when idle (especially noticeable when users are benchmarking
--   and see memory stay high after finishing). In the theoretical worst
--   case there is such low haskell heap pressure that we never run
--   finalizers to free the foreign data from e.g. libpq.</li>
--   <li>as of GHC 8.10.2 we have access to `-Iw`, but those two knobs
--   still don’t give us a guarantee that a major GC will always run at
--   some minumum frequency (e.g. for finalizers)</li>
--   </ul>
--   
--   ...so we hack together our own using GHC.Stats, which should have
--   insignificant runtime overhead.
--   
--   NOTE: as always the cost of a major GC (forced here, or initiated by
--   the RTS) with the default copying collector is proportional to live
--   (non-garbage) heap data. Tune parameters here to balance: more
--   frequent GC pauses vs. prompt cleanup of foreign data (which does not
--   exert GC pressure).
--   
--   NOTE: larger nursery size (+RTS -A) may help us run more finalizers
--   during cheaper minor GCs, before they are promoted, making it feasible
--   (maybe) to run this with longer interval parameters.
ourIdleGC :: Logger Hasura -> DiffTime -> DiffTime -> DiffTime -> IO void


-- | Execute a Select query against the BigQuery REST API.
module Hasura.Backends.BigQuery.Execute
executeSelect :: Select -> Execute (Job, RecordSet)
runExecute :: MonadIO m => BigQuerySourceConfig -> Execute (Job, RecordSet) -> m (Either ExecuteProblem (Job, RecordSet))

-- | TODO: WARNING: This function hasn't been tested on Big Data(tm), and
--   therefore I was unable to get BigQuery to produce paginated results
--   that would contain the <a>pageToken</a> field in the JSON response.
--   Until that test has been done, we should consider this a preliminary
--   implementation.
streamBigQuery :: MonadIO m => BigQueryConnection -> BigQuery -> m (Either ExecuteProblem (Job, RecordSet))

-- | Execute a query without expecting any output (e.g. CREATE TABLE or
--   INSERT)
executeBigQuery :: MonadIO m => BigQueryConnection -> BigQuery -> m (Either ExecuteProblem ())
executeProblemMessage :: ShowDetails -> ExecuteProblem -> Text

-- | Insert a new dataset
insertDataset :: (MonadError ExecuteProblem m, MonadIO m) => BigQueryConnection -> Text -> m Dataset

-- | Delete a dataset
deleteDataset :: (MonadError ExecuteProblem m, MonadIO m) => BigQueryConnection -> Text -> m ()
data BigQuery
BigQuery :: Text -> InsOrdHashMap ParameterName Parameter -> BigQuery
[query] :: BigQuery -> Text
[parameters] :: BigQuery -> InsOrdHashMap ParameterName Parameter

-- | Execute monad; as queries are performed, the record sets are stored in
--   the map.
data Execute a
data ExecuteProblem
GetJobDecodeProblem :: String -> ExecuteProblem
CreateQueryJobDecodeProblem :: String -> ExecuteProblem
InsertDatasetDecodeProblem :: String -> ExecuteProblem
ExecuteRunBigQueryProblem :: BigQueryProblem -> ExecuteProblem
RESTRequestNonOK :: Status -> Value -> ExecuteProblem

-- | As opposed to BigQuery.FieldName which is a qualified name, this is
--   just the unqualified text name itself.
newtype FieldNameText
FieldNameText :: Text -> FieldNameText
data Job
Job :: Text -> Text -> Text -> Job
[state] :: Job -> Text
[jobId] :: Job -> Text
[location] :: Job -> Text
data OutputValue
DecimalOutputValue :: Decimal -> OutputValue
BigDecimalOutputValue :: BigDecimal -> OutputValue
IntegerOutputValue :: Int64 -> OutputValue
FloatOutputValue :: Float64 -> OutputValue
GeographyOutputValue :: Geography -> OutputValue
TextOutputValue :: Text -> OutputValue
TimestampOutputValue :: Timestamp -> OutputValue
DateOutputValue :: Date -> OutputValue
TimeOutputValue :: Time -> OutputValue
DatetimeOutputValue :: Datetime -> OutputValue
BytesOutputValue :: Base64 -> OutputValue
BoolOutputValue :: Bool -> OutputValue
ArrayOutputValue :: Vector OutputValue -> OutputValue
RecordOutputValue :: InsOrdHashMap FieldNameText OutputValue -> OutputValue
JsonOutputValue :: Value -> OutputValue
NullOutputValue :: OutputValue

-- | A set of records produced by the database. These are joined together.
--   There are all sorts of optimizations possible here, from using a
--   matrix/flat vector, unboxed sums for Value, etc. Presently we choose a
--   naive implementation in the interest of getting other work done.
data RecordSet
RecordSet :: Vector (InsOrdHashMap FieldNameText OutputValue) -> Maybe [Text] -> RecordSet
[rows] :: RecordSet -> Vector (InsOrdHashMap FieldNameText OutputValue)
[wantedFields] :: RecordSet -> Maybe [Text]

-- | We use this to hide certain details from the front-end, while allowing
--   them in tests. We have not actually decided whether showing the
--   details is insecure, but until we decide otherwise, it's probably best
--   to err on the side of caution.
data ShowDetails
HideDetails :: ShowDetails
InsecurelyShowDetails :: ShowDetails

-- | Source for this represenation type:
--   
--   
--   <a>https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#google.protobuf.Value</a>
--   
--   BigQuery results come in via the REST API as one of these simply
--   types.
--   
--   TODO: This omits StructValue -- do we need it?
data Value
NullValue :: Value

-- | 64-bit
--   <a>https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#integer_type</a>
IntegerValue :: Int64 -> Value

-- | Fixed precision
--   <a>https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#decimal_types</a>
DecimalValue :: Decimal -> Value

-- | Fixed precision
--   <a>https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#decimal_types</a>
BigDecimalValue :: BigDecimal -> Value

-- | Floating point
--   <a>https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#floating_point_types</a>
FloatValue :: Float64 -> Value
GeographyValue :: Geography -> Value
StringValue :: Text -> Value
BytesValue :: Base64 -> Value
BoolValue :: Bool -> Value
ArrayValue :: Vector Value -> Value
TimestampValue :: Timestamp -> Value
DateValue :: Date -> Value
TimeValue :: Time -> Value
JsonValue :: Value -> Value
DatetimeValue :: Datetime -> Value
instance GHC.Internal.Base.Applicative Hasura.Backends.BigQuery.Execute.Execute
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Execute.FieldNameText
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Execute.OutputValue
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Execute.ParameterName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Execute.BigQueryField
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Execute.Dataset
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Execute.FieldNameText
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Execute.JobResults
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Execute.JobResultsResponse
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Execute.Mode
instance GHC.Internal.Base.Functor Hasura.Backends.BigQuery.Execute.Execute
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Execute.ExecuteProblem
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.Execute.OutputValue
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Execute.FieldNameText
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Execute.OutputValue
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Execute.ParameterName
instance GHC.Internal.Data.String.IsString Hasura.Backends.BigQuery.Execute.FieldNameText
instance Control.Monad.Error.Class.MonadError Hasura.Backends.BigQuery.Execute.ExecuteProblem Hasura.Backends.BigQuery.Execute.Execute
instance GHC.Internal.Base.Monad Hasura.Backends.BigQuery.Execute.Execute
instance Control.Monad.IO.Class.MonadIO Hasura.Backends.BigQuery.Execute.Execute
instance Control.Monad.Reader.Class.MonadReader Hasura.Backends.BigQuery.Execute.ExecuteReader Hasura.Backends.BigQuery.Execute.Execute
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Execute.FieldNameText
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Execute.ParameterName
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Execute.BigQuery
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Execute.BigQueryField
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Execute.BigQueryFieldType
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Execute.Dataset
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Execute.Fetch
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Execute.FieldNameText
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Execute.JobResults
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Execute.JobResultsResponse
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Execute.Mode
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Execute.OutputValue
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Execute.Parameter
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Execute.ParameterName
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.Execute.RecordSet
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.BigQuery.Execute.FieldNameText
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Execute.ExecuteProblem
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Execute.OutputValue
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Execute.ParameterName


-- | This module contains a collection of utility functions we use with
--   tracing throughout the codebase, but that are not a core part of the
--   library. If we were to move tracing to a separate library, those
--   functions should be kept here in the core engine code.
module Hasura.Tracing.Utils

-- | Wrap the execution of an HTTP request in a span in the current trace.
--   Despite its name, this function does not start a new trace, and the
--   span will therefore not be recorded if the surrounding context isn't
--   traced (see <tt>spanWith</tt>).
--   
--   Additionally, this function adds metadata regarding the request to the
--   created span, and injects the trace context into the HTTP header.
traceHTTPRequest :: (MonadIO m, MonadTrace m) => HttpPropagator -> Request -> (Request -> m a) -> m a
attachSourceConfigAttributes :: forall (b :: BackendType) m. (HasSourceConfiguration b, MonadTrace m) => SourceConfig b -> m ()

module Hasura.Tracing


-- | Network service provider.
--   
--   This module defines a Service (see Note [Services]) that provides
--   access to the network; for now, that only means providing a HTTP
--   Manager. This is consequentlt a simple analogue to `(MonadReader r m,
--   Has Manager r)`, but could be updated to either encompass other
--   network utilities, or to provide a more restricted interface if deemed
--   useful. Alternatively this could be removed altogether if all network
--   calls were to be hidden behind more specific services.
module Hasura.Services.Network
class Monad m => ProvidesNetwork (m :: Type -> Type)
askHTTPManager :: ProvidesNetwork m => m Manager
instance Hasura.Services.Network.ProvidesNetwork m => Hasura.Services.Network.ProvidesNetwork (Control.Monad.Trans.Except.ExceptT e m)
instance Hasura.Services.Network.ProvidesNetwork m => Hasura.Services.Network.ProvidesNetwork (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.Services.Network.ProvidesNetwork m => Hasura.Services.Network.ProvidesNetwork (Control.Monad.Trans.State.Strict.StateT s m)
instance Hasura.Services.Network.ProvidesNetwork m => Hasura.Services.Network.ProvidesNetwork (Hasura.Tracing.Monad.TraceT m)
instance (GHC.Internal.Base.Monoid w, Hasura.Services.Network.ProvidesNetwork m) => Hasura.Services.Network.ProvidesNetwork (Control.Monad.Trans.Writer.Strict.WriterT w m)

module Hasura.Services

-- | A constraint alias that groups all services together.
type ProvidesHasuraServices (m :: Type -> Type) = ProvidesNetwork m

module Hasura.Server.Limits

-- | Monads which support resource (memory, CPU time, etc.) limiting
class Monad m => HasResourceLimits (m :: Type -> Type)
askHTTPHandlerLimit :: HasResourceLimits m => m ResourceLimits
($dmaskHTTPHandlerLimit) :: forall (t :: (Type -> Type) -> Type -> Type) (n :: Type -> Type). (HasResourceLimits m, m ~ t n, MonadTrans t, HasResourceLimits n) => m ResourceLimits
askGraphqlOperationLimit :: HasResourceLimits m => RequestId -> UserInfo -> ApiLimit -> m ResourceLimits
($dmaskGraphqlOperationLimit) :: forall (t :: (Type -> Type) -> Type -> Type) (n :: Type -> Type). (HasResourceLimits m, m ~ t n, MonadTrans t, HasResourceLimits n) => RequestId -> UserInfo -> ApiLimit -> m ResourceLimits

-- | Resource limits, represented by a function which modifies IO actions
--   to enforce those limits by throwing errors using <a>MonadError</a> in
--   the case where they are exceeded.
data ResourceLimits
ResourceLimits :: (forall (m :: Type -> Type) a. (MonadBaseControl IO m, MonadError QErr m) => m a -> m a) -> ResourceLimits
[runResourceLimits] :: ResourceLimits -> forall (m :: Type -> Type) a. (MonadBaseControl IO m, MonadError QErr m) => m a -> m a
instance Hasura.Server.Limits.HasResourceLimits m => Hasura.Server.Limits.HasResourceLimits (Control.Monad.Trans.Except.ExceptT e m)
instance Hasura.Server.Limits.HasResourceLimits m => Hasura.Server.Limits.HasResourceLimits (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.Server.Limits.HasResourceLimits m => Hasura.Server.Limits.HasResourceLimits (Hasura.Tracing.Monad.TraceT m)

module Hasura.RQL.Types.OpenTelemetry

-- | Metadata configuration for all OpenTelemetry-related features
data OpenTelemetryConfig
OpenTelemetryConfig :: OtelStatus -> Set OtelDataType -> OtelExporterConfig -> OtelBatchSpanProcessorConfig -> OpenTelemetryConfig
[_ocStatus] :: OpenTelemetryConfig -> OtelStatus
[_ocEnabledDataTypes] :: OpenTelemetryConfig -> Set OtelDataType
[_ocExporterOtlp] :: OpenTelemetryConfig -> OtelExporterConfig
[_ocBatchSpanProcessor] :: OpenTelemetryConfig -> OtelBatchSpanProcessorConfig
ocStatus :: Lens' OpenTelemetryConfig OtelStatus
ocEnabledDataTypes :: Lens' OpenTelemetryConfig (Set OtelDataType)
ocExporterOtlp :: Lens' OpenTelemetryConfig OtelExporterConfig
ocBatchSpanProcessor :: Lens' OpenTelemetryConfig OtelBatchSpanProcessorConfig
emptyOpenTelemetryConfig :: OpenTelemetryConfig

-- | Subsets of the fields of <a>OpenTelemetryConfig</a>, serving as
--   metadata object names for <tt>MetadataObjId</tt>.
data OpenTelemetryConfigSubobject

-- | The entire OpenTelemetry configuration
OtelSubobjectAll :: OpenTelemetryConfigSubobject
OtelSubobjectExporterOtlp :: OpenTelemetryConfigSubobject
OtelSubobjectBatchSpanProcessor :: OpenTelemetryConfigSubobject

-- | Should the OpenTelemetry exporter be enabled?
data OtelStatus
OtelEnabled :: OtelStatus
OtelDisabled :: OtelStatus
data OtelDataType
OtelTraces :: OtelDataType
OtelMetrics :: OtelDataType
OtelLogs :: OtelDataType

-- | 
--   <a>https://opentelemetry.io/docs/reference/specification/protocol/exporter/</a>
data OtelExporterConfig
OtelExporterConfig :: Maybe Text -> Maybe Text -> Maybe Text -> OtlpProtocol -> [HeaderConf] -> [NameValue] -> [TracePropagator] -> OtelExporterConfig

-- | Target URL to which the exporter is going to send traces. No default.
--   Used as-is without modification (e.g. appending <i>v1</i>traces).
[_oecTracesEndpoint] :: OtelExporterConfig -> Maybe Text

-- | Target URL to which the exporter is going to send metrics. No default.
--   Used as-is without modification (e.g. appending <i>v1</i>metrics).
[_oecMetricsEndpoint] :: OtelExporterConfig -> Maybe Text

-- | Target URL to which the exporter is going to send logs. No default.
--   Used as-is without modification (e.g. appending <i>v1</i>logs).
[_oecLogsEndpoint] :: OtelExporterConfig -> Maybe Text

-- | The transport protocol, for all telemetry types.
[_oecProtocol] :: OtelExporterConfig -> OtlpProtocol

-- | Key-value pairs to be used as headers to send with an export request,
--   for all telemetry types. We currently only support string-valued
--   attributes. Like OTEL_EXPORTER_OTLP_HEADERS.
[_oecHeaders] :: OtelExporterConfig -> [HeaderConf]

-- | Attributes to send as the resource attributes of an export request,
--   for all telemetry types.
[_oecResourceAttributes] :: OtelExporterConfig -> [NameValue]

-- | Trace propagator to be used to extract and inject trace headers
[_oecTracesPropagators] :: OtelExporterConfig -> [TracePropagator]
defaultOtelExporterConfig :: OtelExporterConfig

-- | Possible protocol to use with OTLP. Currently, only http/protobuf is
--   supported.
data OtlpProtocol
OtlpProtocolHttpProtobuf :: OtlpProtocol
newtype OtelBatchSpanProcessorConfig
OtelBatchSpanProcessorConfig :: Int -> OtelBatchSpanProcessorConfig

-- | The maximum batch size of every export. It must be smaller or equal to
--   maxQueueSize (not yet configurable). Default 512.
[_obspcMaxExportBatchSize] :: OtelBatchSpanProcessorConfig -> Int
defaultOtelBatchSpanProcessorConfig :: OtelBatchSpanProcessorConfig
data NameValue
NameValue :: Text -> Text -> NameValue
[nv_name] :: NameValue -> Text
[nv_value] :: NameValue -> Text
data TracePropagator
B3 :: TracePropagator
TraceContext :: TracePropagator

-- | Schema cache configuration for all OpenTelemetry-related features
data OpenTelemetryInfo
OpenTelemetryInfo :: OtelExporterInfo -> OtelBatchSpanProcessorInfo -> OpenTelemetryInfo
[_otiExporterOtlp] :: OpenTelemetryInfo -> OtelExporterInfo

-- | This configuration will be used for traces and logs (when implemented)
[_otiBatchSpanProcessorInfo] :: OpenTelemetryInfo -> OtelBatchSpanProcessorInfo
otiExporterOtlp :: Lens' OpenTelemetryInfo OtelExporterInfo
otiBatchSpanProcessorInfo :: Lens' OpenTelemetryInfo OtelBatchSpanProcessorInfo
data OtelExporterInfo
OtelExporterInfo :: Maybe Request -> Maybe Request -> Maybe Request -> Map Text Text -> Propagator RequestHeaders ResponseHeaders -> OtelExporterInfo

-- | HTTP <a>Request</a> containing (1) the target URL to which the
--   exporter is going to send spans, and (2) the user-specified request
--   headers. A value of <a>Nothing</a> indicates that the export of trace
--   data is disabled.
[_oteleiTracesBaseRequest] :: OtelExporterInfo -> Maybe Request

-- | HTTP <a>Request</a> containing (1) the target URL to which the
--   exporter is going to send metrics, and (2) the user-specified request
--   headers. A value of <a>Nothing</a> indicates that the export of trace
--   data is disabled.
[_oteleiMetricsBaseRequest] :: OtelExporterInfo -> Maybe Request

-- | HTTP <a>Request</a> containing (1) the target URL to which the
--   exporter is going to send logs, and (2) the user-specified request
--   headers. A value of <a>Nothing</a> indicates that the export of trace
--   data is disabled.
[_oteleiLogsBaseRequest] :: OtelExporterInfo -> Maybe Request

-- | Attributes to send as the resource attributes of an export request. We
--   currently only support string-valued attributes.
--   
--   Using Data.Map.Strict over Data.Hashmap.Strict because currently the
--   only operations on data are (1) folding and (2) union with a small map
--   of default attributes, and Map should be is faster than HashMap for
--   the latter.
[_oteleiResourceAttributes] :: OtelExporterInfo -> Map Text Text

-- | Trace propagator to be used to extract and inject trace headers
[_oteleiTracesPropagator] :: OtelExporterInfo -> Propagator RequestHeaders ResponseHeaders
emptyOtelExporterInfo :: OtelExporterInfo

-- | Batch processor configuration for trace export.
--   
--   
--   <a>https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/sdk.md</a>
--   
--   NOTE: we could share this configuration with logs when implemented,
--   but that change is invasive; I recommend just adding a new separate
--   configuration. See:
--   <a>https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/logs/sdk.md#batching-processor</a>
data OtelBatchSpanProcessorInfo
OtelBatchSpanProcessorInfo :: Int -> Int -> OtelBatchSpanProcessorInfo

-- | The maximum batch size of every export. It must be smaller or equal to
--   maxQueueSize. Default 512.
[_obspiMaxExportBatchSize] :: OtelBatchSpanProcessorInfo -> Int

-- | The maximum span queue size. After the size is reached spans are
--   dropped. Default 2048.
[_obspiMaxQueueSize] :: OtelBatchSpanProcessorInfo -> Int
getMaxExportBatchSize :: OtelBatchSpanProcessorInfo -> Int
getMaxQueueSize :: OtelBatchSpanProcessorInfo -> Int

-- | Defaults taken from
--   <a>https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/sdk.md#batching-processor</a>
defaultOtelBatchSpanProcessorInfo :: OtelBatchSpanProcessorInfo
defaultOtelExporterTracesPropagators :: [TracePropagator]
mkOtelTracesPropagator :: [TracePropagator] -> HttpPropagator
getOtelTracesPropagator :: OpenTelemetryInfo -> HttpPropagator
instance GHC.Internal.Enum.Bounded Hasura.RQL.Types.OpenTelemetry.OtelDataType
instance GHC.Internal.Enum.Bounded Hasura.RQL.Types.OpenTelemetry.OtelStatus
instance GHC.Internal.Enum.Bounded Hasura.RQL.Types.OpenTelemetry.OtlpProtocol
instance GHC.Internal.Enum.Bounded Hasura.RQL.Types.OpenTelemetry.TracePropagator
instance GHC.Internal.Enum.Enum Hasura.RQL.Types.OpenTelemetry.OtelDataType
instance GHC.Internal.Enum.Enum Hasura.RQL.Types.OpenTelemetry.OtelStatus
instance GHC.Internal.Enum.Enum Hasura.RQL.Types.OpenTelemetry.OtlpProtocol
instance GHC.Internal.Enum.Enum Hasura.RQL.Types.OpenTelemetry.TracePropagator
instance GHC.Classes.Eq Hasura.RQL.Types.OpenTelemetry.NameValue
instance GHC.Classes.Eq Hasura.RQL.Types.OpenTelemetry.OpenTelemetryConfig
instance GHC.Classes.Eq Hasura.RQL.Types.OpenTelemetry.OpenTelemetryConfigSubobject
instance GHC.Classes.Eq Hasura.RQL.Types.OpenTelemetry.OtelBatchSpanProcessorConfig
instance GHC.Classes.Eq Hasura.RQL.Types.OpenTelemetry.OtelDataType
instance GHC.Classes.Eq Hasura.RQL.Types.OpenTelemetry.OtelExporterConfig
instance GHC.Classes.Eq Hasura.RQL.Types.OpenTelemetry.OtelStatus
instance GHC.Classes.Eq Hasura.RQL.Types.OpenTelemetry.OtlpProtocol
instance GHC.Classes.Eq Hasura.RQL.Types.OpenTelemetry.TracePropagator
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.OpenTelemetry.NameValue
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.OpenTelemetry.OpenTelemetryConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.OpenTelemetry.OtelBatchSpanProcessorConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.OpenTelemetry.OtelDataType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.OpenTelemetry.OtelExporterConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.OpenTelemetry.OtelStatus
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.OpenTelemetry.OtlpProtocol
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.OpenTelemetry.TracePropagator
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.OpenTelemetry.OpenTelemetryConfigSubobject
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.OpenTelemetry.NameValue
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.OpenTelemetry.OpenTelemetryConfig
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.OpenTelemetry.OtelBatchSpanProcessorConfig
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.OpenTelemetry.OtelDataType
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.OpenTelemetry.OtelExporterConfig
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.OpenTelemetry.OtelStatus
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.OpenTelemetry.OtlpProtocol
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.OpenTelemetry.TracePropagator
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.OpenTelemetry.OpenTelemetryConfigSubobject
instance Language.Haskell.TH.Syntax.Lift Hasura.RQL.Types.OpenTelemetry.OtelBatchSpanProcessorInfo
instance GHC.Classes.Ord Hasura.RQL.Types.OpenTelemetry.OpenTelemetryConfigSubobject
instance GHC.Classes.Ord Hasura.RQL.Types.OpenTelemetry.OtelDataType
instance GHC.Classes.Ord Hasura.RQL.Types.OpenTelemetry.TracePropagator
instance GHC.Internal.Show.Show Hasura.RQL.Types.OpenTelemetry.NameValue
instance GHC.Internal.Show.Show Hasura.RQL.Types.OpenTelemetry.OpenTelemetryConfig
instance GHC.Internal.Show.Show Hasura.RQL.Types.OpenTelemetry.OpenTelemetryConfigSubobject
instance GHC.Internal.Show.Show Hasura.RQL.Types.OpenTelemetry.OtelBatchSpanProcessorConfig
instance GHC.Internal.Show.Show Hasura.RQL.Types.OpenTelemetry.OtelDataType
instance GHC.Internal.Show.Show Hasura.RQL.Types.OpenTelemetry.OtelExporterConfig
instance GHC.Internal.Show.Show Hasura.RQL.Types.OpenTelemetry.OtelStatus
instance GHC.Internal.Show.Show Hasura.RQL.Types.OpenTelemetry.OtlpProtocol
instance GHC.Internal.Show.Show Hasura.RQL.Types.OpenTelemetry.TracePropagator
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.OpenTelemetry.NameValue
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.OpenTelemetry.OtelBatchSpanProcessorConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.OpenTelemetry.OtelDataType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.OpenTelemetry.OtelExporterConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.OpenTelemetry.OtelStatus
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.OpenTelemetry.OtlpProtocol
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.OpenTelemetry.TracePropagator


-- | <h1>Hasura.Eventing.HTTP</h1>
--   
--   This module is an utility module providing HTTP utilities for
--   <a>Hasura.Eventing.EventTriggers</a> and
--   <a>Hasura.Eventing.ScheduledTriggers</a>.
--   
--   The event triggers and scheduled triggers share the event delivery
--   mechanism using the <tt>tryWebhook</tt> function defined in this
--   module.
module Hasura.Eventing.HTTP
data HTTPErr (a :: TriggerTypes)
HClient :: !HttpException -> HTTPErr (a :: TriggerTypes)
HStatus :: !HTTPResp a -> HTTPErr (a :: TriggerTypes)
HOther :: !String -> HTTPErr (a :: TriggerTypes)
data HTTPResp (a :: TriggerTypes)
HTTPResp :: !Int -> ![HeaderConf] -> !SerializableBlob -> !Int64 -> HTTPResp (a :: TriggerTypes)
[hrsStatus] :: HTTPResp (a :: TriggerTypes) -> !Int
[hrsHeaders] :: HTTPResp (a :: TriggerTypes) -> ![HeaderConf]
[hrsBody] :: HTTPResp (a :: TriggerTypes) -> !SerializableBlob
[hrsSize] :: HTTPResp (a :: TriggerTypes) -> !Int64
httpExceptionErrorEncoding :: HttpException -> ByteString
runHTTP :: forall m (a :: TriggerTypes). MonadIO m => Manager -> Request -> m (Either (HTTPErr a) (HTTPResp a))
isNetworkError :: forall (a :: TriggerTypes). HTTPErr a -> Bool
isNetworkErrorHC :: HttpException -> Bool
logHTTPForET :: (MonadReader r m, MonadTraceContext m, Has (Logger Hasura) r, MonadIO m) => Either (HTTPErr 'EventType) (HTTPResp 'EventType) -> ExtraLogContext -> RequestDetails -> Text -> [HeaderConf] -> TriggersErrorLogLevelStatus -> m ()
logHTTPForST :: (MonadReader r m, MonadTraceContext m, Has (Logger Hasura) r, MonadIO m) => Either (HTTPErr 'ScheduledType) (HTTPResp 'ScheduledType) -> ExtraLogContext -> RequestDetails -> Text -> [HeaderConf] -> TriggersErrorLogLevelStatus -> m ()
data ExtraLogContext
ExtraLogContext :: !EventId -> !Maybe TriggerName -> ExtraLogContext
[elEventId] :: ExtraLogContext -> !EventId
[elEventName] :: ExtraLogContext -> !Maybe TriggerName
data RequestDetails
RequestDetails :: Request -> Int64 -> Maybe Request -> Maybe Int64 -> Maybe RequestContext -> Maybe SessionVariables -> RequestDetails
[_rdOriginalRequest] :: RequestDetails -> Request
[_rdOriginalSize] :: RequestDetails -> Int64
[_rdTransformedRequest] :: RequestDetails -> Maybe Request
[_rdTransformedSize] :: RequestDetails -> Maybe Int64
[_rdReqTransformCtx] :: RequestDetails -> Maybe RequestContext
[_rdSessionVars] :: RequestDetails -> Maybe SessionVariables
extractRequest :: RequestDetails -> Request
data EventId
type InvocationVersion = Text
data Response (a :: TriggerTypes)
ResponseHTTP :: WebhookResponse -> Response (a :: TriggerTypes)
ResponseError :: ClientError -> Response (a :: TriggerTypes)
data WebhookRequest
WebhookRequest :: Value -> [HeaderConf] -> Text -> WebhookRequest
[_rqPayload] :: WebhookRequest -> Value
[_rqHeaders] :: WebhookRequest -> [HeaderConf]
[_rqVersion] :: WebhookRequest -> Text
data WebhookResponse
WebhookResponse :: SerializableBlob -> [HeaderConf] -> Int -> WebhookResponse
[_wrsBody] :: WebhookResponse -> SerializableBlob
[_wrsHeaders] :: WebhookResponse -> [HeaderConf]
[_wrsStatus] :: WebhookResponse -> Int
newtype ClientError
ClientError :: SerializableBlob -> ClientError
[_ceMessage] :: ClientError -> SerializableBlob
isClientError :: Int -> Bool
mkClientErr :: forall (a :: TriggerTypes). SerializableBlob -> Response a
mkWebhookReq :: Value -> [HeaderConf] -> InvocationVersion -> WebhookRequest
mkResp :: forall (a :: TriggerTypes). Int -> SerializableBlob -> [HeaderConf] -> Response a
mkInvocationResp :: forall (a :: TriggerTypes). Maybe Int -> SerializableBlob -> [HeaderConf] -> Response a

-- | Encodes given request headers along with our <a>defaultHeaders</a> and
--   returns them along with the re-decoded set of headers (for logging
--   purposes).
prepareHeaders :: [EventHeaderInfo] -> ([Header], [HeaderConf])
getRetryAfterHeaderFromHTTPErr :: forall (a :: TriggerTypes). HTTPErr a -> Maybe Text
getRetryAfterHeaderFromResp :: forall (a :: TriggerTypes). HTTPResp a -> Maybe Text
parseRetryHeaderValue :: Text -> Maybe Int
invocationVersionET :: InvocationVersion
invocationVersionST :: InvocationVersion
mkRequest :: forall (a :: TriggerTypes) m. MonadError (TransformableRequestError a) m => [Header] -> ResponseTimeout -> ByteString -> Maybe RequestTransform -> ResolvedWebhook -> m RequestDetails
invokeRequest :: forall r m (a :: TriggerTypes). (MonadReader r m, MonadError (TransformableRequestError a) m, Has Manager r, Has (Logger Hasura) r, MonadIO m, MonadTrace m) => RequestDetails -> Maybe ResponseTransform -> Maybe SessionVariables -> (Either (HTTPErr a) (HTTPResp a) -> RequestDetails -> m ()) -> HttpPropagator -> m (HTTPResp a)
data TransformableRequestError (a :: TriggerTypes)
HTTPError :: Value -> HTTPErr a -> TransformableRequestError (a :: TriggerTypes)
TransformationError :: Value -> TransformErrorBundle -> TransformableRequestError (a :: TriggerTypes)
instance GHC.Classes.Eq Hasura.Eventing.HTTP.ExtraLogContext
instance GHC.Classes.Eq Hasura.Eventing.HTTP.HTTPReq
instance GHC.Internal.Generics.Generic Hasura.Eventing.HTTP.HTTPReq
instance GHC.Internal.Generics.Generic (Hasura.Eventing.HTTP.HTTPResp a)
instance GHC.Internal.Generics.Generic Hasura.Eventing.HTTP.RequestDetails
instance GHC.Internal.Show.Show Hasura.Eventing.HTTP.ExtraLogContext
instance GHC.Internal.Show.Show (Hasura.Eventing.HTTP.HTTPErr a)
instance GHC.Internal.Show.Show Hasura.Eventing.HTTP.HTTPReq
instance GHC.Internal.Show.Show (Hasura.Eventing.HTTP.HTTPResp a)
instance GHC.Internal.Show.Show (Hasura.Eventing.HTTP.TransformableRequestError a)
instance Hasura.Logging.ToEngineLog (Hasura.Eventing.HTTP.HTTPErr 'Hasura.RQL.Types.Eventing.EventType) Hasura.Logging.Hasura
instance Hasura.Logging.ToEngineLog (Hasura.Eventing.HTTP.HTTPErr 'Hasura.RQL.Types.Eventing.ScheduledType) Hasura.Logging.Hasura
instance Hasura.Logging.ToEngineLog Hasura.Eventing.HTTP.HTTPReq Hasura.Logging.Hasura
instance Hasura.Logging.ToEngineLog (Hasura.Eventing.HTTP.HTTPRespExtraLog 'Hasura.RQL.Types.Eventing.EventType) Hasura.Logging.Hasura
instance Hasura.Logging.ToEngineLog (Hasura.Eventing.HTTP.HTTPRespExtraLog 'Hasura.RQL.Types.Eventing.ScheduledType) Hasura.Logging.Hasura
instance Hasura.Logging.ToEngineLog (Hasura.Eventing.HTTP.HTTPResp 'Hasura.RQL.Types.Eventing.EventType) Hasura.Logging.Hasura
instance Hasura.Logging.ToEngineLog (Hasura.Eventing.HTTP.HTTPResp 'Hasura.RQL.Types.Eventing.ScheduledType) Hasura.Logging.Hasura
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.Eventing.HTTP.HTTPErr a)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Eventing.HTTP.HTTPReq
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.Eventing.HTTP.HTTPResp a)
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.Eventing.HTTP.HTTPRespExtra a)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Eventing.HTTP.RequestDetails

module Hasura.Eventing.ScheduledTrigger.Types
data CronTriggerStats
CronTriggerStats :: !TriggerName -> !Int -> !UTCTime -> CronTriggerStats
data FetchedCronTriggerStats
FetchedCronTriggerStats :: [CronTriggerStats] -> Int -> FetchedCronTriggerStats
[_fctsCronTriggers] :: FetchedCronTriggerStats -> [CronTriggerStats]
[_fctsNumFetches] :: FetchedCronTriggerStats -> Int
type FetchedCronTriggerStatsLogger = Trigger FetchedCronTriggerStats FetchedCronTriggerStats
data RetryContext
RetryContext :: !Int -> !STRetryConf -> RetryContext
data ScheduledEventOp
SEOpRetry :: !UTCTime -> ScheduledEventOp
SEOpStatus :: !ScheduledEventStatus -> ScheduledEventOp
data ScheduledEventWebhookPayload
ScheduledEventWebhookPayload :: !EventId -> !Maybe TriggerName -> !UTCTime -> !Value -> !Maybe Text -> !Maybe UTCTime -> !Maybe RequestTransform -> !Maybe MetadataResponseTransform -> ScheduledEventWebhookPayload
newtype ScheduledTriggerInternalErr
ScheduledTriggerInternalErr :: QErr -> ScheduledTriggerInternalErr
newtype CronEventsCount
CronEventsCount :: Int -> CronEventsCount
[unCronEventsCount] :: CronEventsCount -> Int
newtype OneOffScheduledEventsCount
OneOffScheduledEventsCount :: Int -> OneOffScheduledEventsCount
[unOneOffScheduledEventsCount] :: OneOffScheduledEventsCount -> Int

-- | Statistics of scheduled events fetched within a timeframe
data FetchedScheduledEventsStats
FetchedScheduledEventsStats :: CronEventsCount -> OneOffScheduledEventsCount -> Int -> FetchedScheduledEventsStats
[_fsesNumCronEventsFetched] :: FetchedScheduledEventsStats -> CronEventsCount
[_fsesNumOneOffScheduledEventsFetched] :: FetchedScheduledEventsStats -> OneOffScheduledEventsCount
[_fsesNumFetches] :: FetchedScheduledEventsStats -> Int
type FetchedScheduledEventsStatsLogger = Trigger FetchedScheduledEventsStats FetchedScheduledEventsStats
instance GHC.Classes.Eq Hasura.Eventing.ScheduledTrigger.Types.CronEventsCount
instance GHC.Classes.Eq Hasura.Eventing.ScheduledTrigger.Types.CronTriggerStats
instance GHC.Classes.Eq Hasura.Eventing.ScheduledTrigger.Types.FetchedCronTriggerStats
instance GHC.Classes.Eq Hasura.Eventing.ScheduledTrigger.Types.FetchedScheduledEventsStats
instance GHC.Classes.Eq Hasura.Eventing.ScheduledTrigger.Types.OneOffScheduledEventsCount
instance GHC.Classes.Eq Hasura.Eventing.ScheduledTrigger.Types.RetryContext
instance GHC.Classes.Eq Hasura.Eventing.ScheduledTrigger.Types.ScheduledEventOp
instance GHC.Classes.Eq Hasura.Eventing.ScheduledTrigger.Types.ScheduledEventWebhookPayload
instance GHC.Classes.Eq Hasura.Eventing.ScheduledTrigger.Types.ScheduledTriggerInternalErr
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Eventing.ScheduledTrigger.Types.CronEventsCount
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Eventing.ScheduledTrigger.Types.OneOffScheduledEventsCount
instance GHC.Internal.Generics.Generic Hasura.Eventing.ScheduledTrigger.Types.CronTriggerStats
instance GHC.Internal.Generics.Generic Hasura.Eventing.ScheduledTrigger.Types.FetchedCronTriggerStats
instance GHC.Internal.Generics.Generic Hasura.Eventing.ScheduledTrigger.Types.FetchedScheduledEventsStats
instance GHC.Internal.Generics.Generic Hasura.Eventing.ScheduledTrigger.Types.ScheduledEventWebhookPayload
instance GHC.Internal.Base.Monoid Hasura.Eventing.ScheduledTrigger.Types.FetchedCronTriggerStats
instance GHC.Internal.Base.Monoid Hasura.Eventing.ScheduledTrigger.Types.FetchedScheduledEventsStats
instance GHC.Internal.Num.Num Hasura.Eventing.ScheduledTrigger.Types.CronEventsCount
instance GHC.Internal.Num.Num Hasura.Eventing.ScheduledTrigger.Types.OneOffScheduledEventsCount
instance GHC.Internal.Base.Semigroup Hasura.Eventing.ScheduledTrigger.Types.FetchedCronTriggerStats
instance GHC.Internal.Base.Semigroup Hasura.Eventing.ScheduledTrigger.Types.FetchedScheduledEventsStats
instance GHC.Internal.Show.Show Hasura.Eventing.ScheduledTrigger.Types.CronEventsCount
instance GHC.Internal.Show.Show Hasura.Eventing.ScheduledTrigger.Types.FetchedScheduledEventsStats
instance GHC.Internal.Show.Show Hasura.Eventing.ScheduledTrigger.Types.OneOffScheduledEventsCount
instance GHC.Internal.Show.Show Hasura.Eventing.ScheduledTrigger.Types.ScheduledEventOp
instance GHC.Internal.Show.Show Hasura.Eventing.ScheduledTrigger.Types.ScheduledEventWebhookPayload
instance Hasura.Logging.ToEngineLog Hasura.Eventing.ScheduledTrigger.Types.FetchedCronTriggerStats Hasura.Logging.Hasura
instance Hasura.Logging.ToEngineLog Hasura.Eventing.ScheduledTrigger.Types.FetchedScheduledEventsStats Hasura.Logging.Hasura
instance Hasura.Logging.ToEngineLog Hasura.Eventing.ScheduledTrigger.Types.ScheduledTriggerInternalErr Hasura.Logging.Hasura
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Eventing.ScheduledTrigger.Types.CronEventsCount
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Eventing.ScheduledTrigger.Types.CronTriggerStats
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Eventing.ScheduledTrigger.Types.FetchedCronTriggerStats
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Eventing.ScheduledTrigger.Types.FetchedScheduledEventsStats
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Eventing.ScheduledTrigger.Types.OneOffScheduledEventsCount
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Eventing.ScheduledTrigger.Types.ScheduledEventWebhookPayload


-- | Postgres Connection MonadTx
--   
--   This module contains <a>MonadTx</a> and related combinators.
--   
--   <a>MonadTx</a>, a class which abstracts the <a>QErr</a> in <a>TxE</a>
--   via <a>MonadError</a>.
--   
--   The combinators are used for running, tracing, or otherwise perform
--   database related tasks. Please consult the individual documentation
--   for more information.
module Hasura.Backends.Postgres.Connection.MonadTx
class MonadError QErr m => MonadTx (m :: Type -> Type)
liftTx :: MonadTx m => TxE QErr a -> m a
runTxWithCtx :: (MonadIO m, MonadBaseControl IO m, MonadError QErr m, MonadTrace m, UserInfoM m) => PGExecCtx -> PGExecTxType -> PGExecFrom -> TxET QErr m a -> m a
runTxWithCtxAndUserInfo :: (MonadIO m, MonadBaseControl IO m, MonadError QErr m, MonadTrace m) => UserInfo -> PGExecCtx -> PGExecTxType -> PGExecFrom -> TxET QErr m a -> m a

-- | This runs the given set of statements (Tx) without wrapping them in
--   BEGIN and COMMIT. This should only be used for running a single
--   statement query!
runQueryTx :: (MonadIO m, MonadBaseControl IO m, MonadError QErr m) => PGExecCtx -> PGExecFrom -> TxET QErr m a -> m a
withUserInfo :: forall (m :: Type -> Type) a. MonadIO m => UserInfo -> TxET QErr m a -> TxET QErr m a

-- | Inject the trace context as a transaction-local variable, so that it
--   can be picked up by any triggers (including event triggers).
withTraceContext :: forall (m :: Type -> Type) a. MonadIO m => Maybe TraceContext -> TxET QErr m a -> TxET QErr m a
setHeadersTx :: forall (m :: Type -> Type). MonadIO m => SessionVariables -> TxET QErr m ()
setTraceContextInTx :: forall (m :: Type -> Type). MonadIO m => Maybe TraceContext -> TxET QErr m ()
sessionInfoJsonExp :: SessionVariables -> SQLExp
checkDbConnection :: MonadTx m => m ()
doesSchemaExist :: MonadTx m => SchemaName -> m Bool
doesTableExist :: MonadTx m => SchemaName -> TableName -> m Bool
enablePgcryptoExtension :: MonadTx m => ExtensionsSchema -> m ()
dropHdbCatalogSchema :: MonadTx m => m ()

-- | The name of the schema in which the graphql-engine will install
--   database extensions.
newtype ExtensionsSchema
ExtensionsSchema :: Text -> ExtensionsSchema
[_unExtensionsSchema] :: ExtensionsSchema -> Text
instance Hasura.Tracing.Class.MonadTraceContext m => Hasura.Tracing.Class.MonadTraceContext (Database.PG.Query.Transaction.TxET e m)
instance Hasura.Tracing.Class.MonadTrace m => Hasura.Tracing.Class.MonadTrace (Database.PG.Query.Transaction.TxET e m)
instance Hasura.Backends.Postgres.Connection.MonadTx.MonadTx m => Hasura.Backends.Postgres.Connection.MonadTx.MonadTx (Control.Monad.Trans.Reader.ReaderT s m)
instance Hasura.Backends.Postgres.Connection.MonadTx.MonadTx m => Hasura.Backends.Postgres.Connection.MonadTx.MonadTx (Control.Monad.Trans.State.Strict.StateT s m)
instance Hasura.Backends.Postgres.Connection.MonadTx.MonadTx m => Hasura.Backends.Postgres.Connection.MonadTx.MonadTx (Hasura.Tracing.Monad.TraceT m)
instance Control.Monad.IO.Class.MonadIO m => Hasura.Backends.Postgres.Connection.MonadTx.MonadTx (Database.PG.Query.Transaction.TxET Hasura.Base.Error.QErr m)
instance Hasura.Backends.Postgres.Connection.MonadTx.MonadTx m => Hasura.Backends.Postgres.Connection.MonadTx.MonadTx (Control.Monad.Validate.Internal.ValidateT e m)
instance (GHC.Internal.Base.Monoid w, Hasura.Backends.Postgres.Connection.MonadTx.MonadTx m) => Hasura.Backends.Postgres.Connection.MonadTx.MonadTx (Control.Monad.Trans.Writer.Strict.WriterT w m)


-- | Postgres Connetion
--   
--   This module re-exports:
--   
--   <ul>
--   <li>MonadTx for abstracting postgres transactions</li>
--   <li>Settings for dealing with connection, pool, and replica
--   settings</li>
--   <li>ET for execution contexts and source configurations</li>
--   </ul>
module Hasura.Backends.Postgres.Connection

module Hasura.LogicalModel.Fields

-- | Class for looking up Logical Models
class Monad m => LogicalModelFieldsRM (b :: BackendType) (m :: Type -> Type)
lookupLogicalModelFields :: LogicalModelFieldsRM b m => LogicalModelName -> m (Maybe (LogicalModelFields b))
getLogicalModelFieldsLookup :: LogicalModelFieldsRM b m => m (LogicalModelFieldsLookup b)
newtype LogicalModelFieldsLookupRT (b :: BackendType) (m :: Type -> Type) a
LogicalModelFieldsLookupRT :: (LogicalModelFieldsLookup b -> m a) -> LogicalModelFieldsLookupRT (b :: BackendType) (m :: Type -> Type) a
[runLogicalModelFieldsLookupRT] :: LogicalModelFieldsLookupRT (b :: BackendType) (m :: Type -> Type) a -> LogicalModelFieldsLookup b -> m a
runLogicalModelFieldsLookup :: forall x (b :: BackendType) m a. (x -> LogicalModelFields b) -> HashMap LogicalModelName x -> LogicalModelFieldsLookupRT b m a -> m a
instance GHC.Internal.Base.Applicative m => GHC.Internal.Base.Applicative (Hasura.LogicalModel.Fields.LogicalModelFieldsLookupRT b m)
instance GHC.Internal.Base.Functor m => GHC.Internal.Base.Functor (Hasura.LogicalModel.Fields.LogicalModelFieldsLookupRT b m)
instance GHC.Internal.Base.Monad m => Hasura.LogicalModel.Fields.LogicalModelFieldsRM b (Hasura.LogicalModel.Fields.LogicalModelFieldsLookupRT b m)
instance Hasura.LogicalModel.Fields.LogicalModelFieldsRM b m => Hasura.LogicalModel.Fields.LogicalModelFieldsRM b (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.LogicalModel.Fields.LogicalModelFieldsRM b m => Hasura.LogicalModel.Fields.LogicalModelFieldsRM b (Control.Monad.Trans.State.Strict.StateT s m)
instance Hasura.LogicalModel.Fields.LogicalModelFieldsRM b m => Hasura.LogicalModel.Fields.LogicalModelFieldsRM b (Hasura.Tracing.Monad.TraceT m)
instance (GHC.Internal.Base.Monoid w, Hasura.LogicalModel.Fields.LogicalModelFieldsRM b m) => Hasura.LogicalModel.Fields.LogicalModelFieldsRM b (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Hasura.LogicalModel.Fields.LogicalModelFieldsLookupRT b m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Hasura.LogicalModel.Fields.LogicalModelFieldsLookupRT b m)
instance GHC.Internal.Base.Monad m => GHC.Internal.Base.Monad (Hasura.LogicalModel.Fields.LogicalModelFieldsLookupRT b m)
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (Hasura.LogicalModel.Fields.LogicalModelFieldsLookupRT b m)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (Hasura.LogicalModel.Fields.LogicalModelFieldsLookupRT b m)
instance Control.Monad.Trans.Class.MonadTrans (Hasura.LogicalModel.Fields.LogicalModelFieldsLookupRT b)
instance Hasura.Backends.Postgres.Connection.MonadTx.MonadTx m => Hasura.Backends.Postgres.Connection.MonadTx.MonadTx (Hasura.LogicalModel.Fields.LogicalModelFieldsLookupRT b m)
instance Control.Monad.Writer.Class.MonadWriter w m => Control.Monad.Writer.Class.MonadWriter w (Hasura.LogicalModel.Fields.LogicalModelFieldsLookupRT b m)
instance Hasura.Authentication.User.UserInfoM m => Hasura.Authentication.User.UserInfoM (Hasura.LogicalModel.Fields.LogicalModelFieldsLookupRT b m)


-- | Connect to a postgres db and run queries. This module is meant for
--   simple one-off checks against a postgres database, such as health
--   checks or version checks, and not for normal work.
module Hasura.Backends.Postgres.Connection.Connect

-- | Connect to a postgres database and run a transaction.
withPostgresDB :: Environment -> SourceName -> PostgresConnConfiguration -> TxET QErr IO a -> IO (Either QErr a)

module Hasura.Backends.Postgres.Instances.PingSource
runCockroachDBPing :: Environment -> (String -> IO ()) -> SourceName -> PostgresConnConfiguration -> IO ()


-- | Check version compatability against postgres-like flavors.
module Hasura.Backends.Postgres.Connection.VersionCheck

-- | Check cockroachdb version compatability.
runCockroachVersionCheck :: Environment -> SourceName -> PostgresConnConfiguration -> IO (Either QErr ())

-- | Cockroach version
data CockroachDbVersion
CockroachDbVersion :: Word -> Word -> Word -> String -> CockroachDbVersion
[crdbMajor] :: CockroachDbVersion -> Word
[crdbMinor] :: CockroachDbVersion -> Word
[crdbPatch] :: CockroachDbVersion -> Word

-- | includes additional information such as "-beta.4"
[crdbRest] :: CockroachDbVersion -> String

-- | Parse a cockroachDB version string
parseCrdbVersion :: Text -> Either ParseError CockroachDbVersion

-- | Check version is &gt;= 22.2.0
--   <a>https://hasura.io/docs/latest/databases/postgres/cockroachdb/index</a>
crdbVersionIsSupported :: CockroachDbVersion -> Bool
instance GHC.Classes.Eq Hasura.Backends.Postgres.Connection.VersionCheck.CockroachDbVersion
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Connection.VersionCheck.CockroachDbVersion


-- | Postgres Instances Types
--   
--   Defines a <a>Backend</a> type class instance for Postgres.
module Hasura.Backends.Postgres.Instances.Types
instance (Hasura.RQL.Types.BackendTag.HasTag ('Hasura.RQL.Types.BackendType.Postgres pgKind), GHC.Internal.Data.Typeable.Internal.Typeable ('Hasura.RQL.Types.BackendType.Postgres pgKind), Hasura.Backends.Postgres.Instances.Types.PostgresBackend pgKind, Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.BackendType.BackendSourceKind ('Hasura.RQL.Types.BackendType.Postgres pgKind)), Autodocodec.Class.HasCodec (Hasura.RQL.Types.BackendType.BackendSourceKind ('Hasura.RQL.Types.BackendType.Postgres pgKind))) => Hasura.RQL.Types.Backend.Backend ('Hasura.RQL.Types.BackendType.Postgres pgKind)
instance Hasura.RQL.Types.BackendTag.HasTag ('Hasura.RQL.Types.BackendType.Postgres pgKind) => Hasura.RQL.Types.SourceConfiguration.HasSourceConfiguration ('Hasura.RQL.Types.BackendType.Postgres pgKind)
instance Hasura.Backends.Postgres.Instances.Types.PostgresBackend 'Hasura.RQL.Types.BackendType.Citus
instance Hasura.Backends.Postgres.Instances.Types.PostgresBackend 'Hasura.RQL.Types.BackendType.Cockroach
instance Hasura.Backends.Postgres.Instances.Types.PostgresBackend 'Hasura.RQL.Types.BackendType.Vanilla

module Hasura.RQL.Types.Instances

module Hasura.RQL.Types.Relationships.Remote
type RemoteRelationship = RemoteRelationshipG RemoteRelationshipDefinition

-- | Metadata representation of the internal definition of a remote
--   relationship.
data RemoteRelationshipDefinition

-- | Remote relationship targetting a source.
RelationshipToSource :: ToSourceRelationshipDef -> RemoteRelationshipDefinition

-- | Remote relationship targetting a remote schema.
RelationshipToSchema :: RRFormat -> ToSchemaRelationshipDef -> RemoteRelationshipDefinition

-- | Specify whether remote schema &lt;&gt; source relationships should be
--   built
data RemoteSourceRelationshipBuilder
IncludeRemoteSourceRelationship :: RemoteSourceRelationshipBuilder
ExcludeRemoteSourceRelationship :: RemoteSourceRelationshipBuilder

-- | Parse <a>RemoteRelationshipDefinition</a> letting the caller decide
--   how lenient to be.
--   
--   This is necessary because <a>RemoteRelationshipDefinition</a> is
--   parsed in different contexts. In <a>RemoteRelationship</a>, the
--   <a>RemoteRelationshipDefinition</a> is always parsed out from a
--   top-level @"definition" field. Thus, a legacy payload looks like this:
--   
--   <pre>
--   {
--     "name": "thing",
--     "definition": {
--       "remote_schema": "stuff",
--       "hasura_fields": ...
--       "remote_field": ...
--     }
--   }
--   </pre>
--   
--   and a new payload looks like this:
--   
--   <pre>
--   {
--     "name": "thing",
--     "definition": {
--       "to_remote_schema": {
--         "schema": "stuff",
--         "lhs_fields": ...
--         "remote_field": ...
--       }
--     }
--   }
--   </pre>
--   
--   In contrast, <tt>CreateFromSourceRelationship</tt> does not have a
--   top- level <tt>"definition"</tt> in its legacy format. Instead, the
--   legacy fields themselves are top-level:
--   
--   <pre>
--   {
--     "remote_schema": "stuff",
--     "hasura_fields": ...
--     "remote_field": ...
--   }
--   </pre>
--   
--   Furthermore, the presence of a <tt>"definition"</tt> field is used to
--   detect that the new payload is being used:
--   
--   <pre>
--   {
--     "definition": {
--       "to_remote_schema": {
--         "schema": "stuff",
--         "lhs_fields": ...
--         "remote_field": ...
--       }
--     }
--   }
--   </pre>
--   
--   In this latter case, we should not allow <tt>"remote_schema"</tt> to
--   appear under <tt>"definition"</tt>.
parseRemoteRelationshipDefinition :: RRParseMode -> Value -> Parser RemoteRelationshipDefinition

-- | Represents the format of the metadata a remote relationship was read
--   from and must be written back as. We don't have a good way of doing
--   metadata versioning yet, and we therefore use this to keep track of
--   the format used.
data RRFormat

-- | The remote relationship was parsed from the old format, that was only
--   used only for db-to-rs schemas.
RRFOldDBToRemoteSchema :: RRFormat

-- | The remote relationship was parsed from the new unified format.
RRFUnifiedFormat :: RRFormat

-- | Whether to accept legacy fields when parsing
--   <a>RemoteRelationshipDefinition</a>
data RRParseMode

-- | Only allow legacy fields when parsing
--   <a>RemoteRelationshipDefinition</a>
RRPLegacy :: RRParseMode

-- | Allow legacy fields when parsing <a>RemoteRelationshipDefinition</a>
RRPLenient :: RRParseMode

-- | Reject legacy fields when parsing <a>RemoteRelationshipDefinition</a>
RRPStrict :: RRParseMode
_RelationshipToSource :: Prism' RemoteRelationshipDefinition ToSourceRelationshipDef
_RelationshipToSchema :: Prism' RemoteRelationshipDefinition (RRFormat, ToSchemaRelationshipDef)
rrName :: forall def f. Functor f => (RelName -> f RelName) -> RemoteRelationshipG def -> f (RemoteRelationshipG def)
rrDefinition :: forall def def' f. Functor f => (def -> f def') -> RemoteRelationshipG def -> f (RemoteRelationshipG def')

-- | Schema cache information for a table field targeting a remote schema.
data RemoteSchemaFieldInfo
RemoteSchemaFieldInfo :: RelName -> HashMap Name RemoteSchemaInputValueDefinition -> RemoteFields -> RemoteSchemaInfo -> [TypeDefinition [Name] RemoteSchemaInputValueDefinition] -> RemoteSchemaName -> LHSIdentifier -> RemoteSchemaFieldInfo

-- | Field name to which we'll map the remote in hasura; this becomes part
--   of the hasura schema.
[_rrfiName] :: RemoteSchemaFieldInfo -> RelName

-- | Input arguments to the remote field info; The <tt>_rfiParamMap</tt>
--   will only include the arguments to the remote field that is being
--   joined. The names of the arguments here are modified, it will be in
--   the format of <a>Field Name</a>_remote_rel_<a>table
--   schema</a>_<a>table name</a><a>relationship name</a>
[_rrfiParamMap] :: RemoteSchemaFieldInfo -> HashMap Name RemoteSchemaInputValueDefinition
[_rrfiRemoteFields] :: RemoteSchemaFieldInfo -> RemoteFields
[_rrfiRemoteSchema] :: RemoteSchemaFieldInfo -> RemoteSchemaInfo

-- | The new input value definitions created for this remote field
[_rrfiInputValueDefinitions] :: RemoteSchemaFieldInfo -> [TypeDefinition [Name] RemoteSchemaInputValueDefinition]

-- | Name of the remote schema, that's used for joining
[_rrfiRemoteSchemaName] :: RemoteSchemaFieldInfo -> RemoteSchemaName

-- | TODO: this one should be gone when <tt>validateRemoteRelationship</tt>
--   function is cleaned up
[_rrfiLHSIdentifier] :: RemoteSchemaFieldInfo -> LHSIdentifier

-- | Schema cache information for a table field targeting a remote source.
data RemoteSourceFieldInfo (tgt :: BackendType)
RemoteSourceFieldInfo :: RelName -> RelType -> SourceName -> SourceConfig tgt -> TableName tgt -> HashMap FieldName (ScalarType tgt, Column tgt) -> RemoteSourceFieldInfo (tgt :: BackendType)
[_rsfiName] :: RemoteSourceFieldInfo (tgt :: BackendType) -> RelName
[_rsfiType] :: RemoteSourceFieldInfo (tgt :: BackendType) -> RelType
[_rsfiSource] :: RemoteSourceFieldInfo (tgt :: BackendType) -> SourceName
[_rsfiSourceConfig] :: RemoteSourceFieldInfo (tgt :: BackendType) -> SourceConfig tgt

-- | this is parsed from <a>Value</a>
[_rsfiTable] :: RemoteSourceFieldInfo (tgt :: BackendType) -> TableName tgt

-- | LHS field name -&gt; RHS Column, RHS Column type
[_rsfiMapping] :: RemoteSourceFieldInfo (tgt :: BackendType) -> HashMap FieldName (ScalarType tgt, Column tgt)

-- | Resolved remote relationship's RHS
data RemoteFieldInfoRHS
RFISchema :: RemoteSchemaFieldInfo -> RemoteFieldInfoRHS
RFISource :: AnyBackend RemoteSourceFieldInfo -> RemoteFieldInfoRHS

-- | Resolved remote relationship, as stored in the schema cache.
data RemoteFieldInfo lhsJoinField
RemoteFieldInfo :: HashMap FieldName lhsJoinField -> RemoteFieldInfoRHS -> RemoteFieldInfo lhsJoinField
[_rfiLHS] :: RemoteFieldInfo lhsJoinField -> HashMap FieldName lhsJoinField
[_rfiRHS] :: RemoteFieldInfo lhsJoinField -> RemoteFieldInfoRHS

-- | Information about the field on the LHS of a join against a remote
--   schema.
data DBJoinField (b :: BackendType)
JoinColumn :: Column b -> ColumnType b -> DBJoinField (b :: BackendType)
JoinComputedField :: ScalarComputedField b -> DBJoinField (b :: BackendType)

-- | Information about a computed field appearing on the LHS of a remote
--   join. FIXME: why do we need all of this?
data ScalarComputedField (b :: BackendType)
ScalarComputedField :: XComputedField b -> ComputedFieldName -> FunctionName b -> ComputedFieldImplicitArguments b -> ScalarType b -> ScalarComputedField (b :: BackendType)
[_scfXField] :: ScalarComputedField (b :: BackendType) -> XComputedField b
[_scfName] :: ScalarComputedField (b :: BackendType) -> ComputedFieldName
[_scfFunction] :: ScalarComputedField (b :: BackendType) -> FunctionName b
[_scfComputedFieldImplicitArgs] :: ScalarComputedField (b :: BackendType) -> ComputedFieldImplicitArguments b
[_scfType] :: ScalarComputedField (b :: BackendType) -> ScalarType b
graphQLValueToJSON :: Value Void -> Value
newtype LHSIdentifier
LHSIdentifier :: Text -> LHSIdentifier
[getLHSIdentifier] :: LHSIdentifier -> Text
tableNameToLHSIdentifier :: forall (b :: BackendType). Backend b => TableName b -> LHSIdentifier
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Relationships.Remote.DBJoinField b)
instance GHC.Classes.Eq Hasura.RQL.Types.Relationships.Remote.RRFormat
instance GHC.Classes.Eq Hasura.RQL.Types.Relationships.Remote.RRParseMode
instance GHC.Classes.Eq lhsJoinField => GHC.Classes.Eq (Hasura.RQL.Types.Relationships.Remote.RemoteFieldInfo lhsJoinField)
instance GHC.Classes.Eq Hasura.RQL.Types.Relationships.Remote.RemoteFieldInfoRHS
instance GHC.Classes.Eq Hasura.RQL.Types.Relationships.Remote.RemoteRelationshipDefinition
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Relationships.Remote.ScalarComputedField b)
instance (TypeError ...) => Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Relationships.Remote.RemoteRelationshipDefinition
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Relationships.Remote.RemoteRelationship
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Relationships.Remote.DBJoinField b)
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Relationships.Remote.RRFormat
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Relationships.Remote.RRParseMode
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Relationships.Remote.RemoteFieldInfo lhsJoinField)
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Relationships.Remote.RemoteFieldInfoRHS
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Relationships.Remote.RemoteRelationshipDefinition
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Relationships.Remote.ScalarComputedField b)
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Relationships.Remote.RemoteRelationship
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.Relationships.Remote.DBJoinField b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.Relationships.Remote.ScalarComputedField b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.Types.Relationships.Remote.DBJoinField b)
instance GHC.Internal.Show.Show Hasura.RQL.Types.Relationships.Remote.RRFormat
instance GHC.Internal.Show.Show Hasura.RQL.Types.Relationships.Remote.RRParseMode
instance GHC.Internal.Show.Show Hasura.RQL.Types.Relationships.Remote.RemoteRelationshipDefinition
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.Types.Relationships.Remote.ScalarComputedField b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Relationships.Remote.DBJoinField b)
instance Data.Aeson.Types.ToJSON.ToJSON lhsJoinField => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Relationships.Remote.RemoteFieldInfo lhsJoinField)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Relationships.Remote.RemoteFieldInfoRHS
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Relationships.Remote.RemoteRelationshipDefinition
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Relationships.Remote.ScalarComputedField b)

module Hasura.Table.Cache

-- | This type is only used as an intermediate type to combine more than
--   one select permissions for inherited roles.
data CombinedSelPermInfo (b :: BackendType)
CombinedSelPermInfo :: [HashMap (Column b) (AnnRedactionExpPartialSQL b)] -> [HashMap ComputedFieldName (AnnRedactionExpPartialSQL b)] -> [AnnBoolExpPartialSQL b] -> Maybe (Max Int) -> Any -> HashSet Text -> AllowedRootFields QueryRootFieldType -> AllowedRootFields SubscriptionRootFieldType -> CombinedSelPermInfo (b :: BackendType)
[cspiCols] :: CombinedSelPermInfo (b :: BackendType) -> [HashMap (Column b) (AnnRedactionExpPartialSQL b)]
[cspiComputedFields] :: CombinedSelPermInfo (b :: BackendType) -> [HashMap ComputedFieldName (AnnRedactionExpPartialSQL b)]
[cspiFilter] :: CombinedSelPermInfo (b :: BackendType) -> [AnnBoolExpPartialSQL b]
[cspiLimit] :: CombinedSelPermInfo (b :: BackendType) -> Maybe (Max Int)
[cspiAllowAgg] :: CombinedSelPermInfo (b :: BackendType) -> Any
[cspiRequiredHeaders] :: CombinedSelPermInfo (b :: BackendType) -> HashSet Text
[cspiAllowedQueryRootFieldTypes] :: CombinedSelPermInfo (b :: BackendType) -> AllowedRootFields QueryRootFieldType
[cspiAllowedSubscriptionRootFieldTypes] :: CombinedSelPermInfo (b :: BackendType) -> AllowedRootFields SubscriptionRootFieldType
data Constraint (b :: BackendType)
Constraint :: ConstraintName b -> OID -> Constraint (b :: BackendType)
[_cName] :: Constraint (b :: BackendType) -> ConstraintName b
[_cOid] :: Constraint (b :: BackendType) -> OID
data ColumnConfig
ColumnConfig :: Maybe Name -> Comment -> ColumnConfig
[_ccfgCustomName] :: ColumnConfig -> Maybe Name
[_ccfgComment] :: ColumnConfig -> Comment
data CustomRootField
CustomRootField :: Maybe Name -> Comment -> CustomRootField
[_crfName] :: CustomRootField -> Maybe Name
[_crfComment] :: CustomRootField -> Comment

-- | Metadata of any Backend table which is being extracted from source
--   database
data DBTableMetadata (b :: BackendType)
DBTableMetadata :: OID -> [RawColumnInfo b] -> Maybe (PrimaryKey b (Column b)) -> HashSet (UniqueConstraint b) -> HashSet (ForeignKeyMetadata b) -> Maybe ViewInfo -> Maybe PGDescription -> ExtraTableMetadata b -> DBTableMetadata (b :: BackendType)
[_ptmiOid] :: DBTableMetadata (b :: BackendType) -> OID
[_ptmiColumns] :: DBTableMetadata (b :: BackendType) -> [RawColumnInfo b]
[_ptmiPrimaryKey] :: DBTableMetadata (b :: BackendType) -> Maybe (PrimaryKey b (Column b))

-- | Does <i>not</i> include the primary key
[_ptmiUniqueConstraints] :: DBTableMetadata (b :: BackendType) -> HashSet (UniqueConstraint b)
[_ptmiForeignKeys] :: DBTableMetadata (b :: BackendType) -> HashSet (ForeignKeyMetadata b)
[_ptmiViewInfo] :: DBTableMetadata (b :: BackendType) -> Maybe ViewInfo
[_ptmiDescription] :: DBTableMetadata (b :: BackendType) -> Maybe PGDescription
[_ptmiExtraTableMetadata] :: DBTableMetadata (b :: BackendType) -> ExtraTableMetadata b
type DBTablesMetadata (b :: BackendType) = HashMap TableName b DBTableMetadata b
data DelPermInfo (b :: BackendType)
DelPermInfo :: TableName b -> AnnBoolExpPartialSQL b -> !Bool -> HashSet Text -> Maybe (ValidateInput ResolvedWebhook) -> DelPermInfo (b :: BackendType)
[dpiTable] :: DelPermInfo (b :: BackendType) -> TableName b
[dpiFilter] :: DelPermInfo (b :: BackendType) -> AnnBoolExpPartialSQL b
[dpiBackendOnly] :: DelPermInfo (b :: BackendType) -> !Bool
[dpiRequiredHeaders] :: DelPermInfo (b :: BackendType) -> HashSet Text
[dpiValidateInput] :: DelPermInfo (b :: BackendType) -> Maybe (ValidateInput ResolvedWebhook)
data FieldInfo (b :: BackendType)
FIColumn :: StructuredColumnInfo b -> FieldInfo (b :: BackendType)
FIRelationship :: RelInfo b -> FieldInfo (b :: BackendType)
FIComputedField :: ComputedFieldInfo b -> FieldInfo (b :: BackendType)
FIRemoteRelationship :: RemoteFieldInfo (DBJoinField b) -> FieldInfo (b :: BackendType)
type FieldInfoMap = HashMap FieldName
data ForeignKey (b :: BackendType)
ForeignKey :: Constraint b -> TableName b -> NEHashMap (ColumnPath b) (ColumnPath b) -> ForeignKey (b :: BackendType)
[_fkConstraint] :: ForeignKey (b :: BackendType) -> Constraint b
[_fkForeignTable] :: ForeignKey (b :: BackendType) -> TableName b
[_fkColumnMapping] :: ForeignKey (b :: BackendType) -> NEHashMap (ColumnPath b) (ColumnPath b)

-- | Metadata of a Postgres foreign key constraint which is being extracted
--   from database via 'src-rsr/pg_table_metadata.sql'
newtype ForeignKeyMetadata (b :: BackendType)
ForeignKeyMetadata :: ForeignKey b -> ForeignKeyMetadata (b :: BackendType)
[unForeignKeyMetadata] :: ForeignKeyMetadata (b :: BackendType) -> ForeignKey b

-- | A wrapper around <a>GType</a> which allows us to define custom JSON
--   instances.
--   
--   TODO: this name is ambiguous, and conflicts with
--   Hasura.RQL.DDL.RemoteSchema.Permission.GraphQLType; it should perhaps
--   be renamed, made internal to this module, or removed altogether?
newtype GraphQLType
GraphQLType :: GType -> GraphQLType
[unGraphQLType] :: GraphQLType -> GType
data InsPermInfo (b :: BackendType)
InsPermInfo :: HashSet (Column b) -> AnnBoolExpPartialSQL b -> PreSetColsPartial b -> Bool -> HashSet Text -> Maybe (ValidateInput ResolvedWebhook) -> InsPermInfo (b :: BackendType)
[ipiCols] :: InsPermInfo (b :: BackendType) -> HashSet (Column b)
[ipiCheck] :: InsPermInfo (b :: BackendType) -> AnnBoolExpPartialSQL b
[ipiSet] :: InsPermInfo (b :: BackendType) -> PreSetColsPartial b
[ipiBackendOnly] :: InsPermInfo (b :: BackendType) -> Bool
[ipiRequiredHeaders] :: InsPermInfo (b :: BackendType) -> HashSet Text
[ipiValidateInput] :: InsPermInfo (b :: BackendType) -> Maybe (ValidateInput ResolvedWebhook)
data PrimaryKey (b :: BackendType) a
PrimaryKey :: Constraint b -> NESeq a -> PrimaryKey (b :: BackendType) a
[_pkConstraint] :: PrimaryKey (b :: BackendType) a -> Constraint b
[_pkColumns] :: PrimaryKey (b :: BackendType) a -> NESeq a
data RolePermInfo (b :: BackendType)
RolePermInfo :: Maybe (InsPermInfo b) -> Maybe (SelPermInfo b) -> Maybe (UpdPermInfo b) -> Maybe (DelPermInfo b) -> RolePermInfo (b :: BackendType)
[_permIns] :: RolePermInfo (b :: BackendType) -> Maybe (InsPermInfo b)
[_permSel] :: RolePermInfo (b :: BackendType) -> Maybe (SelPermInfo b)
[_permUpd] :: RolePermInfo (b :: BackendType) -> Maybe (UpdPermInfo b)
[_permDel] :: RolePermInfo (b :: BackendType) -> Maybe (DelPermInfo b)
type RolePermInfoMap (b :: BackendType) = HashMap RoleName RolePermInfo b
data SelPermInfo (b :: BackendType)
SelPermInfo :: HashMap (Column b) (AnnRedactionExpPartialSQL b) -> HashMap ComputedFieldName (AnnRedactionExpPartialSQL b) -> AnnBoolExpPartialSQL b -> Maybe Int -> Bool -> HashSet Text -> AllowedRootFields QueryRootFieldType -> AllowedRootFields SubscriptionRootFieldType -> SelPermInfo (b :: BackendType)

-- | HashMap of accessible columns to the role, the <a>Column</a> may be
--   mapped to an <a>AnnRedactionExpPartialSQL</a>, which is
--   <a>RedactIfFalse</a> only in the case of an inherited role, for a
--   non-inherited role, it will always be <a>NoRedaction</a>. The
--   <a>RedactIfFalse</a> bool exp will determine if the column should be
--   nullified in a row, when there aren't requisite permissions.
[spiCols] :: SelPermInfo (b :: BackendType) -> HashMap (Column b) (AnnRedactionExpPartialSQL b)

-- | HashMap of accessible computed fields to the role, mapped to
--   <a>AnnRedactionExpPartialSQL</a>, simililar to <a>spiCols</a>. These
--   computed fields do not return rows of existing table.
[spiComputedFields] :: SelPermInfo (b :: BackendType) -> HashMap ComputedFieldName (AnnRedactionExpPartialSQL b)
[spiFilter] :: SelPermInfo (b :: BackendType) -> AnnBoolExpPartialSQL b
[spiLimit] :: SelPermInfo (b :: BackendType) -> Maybe Int
[spiAllowAgg] :: SelPermInfo (b :: BackendType) -> Bool
[spiRequiredHeaders] :: SelPermInfo (b :: BackendType) -> HashSet Text

-- | allowed root field types to be exposed in the query_root
[spiAllowedQueryRootFields] :: SelPermInfo (b :: BackendType) -> AllowedRootFields QueryRootFieldType

-- | allowed root field types to be exposed in the subscription_root
[spiAllowedSubscriptionRootFields] :: SelPermInfo (b :: BackendType) -> AllowedRootFields SubscriptionRootFieldType
type TableCache (b :: BackendType) = HashMap TableName b TableInfo b
data TableConfig (b :: BackendType)
TableConfig :: TableCustomRootFields -> HashMap (Column b) ColumnConfig -> Maybe Name -> Comment -> TableConfig (b :: BackendType)
[_tcCustomRootFields] :: TableConfig (b :: BackendType) -> TableCustomRootFields
[_tcColumnConfig] :: TableConfig (b :: BackendType) -> HashMap (Column b) ColumnConfig
[_tcCustomName] :: TableConfig (b :: BackendType) -> Maybe Name
[_tcComment] :: TableConfig (b :: BackendType) -> Comment
type TableCoreCache (b :: BackendType) = HashMap TableName b TableCoreInfo b

-- | Fully-processed table info that includes non-column fields.
type TableCoreInfo (b :: BackendType) = TableCoreInfoG b FieldInfo b ColumnInfo b
type TableEventTriggers (b :: BackendType) = HashMap TableName b [TriggerName]

-- | The <tt>field</tt> and <tt>primaryKeyColumn</tt> type parameters vary
--   as the schema cache is built and more information is accumulated. See
--   also <a>TableCoreInfo</a>.
data TableCoreInfoG (b :: BackendType) field primaryKeyColumn
TableCoreInfo :: TableName b -> Maybe PGDescription -> FieldInfoMap field -> Maybe (PrimaryKey b primaryKeyColumn) -> HashSet (UniqueConstraint b) -> HashSet (ForeignKey b) -> Maybe ViewInfo -> Maybe EnumValues -> TableConfig b -> ExtraTableMetadata b -> Maybe ApolloFederationConfig -> [RawColumnInfo b] -> TableCoreInfoG (b :: BackendType) field primaryKeyColumn
[_tciName] :: TableCoreInfoG (b :: BackendType) field primaryKeyColumn -> TableName b
[_tciDescription] :: TableCoreInfoG (b :: BackendType) field primaryKeyColumn -> Maybe PGDescription
[_tciFieldInfoMap] :: TableCoreInfoG (b :: BackendType) field primaryKeyColumn -> FieldInfoMap field
[_tciPrimaryKey] :: TableCoreInfoG (b :: BackendType) field primaryKeyColumn -> Maybe (PrimaryKey b primaryKeyColumn)

-- | Does <i>not</i> include the primary key; use
--   <tt>tciUniqueOrPrimaryKeyConstraints</tt> if you need both.
[_tciUniqueConstraints] :: TableCoreInfoG (b :: BackendType) field primaryKeyColumn -> HashSet (UniqueConstraint b)
[_tciForeignKeys] :: TableCoreInfoG (b :: BackendType) field primaryKeyColumn -> HashSet (ForeignKey b)
[_tciViewInfo] :: TableCoreInfoG (b :: BackendType) field primaryKeyColumn -> Maybe ViewInfo
[_tciEnumValues] :: TableCoreInfoG (b :: BackendType) field primaryKeyColumn -> Maybe EnumValues
[_tciCustomConfig] :: TableCoreInfoG (b :: BackendType) field primaryKeyColumn -> TableConfig b
[_tciExtraTableMetadata] :: TableCoreInfoG (b :: BackendType) field primaryKeyColumn -> ExtraTableMetadata b
[_tciApolloFederationConfig] :: TableCoreInfoG (b :: BackendType) field primaryKeyColumn -> Maybe ApolloFederationConfig
[_tciRawColumns] :: TableCoreInfoG (b :: BackendType) field primaryKeyColumn -> [RawColumnInfo b]
data TableCustomRootFields
TableCustomRootFields :: CustomRootField -> CustomRootField -> CustomRootField -> CustomRootField -> CustomRootField -> CustomRootField -> CustomRootField -> CustomRootField -> CustomRootField -> CustomRootField -> CustomRootField -> TableCustomRootFields
[_tcrfSelect] :: TableCustomRootFields -> CustomRootField
[_tcrfSelectByPk] :: TableCustomRootFields -> CustomRootField
[_tcrfSelectAggregate] :: TableCustomRootFields -> CustomRootField
[_tcrfSelectStream] :: TableCustomRootFields -> CustomRootField
[_tcrfInsert] :: TableCustomRootFields -> CustomRootField
[_tcrfInsertOne] :: TableCustomRootFields -> CustomRootField
[_tcrfUpdate] :: TableCustomRootFields -> CustomRootField
[_tcrfUpdateByPk] :: TableCustomRootFields -> CustomRootField
[_tcrfUpdateMany] :: TableCustomRootFields -> CustomRootField
[_tcrfDelete] :: TableCustomRootFields -> CustomRootField
[_tcrfDeleteByPk] :: TableCustomRootFields -> CustomRootField
data TableInfo (b :: BackendType)
TableInfo :: TableCoreInfo b -> RolePermInfoMap b -> EventTriggerInfoMap b -> RolePermInfo b -> TableInfo (b :: BackendType)
[_tiCoreInfo] :: TableInfo (b :: BackendType) -> TableCoreInfo b
[_tiRolePermInfoMap] :: TableInfo (b :: BackendType) -> RolePermInfoMap b
[_tiEventTriggerInfoMap] :: TableInfo (b :: BackendType) -> EventTriggerInfoMap b
[_tiAdminRolePermInfo] :: TableInfo (b :: BackendType) -> RolePermInfo b

-- | Data type modelling uniqueness constraints. Occasionally this will
--   include primary keys, although those are tracked separately in
--   <a>TableCoreInfoG</a>.
--   
--   For more information about unique constraints, visit the postgresql
--   documentation:
--   <a>https://www.postgresql.org/docs/current/ddl-constraints.html#DDL-CONSTRAINTS-UNIQUE-CONSTRAINTS</a>.
data UniqueConstraint (b :: BackendType)
UniqueConstraint :: Constraint b -> HashSet (Column b) -> UniqueConstraint (b :: BackendType)

-- | The postgresql name and object id of a unique constraint.
[_ucConstraint] :: UniqueConstraint (b :: BackendType) -> Constraint b

-- | The set of columns which should be unique for this particular
--   constraint. Used for permissions calculation.
[_ucColumns] :: UniqueConstraint (b :: BackendType) -> HashSet (Column b)
data UpdPermInfo (b :: BackendType)
UpdPermInfo :: HashSet (Column b) -> TableName b -> AnnBoolExpPartialSQL b -> Maybe (AnnBoolExpPartialSQL b) -> PreSetColsPartial b -> Bool -> HashSet Text -> Maybe (ValidateInput ResolvedWebhook) -> UpdPermInfo (b :: BackendType)
[upiCols] :: UpdPermInfo (b :: BackendType) -> HashSet (Column b)
[upiTable] :: UpdPermInfo (b :: BackendType) -> TableName b
[upiFilter] :: UpdPermInfo (b :: BackendType) -> AnnBoolExpPartialSQL b
[upiCheck] :: UpdPermInfo (b :: BackendType) -> Maybe (AnnBoolExpPartialSQL b)
[upiSet] :: UpdPermInfo (b :: BackendType) -> PreSetColsPartial b
[upiBackendOnly] :: UpdPermInfo (b :: BackendType) -> Bool
[upiRequiredHeaders] :: UpdPermInfo (b :: BackendType) -> HashSet Text
[upiValidateInput] :: UpdPermInfo (b :: BackendType) -> Maybe (ValidateInput ResolvedWebhook)
data ViewInfo
ViewInfo :: Bool -> Bool -> Bool -> ViewInfo
[viIsUpdatable] :: ViewInfo -> Bool
[viIsDeletable] :: ViewInfo -> Bool
[viIsInsertable] :: ViewInfo -> Bool
askColInfo :: forall m (backend :: BackendType). (MonadError QErr m, Backend backend) => FieldInfoMap (FieldInfo backend) -> Column backend -> Text -> m (ColumnInfo backend)
askColumnType :: forall m (backend :: BackendType). (MonadError QErr m, Backend backend) => FieldInfoMap (FieldInfo backend) -> Column backend -> Text -> m (ColumnType backend)
askFieldInfo :: MonadError QErr m => FieldInfoMap fieldInfo -> FieldName -> m fieldInfo
assertColumnExists :: forall (backend :: BackendType) m. (MonadError QErr m, Backend backend) => FieldInfoMap (FieldInfo backend) -> Text -> Column backend -> m ()
askRelType :: forall m (backend :: BackendType). MonadError QErr m => FieldInfoMap (FieldInfo backend) -> RelName -> Text -> m (RelInfo backend)
askComputedFieldInfo :: forall m (backend :: BackendType). MonadError QErr m => FieldInfoMap (FieldInfo backend) -> ComputedFieldName -> m (ComputedFieldInfo backend)
askRemoteRel :: forall m (backend :: BackendType). MonadError QErr m => FieldInfoMap (FieldInfo backend) -> RelName -> m (RemoteFieldInfo (DBJoinField backend))
combinedSelPermInfoToSelPermInfo :: forall (b :: BackendType). Backend b => Int -> CombinedSelPermInfo b -> SelPermInfo b
emptyCustomRootFields :: TableCustomRootFields
emptyTableConfig :: forall (b :: BackendType). TableConfig b
fieldInfoGraphQLName :: forall (b :: BackendType). FieldInfo b -> Maybe Name

-- | Returns all the field names created for the given field. Columns,
--   object relationships, and computed fields only ever produce a single
--   field, but array relationships also contain an <tt>_aggregate</tt>
--   field.
fieldInfoGraphQLNames :: forall (b :: BackendType). FieldInfo b -> [Name]
fieldInfoName :: forall (b :: BackendType). Backend b => FieldInfo b -> FieldName
getAllCustomRootFields :: TableCustomRootFields -> [CustomRootField]
getCols :: forall (backend :: BackendType). FieldInfoMap (FieldInfo backend) -> [StructuredColumnInfo backend]
getColumnInfoM :: forall (b :: BackendType). TableInfo b -> FieldName -> Maybe (ColumnInfo b)
getComputedFieldInfos :: forall (backend :: BackendType). FieldInfoMap (FieldInfo backend) -> [ComputedFieldInfo backend]
getFieldInfoM :: forall (b :: BackendType). TableInfo b -> FieldName -> Maybe (FieldInfo b)
getRels :: forall (backend :: BackendType). FieldInfoMap (FieldInfo backend) -> [RelInfo backend]
getRemoteFieldInfoName :: RemoteFieldInfo lhsJoinField -> RelName
isListType :: GraphQLType -> Bool
isMutable :: (ViewInfo -> Bool) -> Maybe ViewInfo -> Bool
isNullableType :: GraphQLType -> Bool
mkAdminRolePermInfo :: forall (b :: BackendType). Backend b => TableCoreInfo b -> RolePermInfo b
permDel :: forall (b :: BackendType) f. Functor f => (Maybe (DelPermInfo b) -> f (Maybe (DelPermInfo b))) -> RolePermInfo b -> f (RolePermInfo b)
permIns :: forall (b :: BackendType) f. Functor f => (Maybe (InsPermInfo b) -> f (Maybe (InsPermInfo b))) -> RolePermInfo b -> f (RolePermInfo b)
permSel :: forall (b :: BackendType) f. Functor f => (Maybe (SelPermInfo b) -> f (Maybe (SelPermInfo b))) -> RolePermInfo b -> f (RolePermInfo b)
permUpd :: forall (b :: BackendType) f. Functor f => (Maybe (UpdPermInfo b) -> f (Maybe (UpdPermInfo b))) -> RolePermInfo b -> f (RolePermInfo b)
pkColumns :: forall (b :: BackendType) a1 a2 f. Functor f => (NESeq a1 -> f (NESeq a2)) -> PrimaryKey b a1 -> f (PrimaryKey b a2)
pkConstraint :: forall (b1 :: BackendType) a (b2 :: BackendType) f. Functor f => (Constraint b1 -> f (Constraint b2)) -> PrimaryKey b1 a -> f (PrimaryKey b2 a)

-- | Sort columns based on their ordinal position
sortCols :: forall (backend :: BackendType). [ColumnInfo backend] -> [ColumnInfo backend]
tableInfoName :: forall (b :: BackendType). TableInfo b -> TableName b
getRolePermInfo :: forall (b :: BackendType). RoleName -> TableInfo b -> RolePermInfo b
tableArrayRelationships :: forall (b :: BackendType). TableInfo b -> [RelInfo b]
tcCustomName :: forall (b :: BackendType) f. Functor f => (Maybe Name -> f (Maybe Name)) -> TableConfig b -> f (TableConfig b)
tcCustomRootFields :: forall (b :: BackendType) f. Functor f => (TableCustomRootFields -> f TableCustomRootFields) -> TableConfig b -> f (TableConfig b)
tcComment :: forall (b :: BackendType) f. Functor f => (Comment -> f Comment) -> TableConfig b -> f (TableConfig b)
tcColumnConfig :: forall (b1 :: BackendType) (b2 :: BackendType) f. Functor f => (HashMap (Column b1) ColumnConfig -> f (HashMap (Column b2) ColumnConfig)) -> TableConfig b1 -> f (TableConfig b2)
tciCustomConfig :: forall (b :: BackendType) field primaryKeyColumn f. Functor f => (TableConfig b -> f (TableConfig b)) -> TableCoreInfoG b field primaryKeyColumn -> f (TableCoreInfoG b field primaryKeyColumn)
tciDescription :: forall (b :: BackendType) field primaryKeyColumn f. Functor f => (Maybe PGDescription -> f (Maybe PGDescription)) -> TableCoreInfoG b field primaryKeyColumn -> f (TableCoreInfoG b field primaryKeyColumn)
tciApolloFederationConfig :: forall (b :: BackendType) field primaryKeyColumn f. Functor f => (Maybe ApolloFederationConfig -> f (Maybe ApolloFederationConfig)) -> TableCoreInfoG b field primaryKeyColumn -> f (TableCoreInfoG b field primaryKeyColumn)
tciEnumValues :: forall (b :: BackendType) field primaryKeyColumn f. Functor f => (Maybe EnumValues -> f (Maybe EnumValues)) -> TableCoreInfoG b field primaryKeyColumn -> f (TableCoreInfoG b field primaryKeyColumn)
tciExtraTableMetadata :: forall (b :: BackendType) field primaryKeyColumn f. Functor f => (ExtraTableMetadata b -> f (ExtraTableMetadata b)) -> TableCoreInfoG b field primaryKeyColumn -> f (TableCoreInfoG b field primaryKeyColumn)
tciFieldInfoMap :: forall (b :: BackendType) field1 primaryKeyColumn field2 f. Functor f => (FieldInfoMap field1 -> f (FieldInfoMap field2)) -> TableCoreInfoG b field1 primaryKeyColumn -> f (TableCoreInfoG b field2 primaryKeyColumn)
tciForeignKeys :: forall (b :: BackendType) field primaryKeyColumn f. Functor f => (HashSet (ForeignKey b) -> f (HashSet (ForeignKey b))) -> TableCoreInfoG b field primaryKeyColumn -> f (TableCoreInfoG b field primaryKeyColumn)
tciName :: forall (b :: BackendType) field primaryKeyColumn f. Functor f => (TableName b -> f (TableName b)) -> TableCoreInfoG b field primaryKeyColumn -> f (TableCoreInfoG b field primaryKeyColumn)
tciPrimaryKey :: forall (b :: BackendType) field primaryKeyColumn1 primaryKeyColumn2 f. Functor f => (Maybe (PrimaryKey b primaryKeyColumn1) -> f (Maybe (PrimaryKey b primaryKeyColumn2))) -> TableCoreInfoG b field primaryKeyColumn1 -> f (TableCoreInfoG b field primaryKeyColumn2)
tciUniqueConstraints :: forall (b :: BackendType) field primaryKeyColumn f. Functor f => (HashSet (UniqueConstraint b) -> f (HashSet (UniqueConstraint b))) -> TableCoreInfoG b field primaryKeyColumn -> f (TableCoreInfoG b field primaryKeyColumn)
tciUniqueOrPrimaryKeyConstraints :: forall (b :: BackendType) f. Hashable (Column b) => TableCoreInfoG b f (ColumnInfo b) -> Maybe (NonEmpty (UniqueConstraint b))
tciViewInfo :: forall (b :: BackendType) field primaryKeyColumn f. Functor f => (Maybe ViewInfo -> f (Maybe ViewInfo)) -> TableCoreInfoG b field primaryKeyColumn -> f (TableCoreInfoG b field primaryKeyColumn)
tciRawColumns :: forall (b :: BackendType) field primaryKeyColumn f. Functor f => ([RawColumnInfo b] -> f [RawColumnInfo b]) -> TableCoreInfoG b field primaryKeyColumn -> f (TableCoreInfoG b field primaryKeyColumn)
tiAdminRolePermInfo :: forall (b :: BackendType) f. Functor f => (RolePermInfo b -> f (RolePermInfo b)) -> TableInfo b -> f (TableInfo b)
tiCoreInfo :: forall (b :: BackendType) f. Functor f => (TableCoreInfo b -> f (TableCoreInfo b)) -> TableInfo b -> f (TableInfo b)
tiEventTriggerInfoMap :: forall (b :: BackendType) f. Functor f => (EventTriggerInfoMap b -> f (EventTriggerInfoMap b)) -> TableInfo b -> f (TableInfo b)
tiName :: forall (b :: BackendType) f. Functor f => (TableName b -> f (TableName b)) -> TableInfo b -> f (TableInfo b)
tiRolePermInfoMap :: forall (b :: BackendType) f. Functor f => (RolePermInfoMap b -> f (RolePermInfoMap b)) -> TableInfo b -> f (TableInfo b)
_FIColumn :: forall (b :: BackendType) p f. (Choice p, Applicative f) => p (StructuredColumnInfo b) (f (StructuredColumnInfo b)) -> p (FieldInfo b) (f (FieldInfo b))
_FIComputedField :: forall (b :: BackendType) p f. (Choice p, Applicative f) => p (ComputedFieldInfo b) (f (ComputedFieldInfo b)) -> p (FieldInfo b) (f (FieldInfo b))
_FIRelationship :: forall (b :: BackendType) p f. (Choice p, Applicative f) => p (RelInfo b) (f (RelInfo b)) -> p (FieldInfo b) (f (FieldInfo b))
_FIRemoteRelationship :: forall (b :: BackendType) p f. (Choice p, Applicative f) => p (RemoteFieldInfo (DBJoinField b)) (f (RemoteFieldInfo (DBJoinField b))) -> p (FieldInfo b) (f (FieldInfo b))

-- | Builds field name with proper case. Please note that this is a pure
--   function as all the validation has already been done while preparing
--   <tt>GQLNameIdentifier</tt>.
setFieldNameCase :: forall (b :: BackendType). NamingCase -> TableInfo b -> CustomRootField -> (GQLNameIdentifier -> GQLNameIdentifier) -> GQLNameIdentifier -> Name
instance GHC.Classes.Eq Hasura.Table.Cache.ColumnConfig
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.Table.Cache.Constraint b)
instance GHC.Classes.Eq Hasura.Table.Cache.CustomRootField
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.Table.Cache.DBTableMetadata b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b)) => GHC.Classes.Eq (Hasura.Table.Cache.DelPermInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.Table.Cache.FieldInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.Table.Cache.ForeignKey b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.Table.Cache.ForeignKeyMetadata b)
instance GHC.Classes.Eq Hasura.Table.Cache.GraphQLType
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b)) => GHC.Classes.Eq (Hasura.Table.Cache.InsPermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq a) => GHC.Classes.Eq (Hasura.Table.Cache.PrimaryKey b a)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b)) => GHC.Classes.Eq (Hasura.Table.Cache.SelPermInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.Table.Cache.TableConfig b)
instance (GHC.Classes.Eq field, GHC.Classes.Eq pkCol, Hasura.RQL.Types.Backend.Backend b) => GHC.Classes.Eq (Hasura.Table.Cache.TableCoreInfoG b field pkCol)
instance GHC.Classes.Eq Hasura.Table.Cache.TableCustomRootFields
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.Table.Cache.UniqueConstraint b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b)) => GHC.Classes.Eq (Hasura.Table.Cache.UpdPermInfo b)
instance GHC.Classes.Eq Hasura.Table.Cache.ViewInfo
instance GHC.Internal.Data.Foldable.Foldable (Hasura.Table.Cache.PrimaryKey b)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Table.Cache.ColumnConfig
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Table.Cache.Constraint b)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Table.Cache.CustomRootField
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Table.Cache.DBTableMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Table.Cache.ForeignKey b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Table.Cache.ForeignKeyMetadata b)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Table.Cache.GraphQLType
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.FromJSON.FromJSON a) => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Table.Cache.PrimaryKey b a)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Table.Cache.TableConfig b)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Table.Cache.TableCustomRootFields
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Table.Cache.UniqueConstraint b)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Table.Cache.ViewInfo
instance GHC.Internal.Generics.Generic Hasura.Table.Cache.ColumnConfig
instance GHC.Internal.Generics.Generic (Hasura.Table.Cache.Constraint b)
instance GHC.Internal.Generics.Generic Hasura.Table.Cache.CustomRootField
instance GHC.Internal.Generics.Generic (Hasura.Table.Cache.DBTableMetadata b)
instance GHC.Internal.Generics.Generic (Hasura.Table.Cache.DelPermInfo b)
instance GHC.Internal.Generics.Generic (Hasura.Table.Cache.FieldInfo b)
instance GHC.Internal.Generics.Generic (Hasura.Table.Cache.ForeignKey b)
instance GHC.Internal.Generics.Generic Hasura.Table.Cache.GraphQLType
instance GHC.Internal.Generics.Generic (Hasura.Table.Cache.InsPermInfo b)
instance GHC.Internal.Generics.Generic (Hasura.Table.Cache.PrimaryKey b a)
instance GHC.Internal.Generics.Generic (Hasura.Table.Cache.RolePermInfo b)
instance GHC.Internal.Generics.Generic (Hasura.Table.Cache.SelPermInfo b)
instance GHC.Internal.Generics.Generic (Hasura.Table.Cache.TableConfig b)
instance GHC.Internal.Generics.Generic (Hasura.Table.Cache.TableCoreInfoG b field primaryKeyColumn)
instance GHC.Internal.Generics.Generic Hasura.Table.Cache.TableCustomRootFields
instance GHC.Internal.Generics.Generic (Hasura.Table.Cache.TableInfo b)
instance GHC.Internal.Generics.Generic (Hasura.Table.Cache.UniqueConstraint b)
instance GHC.Internal.Generics.Generic (Hasura.Table.Cache.UpdPermInfo b)
instance GHC.Internal.Generics.Generic Hasura.Table.Cache.ViewInfo
instance Autodocodec.Class.HasCodec Hasura.Table.Cache.ColumnConfig
instance Autodocodec.Class.HasCodec Hasura.Table.Cache.CustomRootField
instance Autodocodec.Class.HasCodec Hasura.Table.Cache.GraphQLType
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.Table.Cache.TableConfig b)
instance Autodocodec.Class.HasCodec Hasura.Table.Cache.TableCustomRootFields
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.Table.Cache.Constraint b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.Table.Cache.ForeignKey b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.Table.Cache.ForeignKeyMetadata b)
instance (GHC.Classes.Eq a, Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable (Data.Sequence.NonEmpty.Internal.NESeq a)) => Data.Hashable.Class.Hashable (Hasura.Table.Cache.PrimaryKey b a)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.Table.Cache.UniqueConstraint b)
instance GHC.Internal.Base.Monoid Hasura.Table.Cache.ColumnConfig
instance Control.DeepSeq.NFData Hasura.Table.Cache.ColumnConfig
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.Table.Cache.Constraint b)
instance Control.DeepSeq.NFData Hasura.Table.Cache.CustomRootField
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.Table.Cache.DBTableMetadata b)
instance (Hasura.RQL.Types.Backend.Backend b, Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b)) => Control.DeepSeq.NFData (Hasura.Table.Cache.DelPermInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.Table.Cache.ForeignKey b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.Table.Cache.ForeignKeyMetadata b)
instance Control.DeepSeq.NFData Hasura.Table.Cache.GraphQLType
instance (Hasura.RQL.Types.Backend.Backend b, Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b), Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.PreSetColsPartial b)) => Control.DeepSeq.NFData (Hasura.Table.Cache.InsPermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (Hasura.Table.Cache.PrimaryKey b a)
instance (Hasura.RQL.Types.Backend.Backend b, Control.DeepSeq.NFData (Hasura.Table.Cache.InsPermInfo b), Control.DeepSeq.NFData (Hasura.Table.Cache.SelPermInfo b), Control.DeepSeq.NFData (Hasura.Table.Cache.UpdPermInfo b), Control.DeepSeq.NFData (Hasura.Table.Cache.DelPermInfo b)) => Control.DeepSeq.NFData (Hasura.Table.Cache.RolePermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b)) => Control.DeepSeq.NFData (Hasura.Table.Cache.SelPermInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.Table.Cache.TableConfig b)
instance Control.DeepSeq.NFData Hasura.Table.Cache.TableCustomRootFields
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.Table.Cache.UniqueConstraint b)
instance (Hasura.RQL.Types.Backend.Backend b, Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b), Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.PreSetColsPartial b)) => Control.DeepSeq.NFData (Hasura.Table.Cache.UpdPermInfo b)
instance Control.DeepSeq.NFData Hasura.Table.Cache.ViewInfo
instance GHC.Classes.Ord Hasura.Table.Cache.GraphQLType
instance GHC.Internal.Base.Semigroup Hasura.Table.Cache.ColumnConfig
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Base.Semigroup (Hasura.Table.Cache.CombinedSelPermInfo b)
instance GHC.Internal.Show.Show Hasura.Table.Cache.ColumnConfig
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.Table.Cache.Constraint b)
instance GHC.Internal.Show.Show Hasura.Table.Cache.CustomRootField
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.Table.Cache.DBTableMetadata b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b)) => GHC.Internal.Show.Show (Hasura.Table.Cache.DelPermInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.Table.Cache.ForeignKey b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.Table.Cache.ForeignKeyMetadata b)
instance GHC.Internal.Show.Show Hasura.Table.Cache.GraphQLType
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b)) => GHC.Internal.Show.Show (Hasura.Table.Cache.InsPermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show a) => GHC.Internal.Show.Show (Hasura.Table.Cache.PrimaryKey b a)
instance GHC.Internal.Show.Show (Hasura.Table.Cache.RolePermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b)) => GHC.Internal.Show.Show (Hasura.Table.Cache.SelPermInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.Table.Cache.TableConfig b)
instance GHC.Internal.Show.Show Hasura.Table.Cache.TableCustomRootFields
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.Table.Cache.UniqueConstraint b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b)) => GHC.Internal.Show.Show (Hasura.Table.Cache.UpdPermInfo b)
instance GHC.Internal.Show.Show Hasura.Table.Cache.ViewInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Table.Cache.ColumnConfig
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Cache.Constraint b)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Table.Cache.CustomRootField
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Cache.DBTableMetadata b)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b)) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Cache.DelPermInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Cache.FieldInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Cache.ForeignKey b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Cache.ForeignKeyMetadata b)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Table.Cache.GraphQLType
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b)) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Cache.InsPermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.ToJSON.ToJSON a) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Cache.PrimaryKey b a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Cache.InsPermInfo b), Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Cache.SelPermInfo b), Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Cache.UpdPermInfo b), Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Cache.DelPermInfo b)) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Cache.RolePermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b)) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Cache.SelPermInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Cache.TableConfig b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Generics.Generic pkCol, Data.Aeson.Types.ToJSON.ToJSON field, Data.Aeson.Types.ToJSON.ToJSON pkCol) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Cache.TableCoreInfoG b field pkCol)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Table.Cache.TableCustomRootFields
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.EventTrigger.EventTriggerInfoMap b), Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Cache.RolePermInfo b), Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Cache.RolePermInfoMap b), Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Cache.TableCoreInfo b)) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Cache.TableInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Cache.UniqueConstraint b)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b)) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Cache.UpdPermInfo b)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Table.Cache.ViewInfo


-- | In order to avoid circular dependencies while splitting
--   <a>Metadata</a> into multiple modules, some definitions must be moved
--   out of that module. This module is the bucket for definitions that
--   have not been specifically moved elsewhere.
module Hasura.Table.Metadata
data ComputedFieldMetadata (b :: BackendType)
ComputedFieldMetadata :: ComputedFieldName -> ComputedFieldDefinition b -> Comment -> ComputedFieldMetadata (b :: BackendType)
[_cfmName] :: ComputedFieldMetadata (b :: BackendType) -> ComputedFieldName
[_cfmDefinition] :: ComputedFieldMetadata (b :: BackendType) -> ComputedFieldDefinition b
[_cfmComment] :: ComputedFieldMetadata (b :: BackendType) -> Comment
type ComputedFields (b :: BackendType) = InsOrdHashMap ComputedFieldName ComputedFieldMetadata b
type Permissions a = InsOrdHashMap RoleName a
type Relationships a = InsOrdHashMap RelName a
data TableMetadata (b :: BackendType)
TableMetadata :: TableName b -> Bool -> TableConfig b -> Relationships (ObjRelDef b) -> Relationships (ArrRelDef b) -> ComputedFields b -> RemoteRelationships -> Permissions (InsPermDef b) -> Permissions (SelPermDef b) -> Permissions (UpdPermDef b) -> Permissions (DelPermDef b) -> EventTriggers b -> Maybe ApolloFederationConfig -> Maybe LogicalModelName -> TableMetadata (b :: BackendType)
[_tmTable] :: TableMetadata (b :: BackendType) -> TableName b
[_tmIsEnum] :: TableMetadata (b :: BackendType) -> Bool
[_tmConfiguration] :: TableMetadata (b :: BackendType) -> TableConfig b
[_tmObjectRelationships] :: TableMetadata (b :: BackendType) -> Relationships (ObjRelDef b)
[_tmArrayRelationships] :: TableMetadata (b :: BackendType) -> Relationships (ArrRelDef b)
[_tmComputedFields] :: TableMetadata (b :: BackendType) -> ComputedFields b
[_tmRemoteRelationships] :: TableMetadata (b :: BackendType) -> RemoteRelationships
[_tmInsertPermissions] :: TableMetadata (b :: BackendType) -> Permissions (InsPermDef b)
[_tmSelectPermissions] :: TableMetadata (b :: BackendType) -> Permissions (SelPermDef b)
[_tmUpdatePermissions] :: TableMetadata (b :: BackendType) -> Permissions (UpdPermDef b)
[_tmDeletePermissions] :: TableMetadata (b :: BackendType) -> Permissions (DelPermDef b)
[_tmEventTriggers] :: TableMetadata (b :: BackendType) -> EventTriggers b
[_tmApolloFederationConfig] :: TableMetadata (b :: BackendType) -> Maybe ApolloFederationConfig
[_tmLogicalModel] :: TableMetadata (b :: BackendType) -> Maybe LogicalModelName
mkTableMeta :: forall (b :: BackendType). TableName b -> Bool -> TableConfig b -> TableMetadata b
tmArrayRelationships :: forall (b :: BackendType) f. Functor f => (Relationships (ArrRelDef b) -> f (Relationships (ArrRelDef b))) -> TableMetadata b -> f (TableMetadata b)
tmComputedFields :: forall (b :: BackendType) f. Functor f => (ComputedFields b -> f (ComputedFields b)) -> TableMetadata b -> f (TableMetadata b)
tmConfiguration :: forall (b :: BackendType) f. Functor f => (TableConfig b -> f (TableConfig b)) -> TableMetadata b -> f (TableMetadata b)
tmDeletePermissions :: forall (b :: BackendType) f. Functor f => (Permissions (DelPermDef b) -> f (Permissions (DelPermDef b))) -> TableMetadata b -> f (TableMetadata b)
tmApolloFederationConfig :: forall (b :: BackendType) f. Functor f => (Maybe ApolloFederationConfig -> f (Maybe ApolloFederationConfig)) -> TableMetadata b -> f (TableMetadata b)
tmEventTriggers :: forall (b :: BackendType) f. Functor f => (EventTriggers b -> f (EventTriggers b)) -> TableMetadata b -> f (TableMetadata b)
tmInsertPermissions :: forall (b :: BackendType) f. Functor f => (Permissions (InsPermDef b) -> f (Permissions (InsPermDef b))) -> TableMetadata b -> f (TableMetadata b)
tmIsEnum :: forall (b :: BackendType) f. Functor f => (Bool -> f Bool) -> TableMetadata b -> f (TableMetadata b)
tmLogicalModel :: forall (b :: BackendType) f. Functor f => (Maybe LogicalModelName -> f (Maybe LogicalModelName)) -> TableMetadata b -> f (TableMetadata b)
tmObjectRelationships :: forall (b :: BackendType) f. Functor f => (Relationships (ObjRelDef b) -> f (Relationships (ObjRelDef b))) -> TableMetadata b -> f (TableMetadata b)
tmRemoteRelationships :: forall (b :: BackendType) f. Functor f => (RemoteRelationships -> f RemoteRelationships) -> TableMetadata b -> f (TableMetadata b)
tmSelectPermissions :: forall (b :: BackendType) f. Functor f => (Permissions (SelPermDef b) -> f (Permissions (SelPermDef b))) -> TableMetadata b -> f (TableMetadata b)
tmTable :: forall (b :: BackendType) f. Functor f => (TableName b -> f (TableName b)) -> TableMetadata b -> f (TableMetadata b)
tmUpdatePermissions :: forall (b :: BackendType) f. Functor f => (Permissions (UpdPermDef b) -> f (Permissions (UpdPermDef b))) -> TableMetadata b -> f (TableMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.Table.Metadata.ComputedFieldMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.Table.Metadata.TableMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Table.Metadata.ComputedFieldMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Table.Metadata.TableMetadata b)
instance GHC.Internal.Generics.Generic (Hasura.Table.Metadata.ComputedFieldMetadata b)
instance GHC.Internal.Generics.Generic (Hasura.Table.Metadata.TableMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.Table.Metadata.ComputedFieldMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.Table.Metadata.TableMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.Table.Metadata.ComputedFieldMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.Table.Metadata.TableMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Metadata.ComputedFieldMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Metadata.TableMetadata b)

module Hasura.RQL.Types.BoolExp

-- | Context to parse a RHS value in a boolean expression
data BoolExpRHSParser (b :: BackendType) (m :: Type -> Type) v
BoolExpRHSParser :: ValueParser b m v -> v -> BoolExpRHSParser (b :: BackendType) (m :: Type -> Type) v

-- | Parse a JSON value with enforcing a column type
[_berpValueParser] :: BoolExpRHSParser (b :: BackendType) (m :: Type -> Type) v -> ValueParser b m v

-- | Required for a computed field SQL function with session argument
[_berpSessionValue] :: BoolExpRHSParser (b :: BackendType) (m :: Type -> Type) v -> v

-- | A function which resolves boolean expression from given table fields
newtype BoolExpResolver (b :: BackendType) (m :: Type -> Type) v
BoolExpResolver :: (BoolExpRHSParser b m v -> FieldInfoMap (FieldInfo b) -> FieldInfoMap (FieldInfo b) -> GBoolExp b ColExp -> m (AnnBoolExp b v)) -> BoolExpResolver (b :: BackendType) (m :: Type -> Type) v
[getBoolExpResolver] :: BoolExpResolver (b :: BackendType) (m :: Type -> Type) v -> BoolExpRHSParser b m v -> FieldInfoMap (FieldInfo b) -> FieldInfoMap (FieldInfo b) -> GBoolExp b ColExp -> m (AnnBoolExp b v)


-- | Types and functions for interacting with and manipulating SQL enums
--   represented by <i>single-column tables</i>, <b>not</b> native Postgres
--   enum types. Native enum types in Postgres are difficult to change, so
--   we discourage their use, but we might add support for native enum
--   types in the future.
module Hasura.RQL.DDL.Schema.Enum

-- | Represents a reference to an “enum table,” a single-column Postgres
--   table that is referenced via foreign key.
data EnumReference (b :: BackendType)
EnumReference :: TableName b -> EnumValues -> Maybe Name -> EnumReference (b :: BackendType)
[erTable] :: EnumReference (b :: BackendType) -> TableName b
[erValues] :: EnumReference (b :: BackendType) -> EnumValues
[erTableCustomName] :: EnumReference (b :: BackendType) -> Maybe Name
type EnumValues = HashMap EnumValue EnumValueInfo
newtype EnumValueInfo
EnumValueInfo :: Maybe Text -> EnumValueInfo
[evComment] :: EnumValueInfo -> Maybe Text
newtype EnumValue
EnumValue :: Name -> EnumValue
[getEnumValue] :: EnumValue -> Name

-- | Given a map of enum tables, computes all enum references implied by
--   the given set of foreign keys. A foreign key constitutes an enum
--   reference iff the following conditions hold:
--   
--   <ol>
--   <li>The key only includes a single column.</li>
--   <li>The referenced column is the table’s primary key.</li>
--   <li>The referenced table is, in fact, an enum table.</li>
--   </ol>
resolveEnumReferences :: forall (b :: BackendType). Backend b => HashMap (TableName b) (PrimaryKey b (Column b), TableConfig b, EnumValues) -> HashSet (ForeignKey b) -> HashMap (Column b) (NonEmpty (EnumReference b))

module Hasura.LogicalModel.Cache

-- | Description of a logical model for use in metadata (after schema
--   cache)
data LogicalModelInfo (b :: BackendType)
LogicalModelInfo :: LogicalModelName -> LogicalModelFields b -> Maybe Text -> RolePermInfoMap b -> LogicalModelInfo (b :: BackendType)
[_lmiName] :: LogicalModelInfo (b :: BackendType) -> LogicalModelName
[_lmiFields] :: LogicalModelInfo (b :: BackendType) -> LogicalModelFields b
[_lmiDescription] :: LogicalModelInfo (b :: BackendType) -> Maybe Text
[_lmiPermissions] :: LogicalModelInfo (b :: BackendType) -> RolePermInfoMap b
type LogicalModelCache (b :: BackendType) = HashMap LogicalModelName LogicalModelInfo b
instance GHC.Internal.Generics.Generic (Hasura.LogicalModel.Cache.LogicalModelInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.LogicalModel.Cache.LogicalModelInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Cache.RolePermInfoMap b)) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.LogicalModel.Cache.LogicalModelInfo b)


-- | The representation of stored procedures as derived from the schema
--   cache.
module Hasura.StoredProcedure.Cache

-- | The type into which <tt>StoredProcedureMetadata</tt> is resolved in
--   'Hasura<i>RQL</i>DDL<i>Schema</i>Cache.buildSchemaCacheRule'.
data StoredProcedureInfo (b :: BackendType)
StoredProcedureInfo :: FunctionName b -> Name -> StoredProcedureConfig -> LogicalModelInfo b -> HashMap ArgumentName (NullableScalarType b) -> Maybe Text -> StoredProcedureInfo (b :: BackendType)
[_spiStoredProcedure] :: StoredProcedureInfo (b :: BackendType) -> FunctionName b

-- | The GraphQL name of the stored procedure.
[_spiGraphqlName] :: StoredProcedureInfo (b :: BackendType) -> Name
[_spiConfig] :: StoredProcedureInfo (b :: BackendType) -> StoredProcedureConfig
[_spiReturns] :: StoredProcedureInfo (b :: BackendType) -> LogicalModelInfo b
[_spiArguments] :: StoredProcedureInfo (b :: BackendType) -> HashMap ArgumentName (NullableScalarType b)
[_spiDescription] :: StoredProcedureInfo (b :: BackendType) -> Maybe Text
type StoredProcedureCache (b :: BackendType) = HashMap FunctionName b StoredProcedureInfo b
instance GHC.Internal.Generics.Generic (Hasura.StoredProcedure.Cache.StoredProcedureInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Cache.RolePermInfoMap b)) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.StoredProcedure.Cache.StoredProcedureInfo b)

module Hasura.StoredProcedure.Lenses
spiStoredProcedure :: forall (b :: BackendType) f. Functor f => (FunctionName b -> f (FunctionName b)) -> StoredProcedureInfo b -> f (StoredProcedureInfo b)
spiGraphqlName :: forall (b :: BackendType) f. Functor f => (Name -> f Name) -> StoredProcedureInfo b -> f (StoredProcedureInfo b)
spiConfig :: forall (b :: BackendType) f. Functor f => (StoredProcedureConfig -> f StoredProcedureConfig) -> StoredProcedureInfo b -> f (StoredProcedureInfo b)
spiReturns :: forall (b :: BackendType) f. Functor f => (LogicalModelInfo b -> f (LogicalModelInfo b)) -> StoredProcedureInfo b -> f (StoredProcedureInfo b)
spiArguments :: forall (b :: BackendType) f. Functor f => (HashMap ArgumentName (NullableScalarType b) -> f (HashMap ArgumentName (NullableScalarType b))) -> StoredProcedureInfo b -> f (StoredProcedureInfo b)
spiDescription :: forall (b :: BackendType) f. Functor f => (Maybe Text -> f (Maybe Text)) -> StoredProcedureInfo b -> f (StoredProcedureInfo b)


-- | The representation of native queries as derived from the schema cache.
module Hasura.NativeQuery.Cache

-- | The type into which <tt>NativeQueryMetadata</tt> is resolved in
--   'Hasura<i>RQL</i>DDL<i>Schema</i>Cache.buildSchemaCacheRule'.
data NativeQueryInfo (b :: BackendType)
NativeQueryInfo :: NativeQueryName -> InterpolatedQuery ArgumentName -> LogicalModelInfo b -> HashMap ArgumentName (NullableScalarType b) -> InsOrdHashMap RelName (RelInfo b) -> Maybe Text -> NativeQueryInfo (b :: BackendType)
[_nqiRootFieldName] :: NativeQueryInfo (b :: BackendType) -> NativeQueryName
[_nqiCode] :: NativeQueryInfo (b :: BackendType) -> InterpolatedQuery ArgumentName
[_nqiReturns] :: NativeQueryInfo (b :: BackendType) -> LogicalModelInfo b
[_nqiArguments] :: NativeQueryInfo (b :: BackendType) -> HashMap ArgumentName (NullableScalarType b)
[_nqiRelationships] :: NativeQueryInfo (b :: BackendType) -> InsOrdHashMap RelName (RelInfo b)
[_nqiDescription] :: NativeQueryInfo (b :: BackendType) -> Maybe Text
type NativeQueryCache (b :: BackendType) = HashMap NativeQueryName NativeQueryInfo b
instance GHC.Internal.Generics.Generic (Hasura.NativeQuery.Cache.NativeQueryInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.NativeQuery.Cache.NativeQueryInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Cache.RolePermInfoMap b)) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.NativeQuery.Cache.NativeQueryInfo b)

module Hasura.NativeQuery.Lenses
nqiRootFieldName :: forall (b :: BackendType) f. Functor f => (NativeQueryName -> f NativeQueryName) -> NativeQueryInfo b -> f (NativeQueryInfo b)
nqiRelationships :: forall (b :: BackendType) f. Functor f => (InsOrdHashMap RelName (RelInfo b) -> f (InsOrdHashMap RelName (RelInfo b))) -> NativeQueryInfo b -> f (NativeQueryInfo b)
nqiCode :: forall (b :: BackendType) f. Functor f => (InterpolatedQuery ArgumentName -> f (InterpolatedQuery ArgumentName)) -> NativeQueryInfo b -> f (NativeQueryInfo b)
nqiReturns :: forall (b :: BackendType) f. Functor f => (LogicalModelInfo b -> f (LogicalModelInfo b)) -> NativeQueryInfo b -> f (NativeQueryInfo b)
nqiArguments :: forall (b :: BackendType) f. Functor f => (HashMap ArgumentName (NullableScalarType b) -> f (HashMap ArgumentName (NullableScalarType b))) -> NativeQueryInfo b -> f (NativeQueryInfo b)
nqiDescription :: forall (b :: BackendType) f. Functor f => (Maybe Text -> f (Maybe Text)) -> NativeQueryInfo b -> f (NativeQueryInfo b)
nqmArguments :: forall (b :: BackendType) f. Functor f => (HashMap ArgumentName (NullableScalarType b) -> f (HashMap ArgumentName (NullableScalarType b))) -> NativeQueryMetadata b -> f (NativeQueryMetadata b)
nqmObjectRelationships :: forall (b :: BackendType) f. Functor f => (Relationships (RelDef (RelManualConfig b)) -> f (Relationships (RelDef (RelManualConfig b)))) -> NativeQueryMetadata b -> f (NativeQueryMetadata b)
nqmCode :: forall (b :: BackendType) f. Functor f => (InterpolatedQuery ArgumentName -> f (InterpolatedQuery ArgumentName)) -> NativeQueryMetadata b -> f (NativeQueryMetadata b)
nqmDescription :: forall (b :: BackendType) f. Functor f => (Maybe Text -> f (Maybe Text)) -> NativeQueryMetadata b -> f (NativeQueryMetadata b)
nqmReturns :: forall (b :: BackendType) f. Functor f => (LogicalModelIdentifier b -> f (LogicalModelIdentifier b)) -> NativeQueryMetadata b -> f (NativeQueryMetadata b)
nqmArrayRelationships :: forall (b :: BackendType) f. Functor f => (Relationships (RelDef (RelManualConfig b)) -> f (Relationships (RelDef (RelManualConfig b)))) -> NativeQueryMetadata b -> f (NativeQueryMetadata b)
nqmRootFieldName :: forall (b :: BackendType) f. Functor f => (NativeQueryName -> f NativeQueryName) -> NativeQueryMetadata b -> f (NativeQueryMetadata b)

module Hasura.LogicalModel.Lenses
lmiName :: forall (b :: BackendType) f. Functor f => (LogicalModelName -> f LogicalModelName) -> LogicalModelInfo b -> f (LogicalModelInfo b)
lmiPermissions :: forall (b :: BackendType) f. Functor f => (RolePermInfoMap b -> f (RolePermInfoMap b)) -> LogicalModelInfo b -> f (LogicalModelInfo b)
lmiDescription :: forall (b :: BackendType) f. Functor f => (Maybe Text -> f (Maybe Text)) -> LogicalModelInfo b -> f (LogicalModelInfo b)
lmiFields :: forall (b :: BackendType) f. Functor f => (LogicalModelFields b -> f (LogicalModelFields b)) -> LogicalModelInfo b -> f (LogicalModelInfo b)
lmmName :: forall (b :: BackendType) f. Functor f => (LogicalModelName -> f LogicalModelName) -> LogicalModelMetadata b -> f (LogicalModelMetadata b)
lmmFields :: forall (b :: BackendType) f. Functor f => (LogicalModelFields b -> f (LogicalModelFields b)) -> LogicalModelMetadata b -> f (LogicalModelMetadata b)
lmmDescription :: forall (b :: BackendType) f. Functor f => (Maybe Text -> f (Maybe Text)) -> LogicalModelMetadata b -> f (LogicalModelMetadata b)
lmmSelectPermissions :: forall (b :: BackendType) f. Functor f => (InsOrdHashMap RoleName (SelPermDef b) -> f (InsOrdHashMap RoleName (SelPermDef b))) -> LogicalModelMetadata b -> f (LogicalModelMetadata b)


-- | Postgres Types Table
--   
--   Defines a single combinator to throw an error if the view is not
--   mutable.
module Hasura.Backends.Postgres.Types.Table
mutableView :: MonadError QErr m => QualifiedTable -> (ViewInfo -> Bool) -> Maybe ViewInfo -> Text -> m ()


-- | Postgres Translate BoolExp
--   
--   Convert IR boolean expressions to Postgres-specific SQL expressions.
module Hasura.Backends.Postgres.Translate.BoolExp

-- | Translate an IR boolean expression to an SQL boolean expression.
--   References to columns etc are relative to the given
--   <a>rootReference</a>.
toSQLBoolExp :: forall (pgKind :: PostgresKind) m. (Backend ('Postgres pgKind), MonadIO m, MonadError QErr m) => UserInfo -> Qual -> AnnBoolExpSQL ('Postgres pgKind) -> m BoolExp
withRedactionExp :: forall (pgKind :: PostgresKind) m. (Backend ('Postgres pgKind), MonadIO m, MonadError QErr m) => Qual -> AnnRedactionExp ('Postgres pgKind) SQLExp -> UserInfo -> SQLExp -> m SQLExp
instance GHC.Internal.Base.Monad m => GHC.Internal.Base.Applicative (Hasura.Backends.Postgres.Translate.BoolExp.BoolExpM m)
instance GHC.Internal.Base.Functor m => GHC.Internal.Base.Functor (Hasura.Backends.Postgres.Translate.BoolExp.BoolExpM m)
instance GHC.Internal.Base.Monad m => GHC.Internal.Base.Monad (Hasura.Backends.Postgres.Translate.BoolExp.BoolExpM m)
instance GHC.Internal.Base.Monad m => Control.Monad.Reader.Class.MonadReader Hasura.Backends.Postgres.Translate.BoolExp.BoolExpCtx (Hasura.Backends.Postgres.Translate.BoolExp.BoolExpM m)
instance GHC.Internal.Base.Monad m => Control.Monad.State.Class.MonadState GHC.Internal.Word.Word64 (Hasura.Backends.Postgres.Translate.BoolExp.BoolExpM m)
instance Control.Monad.Trans.Class.MonadTrans Hasura.Backends.Postgres.Translate.BoolExp.BoolExpM


-- | Postgres DDL Table
--   
--   Used to fill up the enum values field of <a>TableCoreInfoG</a>.
--   
--   See <a>Backend</a>.
module Hasura.Backends.Postgres.DDL.Table
fetchAndValidateEnumValues :: forall (pgKind :: PostgresKind) m. (Backend ('Postgres pgKind), MonadIO m, MonadBaseControl IO m) => PGSourceConfig -> QualifiedTable -> Maybe (PrimaryKey ('Postgres pgKind) (RawColumnInfo ('Postgres pgKind))) -> [RawColumnInfo ('Postgres pgKind)] -> m (Either QErr EnumValues)


-- | Metadata related types, functions and helpers.
--   
--   Provides a single function which loads the MSSQL database metadata.
--   See the file at src-rsr<i>mssql</i>mssql_table_metadata.sql for the
--   SQL we use to build this metadata. See <a>DBTableMetadata</a> for the
--   Haskell type we use forall storing this metadata.
module Hasura.Backends.MSSQL.Meta
loadDBMetadata :: forall (m :: Type -> Type). MonadIO m => TxET QErr m (DBTablesMetadata 'MSSQL)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Meta.SysColumn
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Meta.SysForeignKeyColumn
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Meta.SysPrimaryKey
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Meta.SysPrimaryKeyColumn
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Meta.SysSchema
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Meta.SysTable
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Meta.SysType
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Meta.SysColumn
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Meta.SysForeignKeyColumn
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Meta.SysPrimaryKey
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Meta.SysPrimaryKeyColumn
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Meta.SysSchema
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Meta.SysTable
instance GHC.Internal.Generics.Generic Hasura.Backends.MSSQL.Meta.SysType
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Meta.SysColumn
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Meta.SysForeignKeyColumn
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Meta.SysPrimaryKey
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Meta.SysPrimaryKeyColumn
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Meta.SysSchema
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Meta.SysTable
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.Meta.SysType


-- | This modules defines the tree of Select types: how we represent a
--   query internally, from its top level <a>QueryDB</a> down to each
--   individual field. Most of those types have three type arguments:
--   
--   b: BackendType The backend that is targeted by that specific select
--   (Postgres Vanilla, MSSQL...); we use the type families in the Backend
--   class to decide how different parts of the IR are represented in
--   different backends.
--   
--   v: Type The type of the leaf values in our AST; used almost
--   exclusively for column values, over which queries can be
--   parameterized. The output of the parser phase will use
--   <tt>UnpreparedValue b</tt> for the leaves, and most backends will then
--   transform the AST to interpret those values and consequently change
--   <tt>v</tt> to be <tt>SQLExpression b</tt>
--   
--   r: BackendType -&gt; Type Joins across backends mean that the
--   aforementioned <tt>b</tt> parameter won't be the same throughout the
--   entire tree; at some point we will have an <tt>AnyBackend</tt> used to
--   encapsulate a branch that uses a different <tt>b</tt>. We still want,
--   however, to be able to parameterize the values of the leaves in that
--   separate branch, and that's what the <tt>r</tt> parameter is for. We
--   also use <tt>UnpreparedValue</tt> here during the parsing phase,
--   meaning all leaf values will be <tt>UnpreparedValue b</tt> for their
--   respective backend <tt>b</tt>, and most backends will then transform
--   their AST, cutting all such remote branches, and therefore using
--   <tt>Const Void</tt> for <tt>r</tt>.
module Hasura.RQL.IR.Select
data AggregateField (b :: BackendType) v
AFCount :: CountType b v -> AggregateField (b :: BackendType) v
AFOp :: AggregateOp b v -> AggregateField (b :: BackendType) v
AFExp :: Text -> AggregateField (b :: BackendType) v
type AggregateFields (b :: BackendType) v = Fields AggregateField b v
data AggregateOp (b :: BackendType) v
AggregateOp :: Text -> SelectionFields b v -> AggregateOp (b :: BackendType) v
[_aoOp] :: AggregateOp (b :: BackendType) v -> Text
[_aoFields] :: AggregateOp (b :: BackendType) v -> SelectionFields b v
type AnnAggregateSelect (b :: BackendType) = AnnAggregateSelectG b Void SQLExpression b
type AnnAggregateSelectG (b :: BackendType) r v = AnnSelectG b TableAggregateFieldG b r v
data AnnColumnField (b :: BackendType) v
AnnColumnField :: Column b -> ColumnType b -> Bool -> Maybe (ScalarSelectionArguments b) -> AnnRedactionExp b v -> AnnColumnField (b :: BackendType) v
[_acfColumn] :: AnnColumnField (b :: BackendType) v -> Column b
[_acfType] :: AnnColumnField (b :: BackendType) v -> ColumnType b

-- | If this field is <a>True</a>, columns are explicitly casted to
--   <tt>text</tt> when fetched, which avoids an issue that occurs because
--   we don’t currently have proper support for array types. See
--   <a>https://github.com/hasura/graphql-engine/pull/3198</a> for more
--   details.
[_acfAsText] :: AnnColumnField (b :: BackendType) v -> Bool

-- | Arguments of this column's selection. See
--   <a>ScalarSelectionArguments</a>
[_acfArguments] :: AnnColumnField (b :: BackendType) v -> Maybe (ScalarSelectionArguments b)

-- | This type is used to determine whether the column should be redacted
[_acfRedactionExpression] :: AnnColumnField (b :: BackendType) v -> AnnRedactionExp b v
type AnnField (b :: BackendType) = AnnFieldG b Void SQLExpression b
data AnnFieldG (b :: BackendType) r v
AFColumn :: AnnColumnField b v -> AnnFieldG (b :: BackendType) r v
AFObjectRelation :: ObjectRelationSelectG b r v -> AnnFieldG (b :: BackendType) r v
AFArrayRelation :: ArraySelectG b r v -> AnnFieldG (b :: BackendType) r v
AFComputedField :: XComputedField b -> ComputedFieldName -> ComputedFieldSelect b r v -> AnnFieldG (b :: BackendType) r v

-- | A remote relationship field
AFRemote :: RemoteRelationshipSelect b r -> AnnFieldG (b :: BackendType) r v
AFNodeId :: XRelay b -> SourceName -> TableName b -> PrimaryKeyColumns b -> AnnFieldG (b :: BackendType) r v
AFExpression :: Text -> AnnFieldG (b :: BackendType) r v

-- | Nested object.
AFNestedObject :: AnnNestedObjectSelectG b r v -> AnnFieldG (b :: BackendType) r v

-- | Nested array
AFNestedArray :: XNestedObjects b -> AnnNestedArraySelectG b r v -> AnnFieldG (b :: BackendType) r v
type AnnFields (b :: BackendType) = AnnFieldsG b Void SQLExpression b
type AnnFieldsG (b :: BackendType) r v = Fields AnnFieldG b r v
data AnnNestedObjectSelectG (b :: BackendType) r v
AnnNestedObjectSelectG :: XNestedObjects b -> Column b -> AnnFieldsG b r v -> AnnNestedObjectSelectG (b :: BackendType) r v
[_anosSupportsNestedObjects] :: AnnNestedObjectSelectG (b :: BackendType) r v -> XNestedObjects b
[_anosColumn] :: AnnNestedObjectSelectG (b :: BackendType) r v -> Column b
[_anosFields] :: AnnNestedObjectSelectG (b :: BackendType) r v -> AnnFieldsG b r v
type AnnNestedObjectSelect (b :: BackendType) r = AnnNestedObjectSelectG b r SQLExpression b
data AnnNestedArraySelectG (b :: BackendType) r v
ANASSimple :: AnnFieldG b r v -> AnnNestedArraySelectG (b :: BackendType) r v
ANASAggregate :: AnnAggregateSelectG b r v -> AnnNestedArraySelectG (b :: BackendType) r v
type AnnNestedArraySelect (b :: BackendType) r = AnnNestedArraySelectG b r SQLExpression b
type AnnObjectSelect (b :: BackendType) r = AnnObjectSelectG b r SQLExpression b
data AnnObjectSelectG (b :: BackendType) r v
AnnObjectSelectG :: AnnFieldsG b r v -> SelectFromG b v -> AnnBoolExp b v -> AnnObjectSelectG (b :: BackendType) r v
[_aosFields] :: AnnObjectSelectG (b :: BackendType) r v -> AnnFieldsG b r v
[_aosTarget] :: AnnObjectSelectG (b :: BackendType) r v -> SelectFromG b v
[_aosTargetFilter] :: AnnObjectSelectG (b :: BackendType) r v -> AnnBoolExp b v
type AnnSimpleSelect (b :: BackendType) = AnnSimpleSelectG b Void SQLExpression b
type AnnSimpleSelectG (b :: BackendType) r v = AnnSelectG b AnnFieldG b r v
type AnnSimpleStreamSelect (b :: BackendType) = AnnSimpleStreamSelectG b Void SQLExpression b
type AnnSimpleStreamSelectG (b :: BackendType) r v = AnnSelectStreamG b AnnFieldG b r v
type ArrayAggregateSelect (b :: BackendType) = ArrayAggregateSelectG b Void SQLExpression b
type ArrayAggregateSelectG (b :: BackendType) r v = AnnRelationSelectG b AnnAggregateSelectG b r v
type ArrayConnectionSelect (b :: BackendType) r v = AnnRelationSelectG b ConnectionSelect b r v
type ArrayRelationSelectG (b :: BackendType) r v = AnnRelationSelectG b AnnSimpleSelectG b r v
type ArraySelect (b :: BackendType) = ArraySelectG b Void SQLExpression b
type ArraySelectFieldsG (b :: BackendType) r v = Fields ArraySelectG b r v
data ArraySelectG (b :: BackendType) r v
ASSimple :: ArrayRelationSelectG b r v -> ArraySelectG (b :: BackendType) r v
ASAggregate :: ArrayAggregateSelectG b r v -> ArraySelectG (b :: BackendType) r v
ASConnection :: ArrayConnectionSelect b r v -> ArraySelectG (b :: BackendType) r v

-- | Types of fields that can be selected in a user query.
data SelectionField (b :: BackendType) v
SFCol :: Column b -> ColumnType b -> AnnRedactionExp b v -> SelectionField (b :: BackendType) v
SFComputedField :: ComputedFieldName -> ComputedFieldScalarSelect b v -> SelectionField (b :: BackendType) v
SFExp :: Text -> SelectionField (b :: BackendType) v
type SelectionFields (b :: BackendType) v = Fields SelectionField b v
data ComputedFieldScalarSelect (b :: BackendType) v
ComputedFieldScalarSelect :: FunctionName b -> FunctionArgsExp b v -> ScalarType b -> Maybe (ScalarSelectionArguments b) -> AnnRedactionExp b v -> ComputedFieldScalarSelect (b :: BackendType) v
[_cfssFunction] :: ComputedFieldScalarSelect (b :: BackendType) v -> FunctionName b
[_cfssArguments] :: ComputedFieldScalarSelect (b :: BackendType) v -> FunctionArgsExp b v
[_cfssType] :: ComputedFieldScalarSelect (b :: BackendType) v -> ScalarType b
[_cfssScalarArguments] :: ComputedFieldScalarSelect (b :: BackendType) v -> Maybe (ScalarSelectionArguments b)

-- | This type is used to determine whether the computed field should be
--   redacted
[_cfssRedactionExpression] :: ComputedFieldScalarSelect (b :: BackendType) v -> AnnRedactionExp b v
data ComputedFieldSelect (b :: BackendType) r v
CFSScalar :: ComputedFieldScalarSelect b v -> ComputedFieldSelect (b :: BackendType) r v
CFSTable :: JsonAggSelect -> AnnSimpleSelectG b r v -> ComputedFieldSelect (b :: BackendType) r v
data ConnectionField (b :: BackendType) r v
ConnectionTypename :: Text -> ConnectionField (b :: BackendType) r v
ConnectionPageInfo :: PageInfoFields -> ConnectionField (b :: BackendType) r v
ConnectionEdges :: EdgeFields b r v -> ConnectionField (b :: BackendType) r v
type ConnectionFields (b :: BackendType) r v = Fields ConnectionField b r v
data ConnectionSelect (b :: BackendType) r v
ConnectionSelect :: XRelay b -> PrimaryKeyColumns b -> Maybe (NonEmpty (ConnectionSplit b v)) -> Maybe ConnectionSlice -> AnnSelectG b (ConnectionField b r) v -> ConnectionSelect (b :: BackendType) r v
[_csXRelay] :: ConnectionSelect (b :: BackendType) r v -> XRelay b
[_csPrimaryKeyColumns] :: ConnectionSelect (b :: BackendType) r v -> PrimaryKeyColumns b
[_csSplit] :: ConnectionSelect (b :: BackendType) r v -> Maybe (NonEmpty (ConnectionSplit b v))
[_csSlice] :: ConnectionSelect (b :: BackendType) r v -> Maybe ConnectionSlice
[_csSelect] :: ConnectionSelect (b :: BackendType) r v -> AnnSelectG b (ConnectionField b r) v
data ConnectionSlice
SliceFirst :: Int -> ConnectionSlice
SliceLast :: Int -> ConnectionSlice
data ConnectionSplit (b :: BackendType) v
ConnectionSplit :: ConnectionSplitKind -> v -> OrderByItemG b (AnnotatedOrderByElement b v) -> ConnectionSplit (b :: BackendType) v
[_csKind] :: ConnectionSplit (b :: BackendType) v -> ConnectionSplitKind
[_csValue] :: ConnectionSplit (b :: BackendType) v -> v
[_csOrderBy] :: ConnectionSplit (b :: BackendType) v -> OrderByItemG b (AnnotatedOrderByElement b v)
data ConnectionSplitKind
CSKBefore :: ConnectionSplitKind
CSKAfter :: ConnectionSplitKind
data EdgeField (b :: BackendType) r v
EdgeTypename :: Text -> EdgeField (b :: BackendType) r v
EdgeCursor :: EdgeField (b :: BackendType) r v
EdgeNode :: AnnFieldsG b r v -> EdgeField (b :: BackendType) r v
type EdgeFields (b :: BackendType) r v = Fields EdgeField b r v
type ObjectRelationSelect (b :: BackendType) = ObjectRelationSelectG b Void SQLExpression b
type ObjectRelationSelectG (b :: BackendType) r v = AnnRelationSelectG b AnnObjectSelectG b r v
data PageInfoField
PageInfoTypename :: Text -> PageInfoField
PageInfoHasNextPage :: PageInfoField
PageInfoHasPreviousPage :: PageInfoField
PageInfoStartCursor :: PageInfoField
PageInfoEndCursor :: PageInfoField
type PageInfoFields = Fields PageInfoField
data QueryDB (b :: BackendType) r v
QDBMultipleRows :: AnnSimpleSelectG b r v -> QueryDB (b :: BackendType) r v
QDBSingleRow :: AnnSimpleSelectG b r v -> QueryDB (b :: BackendType) r v
QDBAggregation :: AnnAggregateSelectG b r v -> QueryDB (b :: BackendType) r v
QDBConnection :: ConnectionSelect b r v -> QueryDB (b :: BackendType) r v
QDBStreamMultipleRows :: AnnSimpleStreamSelectG b r v -> QueryDB (b :: BackendType) r v

-- | A relationship to a remote source. <tt>vf</tt> (could use a better
--   name) is analogous to <tt>v</tt> in other IR types such as
--   <a>AnnFieldG</a>. vf's kind is (BackendType -&gt; Type) instead of v's
--   <a>Type</a> so that <tt>v</tt> of <a>AnnFieldG</a> can be specific to
--   the backend that it captures (<tt>b</tt> of an AnnFieldG changes as we
--   walk down the IR branches which capture relationships to other
--   databases)
data RemoteSourceSelect r (vf :: BackendType -> Type) (tgt :: BackendType)
RemoteSourceSelect :: SourceName -> SourceConfig tgt -> SourceRelationshipSelection tgt r vf -> HashMap FieldName (ScalarType tgt, Column tgt) -> StringifyNumbers -> RemoteSourceSelect r (vf :: BackendType -> Type) (tgt :: BackendType)
[_rssName] :: RemoteSourceSelect r (vf :: BackendType -> Type) (tgt :: BackendType) -> SourceName
[_rssConfig] :: RemoteSourceSelect r (vf :: BackendType -> Type) (tgt :: BackendType) -> SourceConfig tgt
[_rssSelection] :: RemoteSourceSelect r (vf :: BackendType -> Type) (tgt :: BackendType) -> SourceRelationshipSelection tgt r vf

-- | Additional information about the source's join columns: (ScalarType
--   tgt) so that the remote can interpret the join values coming from src
--   (Column tgt) so that an appropriate join condition / IN clause can be
--   built by the remote
[_rssJoinMapping] :: RemoteSourceSelect r (vf :: BackendType -> Type) (tgt :: BackendType) -> HashMap FieldName (ScalarType tgt, Column tgt)
[_rssStringifyNums] :: RemoteSourceSelect r (vf :: BackendType -> Type) (tgt :: BackendType) -> StringifyNumbers

-- | captures a remote relationship's selection and the necessary context
data RemoteRelationshipSelect (b :: BackendType) r
RemoteRelationshipSelect :: HashMap FieldName (DBJoinField b) -> r -> RemoteRelationshipSelect (b :: BackendType) r

-- | The fields on the table that are required for the join condition of
--   the remote relationship
[_rrsLHSJoinFields] :: RemoteRelationshipSelect (b :: BackendType) r -> HashMap FieldName (DBJoinField b)

-- | The field that captures the relationship r ~ (RemoteRelationshipField
--   UnpreparedValue) when the AST is emitted by the parser. r ~ Void when
--   an execution tree is constructed so that a backend is absolved of
--   dealing with remote relationships.
[_rrsRelationship] :: RemoteRelationshipSelect (b :: BackendType) r -> r

-- | Captures the selection set of a remote source relationship.
data SourceRelationshipSelection (b :: BackendType) r (vf :: BackendType -> Type)
SourceRelationshipObject :: AnnObjectSelectG b r (vf b) -> SourceRelationshipSelection (b :: BackendType) r (vf :: BackendType -> Type)
SourceRelationshipArray :: AnnSimpleSelectG b r (vf b) -> SourceRelationshipSelection (b :: BackendType) r (vf :: BackendType -> Type)
SourceRelationshipArrayAggregate :: AnnAggregateSelectG b r (vf b) -> SourceRelationshipSelection (b :: BackendType) r (vf :: BackendType -> Type)
type TableAggregateField (b :: BackendType) = TableAggregateFieldG b Void SQLExpression b
data TableAggregateFieldG (b :: BackendType) r v
TAFAgg :: AggregateFields b v -> TableAggregateFieldG (b :: BackendType) r v
TAFNodes :: XNodesAgg b -> AnnFieldsG b r v -> TableAggregateFieldG (b :: BackendType) r v
TAFGroupBy :: XGroupBy b -> GroupByG b r v -> TableAggregateFieldG (b :: BackendType) r v
TAFExp :: Text -> TableAggregateFieldG (b :: BackendType) r v
type TableAggregateFields (b :: BackendType) = TableAggregateFieldsG b Void SQLExpression b
type TableAggregateFieldsG (b :: BackendType) r v = Fields TableAggregateFieldG b r v
data GroupByG (b :: BackendType) r v
GroupByG :: [GroupKeyField b] -> Fields (GroupByField b r v) -> GroupByG (b :: BackendType) r v
[_gbgKeys] :: GroupByG (b :: BackendType) r v -> [GroupKeyField b]
[_gbgFields] :: GroupByG (b :: BackendType) r v -> Fields (GroupByField b r v)
data GroupByField (b :: BackendType) r v
GBFGroupKey :: Fields (GroupKeyField b) -> GroupByField (b :: BackendType) r v
GBFAggregate :: AggregateFields b v -> GroupByField (b :: BackendType) r v
GBFNodes :: AnnFieldsG b r v -> GroupByField (b :: BackendType) r v
GBFExp :: Text -> GroupByField (b :: BackendType) r v
data GroupKeyField (b :: BackendType)
GKFColumn :: Column b -> GroupKeyField (b :: BackendType)
GKFExp :: Text -> GroupKeyField (b :: BackendType)

-- | The "distinct" input field inside "count" aggregate field
--   
--   count ( distinct: Boolean ): Int
data CountDistinct
SelectCountDistinct :: CountDistinct
SelectCountNonDistinct :: CountDistinct

-- | If argument positional index is less than or equal to length of
--   <tt>positional</tt> arguments then insert the value in
--   <tt>positional</tt> arguments else insert the value with argument name
--   in <tt>named</tt> arguments
insertFunctionArg :: FunctionArgName -> Int -> a -> FunctionArgsExpG a -> FunctionArgsExpG a
mkAnnColumnField :: forall (backend :: BackendType) v r. Column backend -> ColumnType backend -> AnnRedactionExp backend v -> Maybe (ScalarSelectionArguments backend) -> AnnFieldG backend r v
mkAnnColumnFieldAsText :: forall (backend :: BackendType) r v. ColumnInfo backend -> AnnFieldG backend r v
traverseSourceRelationshipSelection :: forall f (backend :: BackendType) vf vg r. (Applicative f, Backend backend) => (vf backend -> f (vg backend)) -> SourceRelationshipSelection backend r vf -> f (SourceRelationshipSelection backend r vg)
instance Hasura.RQL.Types.Backend.Backend b => Data.Bifoldable.Bifoldable (Hasura.RQL.IR.Select.AnnFieldG b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Bifoldable.Bifoldable (Hasura.RQL.IR.Select.AnnNestedArraySelectG b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Bifoldable.Bifoldable (Hasura.RQL.IR.Select.AnnNestedObjectSelectG b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Bifoldable.Bifoldable (Hasura.RQL.IR.Select.AnnObjectSelectG b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Bifoldable.Bifoldable (Hasura.RQL.IR.Select.ArraySelectG b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Bifoldable.Bifoldable (Hasura.RQL.IR.Select.ComputedFieldSelect b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Bifoldable.Bifoldable (Hasura.RQL.IR.Select.ConnectionField b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Bifoldable.Bifoldable (Hasura.RQL.IR.Select.ConnectionSelect b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Bifoldable.Bifoldable (Hasura.RQL.IR.Select.EdgeField b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Bifoldable.Bifoldable (Hasura.RQL.IR.Select.GroupByField b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Bifoldable.Bifoldable (Hasura.RQL.IR.Select.GroupByG b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Bifoldable.Bifoldable (Hasura.RQL.IR.Select.QueryDB b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Bifoldable.Bifoldable (Hasura.RQL.IR.Select.TableAggregateFieldG b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq v) => GHC.Classes.Eq (Hasura.RQL.IR.Select.AggregateField b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq v) => GHC.Classes.Eq (Hasura.RQL.IR.Select.AggregateOp b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq v) => GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnColumnField b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq r, GHC.Classes.Eq v) => GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnFieldG b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq r, GHC.Classes.Eq v) => GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnNestedArraySelectG b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq r, GHC.Classes.Eq v) => GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnNestedObjectSelectG b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq r, GHC.Classes.Eq v) => GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnObjectSelectG b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq r, GHC.Classes.Eq v) => GHC.Classes.Eq (Hasura.RQL.IR.Select.ArraySelectG b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq v) => GHC.Classes.Eq (Hasura.RQL.IR.Select.ComputedFieldScalarSelect b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq r, GHC.Classes.Eq v) => GHC.Classes.Eq (Hasura.RQL.IR.Select.ComputedFieldSelect b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq r, GHC.Classes.Eq v) => GHC.Classes.Eq (Hasura.RQL.IR.Select.ConnectionField b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq r, GHC.Classes.Eq v) => GHC.Classes.Eq (Hasura.RQL.IR.Select.ConnectionSelect b r v)
instance GHC.Classes.Eq Hasura.RQL.IR.Select.ConnectionSlice
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq v) => GHC.Classes.Eq (Hasura.RQL.IR.Select.ConnectionSplit b v)
instance GHC.Classes.Eq Hasura.RQL.IR.Select.ConnectionSplitKind
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq r, GHC.Classes.Eq v) => GHC.Classes.Eq (Hasura.RQL.IR.Select.EdgeField b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq r, GHC.Classes.Eq v) => GHC.Classes.Eq (Hasura.RQL.IR.Select.GroupByField b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq r, GHC.Classes.Eq v) => GHC.Classes.Eq (Hasura.RQL.IR.Select.GroupByG b r v)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.IR.Select.GroupKeyField b)
instance GHC.Classes.Eq Hasura.RQL.IR.Select.PageInfoField
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq r) => GHC.Classes.Eq (Hasura.RQL.IR.Select.RemoteRelationshipSelect b r)
instance (Hasura.RQL.Types.Backend.Backend tgt, GHC.Classes.Eq r, GHC.Classes.Eq (vf tgt)) => GHC.Classes.Eq (Hasura.RQL.IR.Select.RemoteSourceSelect r vf tgt)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq v) => GHC.Classes.Eq (Hasura.RQL.IR.Select.SelectionField b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq r, GHC.Classes.Eq (vf b)) => GHC.Classes.Eq (Hasura.RQL.IR.Select.SourceRelationshipSelection b r vf)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq r, GHC.Classes.Eq v) => GHC.Classes.Eq (Hasura.RQL.IR.Select.TableAggregateFieldG b r v)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.Select.AggregateField b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.Select.AggregateOp b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.Select.AnnColumnField b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.Select.AnnFieldG b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.Select.AnnNestedArraySelectG b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.Select.AnnNestedObjectSelectG b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.Select.AnnObjectSelectG b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.Select.ArraySelectG b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.Select.ComputedFieldScalarSelect b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.Select.ComputedFieldSelect b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.Select.ConnectionField b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.Select.ConnectionSelect b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.Select.ConnectionSplit b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.Select.EdgeField b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.Select.GroupByField b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.Select.GroupByG b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.Select.QueryDB b r)
instance GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.Select.RemoteRelationshipSelect b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.Select.SelectionField b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.Select.TableAggregateFieldG b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Base.Functor (Hasura.RQL.IR.Select.AggregateField b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Base.Functor (Hasura.RQL.IR.Select.AggregateOp b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Base.Functor (Hasura.RQL.IR.Select.AnnColumnField b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Base.Functor (Hasura.RQL.IR.Select.AnnFieldG b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Base.Functor (Hasura.RQL.IR.Select.AnnNestedArraySelectG b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Base.Functor (Hasura.RQL.IR.Select.AnnNestedObjectSelectG b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Base.Functor (Hasura.RQL.IR.Select.AnnObjectSelectG b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Base.Functor (Hasura.RQL.IR.Select.ArraySelectG b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Base.Functor (Hasura.RQL.IR.Select.ComputedFieldScalarSelect b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Base.Functor (Hasura.RQL.IR.Select.ComputedFieldSelect b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Base.Functor (Hasura.RQL.IR.Select.ConnectionField b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Base.Functor (Hasura.RQL.IR.Select.ConnectionSelect b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Base.Functor (Hasura.RQL.IR.Select.ConnectionSplit b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Base.Functor (Hasura.RQL.IR.Select.EdgeField b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Base.Functor (Hasura.RQL.IR.Select.GroupByField b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Base.Functor (Hasura.RQL.IR.Select.GroupByG b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Base.Functor (Hasura.RQL.IR.Select.QueryDB b r)
instance GHC.Internal.Base.Functor (Hasura.RQL.IR.Select.RemoteRelationshipSelect b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Base.Functor (Hasura.RQL.IR.Select.SelectionField b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Base.Functor (Hasura.RQL.IR.Select.TableAggregateFieldG b r)
instance GHC.Internal.Generics.Generic Hasura.RQL.IR.Select.ConnectionSlice
instance GHC.Internal.Generics.Generic (Hasura.RQL.IR.Select.ConnectionSplit b v)
instance GHC.Internal.Generics.Generic Hasura.RQL.IR.Select.ConnectionSplitKind
instance GHC.Internal.Generics.Generic (Hasura.RQL.IR.Select.QueryDB b r v)
instance Data.Hashable.Class.Hashable Hasura.RQL.IR.Select.ConnectionSlice
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable v) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.Select.ConnectionSplit b v)
instance Data.Hashable.Class.Hashable Hasura.RQL.IR.Select.ConnectionSplitKind
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show v) => GHC.Internal.Show.Show (Hasura.RQL.IR.Select.AggregateField b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show v) => GHC.Internal.Show.Show (Hasura.RQL.IR.Select.AggregateOp b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show v) => GHC.Internal.Show.Show (Hasura.RQL.IR.Select.AnnColumnField b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show r, GHC.Internal.Show.Show v) => GHC.Internal.Show.Show (Hasura.RQL.IR.Select.AnnFieldG b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show v, GHC.Internal.Show.Show r) => GHC.Internal.Show.Show (Hasura.RQL.IR.Select.AnnNestedArraySelectG b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show v, GHC.Internal.Show.Show r) => GHC.Internal.Show.Show (Hasura.RQL.IR.Select.AnnNestedObjectSelectG b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show r, GHC.Internal.Show.Show v) => GHC.Internal.Show.Show (Hasura.RQL.IR.Select.AnnObjectSelectG b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show r, GHC.Internal.Show.Show v) => GHC.Internal.Show.Show (Hasura.RQL.IR.Select.ArraySelectG b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show v) => GHC.Internal.Show.Show (Hasura.RQL.IR.Select.ComputedFieldScalarSelect b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show r, GHC.Internal.Show.Show v) => GHC.Internal.Show.Show (Hasura.RQL.IR.Select.ComputedFieldSelect b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show r, GHC.Internal.Show.Show v) => GHC.Internal.Show.Show (Hasura.RQL.IR.Select.ConnectionField b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show r, GHC.Internal.Show.Show v) => GHC.Internal.Show.Show (Hasura.RQL.IR.Select.ConnectionSelect b r v)
instance GHC.Internal.Show.Show Hasura.RQL.IR.Select.ConnectionSlice
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show v) => GHC.Internal.Show.Show (Hasura.RQL.IR.Select.ConnectionSplit b v)
instance GHC.Internal.Show.Show Hasura.RQL.IR.Select.ConnectionSplitKind
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show r, GHC.Internal.Show.Show v) => GHC.Internal.Show.Show (Hasura.RQL.IR.Select.EdgeField b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show r, GHC.Internal.Show.Show v) => GHC.Internal.Show.Show (Hasura.RQL.IR.Select.GroupByField b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show r, GHC.Internal.Show.Show v) => GHC.Internal.Show.Show (Hasura.RQL.IR.Select.GroupByG b r v)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.IR.Select.GroupKeyField b)
instance GHC.Internal.Show.Show Hasura.RQL.IR.Select.PageInfoField
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show r, GHC.Internal.Show.Show v) => GHC.Internal.Show.Show (Hasura.RQL.IR.Select.QueryDB b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show r) => GHC.Internal.Show.Show (Hasura.RQL.IR.Select.RemoteRelationshipSelect b r)
instance (Hasura.RQL.Types.Backend.Backend tgt, GHC.Internal.Show.Show r, GHC.Internal.Show.Show (vf tgt)) => GHC.Internal.Show.Show (Hasura.RQL.IR.Select.RemoteSourceSelect r vf tgt)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show v) => GHC.Internal.Show.Show (Hasura.RQL.IR.Select.SelectionField b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show r, GHC.Internal.Show.Show (vf b)) => GHC.Internal.Show.Show (Hasura.RQL.IR.Select.SourceRelationshipSelection b r vf)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show r, GHC.Internal.Show.Show v) => GHC.Internal.Show.Show (Hasura.RQL.IR.Select.TableAggregateFieldG b r v)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.Select.AggregateField b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.Select.AggregateOp b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.Select.AnnColumnField b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.Select.AnnFieldG b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.Select.AnnNestedArraySelectG b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.Select.AnnNestedObjectSelectG b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.Select.AnnObjectSelectG b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.Select.ArraySelectG b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.Select.ComputedFieldScalarSelect b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.Select.ComputedFieldSelect b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.Select.ConnectionField b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.Select.ConnectionSelect b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.Select.ConnectionSplit b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.Select.EdgeField b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.Select.GroupByField b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.Select.GroupByG b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.Select.QueryDB b r)
instance GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.Select.RemoteRelationshipSelect b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.Select.SelectionField b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.Select.TableAggregateFieldG b r)

module Hasura.RQL.IR.Select.Lenses
asnArgs :: forall (b :: BackendType) (f1 :: Type -> Type) v f2. Functor f2 => (SelectArgsG b v -> f2 (SelectArgsG b v)) -> AnnSelectG b f1 v -> f2 (AnnSelectG b f1 v)
asnFields :: forall (b :: BackendType) f1 v f2 f3. Functor f3 => (Fields (f1 v) -> f3 (Fields (f2 v))) -> AnnSelectG b f1 v -> f3 (AnnSelectG b f2 v)
asnFrom :: forall (b :: BackendType) (f1 :: Type -> Type) v f2. Functor f2 => (SelectFromG b v -> f2 (SelectFromG b v)) -> AnnSelectG b f1 v -> f2 (AnnSelectG b f1 v)
asnNamingConvention :: forall (b :: BackendType) (f1 :: Type -> Type) v f2. Functor f2 => (Maybe NamingCase -> f2 (Maybe NamingCase)) -> AnnSelectG b f1 v -> f2 (AnnSelectG b f1 v)
asnPerm :: forall (b :: BackendType) (f1 :: Type -> Type) v f2. Functor f2 => (TablePermG b v -> f2 (TablePermG b v)) -> AnnSelectG b f1 v -> f2 (AnnSelectG b f1 v)
asnStrfyNum :: forall (b :: BackendType) (f1 :: Type -> Type) v f2. Functor f2 => (StringifyNumbers -> f2 StringifyNumbers) -> AnnSelectG b f1 v -> f2 (AnnSelectG b f1 v)
saDistinct :: forall (b :: BackendType) v f. Functor f => (Maybe (NonEmpty (AnnDistinctColumn b v)) -> f (Maybe (NonEmpty (AnnDistinctColumn b v)))) -> SelectArgsG b v -> f (SelectArgsG b v)
saLimit :: forall (b :: BackendType) v f. Functor f => (Maybe Int -> f (Maybe Int)) -> SelectArgsG b v -> f (SelectArgsG b v)
saOffset :: forall (b :: BackendType) v f. Functor f => (Maybe Int64 -> f (Maybe Int64)) -> SelectArgsG b v -> f (SelectArgsG b v)
saOrderBy :: forall (b :: BackendType) v f. Functor f => (Maybe (NonEmpty (AnnotatedOrderByItemG b v)) -> f (Maybe (NonEmpty (AnnotatedOrderByItemG b v)))) -> SelectArgsG b v -> f (SelectArgsG b v)
saWhere :: forall (b :: BackendType) v f. Functor f => (Maybe (AnnBoolExp b v) -> f (Maybe (AnnBoolExp b v))) -> SelectArgsG b v -> f (SelectArgsG b v)
aarAnnSelect :: forall (b :: BackendType) a1 a2 f. Functor f => (a1 -> f a2) -> AnnRelationSelectG b a1 -> f (AnnRelationSelectG b a2)
aarColumnMapping :: forall (b1 :: BackendType) a (b2 :: BackendType) f. Functor f => (HashMap (ColumnPath b1) (ColumnPath b1) -> f (HashMap (ColumnPath b2) (ColumnPath b2))) -> AnnRelationSelectG b1 a -> f (AnnRelationSelectG b2 a)
aarRelationshipName :: forall (b :: BackendType) a f. Functor f => (RelName -> f RelName) -> AnnRelationSelectG b a -> f (AnnRelationSelectG b a)
aarNullable :: forall (b :: BackendType) a f. Functor f => (Nullable -> f Nullable) -> AnnRelationSelectG b a -> f (AnnRelationSelectG b a)
anosSupportsNestedObjects :: forall (b :: BackendType) r v f. Functor f => (XNestedObjects b -> f (XNestedObjects b)) -> AnnNestedObjectSelectG b r v -> f (AnnNestedObjectSelectG b r v)
anosColumn :: forall (b :: BackendType) r v f. Functor f => (Column b -> f (Column b)) -> AnnNestedObjectSelectG b r v -> f (AnnNestedObjectSelectG b r v)
anosFields :: forall (b :: BackendType) r1 v1 r2 v2 f. Functor f => (AnnFieldsG b r1 v1 -> f (AnnFieldsG b r2 v2)) -> AnnNestedObjectSelectG b r1 v1 -> f (AnnNestedObjectSelectG b r2 v2)
aosFields :: forall (b :: BackendType) r1 v r2 f. Functor f => (AnnFieldsG b r1 v -> f (AnnFieldsG b r2 v)) -> AnnObjectSelectG b r1 v -> f (AnnObjectSelectG b r2 v)
aosTarget :: forall (b :: BackendType) r v f. Functor f => (SelectFromG b v -> f (SelectFromG b v)) -> AnnObjectSelectG b r v -> f (AnnObjectSelectG b r v)
aosTargetFilter :: forall (b :: BackendType) r v f. Functor f => (AnnBoolExp b v -> f (AnnBoolExp b v)) -> AnnObjectSelectG b r v -> f (AnnObjectSelectG b r v)
csXRelay :: forall (b :: BackendType) r v f. Functor f => (XRelay b -> f (XRelay b)) -> ConnectionSelect b r v -> f (ConnectionSelect b r v)
csPrimaryKeyColumns :: forall (b :: BackendType) r v f. Functor f => (PrimaryKeyColumns b -> f (PrimaryKeyColumns b)) -> ConnectionSelect b r v -> f (ConnectionSelect b r v)
csSplit :: forall (b :: BackendType) r v f. Functor f => (Maybe (NonEmpty (ConnectionSplit b v)) -> f (Maybe (NonEmpty (ConnectionSplit b v)))) -> ConnectionSelect b r v -> f (ConnectionSelect b r v)
csSlice :: forall (b :: BackendType) r v f. Functor f => (Maybe ConnectionSlice -> f (Maybe ConnectionSlice)) -> ConnectionSelect b r v -> f (ConnectionSelect b r v)
csSelect :: forall (b :: BackendType) r1 v r2 f. Functor f => (AnnSelectG b (ConnectionField b r1) v -> f (AnnSelectG b (ConnectionField b r2) v)) -> ConnectionSelect b r1 v -> f (ConnectionSelect b r2 v)
gbgFields :: forall (b :: BackendType) r1 v1 r2 v2 f. Functor f => (Fields (GroupByField b r1 v1) -> f (Fields (GroupByField b r2 v2))) -> GroupByG b r1 v1 -> f (GroupByG b r2 v2)
gbgKeys :: forall (b :: BackendType) r v f. Functor f => ([GroupKeyField b] -> f [GroupKeyField b]) -> GroupByG b r v -> f (GroupByG b r v)

-- | If argument positional index is less than or equal to length of
--   <tt>positional</tt> arguments then insert the value in
--   <tt>positional</tt> arguments else insert the value with argument name
--   in <tt>named</tt> arguments
insertFunctionArg :: FunctionArgName -> Int -> a -> FunctionArgsExpG a -> FunctionArgsExpG a
mkAnnColumnField :: forall (backend :: BackendType) v r. Column backend -> ColumnType backend -> AnnRedactionExp backend v -> Maybe (ScalarSelectionArguments backend) -> AnnFieldG backend r v
mkAnnColumnFieldAsText :: forall (backend :: BackendType) r v. ColumnInfo backend -> AnnFieldG backend r v
traverseSourceRelationshipSelection :: forall f (backend :: BackendType) vf vg r. (Applicative f, Backend backend) => (vf backend -> f (vg backend)) -> SourceRelationshipSelection backend r vf -> f (SourceRelationshipSelection backend r vg)
_AOCColumn :: forall (b :: BackendType) v p f. (Choice p, Applicative f) => p (ColumnInfo b, AnnRedactionExp b v) (f (ColumnInfo b, AnnRedactionExp b v)) -> p (AnnotatedOrderByElement b v) (f (AnnotatedOrderByElement b v))
_AOCObjectRelation :: forall (b :: BackendType) v p f. (Choice p, Applicative f) => p (RelInfo b, AnnBoolExp b v, AnnotatedOrderByElement b v) (f (RelInfo b, AnnBoolExp b v, AnnotatedOrderByElement b v)) -> p (AnnotatedOrderByElement b v) (f (AnnotatedOrderByElement b v))
_AOCArrayAggregation :: forall (b :: BackendType) v p f. (Choice p, Applicative f) => p (RelInfo b, AnnBoolExp b v, AnnotatedAggregateOrderBy b v) (f (RelInfo b, AnnBoolExp b v, AnnotatedAggregateOrderBy b v)) -> p (AnnotatedOrderByElement b v) (f (AnnotatedOrderByElement b v))
_AOCComputedField :: forall (b :: BackendType) v p f. (Choice p, Applicative f) => p (ComputedFieldOrderBy b v) (f (ComputedFieldOrderBy b v)) -> p (AnnotatedOrderByElement b v) (f (AnnotatedOrderByElement b v))
_AFArrayRelation :: forall (b :: BackendType) r v p f. (Choice p, Applicative f) => p (ArraySelectG b r v) (f (ArraySelectG b r v)) -> p (AnnFieldG b r v) (f (AnnFieldG b r v))
_AFColumn :: forall (b :: BackendType) r v p f. (Choice p, Applicative f) => p (AnnColumnField b v) (f (AnnColumnField b v)) -> p (AnnFieldG b r v) (f (AnnFieldG b r v))
_AFComputedField :: forall (b :: BackendType) r v p f. (Choice p, Applicative f) => p (XComputedField b, ComputedFieldName, ComputedFieldSelect b r v) (f (XComputedField b, ComputedFieldName, ComputedFieldSelect b r v)) -> p (AnnFieldG b r v) (f (AnnFieldG b r v))
_AFExpression :: forall (b :: BackendType) r v p f. (Choice p, Applicative f) => p Text (f Text) -> p (AnnFieldG b r v) (f (AnnFieldG b r v))
_AFNodeId :: forall (b :: BackendType) r v p f. (Choice p, Applicative f) => p (XRelay b, SourceName, TableName b, PrimaryKeyColumns b) (f (XRelay b, SourceName, TableName b, PrimaryKeyColumns b)) -> p (AnnFieldG b r v) (f (AnnFieldG b r v))
_AFObjectRelation :: forall (b :: BackendType) r v p f. (Choice p, Applicative f) => p (ObjectRelationSelectG b r v) (f (ObjectRelationSelectG b r v)) -> p (AnnFieldG b r v) (f (AnnFieldG b r v))
_AFRemote :: forall (b :: BackendType) r v p f. (Choice p, Applicative f) => p (RemoteRelationshipSelect b r) (f (RemoteRelationshipSelect b r)) -> p (AnnFieldG b r v) (f (AnnFieldG b r v))
_TAFAgg :: forall (b :: BackendType) r v p f. (Choice p, Applicative f) => p (AggregateFields b v) (f (AggregateFields b v)) -> p (TableAggregateFieldG b r v) (f (TableAggregateFieldG b r v))
_TAFNodes :: forall (b :: BackendType) r v p f. (Choice p, Applicative f) => p (XNodesAgg b, AnnFieldsG b r v) (f (XNodesAgg b, AnnFieldsG b r v)) -> p (TableAggregateFieldG b r v) (f (TableAggregateFieldG b r v))
_TAFExp :: forall (b :: BackendType) r v p f. (Choice p, Applicative f) => p Text (f Text) -> p (TableAggregateFieldG b r v) (f (TableAggregateFieldG b r v))
_GBFGroupKey :: forall (b :: BackendType) r v p f. (Choice p, Applicative f) => p (Fields (GroupKeyField b)) (f (Fields (GroupKeyField b))) -> p (GroupByField b r v) (f (GroupByField b r v))
_GBFAggregate :: forall (b :: BackendType) r v p f. (Choice p, Applicative f) => p (AggregateFields b v) (f (AggregateFields b v)) -> p (GroupByField b r v) (f (GroupByField b r v))
_GBFNodes :: forall (b :: BackendType) r1 v r2 p f. (Choice p, Applicative f) => p (AnnFieldsG b r1 v) (f (AnnFieldsG b r2 v)) -> p (GroupByField b r1 v) (f (GroupByField b r2 v))
_GBFExp :: forall (b :: BackendType) r v p f. (Choice p, Applicative f) => p Text (f Text) -> p (GroupByField b r v) (f (GroupByField b r v))
_ConnectionTypename :: forall (b :: BackendType) r v p f. (Choice p, Applicative f) => p Text (f Text) -> p (ConnectionField b r v) (f (ConnectionField b r v))
_ConnectionPageInfo :: forall (b :: BackendType) r v p f. (Choice p, Applicative f) => p PageInfoFields (f PageInfoFields) -> p (ConnectionField b r v) (f (ConnectionField b r v))
_ConnectionEdges :: forall (b1 :: BackendType) r1 v1 (b2 :: BackendType) r2 v2 p f. (Choice p, Applicative f) => p (EdgeFields b1 r1 v1) (f (EdgeFields b2 r2 v2)) -> p (ConnectionField b1 r1 v1) (f (ConnectionField b2 r2 v2))
_EdgeTypename :: forall (b :: BackendType) r v p f. (Choice p, Applicative f) => p Text (f Text) -> p (EdgeField b r v) (f (EdgeField b r v))
_EdgeCursor :: forall (b :: BackendType) r v p f. (Choice p, Applicative f) => p () (f ()) -> p (EdgeField b r v) (f (EdgeField b r v))
_EdgeNode :: forall (b1 :: BackendType) r1 v1 (b2 :: BackendType) r2 v2 p f. (Choice p, Applicative f) => p (AnnFieldsG b1 r1 v1) (f (AnnFieldsG b2 r2 v2)) -> p (EdgeField b1 r1 v1) (f (EdgeField b2 r2 v2))

module Hasura.RQL.IR.Returning
type MutFld (b :: BackendType) = MutFldG b Void SQLExpression b
data MutFldG (b :: BackendType) r v
MCount :: MutFldG (b :: BackendType) r v
MExp :: Text -> MutFldG (b :: BackendType) r v
MRet :: AnnFieldsG b r v -> MutFldG (b :: BackendType) r v
_MCount :: forall (b :: BackendType) r v p f. (Choice p, Applicative f) => p () (f ()) -> p (MutFldG b r v) (f (MutFldG b r v))
_MExp :: forall (b :: BackendType) r v p f. (Choice p, Applicative f) => p Text (f Text) -> p (MutFldG b r v) (f (MutFldG b r v))
_MRet :: forall (b1 :: BackendType) r1 v1 (b2 :: BackendType) r2 v2 p f. (Choice p, Applicative f) => p (AnnFieldsG b1 r1 v1) (f (AnnFieldsG b2 r2 v2)) -> p (MutFldG b1 r1 v1) (f (MutFldG b2 r2 v2))
type MutFlds (b :: BackendType) = MutFldsG b Void SQLExpression b
type MutFldsG (b :: BackendType) r v = Fields MutFldG b r v
type MutationOutput (b :: BackendType) = MutationOutputG b Void SQLExpression b
data MutationOutputG (b :: BackendType) r v
MOutMultirowFields :: MutFldsG b r v -> MutationOutputG (b :: BackendType) r v
MOutSinglerowObject :: AnnFieldsG b r v -> MutationOutputG (b :: BackendType) r v
buildEmptyMutResp :: forall (backend :: BackendType). MutationOutput backend -> EncJSON
hasNestedFld :: forall (backend :: BackendType) r a. MutationOutputG backend r a -> Bool
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq r, GHC.Classes.Eq v) => GHC.Classes.Eq (Hasura.RQL.IR.Returning.MutFldG b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq v, GHC.Classes.Eq r) => GHC.Classes.Eq (Hasura.RQL.IR.Returning.MutationOutputG b r v)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.Returning.MutFldG b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.Returning.MutationOutputG b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Base.Functor (Hasura.RQL.IR.Returning.MutFldG b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Base.Functor (Hasura.RQL.IR.Returning.MutationOutputG b r)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show v, GHC.Internal.Show.Show r) => GHC.Internal.Show.Show (Hasura.RQL.IR.Returning.MutFldG b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show v, GHC.Internal.Show.Show r) => GHC.Internal.Show.Show (Hasura.RQL.IR.Returning.MutationOutputG b r v)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.Returning.MutFldG b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.Returning.MutationOutputG b r)

module Hasura.RQL.IR.Update
type AnnotatedUpdate (b :: BackendType) = AnnotatedUpdateG b Void SQLExpression b
data AnnotatedUpdateG (b :: BackendType) r v
AnnotatedUpdateG :: TableName b -> AnnBoolExp b v -> AnnBoolExp b v -> UpdateVariant b v -> MutationOutputG b r v -> [ColumnInfo b] -> Maybe NamingCase -> Maybe (ValidateInput ResolvedWebhook) -> AnnotatedUpdateG (b :: BackendType) r v
[_auTable] :: AnnotatedUpdateG (b :: BackendType) r v -> TableName b
[_auUpdatePermissions] :: AnnotatedUpdateG (b :: BackendType) r v -> AnnBoolExp b v
[_auCheck] :: AnnotatedUpdateG (b :: BackendType) r v -> AnnBoolExp b v
[_auUpdateVariant] :: AnnotatedUpdateG (b :: BackendType) r v -> UpdateVariant b v

-- | Selection set
[_auOutput] :: AnnotatedUpdateG (b :: BackendType) r v -> MutationOutputG b r v
[_auAllCols] :: AnnotatedUpdateG (b :: BackendType) r v -> [ColumnInfo b]
[_auNamingConvention] :: AnnotatedUpdateG (b :: BackendType) r v -> Maybe NamingCase
[_auValidateInput] :: AnnotatedUpdateG (b :: BackendType) r v -> Maybe (ValidateInput ResolvedWebhook)
auTable :: forall (b :: BackendType) r v f. Functor f => (TableName b -> f (TableName b)) -> AnnotatedUpdateG b r v -> f (AnnotatedUpdateG b r v)
auUpdatePermissions :: forall (b :: BackendType) r v f. Functor f => (AnnBoolExp b v -> f (AnnBoolExp b v)) -> AnnotatedUpdateG b r v -> f (AnnotatedUpdateG b r v)
auCheck :: forall (b :: BackendType) r v f. Functor f => (AnnBoolExp b v -> f (AnnBoolExp b v)) -> AnnotatedUpdateG b r v -> f (AnnotatedUpdateG b r v)
auUpdateVariant :: forall (b :: BackendType) r v f. Functor f => (UpdateVariant b v -> f (UpdateVariant b v)) -> AnnotatedUpdateG b r v -> f (AnnotatedUpdateG b r v)
auOutput :: forall (b :: BackendType) r1 v r2 f. Functor f => (MutationOutputG b r1 v -> f (MutationOutputG b r2 v)) -> AnnotatedUpdateG b r1 v -> f (AnnotatedUpdateG b r2 v)
auAllCols :: forall (b :: BackendType) r v f. Functor f => ([ColumnInfo b] -> f [ColumnInfo b]) -> AnnotatedUpdateG b r v -> f (AnnotatedUpdateG b r v)
auNamingConvention :: forall (b :: BackendType) r v f. Functor f => (Maybe NamingCase -> f (Maybe NamingCase)) -> AnnotatedUpdateG b r v -> f (AnnotatedUpdateG b r v)
auValidateInput :: forall (b :: BackendType) r v f. Functor f => (Maybe (ValidateInput ResolvedWebhook) -> f (Maybe (ValidateInput ResolvedWebhook))) -> AnnotatedUpdateG b r v -> f (AnnotatedUpdateG b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq v, GHC.Classes.Eq r) => GHC.Classes.Eq (Hasura.RQL.IR.Update.AnnotatedUpdateG b r v)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.Update.AnnotatedUpdateG b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Base.Functor (Hasura.RQL.IR.Update.AnnotatedUpdateG b r)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show v, GHC.Internal.Show.Show r) => GHC.Internal.Show.Show (Hasura.RQL.IR.Update.AnnotatedUpdateG b r v)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.Update.AnnotatedUpdateG b r)


-- | Internal representation of an insertion in a database table.
--   
--   What makes this specific mutation tricky is that we support recursive
--   insertions, across local relationships. Because local joins come in
--   two different kinds (object relationships and array relations), and
--   because for each table we expose two root different root fields
--   (insert_one and insert), we distinguish between *single row inserts*
--   and *multi rows inserts*.
--   
--   TODO: the distinction between single-row inserts and multi-rows
--   inserts does not need to be enforced the way it currently is, with
--   booleans and different types. The distinction could be made in the
--   translation layer, if need be.
module Hasura.RQL.IR.Insert

-- | One individual insert, one node from the tree. The <tt>f</tt>
--   parameter is used to construct the container for the values to be
--   inserted: <a>Single</a> for a single-row insert, '[]' for a multi-row
--   insert.
data AnnotatedInsertData (b :: BackendType) (f :: Type -> Type) v
AnnotatedInsertData :: f (AnnotatedInsertRow b v) -> TableName b -> (AnnBoolExp b v, Maybe (AnnBoolExp b v)) -> [ColumnInfo b] -> Maybe (NESeq (Column b)) -> ExtraTableMetadata b -> PreSetColsG b v -> BackendInsert b v -> Maybe (ValidateInput ResolvedWebhook) -> AnnotatedInsertData (b :: BackendType) (f :: Type -> Type) v
[_aiInsertObject] :: AnnotatedInsertData (b :: BackendType) (f :: Type -> Type) v -> f (AnnotatedInsertRow b v)
[_aiTableName] :: AnnotatedInsertData (b :: BackendType) (f :: Type -> Type) v -> TableName b
[_aiCheckCondition] :: AnnotatedInsertData (b :: BackendType) (f :: Type -> Type) v -> (AnnBoolExp b v, Maybe (AnnBoolExp b v))
[_aiTableColumns] :: AnnotatedInsertData (b :: BackendType) (f :: Type -> Type) v -> [ColumnInfo b]
[_aiPrimaryKey] :: AnnotatedInsertData (b :: BackendType) (f :: Type -> Type) v -> Maybe (NESeq (Column b))
[_aiExtraTableMetadata] :: AnnotatedInsertData (b :: BackendType) (f :: Type -> Type) v -> ExtraTableMetadata b
[_aiPresetValues] :: AnnotatedInsertData (b :: BackendType) (f :: Type -> Type) v -> PreSetColsG b v
[_aiBackendInsert] :: AnnotatedInsertData (b :: BackendType) (f :: Type -> Type) v -> BackendInsert b v
[_aiValidateInput] :: AnnotatedInsertData (b :: BackendType) (f :: Type -> Type) v -> Maybe (ValidateInput ResolvedWebhook)

-- | Overall representation of an insert mutation, corresponding to one
--   root field in our mutation, including the parsed selection set of the
--   mutation's output. For historical reasons, it will always contain a
--   <a>MultiObjectInsert</a>, whether the root mutation is a single row or
--   not, and will distinguish between them using a boolean field.
data AnnotatedInsert (b :: BackendType) r v
AnnotatedInsert :: Text -> Bool -> MultiObjectInsert b v -> MutationOutputG b r v -> Maybe NamingCase -> AnnotatedInsert (b :: BackendType) r v
[_aiFieldName] :: AnnotatedInsert (b :: BackendType) r v -> Text
[_aiIsSingle] :: AnnotatedInsert (b :: BackendType) r v -> Bool
[_aiData] :: AnnotatedInsert (b :: BackendType) r v -> MultiObjectInsert b v
[_aiOutput] :: AnnotatedInsert (b :: BackendType) r v -> MutationOutputG b r v
[_aiNamingConvention] :: AnnotatedInsert (b :: BackendType) r v -> Maybe NamingCase
aiFieldName :: forall (b :: BackendType) r v f. Functor f => (Text -> f Text) -> AnnotatedInsert b r v -> f (AnnotatedInsert b r v)
aiIsSingle :: forall (b :: BackendType) r v f. Functor f => (Bool -> f Bool) -> AnnotatedInsert b r v -> f (AnnotatedInsert b r v)
aiData :: forall (b :: BackendType) r v f. Functor f => (MultiObjectInsert b v -> f (MultiObjectInsert b v)) -> AnnotatedInsert b r v -> f (AnnotatedInsert b r v)
aiOutput :: forall (b :: BackendType) r1 v r2 f. Functor f => (MutationOutputG b r1 v -> f (MutationOutputG b r2 v)) -> AnnotatedInsert b r1 v -> f (AnnotatedInsert b r2 v)
aiNamingConvention :: forall (b :: BackendType) r v f. Functor f => (Maybe NamingCase -> f (Maybe NamingCase)) -> AnnotatedInsert b r v -> f (AnnotatedInsert b r v)

-- | An insert item. The object and array relationships are not unavailable
--   when 'XNestedInserts b = XDisable'
data AnnotatedInsertField (b :: BackendType) v
AIColumn :: (Column b, v) -> AnnotatedInsertField (b :: BackendType) v
AIObjectRelationship :: XNestedInserts b -> ObjectRelationInsert b v -> AnnotatedInsertField (b :: BackendType) v
AIArrayRelationship :: XNestedInserts b -> ArrayRelationInsert b v -> AnnotatedInsertField (b :: BackendType) v

-- | One individual row to be inserted. Contains the columns' values and
--   all the matching recursive relationship inserts.
type AnnotatedInsertRow (b :: BackendType) v = [AnnotatedInsertField b v]

-- | Insert across an array relationship. Array relationships are 1:*
--   relationships across tables; an insert across such a relationship may
--   therefore contain multiple rows; <tt>RelIns</tt> is therefore
--   parameterized by a <a>MultiObjectInsert</a>.
type ArrayRelationInsert (b :: BackendType) v = RelationInsert b MultiObjectInsert b v
data OnConflictClause (b :: BackendType) v
OCCDoNothing :: Maybe (ConflictTarget b) -> OnConflictClause (b :: BackendType) v
OCCUpdate :: OnConflictClauseData b v -> OnConflictClause (b :: BackendType) v
data OnConflictClauseData (b :: BackendType) v
OnConflictClauseData :: ConflictTarget b -> [Column b] -> PreSetColsG b v -> AnnBoolExp b v -> OnConflictClauseData (b :: BackendType) v
[cp1udConflictTarget] :: OnConflictClauseData (b :: BackendType) v -> ConflictTarget b
[cp1udAffectedColumns] :: OnConflictClauseData (b :: BackendType) v -> [Column b]
[cp1udValues] :: OnConflictClauseData (b :: BackendType) v -> PreSetColsG b v
[cp1udFilter] :: OnConflictClauseData (b :: BackendType) v -> AnnBoolExp b v
data ConflictTarget (b :: BackendType)
CTColumn :: [Column b] -> ConflictTarget (b :: BackendType)
CTConstraint :: ConstraintName b -> ConflictTarget (b :: BackendType)

-- | Old-style representation used for non-recursive insertions. This is
--   the representation used by RQL.DML, instead of the new fancy recursive
--   one present in this file. Postgres supports both representations, and
--   actually translates recursive queries that do not have any
--   relationships into this representation first.
data InsertQueryP1 (b :: BackendType)
InsertQueryP1 :: TableName b -> [Column b] -> [[SQLExpression b]] -> Maybe (OnConflictClause b (SQLExpression b)) -> (AnnBoolExpSQL b, Maybe (AnnBoolExpSQL b)) -> MutationOutput b -> [ColumnInfo b] -> InsertQueryP1 (b :: BackendType)
[iqp1Table] :: InsertQueryP1 (b :: BackendType) -> TableName b
[iqp1Cols] :: InsertQueryP1 (b :: BackendType) -> [Column b]
[iqp1Tuples] :: InsertQueryP1 (b :: BackendType) -> [[SQLExpression b]]
[iqp1Conflict] :: InsertQueryP1 (b :: BackendType) -> Maybe (OnConflictClause b (SQLExpression b))
[iqp1CheckCond] :: InsertQueryP1 (b :: BackendType) -> (AnnBoolExpSQL b, Maybe (AnnBoolExpSQL b))
[iqp1Output] :: InsertQueryP1 (b :: BackendType) -> MutationOutput b
[iqp1AllCols] :: InsertQueryP1 (b :: BackendType) -> [ColumnInfo b]
type MultiObjectInsert (b :: BackendType) v = AnnotatedInsertData b [] v

-- | Insert across an object relationship. Object relationships are 1:1
--   relationships across tables; an insert across such a relationship can
--   only insert one single row at a time; <tt>RelIns</tt> is therefore
--   parameterized by a <a>SingleObjectInsert</a>.
type ObjectRelationInsert (b :: BackendType) v = RelationInsert b SingleObjectInsert b v

-- | One individual relationship. Unlike other types, this one is not
--   parameterized by the type of the leaves <tt>v</tt>, but by the kind of
--   insert has to be performed: multi-row or single row. See
--   <a>ObjectRelationInsert</a> and <a>ArrayRelationInsert</a>.
data RelationInsert (b :: BackendType) a
RelationInsert :: a -> RelInfo b -> RelationInsert (b :: BackendType) a
[_riInsertData] :: RelationInsert (b :: BackendType) a -> a
[_riRelationInfo] :: RelationInsert (b :: BackendType) a -> RelInfo b

-- | Ad-hoc helper. We differientate between single row inserts
--   (<tt>SingleObjIns</tt>) and multiple row inserts
--   (<tt>MultiObjIns</tt>), but both use the same underlying
--   representation: <tt>AnnIns</tt>. The only difference is which functor
--   is used as a parameter. We use '[]' for <tt>MultiObjIns</tt>, and we
--   use this trivial <a>Single</a> for <tt>SingleObjIns</tt>.
newtype Single a
Single :: a -> Single a
[unSingle] :: Single a -> a
type SingleObjectInsert (b :: BackendType) v = AnnotatedInsertData b Single v
getInsertArrayRelationships :: forall (b :: BackendType) v. AnnotatedInsertRow b v -> [ArrayRelationInsert b v]
getInsertColumns :: forall (b :: BackendType) v. AnnotatedInsertRow b v -> [(Column b, v)]
getInsertObjectRelationships :: forall (b :: BackendType) v. AnnotatedInsertRow b v -> [ObjectRelationInsert b v]
_AIArrayRelationship :: forall (b :: BackendType) v p f. (Choice p, Applicative f) => p (XNestedInserts b, ArrayRelationInsert b v) (f (XNestedInserts b, ArrayRelationInsert b v)) -> p (AnnotatedInsertField b v) (f (AnnotatedInsertField b v))
_AIColumn :: forall (b :: BackendType) v p f. (Choice p, Applicative f) => p (Column b, v) (f (Column b, v)) -> p (AnnotatedInsertField b v) (f (AnnotatedInsertField b v))
_AIObjectRelationship :: forall (b :: BackendType) v p f. (Choice p, Applicative f) => p (XNestedInserts b, ObjectRelationInsert b v) (f (XNestedInserts b, ObjectRelationInsert b v)) -> p (AnnotatedInsertField b v) (f (AnnotatedInsertField b v))
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq a) => GHC.Classes.Eq (Hasura.RQL.IR.Insert.RelationInsert b a)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.Insert.AnnotatedInsert b r)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Data.Foldable.Foldable f) => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.Insert.AnnotatedInsertData b f)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.Insert.AnnotatedInsertField b)
instance GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.Insert.RelationInsert b)
instance GHC.Internal.Data.Foldable.Foldable Hasura.RQL.IR.Insert.Single
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Base.Functor (Hasura.RQL.IR.Insert.AnnotatedInsert b r)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Base.Functor f) => GHC.Internal.Base.Functor (Hasura.RQL.IR.Insert.AnnotatedInsertData b f)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Base.Functor (Hasura.RQL.IR.Insert.AnnotatedInsertField b)
instance GHC.Internal.Base.Functor (Hasura.RQL.IR.Insert.RelationInsert b)
instance GHC.Internal.Base.Functor Hasura.RQL.IR.Insert.Single
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show a) => GHC.Internal.Show.Show (Hasura.RQL.IR.Insert.RelationInsert b a)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.Insert.AnnotatedInsert b r)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Data.Traversable.Traversable f) => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.Insert.AnnotatedInsertData b f)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.Insert.AnnotatedInsertField b)
instance GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.Insert.RelationInsert b)
instance GHC.Internal.Data.Traversable.Traversable Hasura.RQL.IR.Insert.Single

module Hasura.RQL.IR.Delete
type AnnDel (b :: BackendType) = AnnDelG b Void SQLExpression b
data AnnDelG (b :: BackendType) r v
AnnDel :: TableName b -> (AnnBoolExp b v, AnnBoolExp b v) -> MutationOutputG b r v -> [ColumnInfo b] -> Maybe NamingCase -> Maybe (ValidateInput ResolvedWebhook) -> Bool -> AnnDelG (b :: BackendType) r v
[_adTable] :: AnnDelG (b :: BackendType) r v -> TableName b
[_adWhere] :: AnnDelG (b :: BackendType) r v -> (AnnBoolExp b v, AnnBoolExp b v)
[_adOutput] :: AnnDelG (b :: BackendType) r v -> MutationOutputG b r v
[_adAllCols] :: AnnDelG (b :: BackendType) r v -> [ColumnInfo b]
[_adNamingConvention] :: AnnDelG (b :: BackendType) r v -> Maybe NamingCase
[_adValidateInput] :: AnnDelG (b :: BackendType) r v -> Maybe (ValidateInput ResolvedWebhook)
[_adIsDeleteByPk] :: AnnDelG (b :: BackendType) r v -> Bool
adTable :: forall (b :: BackendType) r v f. Functor f => (TableName b -> f (TableName b)) -> AnnDelG b r v -> f (AnnDelG b r v)
adWhere :: forall (b :: BackendType) r v f. Functor f => ((AnnBoolExp b v, AnnBoolExp b v) -> f (AnnBoolExp b v, AnnBoolExp b v)) -> AnnDelG b r v -> f (AnnDelG b r v)
adOutput :: forall (b :: BackendType) r1 v r2 f. Functor f => (MutationOutputG b r1 v -> f (MutationOutputG b r2 v)) -> AnnDelG b r1 v -> f (AnnDelG b r2 v)
adAllCols :: forall (b :: BackendType) r v f. Functor f => ([ColumnInfo b] -> f [ColumnInfo b]) -> AnnDelG b r v -> f (AnnDelG b r v)
adNamingConvention :: forall (b :: BackendType) r v f. Functor f => (Maybe NamingCase -> f (Maybe NamingCase)) -> AnnDelG b r v -> f (AnnDelG b r v)
adValidateInput :: forall (b :: BackendType) r v f. Functor f => (Maybe (ValidateInput ResolvedWebhook) -> f (Maybe (ValidateInput ResolvedWebhook))) -> AnnDelG b r v -> f (AnnDelG b r v)
adIsDeleteByPk :: forall (b :: BackendType) r v f. Functor f => (Bool -> f Bool) -> AnnDelG b r v -> f (AnnDelG b r v)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.Delete.AnnDelG b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Base.Functor (Hasura.RQL.IR.Delete.AnnDelG b r)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show r, GHC.Internal.Show.Show a) => GHC.Internal.Show.Show (Hasura.RQL.IR.Delete.AnnDelG b r a)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.Delete.AnnDelG b r)


-- | Postgres Translate Delete
--   
--   Tranlates an IR delete term to a Postgres SQL DELETE statement.
--   
--   See <a>execDeleteQuery</a>.
module Hasura.Backends.Postgres.Translate.Delete
mkDelete :: forall (pgKind :: PostgresKind) m. (Backend ('Postgres pgKind), MonadIO m, MonadError QErr m) => UserInfo -> AnnDel ('Postgres pgKind) -> m SQLDelete


-- | Postgres Translate Types
--   
--   Intermediary / helper types used for translating IR to Postgres SQL.
module Hasura.Backends.Postgres.Translate.Types
data ApplySortingAndSlicing
ApplySortingAndSlicing :: (Maybe OrderByExp, SelectSlicing, Maybe DistinctExpr) -> (Maybe OrderByExp, SelectSlicing, Maybe DistinctExpr) -> ApplySortingAndSlicing
data ArrayConnectionSource
ArrayConnectionSource :: TableAlias -> HashMap PGCol PGCol -> Maybe BoolExp -> Maybe ConnectionSlice -> SelectSource -> ArrayConnectionSource
data ArrayRelationSource
ArrayRelationSource :: TableAlias -> HashMap PGCol PGCol -> SelectSource -> ArrayRelationSource
data ComputedFieldTableSetSource
ComputedFieldTableSetSource :: FieldName -> SelectSource -> ComputedFieldTableSetSource
newtype CustomSQLCTEs
CustomSQLCTEs :: HashMap TableAlias (InterpolatedQuery SQLExp) -> CustomSQLCTEs
[getCustomSQLCTEs] :: CustomSQLCTEs -> HashMap TableAlias (InterpolatedQuery SQLExp)
newtype NativeQueryFreshIdStore
NativeQueryFreshIdStore :: Int -> NativeQueryFreshIdStore
[nqNextFreshId] :: NativeQueryFreshIdStore -> Int
initialNativeQueryFreshIdStore :: NativeQueryFreshIdStore
data DistinctAndOrderByExpr
ASorting :: (OrderByExp, Maybe DistinctExpr) -> Maybe (OrderByExp, Maybe DistinctExpr) -> DistinctAndOrderByExpr
data JoinTree
JoinTree :: HashMap ObjectRelationSource SelectNode -> HashMap ArrayRelationSource MultiRowSelectNode -> HashMap ArrayConnectionSource MultiRowSelectNode -> HashMap ComputedFieldTableSetSource MultiRowSelectNode -> JoinTree
[_jtObjectRelations] :: JoinTree -> HashMap ObjectRelationSource SelectNode
[_jtArrayRelations] :: JoinTree -> HashMap ArrayRelationSource MultiRowSelectNode
[_jtArrayConnections] :: JoinTree -> HashMap ArrayConnectionSource MultiRowSelectNode
[_jtComputedFieldTableSets] :: JoinTree -> HashMap ComputedFieldTableSetSource MultiRowSelectNode
data MultiRowSelectNode
MultiRowSelectNode :: [Extractor] -> SelectNode -> MultiRowSelectNode
[_mrsnTopExtractors] :: MultiRowSelectNode -> [Extractor]
[_mrsnSelectNode] :: MultiRowSelectNode -> SelectNode
data ObjectRelationSource
ObjectRelationSource :: RelName -> HashMap PGCol PGCol -> ObjectSelectSource -> Nullable -> ObjectRelationSource
[_orsRelationshipName] :: ObjectRelationSource -> RelName
[_orsRelationMapping] :: ObjectRelationSource -> HashMap PGCol PGCol
[_orsSelectSource] :: ObjectRelationSource -> ObjectSelectSource
[_orsNullable] :: ObjectRelationSource -> Nullable
data ObjectSelectSource
ObjectSelectSource :: Identifier -> FromItem -> BoolExp -> ObjectSelectSource
data PermissionLimitSubQuery

-- | Permission limit
PLSQRequired :: Int -> PermissionLimitSubQuery
PLSQNotRequired :: PermissionLimitSubQuery
data SelectNode
SelectNode :: InsOrdHashMap ColumnAlias SQLExp -> JoinTree -> SelectNode

-- | Select portion of rows generated by the query using limit and offset
data SelectSlicing
SelectSlicing :: Maybe Int -> Maybe Int64 -> SelectSlicing
[_ssLimit] :: SelectSlicing -> Maybe Int
[_ssOffset] :: SelectSlicing -> Maybe Int64

-- | Sorting with -- Note [Optimizing queries using limit/offset])
data SelectSorting
NoSorting :: Maybe DistinctExpr -> SelectSorting
Sorting :: DistinctAndOrderByExpr -> SelectSorting
data SelectSource
SelectSource :: Identifier -> FromItem -> BoolExp -> SortingAndSlicing -> SelectSource
data SortingAndSlicing
SortingAndSlicing :: SelectSorting -> SelectSlicing -> SortingAndSlicing
data SourcePrefixes
SourcePrefixes :: Identifier -> Identifier -> SourcePrefixes

-- | Current source prefix
[_pfThis] :: SourcePrefixes -> Identifier

-- | Base table source row identifier to generate the table's column
--   identifiers for computed field function input parameters
[_pfBase] :: SourcePrefixes -> Identifier
type SimilarArrayFields = HashMap FieldName [FieldName]
data SelectWriter
SelectWriter :: JoinTree -> CustomSQLCTEs -> SelectWriter
[_swJoinTree] :: SelectWriter -> JoinTree
[_swCustomSQLCTEs] :: SelectWriter -> CustomSQLCTEs
applySortingAndSlicing :: SortingAndSlicing -> ApplySortingAndSlicing
noSortingAndSlicing :: SortingAndSlicing
objectSelectSourceToSelectSource :: ObjectSelectSource -> SelectSource
orderByForJsonAgg :: SelectSource -> Maybe OrderByExp
instance GHC.Internal.Enum.Enum Hasura.Backends.Postgres.Translate.Types.NativeQueryFreshIdStore
instance GHC.Classes.Eq Hasura.Backends.Postgres.Translate.Types.ArrayConnectionSource
instance GHC.Classes.Eq Hasura.Backends.Postgres.Translate.Types.ArrayRelationSource
instance GHC.Classes.Eq Hasura.Backends.Postgres.Translate.Types.ComputedFieldTableSetSource
instance GHC.Classes.Eq Hasura.Backends.Postgres.Translate.Types.CustomSQLCTEs
instance GHC.Classes.Eq Hasura.Backends.Postgres.Translate.Types.DistinctAndOrderByExpr
instance GHC.Classes.Eq Hasura.Backends.Postgres.Translate.Types.JoinTree
instance GHC.Classes.Eq Hasura.Backends.Postgres.Translate.Types.MultiRowSelectNode
instance GHC.Classes.Eq Hasura.Backends.Postgres.Translate.Types.NativeQueryFreshIdStore
instance GHC.Classes.Eq Hasura.Backends.Postgres.Translate.Types.ObjectRelationSource
instance GHC.Classes.Eq Hasura.Backends.Postgres.Translate.Types.ObjectSelectSource
instance GHC.Classes.Eq Hasura.Backends.Postgres.Translate.Types.PermissionLimitSubQuery
instance GHC.Classes.Eq Hasura.Backends.Postgres.Translate.Types.SelectNode
instance GHC.Classes.Eq Hasura.Backends.Postgres.Translate.Types.SelectSlicing
instance GHC.Classes.Eq Hasura.Backends.Postgres.Translate.Types.SelectSorting
instance GHC.Classes.Eq Hasura.Backends.Postgres.Translate.Types.SelectSource
instance GHC.Classes.Eq Hasura.Backends.Postgres.Translate.Types.SortingAndSlicing
instance GHC.Classes.Eq Hasura.Backends.Postgres.Translate.Types.SourcePrefixes
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.Translate.Types.ArrayConnectionSource
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.Translate.Types.ArrayRelationSource
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.Translate.Types.ComputedFieldTableSetSource
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.Translate.Types.DistinctAndOrderByExpr
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.Translate.Types.ObjectRelationSource
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.Translate.Types.ObjectSelectSource
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.Translate.Types.SelectSlicing
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.Translate.Types.SelectSorting
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.Translate.Types.SelectSource
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.Translate.Types.SortingAndSlicing
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.Translate.Types.SourcePrefixes
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Translate.Types.ArrayConnectionSource
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Translate.Types.ArrayRelationSource
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Translate.Types.ComputedFieldTableSetSource
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Translate.Types.DistinctAndOrderByExpr
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Translate.Types.ObjectRelationSource
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Translate.Types.ObjectSelectSource
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Translate.Types.SelectSlicing
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Translate.Types.SelectSorting
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Translate.Types.SelectSource
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Translate.Types.SortingAndSlicing
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Translate.Types.SourcePrefixes
instance GHC.Internal.Base.Monoid Hasura.Backends.Postgres.Translate.Types.CustomSQLCTEs
instance GHC.Internal.Base.Monoid Hasura.Backends.Postgres.Translate.Types.JoinTree
instance GHC.Internal.Base.Monoid Hasura.Backends.Postgres.Translate.Types.SelectWriter
instance GHC.Internal.Base.Semigroup Hasura.Backends.Postgres.Translate.Types.CustomSQLCTEs
instance GHC.Internal.Base.Semigroup Hasura.Backends.Postgres.Translate.Types.JoinTree
instance GHC.Internal.Base.Semigroup Hasura.Backends.Postgres.Translate.Types.MultiRowSelectNode
instance GHC.Internal.Base.Semigroup Hasura.Backends.Postgres.Translate.Types.SelectNode
instance GHC.Internal.Base.Semigroup Hasura.Backends.Postgres.Translate.Types.SelectWriter
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Translate.Types.ArrayConnectionSource
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Translate.Types.ArrayRelationSource
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Translate.Types.ComputedFieldTableSetSource
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Translate.Types.CustomSQLCTEs
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Translate.Types.DistinctAndOrderByExpr
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Translate.Types.JoinTree
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Translate.Types.MultiRowSelectNode
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Translate.Types.NativeQueryFreshIdStore
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Translate.Types.ObjectRelationSource
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Translate.Types.ObjectSelectSource
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Translate.Types.PermissionLimitSubQuery
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Translate.Types.SelectNode
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Translate.Types.SelectSlicing
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Translate.Types.SelectSorting
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Translate.Types.SelectSource
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Translate.Types.SortingAndSlicing
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Translate.Types.SourcePrefixes


-- | Stuff gutted from Translate.Select
module Hasura.Backends.Postgres.Translate.Select.Internal.JoinTree

-- | This is the lowest level function which deals with <tt>MonadWriter
--   SelectWriter</tt>, which contains <tt>JoinTree</tt> whose purpose is
--   to essentially create the selection tree across relationships.
--   
--   Each type of relationship uses a different kind of update function;
--   see <a>withWriteObjectRelation</a>, <a>withWriteArrayRelation</a>,
--   <a>withWriteArrayConnection</a>, and
--   <a>withWriteComputedFieldTableSet</a>.
--   
--   See the definition of <a>JoinTree</a> for details before diving
--   further (particularly its components and Monoid instance).
withWriteJoinTree :: MonadWriter SelectWriter m => (JoinTree -> b -> JoinTree) -> m (a, b) -> m a
withWriteObjectRelation :: MonadWriter SelectWriter m => m (ObjectRelationSource, InsOrdHashMap ColumnAlias SQLExp, a) -> m a
withWriteArrayRelation :: MonadWriter SelectWriter m => m (ArrayRelationSource, Extractor, InsOrdHashMap ColumnAlias SQLExp, a) -> m a
withWriteArrayConnection :: MonadWriter SelectWriter m => m (ArrayConnectionSource, Extractor, InsOrdHashMap ColumnAlias SQLExp, a) -> m a
withWriteComputedFieldTableSet :: MonadWriter SelectWriter m => m (ComputedFieldTableSetSource, Extractor, InsOrdHashMap ColumnAlias SQLExp, a) -> m a


-- | Stuff gutted from Translate.Select
module Hasura.Backends.Postgres.Translate.Select.Internal.Aliases
mkAggregateOrderByAlias :: forall (pgKind :: PostgresKind) v. AnnotatedAggregateOrderBy ('Postgres pgKind) v -> ColumnAlias

-- | Generate alias for order by extractors
mkAnnOrderByAlias :: forall (pgKind :: PostgresKind) v. TableIdentifier -> FieldName -> SimilarArrayFields -> AnnotatedOrderByElement ('Postgres pgKind) v -> ColumnAlias
mkArrayRelationAlias :: FieldName -> HashMap FieldName [FieldName] -> FieldName -> TableAlias
mkArrayRelationSourcePrefix :: TableIdentifier -> FieldName -> HashMap FieldName [FieldName] -> FieldName -> TableIdentifier
mkBaseTableAlias :: TableAlias -> TableAlias
mkBaseTableIdentifier :: TableIdentifier -> TableIdentifier
contextualizeBaseTableColumn :: TableIdentifier -> PGCol -> ColumnAlias
contextualizeField :: TableIdentifier -> FieldName -> ColumnAlias
contextualizeAggregateInput :: TableIdentifier -> FieldName -> FieldName -> ColumnAlias
mkComputedFieldTableIdentifier :: TableIdentifier -> FieldName -> TableIdentifier
mkObjectRelationTableAlias :: TableIdentifier -> RelName -> TableIdentifier
mkOrderByFieldName :: ToTxt a => a -> FieldName


-- | Stuff gutted from Translate.Select.
module Hasura.Backends.Postgres.Translate.Select.Internal.Helpers

-- | First element extractor expression from given record set For example:-
--   To get first "id" column from given row set, the function generates
--   the SQL expression AS `(array_agg("id"))[1]`
mkFirstElementExp :: SQLExp -> SQLExp

-- | Last element extractor expression from given record set. For example:-
--   To get first "id" column from given row set, the function generates
--   the SQL expression AS `(array_agg("id"))[array_length(array_agg("id"),
--   1)]`
mkLastElementExp :: SQLExp -> SQLExp
cursorIdentifier :: Identifier
startCursorIdentifier :: Identifier
endCursorIdentifier :: Identifier
hasNextPageIdentifier :: Identifier
hasPreviousPageIdentifier :: Identifier
pageInfoSelectAlias :: TableAlias
pageInfoSelectAliasIdentifier :: TableIdentifier
cursorsSelectAlias :: TableAlias
cursorsSelectAliasIdentifier :: TableIdentifier
encodeBase64 :: SQLExp -> SQLExp
fromTableRowArgs :: TableIdentifier -> FunctionArgsExpG (ArgumentExp SQLExp) -> FunctionArgs

-- | Converts a function name to an <a>Identifier</a>.
--   
--   If the schema name is public, it will just use its name, otherwise it
--   will prefix it by the schema name.
functionToIdentifier :: QualifiedFunction -> Identifier
withJsonBuildObj :: FieldName -> [SQLExp] -> (ColumnAlias, SQLExp)

-- | Forces aggregation
withForceAggregation :: TypeAnn -> SQLExp -> SQLExp

-- | unwrap any emitted TopLevelCTEs for custom sql from the Writer and
--   combine them with a <tt>Select</tt> to create a <tt>SelectWith</tt>
selectToSelectWith :: Writer CustomSQLCTEs Select -> SelectWith

-- | convert map of CustomSQL CTEs into named TopLevelCTEs
customSQLToTopLevelCTEs :: CustomSQLCTEs -> [(TableAlias, TopLevelCTE)]

-- | convert map of CustomSQL CTEs into named InnerCTEs
customSQLToInnerCTEs :: CustomSQLCTEs -> [(TableAlias, InnerCTE)]

-- | Given a <tt>NativeQueryName</tt>, what should we call the CTE
--   generated for it?
nativeQueryNameToAlias :: NativeQueryName -> Int -> TableAlias
toQuery :: SelectWithG TopLevelCTE -> Query
selectToSelectWithM :: MonadIO m => WriterT CustomSQLCTEs m Select -> m SelectWith


-- | This module defines the type class <a>PostgresAnnotatedFieldJSON</a>.
module Hasura.Backends.Postgres.Translate.Select.AnnotatedFieldJSON
class PostgresAnnotatedFieldJSON (pgKind :: PostgresKind)
annRowToJson :: PostgresAnnotatedFieldJSON pgKind => FieldName -> [(FieldName, SQLExp)] -> (ColumnAlias, SQLExp)
instance Hasura.Backends.Postgres.Translate.Select.AnnotatedFieldJSON.PostgresAnnotatedFieldJSON 'Hasura.RQL.Types.BackendType.Citus
instance Hasura.Backends.Postgres.Translate.Select.AnnotatedFieldJSON.PostgresAnnotatedFieldJSON 'Hasura.RQL.Types.BackendType.Cockroach
instance Hasura.Backends.Postgres.Translate.Select.AnnotatedFieldJSON.PostgresAnnotatedFieldJSON 'Hasura.RQL.Types.BackendType.Vanilla


-- | This module contains worker definitions pertaining to generating
--   <tt>Select</tt> AST nodes.
--   
--   NOTE: <a>generateSQLSelect</a> is mutually recursive with
--   <a>connectionToSelectWith</a>, thus these two cohabitate in this
--   module.
module Hasura.Backends.Postgres.Translate.Select.Internal.GenerateSelect
class PostgresGenerateSQLSelect (pgKind :: PostgresKind)
generateSQLSelect :: PostgresGenerateSQLSelect pgKind => BoolExp -> SelectSource -> SelectNode -> Select

-- | Create a select query
generateSQLSelectFromArrayNode :: forall (pgKind :: PostgresKind). PostgresGenerateSQLSelect pgKind => SelectSource -> MultiRowSelectNode -> BoolExp -> Select
connectionToSelectWith :: forall (pgKind :: PostgresKind). PostgresGenerateSQLSelect pgKind => TableAlias -> ArrayConnectionSource -> MultiRowSelectNode -> SelectWithG Select
instance Hasura.Backends.Postgres.Translate.Select.Internal.GenerateSelect.PostgresGenerateSQLSelect 'Hasura.RQL.Types.BackendType.Citus
instance Hasura.Backends.Postgres.Translate.Select.Internal.GenerateSelect.PostgresGenerateSQLSelect 'Hasura.RQL.Types.BackendType.Cockroach
instance Hasura.Backends.Postgres.Translate.Select.Internal.GenerateSelect.PostgresGenerateSQLSelect 'Hasura.RQL.Types.BackendType.Vanilla


-- | Extractors are a pair of an SQL expression and an alias; they get
--   translated like "[SELECT ...] <a>expr</a> as <a>alias</a>"
module Hasura.Backends.Postgres.Translate.Select.Internal.Extractor

-- | Creates node extractors for all of the columns and computed fields
--   used in aggregated fields. The ColumnAliases for all the extractors
--   are namespaced aliases using the 'contextualize*` functions so that
--   none of the extractors names will conflict with one another (for
--   example, if a column name is the same as a field name (eg
--   <tt>nodes</tt>))
aggregateFieldsToExtractorExps :: forall (pgKind :: PostgresKind) m. (Backend ('Postgres pgKind), MonadIO m, MonadError QErr m) => TableIdentifier -> UserInfo -> AggregateFields ('Postgres pgKind) SQLExp -> m [(ColumnAlias, SQLExp)]
mkAggregateOrderByExtractorAndFields :: forall (pgKind :: PostgresKind). Backend ('Postgres pgKind) => TableIdentifier -> AnnotatedAggregateOrderBy ('Postgres pgKind) SQLExp -> (Extractor, AggregateFields ('Postgres pgKind) SQLExp)
mkRawComputedFieldExpression :: forall (pgKind :: PostgresKind) m. (Backend ('Postgres pgKind), MonadIO m, MonadError QErr m) => TableIdentifier -> UserInfo -> ComputedFieldScalarSelect ('Postgres pgKind) SQLExp -> m SQLExp
withJsonAggExtr :: PermissionLimitSubQuery -> Maybe OrderByExp -> ColumnAlias -> SQLExp
asSingleRowExtr :: ColumnAlias -> SQLExp
asJsonAggExtr :: JsonAggSelect -> ColumnAlias -> PermissionLimitSubQuery -> Maybe OrderByExp -> Extractor
withColumnOp :: Maybe ColumnOp -> SQLExp -> SQLExp


-- | This module relates to the processing of Order-By clauses.
module Hasura.Backends.Postgres.Translate.Select.Internal.OrderBy
processOrderByItems :: forall (pgKind :: PostgresKind) m. (MonadReader StringifyNumbers m, MonadIO m, MonadWriter SelectWriter m, Backend ('Postgres pgKind), MonadError QErr m) => UserInfo -> TableIdentifier -> Qual -> FieldName -> SimilarArrayFields -> Maybe (NonEmpty (AnnDistinctColumn ('Postgres pgKind) SQLExp)) -> Maybe (NonEmpty (AnnotatedOrderByItem ('Postgres pgKind))) -> m ([(ColumnAlias, SQLExp)], SelectSorting, Maybe SQLExp)

module Hasura.RQL.Types.CustomTypes

-- | A wrapper around <a>GType</a> which allows us to define custom JSON
--   instances.
--   
--   TODO: this name is ambiguous, and conflicts with
--   Hasura.RQL.DDL.RemoteSchema.Permission.GraphQLType; it should perhaps
--   be renamed, made internal to this module, or removed altogether?
newtype GraphQLType
GraphQLType :: GType -> GraphQLType
[unGraphQLType] :: GraphQLType -> GType
isListType :: GraphQLType -> Bool
isNullableType :: GraphQLType -> Bool
isInBuiltScalar :: Text -> Bool

-- | A set of custom GraphQL types, sorted by "kind".
data CustomTypes
CustomTypes :: [InputObjectTypeDefinition] -> [ObjectTypeDefinition] -> [ScalarTypeDefinition] -> [EnumTypeDefinition] -> CustomTypes
[_ctInputObjects] :: CustomTypes -> [InputObjectTypeDefinition]
[_ctObjects] :: CustomTypes -> [ObjectTypeDefinition]
[_ctScalars] :: CustomTypes -> [ScalarTypeDefinition]
[_ctEnums] :: CustomTypes -> [EnumTypeDefinition]
emptyCustomTypes :: CustomTypes
data InputObjectTypeDefinition
InputObjectTypeDefinition :: InputObjectTypeName -> Maybe Description -> NonEmpty InputObjectFieldDefinition -> InputObjectTypeDefinition
[_iotdName] :: InputObjectTypeDefinition -> InputObjectTypeName
[_iotdDescription] :: InputObjectTypeDefinition -> Maybe Description
[_iotdFields] :: InputObjectTypeDefinition -> NonEmpty InputObjectFieldDefinition
newtype InputObjectTypeName
InputObjectTypeName :: Name -> InputObjectTypeName
[unInputObjectTypeName] :: InputObjectTypeName -> Name
data InputObjectFieldDefinition
InputObjectFieldDefinition :: InputObjectFieldName -> Maybe Description -> GraphQLType -> InputObjectFieldDefinition
[_iofdName] :: InputObjectFieldDefinition -> InputObjectFieldName
[_iofdDescription] :: InputObjectFieldDefinition -> Maybe Description
[_iofdType] :: InputObjectFieldDefinition -> GraphQLType
newtype InputObjectFieldName
InputObjectFieldName :: Name -> InputObjectFieldName
[unInputObjectFieldName] :: InputObjectFieldName -> Name
data ObjectTypeDefinition
ObjectTypeDefinition :: ObjectTypeName -> Maybe Description -> NonEmpty (ObjectFieldDefinition GraphQLType) -> [TypeRelationshipDefinition] -> ObjectTypeDefinition
[_otdName] :: ObjectTypeDefinition -> ObjectTypeName
[_otdDescription] :: ObjectTypeDefinition -> Maybe Description
[_otdFields] :: ObjectTypeDefinition -> NonEmpty (ObjectFieldDefinition GraphQLType)
[_otdRelationships] :: ObjectTypeDefinition -> [TypeRelationshipDefinition]
newtype ObjectTypeName
ObjectTypeName :: Name -> ObjectTypeName
[unObjectTypeName] :: ObjectTypeName -> Name
data ObjectFieldDefinition field
ObjectFieldDefinition :: ObjectFieldName -> Maybe Value -> Maybe Description -> field -> ObjectFieldDefinition field
[_ofdName] :: ObjectFieldDefinition field -> ObjectFieldName
[_ofdArguments] :: ObjectFieldDefinition field -> Maybe Value
[_ofdDescription] :: ObjectFieldDefinition field -> Maybe Description
[_ofdType] :: ObjectFieldDefinition field -> field
newtype ObjectFieldName
ObjectFieldName :: Name -> ObjectFieldName
[unObjectFieldName] :: ObjectFieldName -> Name
data ScalarTypeDefinition
ScalarTypeDefinition :: Name -> Maybe Description -> ScalarTypeDefinition
[_stdName] :: ScalarTypeDefinition -> Name
[_stdDescription] :: ScalarTypeDefinition -> Maybe Description
defaultGraphQLScalars :: HashMap Name ScalarTypeDefinition
data EnumTypeDefinition
EnumTypeDefinition :: EnumTypeName -> Maybe Description -> NonEmpty EnumValueDefinition -> EnumTypeDefinition
[_etdName] :: EnumTypeDefinition -> EnumTypeName
[_etdDescription] :: EnumTypeDefinition -> Maybe Description
[_etdValues] :: EnumTypeDefinition -> NonEmpty EnumValueDefinition
newtype EnumTypeName
EnumTypeName :: Name -> EnumTypeName
[unEnumTypeName] :: EnumTypeName -> Name
data EnumValueDefinition
EnumValueDefinition :: EnumValue -> Maybe Description -> Maybe Bool -> EnumValueDefinition
[_evdValue] :: EnumValueDefinition -> EnumValue
[_evdDescription] :: EnumValueDefinition -> Maybe Description
[_evdIsDeprecated] :: EnumValueDefinition -> Maybe Bool
data TypeRelationshipDefinition
TypeRelationshipDefinition :: RelationshipName -> RelType -> SourceName -> QualifiedTable -> HashMap ObjectFieldName PGCol -> TypeRelationshipDefinition
[_trdName] :: TypeRelationshipDefinition -> RelationshipName
[_trdType] :: TypeRelationshipDefinition -> RelType
[_trdSource] :: TypeRelationshipDefinition -> SourceName
[_trdRemoteTable] :: TypeRelationshipDefinition -> QualifiedTable
[_trdFieldMapping] :: TypeRelationshipDefinition -> HashMap ObjectFieldName PGCol

-- | TODO: deduplicate this in favour of RelName
newtype RelationshipName
RelationshipName :: Name -> RelationshipName
[unRelationshipName] :: RelationshipName -> Name
trdName :: Lens' TypeRelationshipDefinition RelationshipName
trdType :: Lens' TypeRelationshipDefinition RelType
trdSource :: Lens' TypeRelationshipDefinition SourceName
trdRemoteTable :: Lens' TypeRelationshipDefinition QualifiedTable
trdFieldMapping :: Lens' TypeRelationshipDefinition (HashMap ObjectFieldName PGCol)

-- | While we do not persist resolved types in the schema cache, they are
--   used when building the cache to validate and resolve actions and their
--   relationships.
data AnnotatedCustomTypes
AnnotatedCustomTypes :: HashMap Name AnnotatedInputType -> HashMap Name AnnotatedObjectType -> AnnotatedCustomTypes
[_actInputTypes] :: AnnotatedCustomTypes -> HashMap Name AnnotatedInputType
[_actObjectTypes] :: AnnotatedCustomTypes -> HashMap Name AnnotatedObjectType
data AnnotatedInputType
NOCTScalar :: AnnotatedScalarType -> AnnotatedInputType
NOCTEnum :: EnumTypeDefinition -> AnnotatedInputType
NOCTInputObject :: InputObjectTypeDefinition -> AnnotatedInputType
data AnnotatedOutputType
AOTObject :: AnnotatedObjectType -> AnnotatedOutputType
AOTScalar :: AnnotatedScalarType -> AnnotatedOutputType
data AnnotatedObjectType
AnnotatedObjectType :: ObjectTypeName -> Maybe Description -> NonEmpty (ObjectFieldDefinition (GType, AnnotatedObjectFieldType)) -> [AnnotatedTypeRelationship] -> AnnotatedObjectType
[_aotName] :: AnnotatedObjectType -> ObjectTypeName
[_aotDescription] :: AnnotatedObjectType -> Maybe Description
[_aotFields] :: AnnotatedObjectType -> NonEmpty (ObjectFieldDefinition (GType, AnnotatedObjectFieldType))
[_aotRelationships] :: AnnotatedObjectType -> [AnnotatedTypeRelationship]
data AnnotatedObjectFieldType
AOFTScalar :: AnnotatedScalarType -> AnnotatedObjectFieldType
AOFTEnum :: EnumTypeDefinition -> AnnotatedObjectFieldType
AOFTObject :: Name -> AnnotatedObjectFieldType
data AnnotatedTypeRelationship
AnnotatedTypeRelationship :: RelationshipName -> RelType -> SourceName -> SourceConfig ('Postgres 'Vanilla) -> TableName ('Postgres 'Vanilla) -> HashMap ObjectFieldName (ColumnInfo ('Postgres 'Vanilla)) -> AnnotatedTypeRelationship
[_atrName] :: AnnotatedTypeRelationship -> RelationshipName
[_atrType] :: AnnotatedTypeRelationship -> RelType
[_atrSource] :: AnnotatedTypeRelationship -> SourceName
[_atrSourceConfig] :: AnnotatedTypeRelationship -> SourceConfig ('Postgres 'Vanilla)
[_atrTableName] :: AnnotatedTypeRelationship -> TableName ('Postgres 'Vanilla)
[_atrFieldMapping] :: AnnotatedTypeRelationship -> HashMap ObjectFieldName (ColumnInfo ('Postgres 'Vanilla))
data AnnotatedScalarType
ASTCustom :: ScalarTypeDefinition -> AnnotatedScalarType
ASTReusedScalar :: Name -> AnyBackend ScalarWrapper -> AnnotatedScalarType
data ScalarWrapper (b :: BackendType)
ScalarWrapper :: ScalarType b -> ScalarTypeParsingContext b -> ScalarWrapper (b :: BackendType)
[unwrapScalar] :: ScalarWrapper (b :: BackendType) -> ScalarType b
[parsingContext] :: ScalarWrapper (b :: BackendType) -> ScalarTypeParsingContext b
instance GHC.Classes.Eq Hasura.RQL.Types.CustomTypes.AnnotatedInputType
instance GHC.Classes.Eq Hasura.RQL.Types.CustomTypes.AnnotatedScalarType
instance GHC.Classes.Eq Hasura.RQL.Types.CustomTypes.CustomTypes
instance GHC.Classes.Eq Hasura.RQL.Types.CustomTypes.EnumTypeDefinition
instance GHC.Classes.Eq Hasura.RQL.Types.CustomTypes.EnumTypeName
instance GHC.Classes.Eq Hasura.RQL.Types.CustomTypes.EnumValueDefinition
instance GHC.Classes.Eq Hasura.RQL.Types.CustomTypes.InputObjectFieldDefinition
instance GHC.Classes.Eq Hasura.RQL.Types.CustomTypes.InputObjectFieldName
instance GHC.Classes.Eq Hasura.RQL.Types.CustomTypes.InputObjectTypeDefinition
instance GHC.Classes.Eq Hasura.RQL.Types.CustomTypes.InputObjectTypeName
instance GHC.Classes.Eq field => GHC.Classes.Eq (Hasura.RQL.Types.CustomTypes.ObjectFieldDefinition field)
instance GHC.Classes.Eq Hasura.RQL.Types.CustomTypes.ObjectFieldName
instance GHC.Classes.Eq Hasura.RQL.Types.CustomTypes.ObjectTypeDefinition
instance GHC.Classes.Eq Hasura.RQL.Types.CustomTypes.ObjectTypeName
instance GHC.Classes.Eq Hasura.RQL.Types.CustomTypes.RelationshipName
instance GHC.Classes.Eq Hasura.RQL.Types.CustomTypes.ScalarTypeDefinition
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.CustomTypes.ScalarWrapper b)
instance GHC.Classes.Eq Hasura.RQL.Types.CustomTypes.TypeRelationshipDefinition
instance GHC.Internal.Data.Foldable.Foldable Hasura.RQL.Types.CustomTypes.ObjectFieldDefinition
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.RQL.Types.CustomTypes.ObjectFieldName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.CustomTypes.CustomTypes
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.CustomTypes.EnumTypeDefinition
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.CustomTypes.EnumTypeName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.CustomTypes.EnumValueDefinition
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.CustomTypes.InputObjectFieldDefinition
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.CustomTypes.InputObjectFieldName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.CustomTypes.InputObjectTypeDefinition
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.CustomTypes.InputObjectTypeName
instance Data.Aeson.Types.FromJSON.FromJSON field => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.CustomTypes.ObjectFieldDefinition field)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.CustomTypes.ObjectFieldName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.CustomTypes.ObjectTypeDefinition
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.CustomTypes.ObjectTypeName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.CustomTypes.RelationshipName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.CustomTypes.ScalarTypeDefinition
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.CustomTypes.TypeRelationshipDefinition
instance GHC.Internal.Base.Functor Hasura.RQL.Types.CustomTypes.ObjectFieldDefinition
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.CustomTypes.AnnotatedInputType
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.CustomTypes.AnnotatedObjectFieldType
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.CustomTypes.AnnotatedObjectType
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.CustomTypes.AnnotatedOutputType
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.CustomTypes.AnnotatedScalarType
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.CustomTypes.AnnotatedTypeRelationship
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.CustomTypes.CustomTypes
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.CustomTypes.EnumTypeDefinition
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.CustomTypes.EnumTypeName
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.CustomTypes.EnumValueDefinition
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.CustomTypes.InputObjectFieldDefinition
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.CustomTypes.InputObjectFieldName
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.CustomTypes.InputObjectTypeDefinition
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.CustomTypes.InputObjectTypeName
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.CustomTypes.ObjectFieldDefinition field)
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.CustomTypes.ObjectFieldName
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.CustomTypes.ObjectTypeDefinition
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.CustomTypes.ObjectTypeName
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.CustomTypes.RelationshipName
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.CustomTypes.ScalarTypeDefinition
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.CustomTypes.TypeRelationshipDefinition
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.CustomTypes.CustomTypes
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.CustomTypes.EnumTypeDefinition
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.CustomTypes.EnumTypeName
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.CustomTypes.EnumValueDefinition
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.CustomTypes.InputObjectFieldDefinition
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.CustomTypes.InputObjectFieldName
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.CustomTypes.InputObjectTypeDefinition
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.CustomTypes.InputObjectTypeName
instance (Autodocodec.Class.HasCodec field, GHC.Internal.Data.Typeable.Internal.Typeable field) => Autodocodec.Class.HasCodec (Hasura.RQL.Types.CustomTypes.ObjectFieldDefinition field)
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.CustomTypes.ObjectFieldName
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.CustomTypes.ObjectTypeDefinition
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.CustomTypes.ObjectTypeName
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.CustomTypes.RelationshipName
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.CustomTypes.ScalarTypeDefinition
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.CustomTypes.TypeRelationshipDefinition
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.CustomTypes.EnumTypeName
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.CustomTypes.InputObjectFieldName
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.CustomTypes.InputObjectTypeName
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.CustomTypes.ObjectFieldName
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.CustomTypes.ObjectTypeName
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.CustomTypes.RelationshipName
instance GHC.Internal.Base.Monoid Hasura.RQL.Types.CustomTypes.AnnotatedCustomTypes
instance Control.DeepSeq.NFData Hasura.RQL.Types.CustomTypes.CustomTypes
instance Control.DeepSeq.NFData Hasura.RQL.Types.CustomTypes.EnumTypeDefinition
instance Control.DeepSeq.NFData Hasura.RQL.Types.CustomTypes.EnumTypeName
instance Control.DeepSeq.NFData Hasura.RQL.Types.CustomTypes.EnumValueDefinition
instance Control.DeepSeq.NFData Hasura.RQL.Types.CustomTypes.InputObjectFieldDefinition
instance Control.DeepSeq.NFData Hasura.RQL.Types.CustomTypes.InputObjectFieldName
instance Control.DeepSeq.NFData Hasura.RQL.Types.CustomTypes.InputObjectTypeDefinition
instance Control.DeepSeq.NFData Hasura.RQL.Types.CustomTypes.InputObjectTypeName
instance Control.DeepSeq.NFData field => Control.DeepSeq.NFData (Hasura.RQL.Types.CustomTypes.ObjectFieldDefinition field)
instance Control.DeepSeq.NFData Hasura.RQL.Types.CustomTypes.ObjectFieldName
instance Control.DeepSeq.NFData Hasura.RQL.Types.CustomTypes.ObjectTypeDefinition
instance Control.DeepSeq.NFData Hasura.RQL.Types.CustomTypes.ObjectTypeName
instance Control.DeepSeq.NFData Hasura.RQL.Types.CustomTypes.RelationshipName
instance Control.DeepSeq.NFData Hasura.RQL.Types.CustomTypes.ScalarTypeDefinition
instance Control.DeepSeq.NFData Hasura.RQL.Types.CustomTypes.TypeRelationshipDefinition
instance GHC.Classes.Ord Hasura.RQL.Types.CustomTypes.AnnotatedInputType
instance GHC.Classes.Ord Hasura.RQL.Types.CustomTypes.AnnotatedScalarType
instance GHC.Classes.Ord Hasura.RQL.Types.CustomTypes.EnumTypeDefinition
instance GHC.Classes.Ord Hasura.RQL.Types.CustomTypes.EnumTypeName
instance GHC.Classes.Ord Hasura.RQL.Types.CustomTypes.EnumValueDefinition
instance GHC.Classes.Ord Hasura.RQL.Types.CustomTypes.InputObjectFieldDefinition
instance GHC.Classes.Ord Hasura.RQL.Types.CustomTypes.InputObjectFieldName
instance GHC.Classes.Ord Hasura.RQL.Types.CustomTypes.InputObjectTypeDefinition
instance GHC.Classes.Ord Hasura.RQL.Types.CustomTypes.InputObjectTypeName
instance GHC.Classes.Ord Hasura.RQL.Types.CustomTypes.ObjectFieldName
instance GHC.Classes.Ord Hasura.RQL.Types.CustomTypes.ObjectTypeName
instance GHC.Classes.Ord Hasura.RQL.Types.CustomTypes.RelationshipName
instance GHC.Classes.Ord Hasura.RQL.Types.CustomTypes.ScalarTypeDefinition
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Ord (Hasura.RQL.Types.CustomTypes.ScalarWrapper b)
instance GHC.Internal.Base.Semigroup Hasura.RQL.Types.CustomTypes.AnnotatedCustomTypes
instance GHC.Internal.Show.Show Hasura.RQL.Types.CustomTypes.CustomTypes
instance GHC.Internal.Show.Show Hasura.RQL.Types.CustomTypes.EnumTypeDefinition
instance GHC.Internal.Show.Show Hasura.RQL.Types.CustomTypes.EnumTypeName
instance GHC.Internal.Show.Show Hasura.RQL.Types.CustomTypes.EnumValueDefinition
instance GHC.Internal.Show.Show Hasura.RQL.Types.CustomTypes.InputObjectFieldDefinition
instance GHC.Internal.Show.Show Hasura.RQL.Types.CustomTypes.InputObjectFieldName
instance GHC.Internal.Show.Show Hasura.RQL.Types.CustomTypes.InputObjectTypeDefinition
instance GHC.Internal.Show.Show Hasura.RQL.Types.CustomTypes.InputObjectTypeName
instance GHC.Internal.Show.Show field => GHC.Internal.Show.Show (Hasura.RQL.Types.CustomTypes.ObjectFieldDefinition field)
instance GHC.Internal.Show.Show Hasura.RQL.Types.CustomTypes.ObjectFieldName
instance GHC.Internal.Show.Show Hasura.RQL.Types.CustomTypes.ObjectTypeDefinition
instance GHC.Internal.Show.Show Hasura.RQL.Types.CustomTypes.ObjectTypeName
instance GHC.Internal.Show.Show Hasura.RQL.Types.CustomTypes.RelationshipName
instance GHC.Internal.Show.Show Hasura.RQL.Types.CustomTypes.ScalarTypeDefinition
instance GHC.Internal.Show.Show Hasura.RQL.Types.CustomTypes.TypeRelationshipDefinition
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.Types.CustomTypes.ObjectFieldName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.AnnotatedInputType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.AnnotatedObjectFieldType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.AnnotatedObjectType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.AnnotatedOutputType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.AnnotatedScalarType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.AnnotatedTypeRelationship
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.CustomTypes
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.EnumTypeDefinition
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.EnumTypeName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.EnumValueDefinition
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.InputObjectFieldDefinition
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.InputObjectFieldName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.InputObjectTypeDefinition
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.InputObjectTypeName
instance Data.Aeson.Types.ToJSON.ToJSON field => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.CustomTypes.ObjectFieldDefinition field)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.ObjectFieldName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.ObjectTypeDefinition
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.ObjectTypeName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.RelationshipName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.ScalarTypeDefinition
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.TypeRelationshipDefinition
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.CustomTypes.EnumTypeName
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.CustomTypes.InputObjectFieldName
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.CustomTypes.InputObjectTypeName
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.CustomTypes.ObjectFieldName
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.CustomTypes.ObjectTypeName
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.CustomTypes.RelationshipName
instance GHC.Internal.Data.Traversable.Traversable Hasura.RQL.Types.CustomTypes.ObjectFieldDefinition

module Hasura.RQL.Types.Action
data ActionMetadata
ActionMetadata :: ActionName -> Maybe Text -> ActionDefinitionInput -> [ActionPermissionMetadata] -> ActionMetadata
[_amName] :: ActionMetadata -> ActionName
[_amComment] :: ActionMetadata -> Maybe Text
[_amDefinition] :: ActionMetadata -> ActionDefinitionInput
[_amPermissions] :: ActionMetadata -> [ActionPermissionMetadata]
amName :: Lens' ActionMetadata ActionName
amComment :: Lens' ActionMetadata (Maybe Text)
amDefinition :: Lens' ActionMetadata ActionDefinitionInput
amPermissions :: Lens' ActionMetadata [ActionPermissionMetadata]
data ActionPermissionMetadata
ActionPermissionMetadata :: RoleName -> Maybe Text -> ActionPermissionMetadata
[_apmRole] :: ActionPermissionMetadata -> RoleName
[_apmComment] :: ActionPermissionMetadata -> Maybe Text
newtype ActionName
ActionName :: Name -> ActionName
[unActionName] :: ActionName -> Name
newtype ActionId
ActionId :: UUID -> ActionId
[unActionId] :: ActionId -> UUID
actionIdToText :: ActionId -> Text
type ActionDefinitionInput = ActionDefinition GraphQLType InputWebhook
data ActionDefinition arg webhook
ActionDefinition :: [ArgumentDefinition arg] -> GraphQLType -> ActionType -> [HeaderConf] -> Bool -> Timeout -> webhook -> Maybe RequestTransform -> Maybe MetadataResponseTransform -> ActionDefinition arg webhook
[_adArguments] :: ActionDefinition arg webhook -> [ArgumentDefinition arg]
[_adOutputType] :: ActionDefinition arg webhook -> GraphQLType
[_adType] :: ActionDefinition arg webhook -> ActionType
[_adHeaders] :: ActionDefinition arg webhook -> [HeaderConf]
[_adForwardClientHeaders] :: ActionDefinition arg webhook -> Bool

-- | If the timeout is not provided by the user, then the default timeout
--   of 30 seconds will be used
[_adTimeout] :: ActionDefinition arg webhook -> Timeout
[_adHandler] :: ActionDefinition arg webhook -> webhook
[_adRequestTransform] :: ActionDefinition arg webhook -> Maybe RequestTransform
[_adResponseTransform] :: ActionDefinition arg webhook -> Maybe MetadataResponseTransform
adArguments :: forall arg1 webhook arg2 f. Functor f => ([ArgumentDefinition arg1] -> f [ArgumentDefinition arg2]) -> ActionDefinition arg1 webhook -> f (ActionDefinition arg2 webhook)
adOutputType :: forall arg webhook f. Functor f => (GraphQLType -> f GraphQLType) -> ActionDefinition arg webhook -> f (ActionDefinition arg webhook)
adType :: forall arg webhook f. Functor f => (ActionType -> f ActionType) -> ActionDefinition arg webhook -> f (ActionDefinition arg webhook)
adForwardClientHeaders :: forall arg webhook f. Functor f => (Bool -> f Bool) -> ActionDefinition arg webhook -> f (ActionDefinition arg webhook)
adHeaders :: forall arg webhook f. Functor f => ([HeaderConf] -> f [HeaderConf]) -> ActionDefinition arg webhook -> f (ActionDefinition arg webhook)
adHandler :: forall arg webhook1 webhook2 f. Functor f => (webhook1 -> f webhook2) -> ActionDefinition arg webhook1 -> f (ActionDefinition arg webhook2)
adTimeout :: forall arg webhook f. Functor f => (Timeout -> f Timeout) -> ActionDefinition arg webhook -> f (ActionDefinition arg webhook)
adRequestTransform :: forall arg webhook f. Functor f => (Maybe RequestTransform -> f (Maybe RequestTransform)) -> ActionDefinition arg webhook -> f (ActionDefinition arg webhook)
adResponseTransform :: forall arg webhook f. Functor f => (Maybe MetadataResponseTransform -> f (Maybe MetadataResponseTransform)) -> ActionDefinition arg webhook -> f (ActionDefinition arg webhook)
data ActionType
ActionQuery :: ActionType
ActionMutation :: ActionMutationKind -> ActionType
data ActionMutationKind
ActionSynchronous :: ActionMutationKind
ActionAsynchronous :: ActionMutationKind
data ArgumentDefinition a
ArgumentDefinition :: ArgumentName -> a -> Maybe Description -> ArgumentDefinition a
[_argName] :: ArgumentDefinition a -> ArgumentName
[_argType] :: ArgumentDefinition a -> a
[_argDescription] :: ArgumentDefinition a -> Maybe Description
newtype ArgumentName
ArgumentName :: Name -> ArgumentName
[unArgumentName] :: ArgumentName -> Name
data ActionInfo
ActionInfo :: ActionName -> (GType, AnnotatedOutputType) -> ResolvedActionDefinition -> HashMap RoleName ActionPermissionInfo -> Bool -> Maybe Text -> ActionInfo
[_aiName] :: ActionInfo -> ActionName
[_aiOutputType] :: ActionInfo -> (GType, AnnotatedOutputType)
[_aiDefinition] :: ActionInfo -> ResolvedActionDefinition
[_aiPermissions] :: ActionInfo -> HashMap RoleName ActionPermissionInfo
[_aiForwardedClientHeaders] :: ActionInfo -> Bool
[_aiComment] :: ActionInfo -> Maybe Text
aiName :: Lens' ActionInfo ActionName
aiComment :: Lens' ActionInfo (Maybe Text)
aiDefinition :: Lens' ActionInfo ResolvedActionDefinition
aiOutputType :: Lens' ActionInfo (GType, AnnotatedOutputType)
aiPermissions :: Lens' ActionInfo (HashMap RoleName ActionPermissionInfo)
aiForwardedClientHeaders :: Lens' ActionInfo Bool
newtype ActionPermissionInfo
ActionPermissionInfo :: RoleName -> ActionPermissionInfo
[_apiRole] :: ActionPermissionInfo -> RoleName
type ResolvedActionDefinition = ActionDefinition (GType, AnnotatedInputType) EnvRecord ResolvedWebhook
data ActionExecContext
ActionExecContext :: RequestHeaders -> SessionVariables -> ActionExecContext
[_aecHeaders] :: ActionExecContext -> RequestHeaders
[_aecSessionVariables] :: ActionExecContext -> SessionVariables
data ActionLogResponse
ActionLogResponse :: ActionId -> UTCTime -> Maybe Value -> Maybe Value -> SessionVariables -> ActionLogResponse
[_alrId] :: ActionLogResponse -> ActionId
[_alrCreatedAt] :: ActionLogResponse -> UTCTime
[_alrResponsePayload] :: ActionLogResponse -> Maybe Value
[_alrErrors] :: ActionLogResponse -> Maybe Value
[_alrSessionVariables] :: ActionLogResponse -> SessionVariables
type ActionLogResponseMap = HashMap ActionId ActionLogResponse
data ActionLogItem
ActionLogItem :: ActionId -> ActionName -> [Header] -> SessionVariables -> Value -> ActionLogItem
[_aliId] :: ActionLogItem -> ActionId
[_aliActionName] :: ActionLogItem -> ActionName
[_aliRequestHeaders] :: ActionLogItem -> [Header]
[_aliSessionVariables] :: ActionLogItem -> SessionVariables
[_aliInputPayload] :: ActionLogItem -> Value
type LockedActionEventId = EventId
newtype LockedActionIdArray
LockedActionIdArray :: [LockedActionEventId] -> LockedActionIdArray
[unCohortIdArray] :: LockedActionIdArray -> [LockedActionEventId]
data AsyncActionStatus
AASCompleted :: Value -> AsyncActionStatus
AASError :: QErr -> AsyncActionStatus
data ActionsInfo
ActionsInfo :: ActionName -> Bool -> ActionsInfo
[_asiName] :: ActionsInfo -> ActionName
[_asiForwardClientHeaders] :: ActionsInfo -> Bool
instance GHC.Internal.Enum.Bounded Hasura.RQL.Types.Action.ActionMutationKind
instance GHC.Internal.Enum.Enum Hasura.RQL.Types.Action.ActionMutationKind
instance (GHC.Classes.Eq arg, GHC.Classes.Eq webhook) => GHC.Classes.Eq (Hasura.RQL.Types.Action.ActionDefinition arg webhook)
instance GHC.Classes.Eq Hasura.RQL.Types.Action.ActionId
instance GHC.Classes.Eq Hasura.RQL.Types.Action.ActionLogItem
instance GHC.Classes.Eq Hasura.RQL.Types.Action.ActionLogResponse
instance GHC.Classes.Eq Hasura.RQL.Types.Action.ActionMetadata
instance GHC.Classes.Eq Hasura.RQL.Types.Action.ActionMutationKind
instance GHC.Classes.Eq Hasura.RQL.Types.Action.ActionName
instance GHC.Classes.Eq Hasura.RQL.Types.Action.ActionPermissionInfo
instance GHC.Classes.Eq Hasura.RQL.Types.Action.ActionPermissionMetadata
instance GHC.Classes.Eq Hasura.RQL.Types.Action.ActionType
instance GHC.Classes.Eq Hasura.RQL.Types.Action.ActionsInfo
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.RQL.Types.Action.ArgumentDefinition a)
instance GHC.Classes.Eq Hasura.RQL.Types.Action.ArgumentName
instance GHC.Classes.Eq Hasura.RQL.Types.Action.LockedActionIdArray
instance GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.Types.Action.ActionDefinition arg)
instance GHC.Internal.Data.Foldable.Foldable Hasura.RQL.Types.Action.ArgumentDefinition
instance Database.PG.Query.Class.FromCol Hasura.RQL.Types.Action.ActionId
instance Database.PG.Query.Class.FromCol Hasura.RQL.Types.Action.ActionName
instance (Data.Aeson.Types.FromJSON.FromJSON a, Data.Aeson.Types.FromJSON.FromJSON b) => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Action.ActionDefinition a b)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Action.ActionId
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Action.ActionMetadata
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Action.ActionMutationKind
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Action.ActionName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Action.ActionPermissionInfo
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Action.ActionPermissionMetadata
instance Data.Aeson.Types.FromJSON.FromJSON arg => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Action.ArgumentDefinition arg)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Action.ArgumentName
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.RQL.Types.Action.ActionName
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.RQL.Types.Action.ArgumentName
instance GHC.Internal.Base.Functor (Hasura.RQL.Types.Action.ActionDefinition arg)
instance GHC.Internal.Base.Functor Hasura.RQL.Types.Action.ArgumentDefinition
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Action.ActionDefinition arg webhook)
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Action.ActionInfo
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Action.ActionLogResponse
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Action.ActionMetadata
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Action.ActionMutationKind
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Action.ActionName
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Action.ActionPermissionMetadata
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Action.ActionType
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Action.ActionsInfo
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Action.ArgumentDefinition a)
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Action.ArgumentName
instance (GHC.Classes.Eq arg, Autodocodec.Class.HasCodec (Hasura.RQL.Types.Action.ArgumentDefinition arg), Autodocodec.Class.HasCodec webhook, GHC.Internal.Data.Typeable.Internal.Typeable arg, GHC.Internal.Data.Typeable.Internal.Typeable webhook) => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Action.ActionDefinition arg webhook)
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Action.ActionMetadata
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Action.ActionMutationKind
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Action.ActionName
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Action.ActionPermissionMetadata
instance (Autodocodec.Class.HasCodec a, GHC.Internal.Data.Typeable.Internal.Typeable a) => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Action.ArgumentDefinition a)
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Action.ArgumentName
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Action.ActionId
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Action.ActionName
instance (Control.DeepSeq.NFData a, Control.DeepSeq.NFData w) => Control.DeepSeq.NFData (Hasura.RQL.Types.Action.ActionDefinition a w)
instance Control.DeepSeq.NFData Hasura.RQL.Types.Action.ActionMetadata
instance Control.DeepSeq.NFData Hasura.RQL.Types.Action.ActionMutationKind
instance Control.DeepSeq.NFData Hasura.RQL.Types.Action.ActionName
instance Control.DeepSeq.NFData Hasura.RQL.Types.Action.ActionPermissionMetadata
instance Control.DeepSeq.NFData Hasura.RQL.Types.Action.ActionType
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.RQL.Types.Action.ArgumentDefinition a)
instance Control.DeepSeq.NFData Hasura.RQL.Types.Action.ArgumentName
instance GHC.Classes.Ord Hasura.RQL.Types.Action.ActionName
instance (GHC.Internal.Show.Show arg, GHC.Internal.Show.Show webhook) => GHC.Internal.Show.Show (Hasura.RQL.Types.Action.ActionDefinition arg webhook)
instance GHC.Internal.Show.Show Hasura.RQL.Types.Action.ActionId
instance GHC.Internal.Show.Show Hasura.RQL.Types.Action.ActionLogItem
instance GHC.Internal.Show.Show Hasura.RQL.Types.Action.ActionLogResponse
instance GHC.Internal.Show.Show Hasura.RQL.Types.Action.ActionMetadata
instance GHC.Internal.Show.Show Hasura.RQL.Types.Action.ActionMutationKind
instance GHC.Internal.Show.Show Hasura.RQL.Types.Action.ActionName
instance GHC.Internal.Show.Show Hasura.RQL.Types.Action.ActionPermissionInfo
instance GHC.Internal.Show.Show Hasura.RQL.Types.Action.ActionPermissionMetadata
instance GHC.Internal.Show.Show Hasura.RQL.Types.Action.ActionType
instance GHC.Internal.Show.Show Hasura.RQL.Types.Action.ActionsInfo
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (Hasura.RQL.Types.Action.ArgumentDefinition a)
instance GHC.Internal.Show.Show Hasura.RQL.Types.Action.ArgumentName
instance GHC.Internal.Show.Show Hasura.RQL.Types.Action.LockedActionIdArray
instance (Data.Aeson.Types.ToJSON.ToJSON a, Data.Aeson.Types.ToJSON.ToJSON b) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Action.ActionDefinition a b)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Action.ActionId
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Action.ActionInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Action.ActionLogResponse
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Action.ActionMetadata
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Action.ActionMutationKind
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Action.ActionName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Action.ActionPermissionInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Action.ActionPermissionMetadata
instance Data.Aeson.Types.ToJSON.ToJSON arg => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Action.ArgumentDefinition arg)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Action.ArgumentName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.Types.Action.ActionName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.Types.Action.ArgumentName
instance Database.PG.Query.Class.ToPrepArg Hasura.RQL.Types.Action.ActionId
instance Database.PG.Query.Class.ToPrepArg Hasura.RQL.Types.Action.ActionName
instance Database.PG.Query.Class.ToPrepArg Hasura.RQL.Types.Action.LockedActionIdArray
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.Action.ActionName
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.Action.ArgumentName
instance GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.Types.Action.ActionDefinition arg)
instance GHC.Internal.Data.Traversable.Traversable Hasura.RQL.Types.Action.ArgumentDefinition

module Hasura.RQL.Types.Metadata.Object
data InconsistentMetadata
InconsistentObject :: Text -> Maybe Value -> MetadataObject -> InconsistentMetadata
ConflictingObjects :: Text -> [MetadataObject] -> InconsistentMetadata
DuplicateObjects :: MetadataObjId -> [Value] -> InconsistentMetadata
DuplicateRestVariables :: Text -> MetadataObject -> InconsistentMetadata
InvalidRestSegments :: Text -> MetadataObject -> InconsistentMetadata
AmbiguousRestEndpoints :: Text -> [MetadataObject] -> InconsistentMetadata
ConflictingInheritedPermission :: RoleName -> InconsistentRoleEntity -> InconsistentMetadata
data InconsistentRoleEntity
InconsistentTablePermission :: SourceName -> Text -> PermType -> InconsistentRoleEntity
InconsistentRemoteSchemaPermission :: RemoteSchemaName -> InconsistentRoleEntity
data MetadataObjId
MOSource :: SourceName -> MetadataObjId
MOSourceObjId :: SourceName -> AnyBackend SourceMetadataObjId -> MetadataObjId

-- | Originates from user-defined <tt>_arsqName</tt>
MORemoteSchema :: RemoteSchemaName -> MetadataObjId
MORemoteSchemaPermissions :: RemoteSchemaName -> RoleName -> MetadataObjId

-- | A remote relationship on a remote schema type, identified by 1. remote
--   schema name 2. remote schema type on which the relationship is defined
--   3. name of the relationship
MORemoteSchemaRemoteRelationship :: RemoteSchemaName -> Name -> RelName -> MetadataObjId
MOCustomTypes :: MetadataObjId
MOAction :: ActionName -> MetadataObjId
MOActionPermission :: ActionName -> RoleName -> MetadataObjId
MOCronTrigger :: TriggerName -> MetadataObjId
MOInheritedRole :: RoleName -> MetadataObjId
MOEndpoint :: EndpointName -> MetadataObjId
MOQueryCollectionsQuery :: CollectionName -> ListedQuery -> MetadataObjId
MODataConnectorAgent :: DataConnectorName -> MetadataObjId
MOOpenTelemetry :: OpenTelemetryConfigSubobject -> MetadataObjId
data MetadataObject
MetadataObject :: MetadataObjId -> Value -> MetadataObject
[_moId] :: MetadataObject -> MetadataObjId
[_moDefinition] :: MetadataObject -> Value
data SourceMetadataObjId (b :: BackendType)
SMOTable :: TableName b -> SourceMetadataObjId (b :: BackendType)
SMOFunction :: FunctionName b -> SourceMetadataObjId (b :: BackendType)
SMOFunctionPermission :: FunctionName b -> RoleName -> SourceMetadataObjId (b :: BackendType)
SMOTableObj :: TableName b -> TableMetadataObjId -> SourceMetadataObjId (b :: BackendType)
SMONativeQuery :: NativeQueryName -> SourceMetadataObjId (b :: BackendType)
SMONativeQueryObj :: NativeQueryName -> NativeQueryMetadataObjId -> SourceMetadataObjId (b :: BackendType)
SMOStoredProcedure :: FunctionName b -> SourceMetadataObjId (b :: BackendType)
SMOLogicalModel :: LogicalModelName -> SourceMetadataObjId (b :: BackendType)
SMOLogicalModelObj :: LogicalModelLocation -> LogicalModelMetadataObjId -> SourceMetadataObjId (b :: BackendType)
data TableMetadataObjId
MTORel :: RelName -> RelType -> TableMetadataObjId
MTOComputedField :: ComputedFieldName -> TableMetadataObjId
MTOPerm :: RoleName -> PermType -> TableMetadataObjId
MTOTrigger :: TriggerName -> TableMetadataObjId
MTORemoteRelationship :: RelName -> TableMetadataObjId

-- | Identifiers for logical model elements within the metadata structure.
data LogicalModelMetadataObjId
LMMOPerm :: RoleName -> PermType -> LogicalModelMetadataObjId
LMMOReferencedLogicalModel :: LogicalModelName -> LogicalModelMetadataObjId

-- | the native query should probably also link to its logical model
data NativeQueryMetadataObjId
NQMORel :: RelName -> RelType -> NativeQueryMetadataObjId

-- | Helper function to differentiate which type of inconsistent metadata
--   can be dropped, if an inconsistency cannot be resolved by dropping any
--   part of the metadata then this function should return <a>False</a>,
--   otherwise it should return <a>True</a>
droppableInconsistentMetadata :: InconsistentMetadata -> Bool
getInconsistentRemoteSchemas :: [InconsistentMetadata] -> [RemoteSchemaName]

-- | Builds a map from each unique metadata object id to the
--   inconsistencies associated with it. Note that a single inconsistency
--   can involve multiple metadata objects, so the same inconsistency may
--   appear in the resulting map multiple times!
groupInconsistentMetadataById :: [InconsistentMetadata] -> HashMap MetadataObjId (NonEmpty InconsistentMetadata)
imObjectIds :: InconsistentMetadata -> [MetadataObjId]
imReason :: InconsistentMetadata -> Text
moDefinition :: Lens' MetadataObject Value
moId :: Lens' MetadataObject MetadataObjId
moiName :: MetadataObjId -> Text
moiTypeName :: MetadataObjId -> Text
_AmbiguousRestEndpoints :: Prism' InconsistentMetadata (Text, [MetadataObject])
_ConflictingInheritedPermission :: Prism' InconsistentMetadata (RoleName, InconsistentRoleEntity)
_ConflictingObjects :: Prism' InconsistentMetadata (Text, [MetadataObject])
_DuplicateObjects :: Prism' InconsistentMetadata (MetadataObjId, [Value])
_DuplicateRestVariables :: Prism' InconsistentMetadata (Text, MetadataObject)
_InconsistentObject :: Prism' InconsistentMetadata (Text, Maybe Value, MetadataObject)
_InvalidRestSegments :: Prism' InconsistentMetadata (Text, MetadataObject)
_MOAction :: Prism' MetadataObjId ActionName
_MOActionPermission :: Prism' MetadataObjId (ActionName, RoleName)
_MOCronTrigger :: Prism' MetadataObjId TriggerName
_MOCustomTypes :: Prism' MetadataObjId ()
_MOEndpoint :: Prism' MetadataObjId EndpointName
_MOInheritedRole :: Prism' MetadataObjId RoleName
_MORemoteSchema :: Prism' MetadataObjId RemoteSchemaName
_MORemoteSchemaPermissions :: Prism' MetadataObjId (RemoteSchemaName, RoleName)
_MOSource :: Prism' MetadataObjId SourceName
_MOSourceObjId :: Prism' MetadataObjId (SourceName, AnyBackend SourceMetadataObjId)
instance GHC.Classes.Eq Hasura.RQL.Types.Metadata.Object.InconsistentMetadata
instance GHC.Classes.Eq Hasura.RQL.Types.Metadata.Object.InconsistentRoleEntity
instance GHC.Classes.Eq Hasura.RQL.Types.Metadata.Object.LogicalModelMetadataObjId
instance GHC.Classes.Eq Hasura.RQL.Types.Metadata.Object.MetadataObjId
instance GHC.Classes.Eq Hasura.RQL.Types.Metadata.Object.MetadataObject
instance GHC.Classes.Eq Hasura.RQL.Types.Metadata.Object.NativeQueryMetadataObjId
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Metadata.Object.SourceMetadataObjId b)
instance GHC.Classes.Eq Hasura.RQL.Types.Metadata.Object.TableMetadataObjId
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Metadata.Object.InconsistentMetadata
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Metadata.Object.InconsistentRoleEntity
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Metadata.Object.LogicalModelMetadataObjId
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Metadata.Object.MetadataObjId
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Metadata.Object.MetadataObject
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Metadata.Object.NativeQueryMetadataObjId
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Metadata.Object.SourceMetadataObjId b)
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Metadata.Object.TableMetadataObjId
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Metadata.Object.InconsistentMetadata
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Metadata.Object.InconsistentRoleEntity
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Metadata.Object.LogicalModelMetadataObjId
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Metadata.Object.MetadataObjId
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Metadata.Object.MetadataObject
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Metadata.Object.NativeQueryMetadataObjId
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.Metadata.Object.SourceMetadataObjId b)
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Metadata.Object.TableMetadataObjId
instance GHC.Classes.Ord Hasura.RQL.Types.Metadata.Object.InconsistentMetadata
instance GHC.Classes.Ord Hasura.RQL.Types.Metadata.Object.InconsistentRoleEntity
instance GHC.Classes.Ord Hasura.RQL.Types.Metadata.Object.LogicalModelMetadataObjId
instance GHC.Classes.Ord Hasura.RQL.Types.Metadata.Object.MetadataObjId
instance GHC.Classes.Ord Hasura.RQL.Types.Metadata.Object.MetadataObject
instance GHC.Classes.Ord Hasura.RQL.Types.Metadata.Object.NativeQueryMetadataObjId
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Ord (Hasura.RQL.Types.Metadata.Object.SourceMetadataObjId b)
instance GHC.Classes.Ord Hasura.RQL.Types.Metadata.Object.TableMetadataObjId
instance GHC.Internal.Show.Show Hasura.RQL.Types.Metadata.Object.InconsistentMetadata
instance GHC.Internal.Show.Show Hasura.RQL.Types.Metadata.Object.InconsistentRoleEntity
instance GHC.Internal.Show.Show Hasura.RQL.Types.Metadata.Object.LogicalModelMetadataObjId
instance GHC.Internal.Show.Show Hasura.RQL.Types.Metadata.Object.MetadataObjId
instance GHC.Internal.Show.Show Hasura.RQL.Types.Metadata.Object.MetadataObject
instance GHC.Internal.Show.Show Hasura.RQL.Types.Metadata.Object.NativeQueryMetadataObjId
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.Types.Metadata.Object.SourceMetadataObjId b)
instance GHC.Internal.Show.Show Hasura.RQL.Types.Metadata.Object.TableMetadataObjId
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.RQL.Types.Metadata.Object.MetadataObjId
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Metadata.Object.InconsistentMetadata
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Metadata.Object.InconsistentRoleEntity
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.Metadata.Object.InconsistentRoleEntity


-- | Warnings for metadata APIs
--   
--   This module provides a mechanism for metadata APIs to emit warnings.
--   An example use of <tt>MonadWarnings</tt> to emit warnings with success
--   message is given below:
--   
--   <pre>
--   import Hasura.RQL.DDL.Warnings
--   
--   someMetadataAPIHandler :: args -&gt; m EncJSON
--   someMetadataAPIHandler args = successMsgWithWarnings $ do
--     -- do some stuff
--     let warning = MetadataWarning (MOSource defaultSource) "some warning message"
--     warn $ warning
--     -- do some more stuff
--     pure ()
--   </pre>
module Hasura.RQL.DDL.Warnings

-- | Allow/Disallow metadata warnings
data AllowWarnings
AllowWarnings :: AllowWarnings
DisallowWarnings :: AllowWarnings
data MetadataWarning
MetadataWarning :: WarningCode -> MetadataObjId -> Text -> MetadataWarning
[_mwCode] :: MetadataWarning -> WarningCode
[_mwMetadataObj] :: MetadataWarning -> MetadataObjId
[_mwMessage] :: MetadataWarning -> Text
type MetadataWarnings = Seq MetadataWarning
class Monad m => MonadWarnings (m :: Type -> Type)

-- | Add a warning to the current context
warn :: MonadWarnings m => MetadataWarning -> m ()
runMetadataWarnings :: StateT MetadataWarnings m a -> m (a, MetadataWarnings)
mkSuccessResponseWithWarnings :: MetadataWarnings -> EncJSON
successMsgWithWarnings :: Monad m => StateT MetadataWarnings m () -> m EncJSON
data WarningCode
WCSourceCleanupFailed :: WarningCode
WCIllegalEventTriggerName :: WarningCode
WCTimeLimitExceededSystemLimit :: WarningCode
WCTrackTableFailed :: WarningCode
WCUntrackTableFailed :: WarningCode
instance GHC.Classes.Eq Hasura.RQL.DDL.Warnings.AllowWarnings
instance GHC.Classes.Eq Hasura.RQL.DDL.Warnings.MetadataWarning
instance GHC.Classes.Eq Hasura.RQL.DDL.Warnings.WarningCode
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Warnings.AllowWarnings
instance GHC.Internal.Base.Monad m => Hasura.RQL.DDL.Warnings.MonadWarnings (Control.Monad.Trans.State.Strict.StateT Hasura.RQL.DDL.Warnings.MetadataWarnings m)
instance GHC.Classes.Ord Hasura.RQL.DDL.Warnings.MetadataWarning
instance GHC.Classes.Ord Hasura.RQL.DDL.Warnings.WarningCode
instance GHC.Internal.Show.Show Hasura.RQL.DDL.Warnings.AllowWarnings
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Warnings.AllowWarnings
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Warnings.MetadataWarning
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Warnings.WarningCode


-- | In <a>Parser</a>, the <a>Definition</a> type has a <a>dOrigin</a>
--   field that allows to track where a fragment of GraphQL type
--   information comes from. This is useful for error reporting and
--   internal repair mechanisms such as inconsistency tracking.
--   
--   Morally, within the HGE codebase, this origin is always
--   <a>MetadataObjId</a>. However, in order to avoid an import of
--   <a>RQL</a> from <a>Parser</a>, the <a>dOrigin</a> has been defined
--   through a type parameter of <a>Definition</a>. This type parameter
--   then has to get threaded through throughout the <a>Parser</a> module
--   hierarchy, so that it ends up in a lot of types. This is very noisy.
--   
--   In order to avoid the noise of this type parameter, which really only
--   has one value, and is really only used in one type, this module erases
--   the type parameter by filling in the desired value, exporting type
--   synonyms of the now-fixed notion of "origin". So most modules in the
--   HGE codebase should import this module rather than <a>Parser</a>.
module Hasura.GraphQL.Schema.Parser
type FieldParser = FieldParser MetadataObjId
pattern FieldParser :: () => Definition origin (FieldInfo origin) -> (Field NoFragments Variable -> m a) -> FieldParser origin m a
type InputFieldsParser = InputFieldsParser MetadataObjId
pattern InputFieldsParser :: () => [Definition origin (InputFieldInfo origin)] -> (HashMap Name (InputValue Variable) -> m a) -> InputFieldsParser origin m a
type InputObjectInfo = InputObjectInfo MetadataObjId
pattern InputObjectInfo :: [Definition origin (InputFieldInfo origin)] -> InputObjectInfo origin
type Parser = Parser MetadataObjId
pattern Parser :: () => ~Type origin k -> (ParserInput k -> m a) -> Parser origin k m a
type Schema = Schema MetadataObjId
pattern Schema :: () => Maybe Description -> HashMap Name (SomeDefinitionTypeInfo origin) -> Type origin 'Output -> Maybe (Type origin 'Output) -> Maybe (Type origin 'Output) -> [DirectiveInfo origin] -> Schema origin
type ConflictingDefinitions = ConflictingDefinitions MetadataObjId

-- | Type collection has found at least two types with the same name.
pattern ConflictingDefinitions :: () => (SomeDefinitionTypeInfo origin, TypeOriginStack) -> (SomeDefinitionTypeInfo origin, NonEmpty TypeOriginStack) -> ConflictingDefinitions origin
type Definition = Definition MetadataObjId
pattern Definition :: () => Name -> Maybe Description -> Maybe origin -> [Directive Void] -> ~a -> Definition origin a
type Type = Type MetadataObjId
type TypeInfo = TypeInfo MetadataObjId
type Directive = Directive MetadataObjId
pattern Directive :: () => DirectiveInfo origin -> Bool -> (Directive Variable -> m a) -> Directive origin m
type DirectiveInfo = DirectiveInfo MetadataObjId
pattern DirectiveInfo :: () => !Name -> !Maybe Description -> ![Definition origin (InputFieldInfo origin)] -> ![DirectiveLocation] -> DirectiveInfo origin
type FieldInfo = FieldInfo MetadataObjId
pattern FieldInfo :: () => 'Output <: k => [Definition origin (InputFieldInfo origin)] -> Type origin k -> FieldInfo origin
type InputFieldInfo = InputFieldInfo MetadataObjId

-- | An input field with a type and possibly a default value. If a default
--   value is provided, it should be a valid value for the type.
--   
--   Note that a default value of <a>VNull</a> is subtly different from
--   having no default value at all. If no default value is provided (i.e.
--   <a>Nothing</a>), the GraphQL specification allows distinguishing
--   provided <tt>null</tt> values from values left completely absent; see
--   Note [The value of omitted fields] in
--   Hasura.GraphQL.Parser.Internal.Parser.
pattern InputFieldInfo :: () => 'Input <: k => Type origin k -> Maybe (Value Void) -> InputFieldInfo origin
type HasTypeDefinitions = HasTypeDefinitions MetadataObjId
type SomeDefinitionTypeInfo = SomeDefinitionTypeInfo MetadataObjId
pattern SomeDefinitionTypeInfo :: () => Definition origin (TypeInfo origin k) -> SomeDefinitionTypeInfo origin
type TypeDefinitionsWrapper = TypeDefinitionsWrapper MetadataObjId

-- | In order to aid type inference and type checking, we define this
--   pattern synonym (an actual one) which restricts
--   <a>TypeDefinitionsWrapper</a> to have <a>MetadataObjId</a> set for its
--   origin type parameter.
pattern TypeDefinitionsWrapper :: () => HasTypeDefinitions a => a -> TypeDefinitionsWrapper
data ParseErrorCode
ValidationFailed :: ParseErrorCode
ParseFailed :: ParseErrorCode
ConflictingDefinitionsError :: ParseErrorCode
NotSupported :: ParseErrorCode
toQErr :: MonadError QErr m => Either ParseError a -> m a
uuid :: forall (m :: Type -> Type) origin. MonadParse m => Parser origin 'Both m UUID

-- | Parser for <a>Scientific</a>. Certain backends like BigQuery support
--   Decimal/BigDecimal and need an arbitrary precision number.
scientific :: forall (m :: Type -> Type) origin. MonadParse m => Parser origin 'Both m Scientific
json :: forall (m :: Type -> Type) origin. MonadParse m => Parser origin 'Both m Value
object :: forall (m :: Type -> Type) origin a. MonadParse m => Name -> Maybe Description -> InputFieldsParser origin m a -> Parser origin 'Input m a
string :: forall (m :: Type -> Type) origin. MonadParse m => Parser origin 'Both m Text
list :: forall origin (k :: Kind) (m :: Type -> Type) a. (MonadParse m, 'Input <: k) => Parser origin k m a -> Parser origin k m [a]
int :: forall (m :: Type -> Type) origin. MonadParse m => Parser origin 'Both m Int32
float :: forall (m :: Type -> Type) origin. MonadParse m => Parser origin 'Both m Double

-- | GraphQL types are divided into two classes: input types and output
--   types. The GraphQL spec does not use the word “kind” to describe these
--   classes, but it’s an apt term.
--   
--   Some GraphQL types can be used at either kind, so we also include the
--   <a>Both</a> kind, the superkind of both <a>Input</a> and
--   <a>Output</a>. The <tt>&lt;:</tt> class provides kind subsumption
--   constraints.
--   
--   For more details, see
--   <a>http://spec.graphql.org/June2018/#sec-Input-and-Output-Types</a>.
data Kind

-- | see Note [The 'Both kind]
Both :: Kind
Input :: Kind
Output :: Kind
runParser :: forall origin (k :: Kind) m a. Parser origin k m a -> ParserInput k -> m a
multiple :: forall (m :: Type -> Type) origin a. Parser origin 'Output m a -> Parser origin 'Output m a
data ParseError
ParseError :: JSONPath -> ErrorMessage -> ParseErrorCode -> ParseError
[pePath] :: ParseError -> JSONPath
[peMessage] :: ParseError -> ErrorMessage
[peCode] :: ParseError -> ParseErrorCode
bind :: forall m origin (k :: Kind) a b. Monad m => Parser origin k m a -> (a -> m b) -> Parser origin k m b
infixl 1 `bind`
class HasName a
getName :: HasName a => a -> Name

-- | Like <a>==</a>, but can compare <a>Type</a>s of different kinds.
eqType :: forall origin (k1 :: Kind) (k2 :: Kind). Type origin k1 -> Type origin k2 -> Bool
parseError :: MonadParse m => ErrorMessage -> m a
data Nullability
Nullable :: Nullability
NonNullable :: Nullability
data Variable
Variable :: VariableInfo -> GType -> Maybe (InputValue Void) -> Variable
[vInfo] :: Variable -> VariableInfo
[vType] :: Variable -> GType

-- | The following cases are distinguished:
--   
--   <ol>
--   <li>A JSON value (including <a>null</a>) was provided: Just (JSONValue
--   ...)</li>
--   <li>No JSON value was provided, but a default value exists: Just
--   (GraphQLValue ...)</li>
--   <li>No JSON value was provided, and no default value exists:
--   Nothing</li>
--   </ol>
[vValue] :: Variable -> Maybe (InputValue Void)

-- | Creates a parser for an input field. For nullable value parsers, if an
--   input field is omitted, the provided parser <i>will be called</i> with
--   a value of <a>null</a>.
field :: forall (m :: Type -> Type) (k :: Kind) origin a. (MonadParse m, 'Input <: k) => Name -> Maybe Description -> Parser origin k m a -> InputFieldsParser origin m a

-- | A variant of <a>selectionSetObject</a> which doesn't implement any
--   interfaces
selectionSet :: forall (m :: Type -> Type) origin a. MonadParse m => Name -> Maybe Description -> [FieldParser origin m a] -> Parser origin 'Output m (InsOrdHashMap Name (ParsedSelection a))
enum :: forall (m :: Type -> Type) origin a. MonadParse m => Name -> Maybe Description -> NonEmpty (Definition origin EnumValueInfo, a) -> Parser origin 'Both m a
nullable :: forall origin (k :: Kind) (m :: Type -> Type) a. (MonadParse m, 'Input <: k) => Parser origin k m a -> Parser origin k m (Maybe a)
identifier :: forall (m :: Type -> Type) origin. MonadParse m => Parser origin 'Both m Text
jsonb :: forall (m :: Type -> Type) origin. MonadParse m => Parser origin 'Both m Value

-- | A class that provides functionality for parsing GraphQL queries, i.e.
--   running a fully-constructed <tt>Parser</tt>.
class (Monad m, Typeable m) => MonadParse (m :: Type -> Type)
withKey :: MonadParse m => JSONPathElement -> m a -> m a

-- | Not the full power of <tt>MonadError</tt> because parse errors cannot
--   be caught.
parseErrorWith :: MonadParse m => ParseErrorCode -> ErrorMessage -> m a
withPath :: MonadParse m => JSONPath -> m a -> m a
data Parse a
runParse :: MonadError ParseError m => Parse a -> m a
sDirectives :: Schema origin -> [DirectiveInfo origin]
sSubscriptionType :: Schema origin -> Maybe (Type origin 'Output)
sMutationType :: Schema origin -> Maybe (Type origin 'Output)
sQueryType :: Schema origin -> Type origin 'Output
sTypes :: Schema origin -> HashMap Name (SomeDefinitionTypeInfo origin)
sDescription :: Schema origin -> Maybe Description
diLocations :: DirectiveInfo origin -> [DirectiveLocation]
diArguments :: DirectiveInfo origin -> [Definition origin (InputFieldInfo origin)]
diDescription :: DirectiveInfo origin -> Maybe Description
diName :: DirectiveInfo origin -> Name
fType :: FieldInfo origin -> Type origin k
fArguments :: FieldInfo origin -> [Definition origin (InputFieldInfo origin)]

-- | Enum values have no extra information except for the information
--   common to all definitions, so this is just a placeholder for use as
--   <tt><a>Definition</a> <a>EnumValueInfo</a></tt>.
data EnumValueInfo
EnumValueInfo :: EnumValueInfo

-- | Lazy to allow mutually-recursive type definitions.
dInfo :: Definition origin a -> a

-- | The directives for this object.
dDirectives :: Definition origin a -> [Directive Void]

-- | What piece of metadata was this fragment of GraphQL type information
--   from? See also <a>Parser</a>.
--   
--   <a>Nothing</a> can represent a couple of scenarios: 1. This is a
--   native part of the GraphQL spec, e.g. the <tt>__Type</tt>
--   introspection type 2. This is a native part of HGE, e.g. our scalar
--   types and Relay-related types 3. We don't have a clear origin, because
--   a. Semantically there is no clear origin because it arose from the
--   combination of several things b. We generated this <a>Definition</a>
--   in a context where origin information was no longer in scope
--   
--   Maybe, at some point, it makes sense to represent the above options
--   more accurately in the type of <a>dOrigin</a>.
dOrigin :: Definition origin a -> Maybe origin
dDescription :: Definition origin a -> Maybe Description
dName :: Definition origin a -> Name
pattern TIScalar :: () => TypeInfo origin 'Both
pattern TIInputObject :: () => InputObjectInfo origin -> TypeInfo origin 'Input
pattern TIObject :: () => ObjectInfo origin -> TypeInfo origin 'Output
pattern TIInterface :: () => InterfaceInfo origin -> TypeInfo origin 'Output
pattern TIUnion :: () => UnionInfo origin -> TypeInfo origin 'Output
pattern TIEnum :: () => k ~ 'Both => NonEmpty (Definition origin EnumValueInfo) -> TypeInfo origin k

-- | Invariant: the list is sorted by <a>dName</a>
data UnionInfo origin
pattern UnionInfo :: [Definition origin (ObjectInfo origin)] -> UnionInfo origin

-- | Type information for a GraphQL interface; see Note [The interfaces
--   story] for more details.
--   
--   Note: in the current working draft of the GraphQL specification (&gt;
--   June 2018), interfaces may implement other interfaces, but we
--   currently don't support this.
--   
--   Invariant: the lists are sorted by <a>dName</a>, maintained via
--   pattern synonyms
data InterfaceInfo origin
pattern InterfaceInfo :: [Definition origin (FieldInfo origin)] -> [Definition origin (ObjectInfo origin)] -> InterfaceInfo origin

-- | Invariant: the lists are sorted by <a>dName</a>, maintained via
--   pattern synonyms
data ObjectInfo origin
pattern ObjectInfo :: [Definition origin (FieldInfo origin)] -> [Definition origin (InterfaceInfo origin)] -> ObjectInfo origin
pattern TNamed :: () => Nullability -> Definition origin (TypeInfo origin k) -> Type origin k
pattern TList :: () => Nullability -> Type origin k -> Type origin k

-- | <a>Kind</a> subsumption. The GraphQL kind hierarchy is extremely
--   simple:
--   
--   <pre>
--       Both
--       /  \
--   Input  Output
--   </pre>
--   
--   Various functions in this module use <tt>&lt;:</tt> to allow
--   <a>Both</a> to be used in places where <a>Input</a> or <a>Output</a>
--   would otherwise be expected.
class (k1 :: Kind) <: (k2 :: Kind)
subKind :: (<:) k1 k2 => k1 :<: k2

-- | Evidence for <tt>&lt;:</tt>.
data (k1 :: Kind) :<: (k2 :: Kind)
[KRefl] :: forall (k1 :: Kind). k1 :<: k1
[KBoth] :: forall (k1 :: Kind). k1 :<: 'Both

-- | Adjust the <a>Definition</a> underlying a <a>Type</a>
onTypeDef :: forall origin (k :: Kind). (forall a. () => Definition origin a -> Definition origin a) -> Type origin k -> Type origin k
typeNullability :: forall origin (k :: Kind). Type origin k -> Nullability
nullableType :: forall origin (k :: Kind). Type origin k -> Type origin k
nonNullableType :: forall origin (k :: Kind). Type origin k -> Type origin k
toGraphQLType :: forall origin (k :: Kind). Type origin k -> GType

-- | Like <a>==</a>, but can compare <a>TypeInfo</a>s of different kinds.
eqTypeInfo :: forall origin (k1 :: Kind) (k2 :: Kind). TypeInfo origin k1 -> TypeInfo origin k2 -> Bool
getTypeInfo :: forall origin (k :: Kind). Type origin k -> Definition origin (TypeInfo origin k)
getObjectInfo :: forall origin (k :: Kind). Type origin k -> Maybe (Definition origin (ObjectInfo origin))
getInterfaceInfo :: forall origin (k :: Kind). Type origin k -> Maybe (Definition origin (InterfaceInfo origin))

-- | Recursively accumulates all type definitions accessible from the given
--   value. This is done statefully to avoid infinite loops arising from
--   recursive type definitions; see Note [Tying the knot] in
--   Hasura.GraphQL.Parser.Class.
accumulateTypeDefinitions :: HasTypeDefinitions origin a => a -> TypeAccumulation origin ()

-- | Recursively collects all type definitions accessible from the given
--   value, attempting to detect any conflicting defintions that may have
--   made it this far (See <a>ConflictingDefinitions</a> for details).
collectTypeDefinitions :: HasTypeDefinitions origin a => a -> Either (ConflictingDefinitions origin) (HashMap Name (SomeDefinitionTypeInfo origin))
data VariableInfo
VIRequired :: Name -> VariableInfo

-- | Unlike fields (see <tt>InputFieldInfo</tt>), nullable variables with
--   no default value are indistinguishable from variables with a default
--   value of null, so we don’t distinguish those cases here.
VIOptional :: Name -> Value Void -> VariableInfo

-- | See Note [Parsing variable values].
data InputValue v
GraphQLValue :: Value v -> InputValue v
JSONValue :: Value -> InputValue v
pParser :: Parser origin k m a -> ParserInput k -> m a

-- | Lazy for knot-tying reasons; see Note [Tying the knot] in
--   Hasura.GraphQL.Parser.Class.
pType :: Parser origin k m a -> Type origin k
parserType :: forall origin (k :: Kind) (m :: Type -> Type) a. Parser origin k m a -> Type origin k
ifParser :: InputFieldsParser origin m a -> HashMap Name (InputValue Variable) -> m a
ifDefinitions :: InputFieldsParser origin m a -> [Definition origin (InputFieldInfo origin)]

-- | Creates a parser for a nullable field with no default value. If the
--   field is omitted, the provided parser <i>will not be called</i>. This
--   allows a field to distinguish an omitted field from a field supplied
--   with <tt>null</tt> (which is permitted by the GraphQL specification);
--   see Note [The value of omitted fields] for more details.
--   
--   If you want a field with a default value of <tt>null</tt>, use
--   <a>field</a> with a nullable value parser, instead.
fieldOptional :: forall (m :: Type -> Type) (k :: Kind) origin a. (MonadParse m, 'Input <: k) => Name -> Maybe Description -> Parser origin k m a -> InputFieldsParser origin m (Maybe a)
fieldOptional' :: forall (m :: Type -> Type) (k :: Kind) origin a. (MonadParse m, 'Input <: k) => Name -> Maybe Description -> Parser origin k m a -> InputFieldsParser origin m (Maybe a)

-- | Creates a parser for an input field with the given default value. The
--   resulting field will always be optional, even if the underlying parser
--   rejects <a>null</a> values. The underlying parser is always called.
fieldWithDefault :: forall (m :: Type -> Type) (k :: Kind) origin a. (MonadParse m, 'Input <: k) => Name -> Maybe Description -> Value Void -> Parser origin k m a -> InputFieldsParser origin m a
fieldWithDefault' :: forall (m :: Type -> Type) (k :: Kind) origin a. (MonadParse m, 'Input <: k) => Name -> Maybe Description -> Value Void -> Parser origin k m a -> InputFieldsParser origin m a
valueToJSON :: MonadParse m => GType -> InputValue Variable -> m Value
jsonToGraphQL :: Value -> Either ErrorMessage (Value Void)
namedBoolean :: forall (m :: Type -> Type) origin. MonadParse m => Name -> Parser origin 'Both m Bool
boolean :: forall (m :: Type -> Type) origin. MonadParse m => Parser origin 'Both m Bool
namedInt :: forall (m :: Type -> Type) origin. MonadParse m => Name -> Parser origin 'Both m Int32
namedFloat :: forall (m :: Type -> Type) origin. MonadParse m => Name -> Parser origin 'Both m Double
namedString :: forall (m :: Type -> Type) origin. MonadParse m => Name -> Parser origin 'Both m Text

-- | As an input type, any string or integer input value should be coerced
--   to ID as Text <a>https://spec.graphql.org/June2018/#sec-ID</a>
namedIdentifier :: forall (m :: Type -> Type) origin. MonadParse m => Name -> Parser origin 'Both m Text

-- | Additional validation on integers. We do keep the same type name in
--   the schema for backwards compatibility. TODO: when we can do a
--   breaking change, we can rename the type to <a>NonNegativeInt</a>.
nonNegativeInt :: forall (m :: Type -> Type) origin. MonadParse m => Parser origin 'Both m Int32

-- | GraphQL ints are 32-bit integers; but in some places we want to accept
--   bigger ints. To do so, we declare a cusom scalar that can represent
--   64-bit ints, which accepts both int literals and string literals. We
--   do keep the same type name in the schema for backwards compatibility.
--   TODO: when we can do a breaking change, we can rename the type to
--   <a>BigInt</a>.
bigInt :: forall (m :: Type -> Type) origin. MonadParse m => Parser origin 'Both m Int64

-- | Creates a parser that transforms its input into a JSON value.
--   <a>valueToJSON</a> does properly unpack variables.
jsonScalar :: forall (m :: Type -> Type) origin. MonadParse m => Name -> Maybe Description -> Parser origin 'Both m Value
dParser :: Directive origin m -> Directive Variable -> m a
dAdvertised :: Directive origin m -> Bool
dDefinition :: Directive origin m -> DirectiveInfo origin

-- | A single parsed field in a selection set.
data ParsedSelection a

-- | An ordinary field.
SelectField :: a -> ParsedSelection a

-- | The magical <tt>__typename</tt> field, implicitly available on all
--   objects <a>part of GraphQL introspection
--   http://spec.graphql.org/June2018/#sec-Type-Name-Introspection</a>.
SelectTypename :: Name -> ParsedSelection a
fParser :: FieldParser origin m a -> Field NoFragments Variable -> m a
fDefinition :: FieldParser origin m a -> Definition origin (FieldInfo origin)
bindFields :: Monad m => InputFieldsParser origin m a -> (a -> m b) -> InputFieldsParser origin m b
infixl 1 `bindFields`
bindField :: Monad m => FieldParser origin m a -> (a -> m b) -> FieldParser origin m b
infixl 1 `bindField`
handleTypename :: (Name -> a) -> ParsedSelection a -> a

-- | Decorate a schema field with reference to given @<a>GType</a>
wrapFieldParser :: forall (m :: Type -> Type) origin a. GType -> FieldParser origin m a -> FieldParser origin m a

-- | Decorate a schema type as NON_NULL. Note that this is unsafe for
--   'Output parsers, in the sense that <a>nonNullableParser</a> doesn't
--   (and due to the polymorphic nature of the <tt>a</tt> type parameter,
--   can't) ensure that the provided parser provides a semantically
--   non-null value.
nonNullableParser :: forall (m :: Type -> Type) origin (k :: Kind) a. Parser origin k m a -> Parser origin k m a

-- | Mark a schema type as nullable. Syntactically speaking, this is the
--   default, because the GraphQL spec explicitly requires use of ! to mark
--   types as non-nullable. But many constructions in our codebase are
--   non-nullable by default, since this matches the Haskell type system
--   better.
--   
--   Note that this is unsafe for 'Input parsers, in the sense that
--   <a>nullableParser</a> doesn't ensure that the provided parser actually
--   deals with <a>null</a> input values.
nullableParser :: forall (m :: Type -> Type) origin (k :: Kind) a. Parser origin k m a -> Parser origin k m a

-- | Set the metadata origin of a <a>Parser</a>
setParserOrigin :: forall origin (k :: Kind) (m :: Type -> Type) a. origin -> Parser origin k m a -> Parser origin k m a

-- | Set the metadata origin of a <a>FieldParser</a>
setFieldParserOrigin :: forall (m :: Type -> Type) origin a. origin -> FieldParser origin m a -> FieldParser origin m a

-- | Set the metadata origin of the arguments in a <a>InputFieldsParser</a>
setInputFieldsParserOrigin :: forall (m :: Type -> Type) origin a. origin -> InputFieldsParser origin m a -> InputFieldsParser origin m a
safeSelectionSet :: forall n (m :: Type -> Type) origin a. (MonadError ErrorMessage n, MonadParse m, Hashable origin, ToErrorValue origin) => Name -> Maybe Description -> [FieldParser origin m a] -> n (Parser origin 'Output m (InsOrdHashMap Name (ParsedSelection a)))
selectionSetObject :: forall (m :: Type -> Type) origin a b. MonadParse m => Name -> Maybe Description -> [FieldParser origin m a] -> [Parser origin 'Output m b] -> Parser origin 'Output m (InsOrdHashMap Name (ParsedSelection a))
selectionSetInterface :: forall (n :: Type -> Type) t origin a b. (MonadParse n, Traversable t) => Name -> Maybe Description -> [FieldParser origin n a] -> t (Parser origin 'Output n b) -> Parser origin 'Output n (t b)
selectionSetUnion :: forall (n :: Type -> Type) t origin b. (MonadParse n, Traversable t) => Name -> Maybe Description -> t (Parser origin 'Output n b) -> Parser origin 'Output n (t b)

-- | Builds a <a>FieldParser</a> for a field that does not take a
--   subselection set, i.e. a field that returns a scalar or enum. The
--   field’s type is taken from the provided <a>Parser</a>, but the
--   <a>Parser</a> is not otherwise used.
--   
--   See also Note [The delicate balance of GraphQL kinds] in
--   <a>Hasura.GraphQL.Parser.Schema</a>.
selection :: forall (m :: Type -> Type) origin a b. MonadParse m => Name -> Maybe Description -> InputFieldsParser origin m a -> Parser origin 'Both m b -> FieldParser origin m a
rawSelection :: forall (m :: Type -> Type) origin a b. MonadParse m => Name -> Maybe Description -> InputFieldsParser origin m a -> Parser origin 'Both m b -> FieldParser origin m (Maybe Name, HashMap Name (Value Variable), a)

-- | Builds a <a>FieldParser</a> for a field that takes a subselection set,
--   i.e. a field that returns an object.
--   
--   For example, <tt>subselection name _ args fields</tt> produces schema:
--   
--   <pre>
--   name (args) { fields }
--   </pre>
--   
--   See also Note [The delicate balance of GraphQL kinds] in
--   <a>Hasura.GraphQL.Parser.Schema</a>.
subselection :: forall (m :: Type -> Type) origin a b. MonadParse m => Name -> Maybe Description -> InputFieldsParser origin m a -> Parser origin 'Output m b -> FieldParser origin m (a, b)
rawSubselection :: forall (m :: Type -> Type) origin a b. MonadParse m => Name -> Maybe Description -> InputFieldsParser origin m a -> Parser origin 'Output m b -> FieldParser origin m (Maybe Name, HashMap Name (Value Variable), a, b)

-- | A shorthand for a <a>selection</a> that takes no arguments.
selection_ :: forall (m :: Type -> Type) origin a. MonadParse m => Name -> Maybe Description -> Parser origin 'Both m a -> FieldParser origin m ()

-- | A shorthand for a <a>subselection</a> that takes no arguments.
subselection_ :: forall (m :: Type -> Type) origin a. MonadParse m => Name -> Maybe Description -> Parser origin 'Output m a -> FieldParser origin m a
class Monad m => MonadMemoize (m :: Type -> Type)
memoizeOn :: forall m a p (n :: Type -> Type) b. (MonadMemoize m, Ord a, Typeable a, Typeable p, MonadParse n, Typeable b) => Name -> a -> m (p n b) -> m (p n b)

-- | A wrapper around <a>memoizeOn</a> that memoizes a function by using
--   its argument as the key.
memoize :: forall m a p (n :: Type -> Type) b. (MonadMemoize m, Ord a, Typeable a, Typeable p, MonadParse n, Typeable b) => Name -> (a -> m (p n b)) -> a -> m (p n b)

module Hasura.GraphQL.Schema.Introspect

-- | Builds a <tt>Schema</tt> from GraphQL types for the query_root,
--   mutation_root and subscription_root.
--   
--   See Note [What introspection exposes]
buildIntrospectionSchema :: Type 'Output -> Maybe (Type 'Output) -> Maybe (Type 'Output) -> Either ConflictingDefinitions Schema

-- | Generate a __schema introspection parser.
schema :: forall (n :: Type -> Type). MonadParse n => FieldParser n (Schema -> Value)

-- | Generate a __type introspection parser
typeIntrospection :: forall (n :: Type -> Type). MonadParse n => FieldParser n (Schema -> Value)

module Hasura.GraphQL.Namespace
data RootFieldAlias
RootFieldAlias :: !Maybe Name -> !Name -> RootFieldAlias
[_rfaNamespace] :: RootFieldAlias -> !Maybe Name
[_rfaAlias] :: RootFieldAlias -> !Name
mkUnNamespacedRootFieldAlias :: Name -> RootFieldAlias
mkNamespacedRootFieldAlias :: Name -> Name -> RootFieldAlias
type RootFieldMap = InsOrdHashMap RootFieldAlias
data NamespacedField a

-- | Normal field
NotNamespaced :: a -> NamespacedField a

-- | Namespace field with other fields nested within
Namespaced :: InsOrdHashMap Name a -> NamespacedField a
namespacedField :: (a -> b) -> (InsOrdHashMap Name a -> b) -> NamespacedField a -> b
type NamespacedFieldMap a = InsOrdHashMap Name NamespacedField a
flattenNamespaces :: NamespacedFieldMap a -> RootFieldMap a
unflattenNamespaces :: RootFieldMap a -> NamespacedFieldMap a

-- | Wrap the field parser results in <tt>NamespacedField</tt>
customizeNamespace :: forall (n :: Type -> Type) a. MonadParse n => Maybe Name -> (Name -> ParsedSelection a -> a) -> MkTypename -> [FieldParser n a] -> [FieldParser n (NamespacedField a)]
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.GraphQL.Namespace.NamespacedField a)
instance GHC.Classes.Eq Hasura.GraphQL.Namespace.RootFieldAlias
instance GHC.Internal.Base.Functor Hasura.GraphQL.Namespace.NamespacedField
instance GHC.Internal.Generics.Generic Hasura.GraphQL.Namespace.RootFieldAlias
instance Data.Hashable.Class.Hashable Hasura.GraphQL.Namespace.RootFieldAlias
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (Hasura.GraphQL.Namespace.NamespacedField a)
instance GHC.Internal.Show.Show Hasura.GraphQL.Namespace.RootFieldAlias
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Namespace.RootFieldAlias
instance Data.Text.Extended.ToTxt Hasura.GraphQL.Namespace.RootFieldAlias


-- | This module has the various metadata we want to attach to the
--   generated/executed query
module Hasura.QueryTags
type Attribute = (Text, Text)
data LivequeryMetadata
LivequeryMetadata :: RootFieldAlias -> ParameterizedQueryHash -> LivequeryMetadata
data MutationMetadata
MutationMetadata :: Maybe RequestId -> Maybe Name -> RootFieldAlias -> ParameterizedQueryHash -> MutationMetadata
data QueryMetadata
QueryMetadata :: Maybe RequestId -> Maybe Name -> RootFieldAlias -> ParameterizedQueryHash -> QueryMetadata

-- | Query Tags are SQL comments which are made up of (key=value) pairs.
--   
--   These are appended to the SQL statements generated by Hasura for
--   GraphQL operations. This enables the ability to get some application
--   context in the database logs and also use native database monitoring
--   tools (e.g. pganalyze) for better performance analysis.
--   
--   The application context(query tags) can be used to detect slow GQL
--   operation and relate them back to the SQL that was generated.
--   
--   For eg: SELECT name FROM child <i>*
--   request_id=487c2ed5-08a4-429a-b0e0-4666a82e3cc6, field_name=child,
--   operation_name=GetChild *</i>
--   
--   For more usage information, refer <a>Query Tags Docs</a>
data QueryTags
QTQuery :: !QueryMetadata -> QueryTags
QTMutation :: !MutationMetadata -> QueryTags
QTLiveQuery :: !LivequeryMetadata -> QueryTags
data QueryTagsAttributes

-- | query-tags as SQL comment which is appended to the prepared SQL
--   statement
newtype QueryTagsComment
QueryTagsComment :: Text -> QueryTagsComment
[_unQueryTagsComment] :: QueryTagsComment -> Text
emptyQueryTagsComment :: QueryTagsComment
encodeQueryTags :: QueryTags -> QueryTagsAttributes
class Monad m => MonadQueryTags (m :: Type -> Type)

-- | Creates Query Tags. These are appended to the Generated SQL. Helps
--   users to use native database monitoring tools to get some
--   'application-context'.
createQueryTags :: MonadQueryTags m => QueryTagsAttributes -> Maybe QueryTagsConfig -> Tagged m QueryTagsComment
($dmcreateQueryTags) :: forall (t :: (Type -> Type) -> Type -> Type) (n :: Type -> Type). (MonadQueryTags m, m ~ t n, MonadQueryTags n) => QueryTagsAttributes -> Maybe QueryTagsConfig -> Tagged m QueryTagsComment
emptyQueryTagsAttributes :: QueryTagsAttributes
instance GHC.Classes.Eq Hasura.QueryTags.QueryTagsAttributes
instance GHC.Classes.Eq Hasura.QueryTags.QueryTagsComment
instance Hasura.QueryTags.MonadQueryTags m => Hasura.QueryTags.MonadQueryTags (Control.Monad.Trans.Except.ExceptT e m)
instance Hasura.QueryTags.MonadQueryTags m => Hasura.QueryTags.MonadQueryTags (Control.Monad.Trans.Reader.ReaderT r m)
instance GHC.Internal.Show.Show Hasura.QueryTags.LivequeryMetadata
instance GHC.Internal.Show.Show Hasura.QueryTags.MutationMetadata
instance GHC.Internal.Show.Show Hasura.QueryTags.QueryMetadata
instance GHC.Internal.Show.Show Hasura.QueryTags.QueryTags
instance GHC.Internal.Show.Show Hasura.QueryTags.QueryTagsAttributes
instance GHC.Internal.Show.Show Hasura.QueryTags.QueryTagsComment

module Hasura.Backends.MSSQL.Execute.QueryTags
withQueryTags :: Query -> QueryTagsComment -> Query
withQueryTagsPrinter :: Printer -> QueryTagsComment -> Printer


-- | Add metadata tags as comments to SQL queries.
module Data.SqlCommenter

-- | query-tags format as defined in the Spec
--   <a>https://google.github.io/sqlcommenter/spec/#sql-commenter</a>
sqlCommenterGoogle :: QueryTagsAttributes -> QueryTagsComment

-- | Default 'Query Tags' format in the Hasura GraphQL Engine Creates
--   simple 'key=value' pairs of query tags. No sorting, No URL encoding.
--   If the format of query tags is not mentioned in the metadata then,
--   query-tags are formatted using hte below format
sqlCommenterStandard :: QueryTagsAttributes -> QueryTagsComment
type Attribute = (Text, Text)


-- | In order to avoid circular dependencies while splitting
--   <a>Metadata</a> into multiple modules, some definitions must be moved
--   out of that module. This module is the bucket for definitions that
--   have not been specifically moved elsewhere.
module Hasura.RQL.Types.Metadata.Common
type Actions = InsOrdHashMap ActionName ActionMetadata

-- | This newtype simply wraps the BackendConfig type family so that it can
--   be used with BackendMap in the Metadata type. GHC will not allow the
--   type family to be used directly. :(
newtype BackendConfigWrapper (b :: BackendType)
BackendConfigWrapper :: BackendConfig b -> BackendConfigWrapper (b :: BackendType)
[unBackendConfigWrapper] :: BackendConfigWrapper (b :: BackendType) -> BackendConfig b

-- | Source configuration as stored in the Metadata DB for some
--   existentialized backend.
newtype BackendSourceMetadata
BackendSourceMetadata :: AnyBackend SourceMetadata -> BackendSourceMetadata
[unBackendSourceMetadata] :: BackendSourceMetadata -> AnyBackend SourceMetadata
data CatalogState
CatalogState :: Text -> Value -> Value -> CatalogState
[_csId] :: CatalogState -> Text
[_csCliState] :: CatalogState -> Value
[_csConsoleState] :: CatalogState -> Value
data CatalogStateType
CSTCli :: CatalogStateType
CSTConsole :: CatalogStateType
data ComputedFieldMetadata (b :: BackendType)
ComputedFieldMetadata :: ComputedFieldName -> ComputedFieldDefinition b -> Comment -> ComputedFieldMetadata (b :: BackendType)
[_cfmName] :: ComputedFieldMetadata (b :: BackendType) -> ComputedFieldName
[_cfmDefinition] :: ComputedFieldMetadata (b :: BackendType) -> ComputedFieldDefinition b
[_cfmComment] :: ComputedFieldMetadata (b :: BackendType) -> Comment
type CronTriggers = InsOrdHashMap TriggerName CronTriggerMetadata
type LogicalModels (b :: BackendType) = InsOrdHashMap LogicalModelName LogicalModelMetadata b
type Endpoints = InsOrdHashMap EndpointName CreateEndpoint
type NativeQueries (b :: BackendType) = InsOrdHashMap NativeQueryName NativeQueryMetadata b
type StoredProcedures (b :: BackendType) = InsOrdHashMap FunctionName b StoredProcedureMetadata b
type EventTriggers (b :: BackendType) = InsOrdHashMap TriggerName EventTriggerConf b
type Functions (b :: BackendType) = InsOrdHashMap FunctionName b FunctionMetadata b
data GetCatalogState
GetCatalogState :: GetCatalogState
type InheritedRoles = InsOrdHashMap RoleName InheritedRole
type QueryCollections = InsOrdHashMap CollectionName CreateCollection
type RemoteSchemaMetadata = RemoteSchemaMetadataG RemoteRelationshipDefinition
type RemoteSchemas = InsOrdHashMap RemoteSchemaName RemoteSchemaMetadata
data SetCatalogState
SetCatalogState :: CatalogStateType -> Value -> SetCatalogState
[_scsType] :: SetCatalogState -> CatalogStateType
[_scsState] :: SetCatalogState -> Value

-- | Source configuration for a source of backend type <tt>b</tt> as stored
--   in the Metadata DB.
data SourceMetadata (b :: BackendType)
SourceMetadata :: SourceName -> BackendSourceKind b -> Tables b -> Functions b -> NativeQueries b -> StoredProcedures b -> LogicalModels b -> SourceConnConfiguration b -> Maybe QueryTagsConfig -> SourceCustomization -> Maybe (HealthCheckConfig b) -> SourceMetadata (b :: BackendType)
[_smName] :: SourceMetadata (b :: BackendType) -> SourceName
[_smKind] :: SourceMetadata (b :: BackendType) -> BackendSourceKind b
[_smTables] :: SourceMetadata (b :: BackendType) -> Tables b
[_smFunctions] :: SourceMetadata (b :: BackendType) -> Functions b
[_smNativeQueries] :: SourceMetadata (b :: BackendType) -> NativeQueries b
[_smStoredProcedures] :: SourceMetadata (b :: BackendType) -> StoredProcedures b
[_smLogicalModels] :: SourceMetadata (b :: BackendType) -> LogicalModels b
[_smConfiguration] :: SourceMetadata (b :: BackendType) -> SourceConnConfiguration b
[_smQueryTags] :: SourceMetadata (b :: BackendType) -> Maybe QueryTagsConfig
[_smCustomization] :: SourceMetadata (b :: BackendType) -> SourceCustomization

-- | 
--   <a>https://hasura.io/docs/latest/deployment/health-checks/source-health-check/</a>
[_smHealthCheckConfig] :: SourceMetadata (b :: BackendType) -> Maybe (HealthCheckConfig b)
type Sources = InsOrdHashMap SourceName BackendSourceMetadata
type Tables (b :: BackendType) = InsOrdHashMap TableName b TableMetadata b
backendSourceMetadataCodec :: JSONCodec BackendSourceMetadata
getSourceName :: BackendSourceMetadata -> SourceName
mkSourceMetadata :: forall (b :: BackendType). Backend b => SourceName -> BackendSourceKind b -> SourceConnConfiguration b -> SourceCustomization -> Maybe (HealthCheckConfig b) -> BackendSourceMetadata
parseNonSourcesMetadata :: Object -> Parser (RemoteSchemas, QueryCollections, MetadataAllowlist, CustomTypes, Actions, CronTriggers, ApiLimit, MetricsConfig, InheritedRoles, SetGraphqlIntrospectionOptions)
smConfiguration :: forall (b :: BackendType) f. Functor f => (SourceConnConfiguration b -> f (SourceConnConfiguration b)) -> SourceMetadata b -> f (SourceMetadata b)
smFunctions :: forall (b :: BackendType) f. Functor f => (Functions b -> f (Functions b)) -> SourceMetadata b -> f (SourceMetadata b)
smKind :: forall (b :: BackendType) f. Functor f => (BackendSourceKind b -> f (BackendSourceKind b)) -> SourceMetadata b -> f (SourceMetadata b)
smName :: forall (b :: BackendType) f. Functor f => (SourceName -> f SourceName) -> SourceMetadata b -> f (SourceMetadata b)
smQueryTags :: forall (b :: BackendType) f. Functor f => (Maybe QueryTagsConfig -> f (Maybe QueryTagsConfig)) -> SourceMetadata b -> f (SourceMetadata b)
smTables :: forall (b :: BackendType) f. Functor f => (Tables b -> f (Tables b)) -> SourceMetadata b -> f (SourceMetadata b)
smCustomization :: forall (b :: BackendType) f. Functor f => (SourceCustomization -> f SourceCustomization) -> SourceMetadata b -> f (SourceMetadata b)
smNativeQueries :: forall (b :: BackendType) f. Functor f => (NativeQueries b -> f (NativeQueries b)) -> SourceMetadata b -> f (SourceMetadata b)
smStoredProcedures :: forall (b :: BackendType) f. Functor f => (StoredProcedures b -> f (StoredProcedures b)) -> SourceMetadata b -> f (SourceMetadata b)
smLogicalModels :: forall (b :: BackendType) f. Functor f => (LogicalModels b -> f (LogicalModels b)) -> SourceMetadata b -> f (SourceMetadata b)
smHealthCheckConfig :: forall (b :: BackendType) f. Functor f => (Maybe (HealthCheckConfig b) -> f (Maybe (HealthCheckConfig b))) -> SourceMetadata b -> f (SourceMetadata b)
sourcesCodec :: JSONCodec Sources
toSourceMetadata :: forall (b :: BackendType). Backend b => Prism' BackendSourceMetadata (SourceMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Metadata.Common.BackendConfigWrapper b)
instance GHC.Classes.Eq Hasura.RQL.Types.Metadata.Common.BackendSourceMetadata
instance GHC.Classes.Eq Hasura.RQL.Types.Metadata.Common.CatalogState
instance GHC.Classes.Eq Hasura.RQL.Types.Metadata.Common.CatalogStateType
instance GHC.Classes.Eq Hasura.RQL.Types.Metadata.Common.GetCatalogState
instance GHC.Classes.Eq Hasura.RQL.Types.Metadata.Common.SetCatalogState
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Metadata.Common.SourceMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Metadata.Common.BackendConfigWrapper b)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Metadata.Common.CatalogStateType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Metadata.Common.GetCatalogState
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Metadata.Common.SetCatalogState
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Extended.FromJSONWithContext (Hasura.RQL.Types.BackendType.BackendSourceKind b) (Hasura.RQL.Types.Metadata.Common.SourceMetadata b)
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Metadata.Common.CatalogState
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Metadata.Common.CatalogStateType
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Metadata.Common.GetCatalogState
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Metadata.Common.SetCatalogState
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Metadata.Common.SourceMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Metadata.Common.BackendConfigWrapper b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Metadata.Common.SourceMetadata b)
instance GHC.Internal.Base.Monoid (Hasura.RQL.Types.Backend.BackendConfig b) => GHC.Internal.Base.Monoid (Hasura.RQL.Types.Metadata.Common.BackendConfigWrapper b)
instance GHC.Internal.Base.Semigroup (Hasura.RQL.Types.Backend.BackendConfig b) => GHC.Internal.Base.Semigroup (Hasura.RQL.Types.Metadata.Common.BackendConfigWrapper b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.Types.Metadata.Common.BackendConfigWrapper b)
instance GHC.Internal.Show.Show Hasura.RQL.Types.Metadata.Common.BackendSourceMetadata
instance GHC.Internal.Show.Show Hasura.RQL.Types.Metadata.Common.CatalogState
instance GHC.Internal.Show.Show Hasura.RQL.Types.Metadata.Common.CatalogStateType
instance GHC.Internal.Show.Show Hasura.RQL.Types.Metadata.Common.GetCatalogState
instance GHC.Internal.Show.Show Hasura.RQL.Types.Metadata.Common.SetCatalogState
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.Types.Metadata.Common.SourceMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Metadata.Common.BackendConfigWrapper b)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Metadata.Common.CatalogState
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Metadata.Common.CatalogStateType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Metadata.Common.GetCatalogState
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Metadata.Common.SetCatalogState

module Hasura.RQL.Types.Source
data SourceInfo (b :: BackendType)
SourceInfo :: SourceName -> BackendSourceKind b -> TableCache b -> FunctionCache b -> NativeQueryCache b -> StoredProcedureCache b -> LogicalModelCache b -> ~SourceConfig b -> Maybe QueryTagsConfig -> ResolvedSourceCustomization -> DBObjectsIntrospection b -> SourceInfo (b :: BackendType)
[_siName] :: SourceInfo (b :: BackendType) -> SourceName
[_siSourceKind] :: SourceInfo (b :: BackendType) -> BackendSourceKind b
[_siTables] :: SourceInfo (b :: BackendType) -> TableCache b
[_siFunctions] :: SourceInfo (b :: BackendType) -> FunctionCache b
[_siNativeQueries] :: SourceInfo (b :: BackendType) -> NativeQueryCache b
[_siStoredProcedures] :: SourceInfo (b :: BackendType) -> StoredProcedureCache b
[_siLogicalModels] :: SourceInfo (b :: BackendType) -> LogicalModelCache b
[_siConfiguration] :: SourceInfo (b :: BackendType) -> ~SourceConfig b
[_siQueryTagsConfig] :: SourceInfo (b :: BackendType) -> Maybe QueryTagsConfig
[_siCustomization] :: SourceInfo (b :: BackendType) -> ResolvedSourceCustomization
[_siDbObjectsIntrospection] :: SourceInfo (b :: BackendType) -> DBObjectsIntrospection b
type BackendSourceInfo = AnyBackend SourceInfo
type SourceCache = HashMap SourceName BackendSourceInfo
unsafeSourceConfiguration :: forall (b :: BackendType). HasTag b => BackendSourceInfo -> Maybe (SourceConfig b)
unsafeSourceFunctions :: forall (b :: BackendType). HasTag b => BackendSourceInfo -> Maybe (FunctionCache b)
unsafeSourceInfo :: forall (b :: BackendType). HasTag b => BackendSourceInfo -> Maybe (SourceInfo b)
unsafeSourceName :: BackendSourceInfo -> SourceName
unsafeSourceTables :: forall (b :: BackendType). HasTag b => BackendSourceInfo -> Maybe (TableCache b)
unsafeSourceLogicalModels :: forall (b :: BackendType). HasTag b => BackendSourceInfo -> Maybe (LogicalModelCache b)
siConfiguration :: forall (b :: BackendType) f. Functor f => (SourceConfig b -> f (SourceConfig b)) -> SourceInfo b -> f (SourceInfo b)
siNativeQueries :: forall (b :: BackendType) f. Functor f => (NativeQueryCache b -> f (NativeQueryCache b)) -> SourceInfo b -> f (SourceInfo b)
siStoredProcedures :: forall (b :: BackendType) f. Functor f => (StoredProcedureCache b -> f (StoredProcedureCache b)) -> SourceInfo b -> f (SourceInfo b)
siLogicalModels :: forall (b :: BackendType) f. Functor f => (LogicalModelCache b -> f (LogicalModelCache b)) -> SourceInfo b -> f (SourceInfo b)
siFunctions :: forall (b :: BackendType) f. Functor f => (FunctionCache b -> f (FunctionCache b)) -> SourceInfo b -> f (SourceInfo b)
siName :: forall (b :: BackendType) f. Functor f => (SourceName -> f SourceName) -> SourceInfo b -> f (SourceInfo b)
siSourceKind :: forall (b :: BackendType) f. Functor f => (BackendSourceKind b -> f (BackendSourceKind b)) -> SourceInfo b -> f (SourceInfo b)
siQueryTagsConfig :: forall (b :: BackendType) f. Functor f => (Maybe QueryTagsConfig -> f (Maybe QueryTagsConfig)) -> SourceInfo b -> f (SourceInfo b)
siTables :: forall (b :: BackendType) f. Functor f => (TableCache b -> f (TableCache b)) -> SourceInfo b -> f (SourceInfo b)
siCustomization :: forall (b :: BackendType) f. Functor f => (ResolvedSourceCustomization -> f ResolvedSourceCustomization) -> SourceInfo b -> f (SourceInfo b)
siDbObjectsIntrospection :: forall (b :: BackendType) f. Functor f => (DBObjectsIntrospection b -> f (DBObjectsIntrospection b)) -> SourceInfo b -> f (SourceInfo b)

-- | Contains metadata (introspection) from the database, used to build the
--   schema cache. This type only contains results of introspecting DB
--   objects, i.e. the DB types specified by tables, functions, and
--   scalars. Notably, it does not include the additional introspection
--   that takes place on Postgres, namely reading the contents of tables
--   used as Enum Values -- see <tt>fetchAndValidateEnumValues</tt>.
data DBObjectsIntrospection (b :: BackendType)
DBObjectsIntrospection :: DBTablesMetadata b -> DBFunctionsMetadata b -> ScalarMap b -> LogicalModels b -> DBObjectsIntrospection (b :: BackendType)
[_rsTables] :: DBObjectsIntrospection (b :: BackendType) -> DBTablesMetadata b
[_rsFunctions] :: DBObjectsIntrospection (b :: BackendType) -> DBFunctionsMetadata b
[_rsScalars] :: DBObjectsIntrospection (b :: BackendType) -> ScalarMap b
[_rsLogicalModels] :: DBObjectsIntrospection (b :: BackendType) -> LogicalModels b

-- | A map from GraphQL name to equivalent scalar type for a given backend.
newtype ScalarMap (b :: BackendType)
ScalarMap :: HashMap Name (ScalarType b) -> ScalarMap (b :: BackendType)

-- | FIXME: this should be either in <tt>BackendMetadata</tt>, or into a
--   new dedicated <tt>BackendResolve</tt>, instead of listing backends
--   explicitly. It could also be moved to the app level.
type SourceResolver (b :: BackendType) = Environment -> SourceName -> SourceConnConfiguration b -> IO Either QErr SourceConfig b
class Monad m => MonadResolveSource (m :: Type -> Type)
getPGSourceResolver :: MonadResolveSource m => m (SourceResolver ('Postgres 'Vanilla))
getMSSQLSourceResolver :: MonadResolveSource m => m (SourceResolver 'MSSQL)
data MaintenanceModeVersion

-- | should correspond to the source catalog version from which the user is
--   migrating from
PreviousMMVersion :: MaintenanceModeVersion

-- | should correspond to the latest source catalog version
CurrentMMVersion :: MaintenanceModeVersion
data SourceHealthCheckInfo (b :: BackendType)
SourceHealthCheckInfo :: SourceName -> SourceConnConfiguration b -> HealthCheckConfig b -> SourceHealthCheckInfo (b :: BackendType)
[_shciName] :: SourceHealthCheckInfo (b :: BackendType) -> SourceName
[_shciConnection] :: SourceHealthCheckInfo (b :: BackendType) -> SourceConnConfiguration b
[_shciHealthCheck] :: SourceHealthCheckInfo (b :: BackendType) -> HealthCheckConfig b
type BackendSourceHealthCheckInfo = AnyBackend SourceHealthCheckInfo
type SourceHealthCheckCache = HashMap SourceName BackendSourceHealthCheckInfo
data SourcePingInfo (b :: BackendType)
SourcePingInfo :: SourceName -> SourceConnConfiguration b -> SourcePingInfo (b :: BackendType)
[_spiName] :: SourcePingInfo (b :: BackendType) -> SourceName
[_spiConnection] :: SourcePingInfo (b :: BackendType) -> SourceConnConfiguration b
type BackendSourcePingInfo = AnyBackend SourcePingInfo
type SourcePingCache = HashMap SourceName BackendSourcePingInfo
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Source.DBObjectsIntrospection b)
instance GHC.Classes.Eq Hasura.RQL.Types.Source.MaintenanceModeVersion
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Source.ScalarMap b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Source.DBObjectsIntrospection b)
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.Source.DBObjectsIntrospection b)
instance Hasura.RQL.Types.Source.MonadResolveSource m => Hasura.RQL.Types.Source.MonadResolveSource (Control.Monad.Trans.Except.ExceptT e m)
instance Hasura.RQL.Types.Source.MonadResolveSource m => Hasura.RQL.Types.Source.MonadResolveSource (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.RQL.Types.Source.MonadResolveSource m => Hasura.RQL.Types.Source.MonadResolveSource (Control.Monad.Trans.State.Strict.StateT s m)
instance Hasura.RQL.Types.Source.MonadResolveSource m => Hasura.RQL.Types.Source.MonadResolveSource (Hasura.Tracing.Monad.TraceT m)
instance Hasura.RQL.Types.Source.MonadResolveSource m => Hasura.RQL.Types.Source.MonadResolveSource (Database.PG.Query.Transaction.TxET Hasura.Base.Error.QErr m)
instance GHC.Internal.Base.Monoid (Hasura.RQL.Types.Source.ScalarMap b)
instance GHC.Internal.Base.Semigroup (Hasura.RQL.Types.Source.ScalarMap b)
instance GHC.Internal.Show.Show Hasura.RQL.Types.Source.MaintenanceModeVersion
instance Hasura.Logging.ToEngineLog (Hasura.RQL.Types.Source.DBObjectsIntrospection b) Hasura.Logging.Hasura
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Source.DBObjectsIntrospection b)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Cache.TableCache b), Data.Aeson.Types.ToJSON.ToJSON (Hasura.Function.Cache.FunctionCache b), Data.Aeson.Types.ToJSON.ToJSON (Hasura.NativeQuery.Cache.NativeQueryCache b), Data.Aeson.Types.ToJSON.ToJSON (Hasura.StoredProcedure.Cache.StoredProcedureCache b), Data.Aeson.Types.ToJSON.ToJSON Hasura.QueryTags.Types.QueryTagsConfig, Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.SourceCustomization.SourceCustomization) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Source.SourceInfo b)


-- | This is taken from wai-logger and customised for our use
module Hasura.Server.Logging
data StartupLog
StartupLog :: !LogLevel -> !Text -> !Value -> StartupLog
[slLogLevel] :: StartupLog -> !LogLevel
[slKind] :: StartupLog -> !Text
[slInfo] :: StartupLog -> !Value
data PGLog
PGLog :: !LogLevel -> !Value -> PGLog
[plLogLevel] :: PGLog -> !LogLevel
[plMessage] :: PGLog -> !Value

-- | whether a request is executed in batched mode or not
data RequestMode

-- | this request is batched
RequestModeBatched :: RequestMode

-- | this is a single request
RequestModeSingle :: RequestMode

-- | this request is of a kind for which batching is not done or does not
--   make sense
RequestModeNonBatchable :: RequestMode

-- | the execution of this request failed
RequestModeError :: RequestMode
mkInconsMetadataLog :: [InconsistentMetadata] -> MetadataLog
mkHttpAccessLogContext :: Maybe UserInfo -> LoggingSettings -> RequestId -> Request -> (ByteString, Maybe Value) -> Int64 -> ByteString -> Maybe (DiffTime, DiffTime) -> Maybe CompressionType -> [Header] -> RequestMode -> Maybe (GQLBatchedReqs GQLBatchQueryOperationLog) -> HttpLogContext
mkHttpErrorLogContext :: Maybe UserInfo -> LoggingSettings -> RequestId -> Request -> (ByteString, Maybe Value) -> QErr -> Maybe (DiffTime, DiffTime) -> Maybe CompressionType -> [Header] -> HttpLogContext
mkHttpLog :: HttpLogContext -> HttpLogLine

-- | Log information about the HTTP request
data HttpInfoLog
HttpInfoLog :: !Status -> !Text -> !IpAddress -> !Text -> !HttpVersion -> !Maybe CompressionType -> ![Header] -> HttpInfoLog
[hlStatus] :: HttpInfoLog -> !Status
[hlMethod] :: HttpInfoLog -> !Text
[hlSource] :: HttpInfoLog -> !IpAddress
[hlPath] :: HttpInfoLog -> !Text
[hlHttpVersion] :: HttpInfoLog -> !HttpVersion
[hlCompression] :: HttpInfoLog -> !Maybe CompressionType

-- | all the request headers
[hlHeaders] :: HttpInfoLog -> ![Header]

-- | Information about a GraphQL/Hasura metadata operation over HTTP
data OperationLog
OperationLog :: !RequestId -> !Maybe SessionVariables -> !Maybe Int64 -> !Int64 -> !Maybe Seconds -> !Maybe Seconds -> !Maybe Value -> !Maybe Text -> !Maybe QErr -> !RequestMode -> OperationLog
[olRequestId] :: OperationLog -> !RequestId
[olUserVars] :: OperationLog -> !Maybe SessionVariables
[olResponseSize] :: OperationLog -> !Maybe Int64

-- | Response size before compression
[olUncompressedResponseSize] :: OperationLog -> !Int64

-- | Request IO wait time, i.e. time spent reading the full request from
--   the socket.
[olRequestReadTime] :: OperationLog -> !Maybe Seconds

-- | Service time, not including request IO wait time.
[olQueryExecutionTime] :: OperationLog -> !Maybe Seconds
[olQuery] :: OperationLog -> !Maybe Value
[olRawQuery] :: OperationLog -> !Maybe Text
[olError] :: OperationLog -> !Maybe QErr
[olRequestMode] :: OperationLog -> !RequestMode
data HttpLogContext
HttpLogContext :: !HttpInfoLog -> !OperationLog -> !RequestId -> !Maybe (NonEmpty BatchOperationLog) -> HttpLogContext
[hlcHttpInfo] :: HttpLogContext -> !HttpInfoLog
[hlcOperation] :: HttpLogContext -> !OperationLog
[hlcRequestId] :: HttpLogContext -> !RequestId
[hlcBatchedOperations] :: HttpLogContext -> !Maybe (NonEmpty BatchOperationLog)
data WebHookLog
WebHookLog :: !LogLevel -> !Maybe Status -> !Text -> !StdMethod -> !Maybe HttpException -> !Maybe Text -> !Maybe Text -> WebHookLog
[whlLogLevel] :: WebHookLog -> !LogLevel
[whlStatusCode] :: WebHookLog -> !Maybe Status
[whlUrl] :: WebHookLog -> !Text
[whlMethod] :: WebHookLog -> !StdMethod
[whlError] :: WebHookLog -> !Maybe HttpException
[whlResponse] :: WebHookLog -> !Maybe Text
[whlMessage] :: WebHookLog -> !Maybe Text
data HttpException
class Monad m => HttpLog (m :: Type -> Type) where {
    
    -- | Extra http-log metadata that we attach when operating in <tt>m</tt>.
    type ExtraHttpLogMetadata (m :: Type -> Type);
}
emptyExtraHttpLogMetadata :: HttpLog m => ExtraHttpLogMetadata m
buildExtraHttpLogMetadata :: HttpLog m => ParameterizedQueryHashList -> ExtraUserInfo -> ExtraHttpLogMetadata m
logHttpError :: HttpLog m => Logger Hasura -> LoggingSettings -> Maybe UserInfo -> RequestId -> Request -> (ByteString, Maybe Value) -> QErr -> [Header] -> HttpLogMetadata m -> Bool -> m ()
logHttpSuccess :: HttpLog m => Logger Hasura -> LoggingSettings -> Maybe UserInfo -> RequestId -> Request -> (ByteString, Maybe Value) -> ByteString -> ByteString -> Maybe (DiffTime, DiffTime) -> Maybe CompressionType -> [Header] -> HttpLogMetadata m -> Bool -> m ()
data GQLBatchQueryOperationLog
GQLQueryOperationSuccess :: !GQLQueryOperationSuccessLog -> GQLBatchQueryOperationLog
GQLQueryOperationError :: !GQLQueryOperationErrorLog -> GQLBatchQueryOperationLog

-- | GQLQueryOperationSuccessLog captures all the data required to
--   construct an HTTP success log.
data GQLQueryOperationSuccessLog
GQLQueryOperationSuccessLog :: !GQLReqUnparsed -> !DiffTime -> !Int64 -> !Int64 -> !ParameterizedQueryHash -> GQLQueryOperationSuccessLog
[gqolQuery] :: GQLQueryOperationSuccessLog -> !GQLReqUnparsed
[gqolQueryExecutionTime] :: GQLQueryOperationSuccessLog -> !DiffTime
[gqolResponseSize] :: GQLQueryOperationSuccessLog -> !Int64
[gqolRequestSize] :: GQLQueryOperationSuccessLog -> !Int64
[gqolParameterizedQueryHash] :: GQLQueryOperationSuccessLog -> !ParameterizedQueryHash

-- | GQLQueryOperationErrorLog captures the request along with the error
--   message
data GQLQueryOperationErrorLog
GQLQueryOperationErrorLog :: !GQLReqUnparsed -> !QErr -> GQLQueryOperationErrorLog
[gqelQuery] :: GQLQueryOperationErrorLog -> !GQLReqUnparsed
[gqelError] :: GQLQueryOperationErrorLog -> !QErr
data MetadataLog
MetadataLog :: !LogLevel -> !Text -> !Value -> MetadataLog
[mlLogLevel] :: MetadataLog -> !LogLevel
[mlMessage] :: MetadataLog -> !Text
[mlInfo] :: MetadataLog -> !Value

-- | The environment variables that were moved to metadata. These
--   environment variables are available if a v1 hasura project is run an
--   v2 hasura server. These environment variables are marked as deprecated
--   only when the v1 hasura project is migrated to v2 project.
newtype EnvVarsMovedToMetadata
EnvVarsMovedToMetadata :: [String] -> EnvVarsMovedToMetadata
[unEnvVarsMovedToMetadata] :: EnvVarsMovedToMetadata -> [String]

-- | These env vars are completely deprecated
newtype DeprecatedEnvVars
DeprecatedEnvVars :: [String] -> DeprecatedEnvVars
[unDeprecatedEnvVars] :: DeprecatedEnvVars -> [String]

-- | Log warning messages for deprecated environment variables
logDeprecatedEnvVars :: Logger Hasura -> Environment -> SourceCache -> IO ()
data CommonHttpLogMetadata
CommonHttpLogMetadata :: !RequestMode -> !Maybe (GQLBatchedReqs GQLBatchQueryOperationLog) -> CommonHttpLogMetadata
[_chlmRequestMode] :: CommonHttpLogMetadata -> !RequestMode
[_chlmBatchOperationLog] :: CommonHttpLogMetadata -> !Maybe (GQLBatchedReqs GQLBatchQueryOperationLog)

-- | The http-log metadata attached to HTTP requests running in the monad
--   <tt>m</tt>, split into a common portion that is present regardless of
--   <tt>m</tt>, and a monad-specific one defined in the <a>HttpLog</a>
--   instance.
--   
--   This allows us to not have to duplicate the code that generates the
--   common part of the metadata across OSS and Pro, so that instances only
--   have to implement the part of it unique to them.
type HttpLogMetadata (m :: Type -> Type) = (CommonHttpLogMetadata, ExtraHttpLogMetadata m)
buildHttpLogMetadata :: forall (m :: Type -> Type). HttpLog m => HttpLogGraphQLInfo -> ExtraUserInfo -> HttpLogMetadata m

-- | synonym for clarity, writing `emptyHttpLogMetadata <tt>m` instead of
--   `def </tt>(HttpLogMetadata m)`
emptyHttpLogMetadata :: forall (m :: Type -> Type). HttpLog m => HttpLogMetadata m
data MetadataQueryLoggingMode
MetadataQueryLoggingEnabled :: MetadataQueryLoggingMode
MetadataQueryLoggingDisabled :: MetadataQueryLoggingMode
data HttpLogQueryOnlyOnError
HttpLogQueryOnlyOnErrorEnabled :: HttpLogQueryOnlyOnError
HttpLogQueryOnlyOnErrorDisabled :: HttpLogQueryOnlyOnError

-- | Setting used to control the information in logs
data LoggingSettings
LoggingSettings :: HashSet (EngineLogType Hasura) -> MetadataQueryLoggingMode -> HttpLogQueryOnlyOnError -> LoggingSettings

-- | this is only required for the short-term fix in
--   <a>https://github.com/hasura/graphql-engine-mono/issues/1770</a> See
--   Note [Disable query printing when query-log is disabled]
[_lsEnabledLogTypes] :: LoggingSettings -> HashSet (EngineLogType Hasura)
[_lsMetadataQueryLoggingMode] :: LoggingSettings -> MetadataQueryLoggingMode
[_lsHttpLogQueryOnlyOnError] :: LoggingSettings -> HttpLogQueryOnlyOnError
data SchemaSyncThreadType
TTListener :: SchemaSyncThreadType
TTProcessor :: SchemaSyncThreadType
TTMetadataApi :: SchemaSyncThreadType
data SchemaSyncLog
SchemaSyncLog :: !LogLevel -> !SchemaSyncThreadType -> !Value -> SchemaSyncLog
[sslLogLevel] :: SchemaSyncLog -> !LogLevel
[sslThreadType] :: SchemaSyncLog -> !SchemaSyncThreadType
[sslInfo] :: SchemaSyncLog -> !Value
type HttpLogGraphQLInfo = (CommonHttpLogMetadata, ParameterizedQueryHashList)
emptyHttpLogGraphQLInfo :: HttpLogGraphQLInfo
data ModelInfo
ModelInfo :: !Text -> !Text -> !Maybe Text -> !Maybe Text -> !Text -> !Bool -> ModelInfo
[miModelName] :: ModelInfo -> !Text
[miModelType] :: ModelInfo -> !Text
[miSourceName] :: ModelInfo -> !Maybe Text
[miSourceType] :: ModelInfo -> !Maybe Text
[miQueryType] :: ModelInfo -> !Text
[miIsCached] :: ModelInfo -> !Bool
data ModelInfoLog
ModelInfoLog :: !LogLevel -> !ModelInfo -> ModelInfoLog
[milLogType] :: ModelInfoLog -> !LogLevel
[milModelInfo] :: ModelInfoLog -> !ModelInfo
instance GHC.Classes.Eq Hasura.Server.Logging.BatchOperationErrorLog
instance GHC.Classes.Eq Hasura.Server.Logging.BatchOperationLog
instance GHC.Classes.Eq Hasura.Server.Logging.BatchOperationSuccessLog
instance GHC.Classes.Eq Hasura.Server.Logging.CommonHttpLogMetadata
instance GHC.Classes.Eq Hasura.Server.Logging.GQLBatchQueryOperationLog
instance GHC.Classes.Eq Hasura.Server.Logging.GQLQueryOperationErrorLog
instance GHC.Classes.Eq Hasura.Server.Logging.GQLQueryOperationSuccessLog
instance GHC.Classes.Eq Hasura.Server.Logging.HttpInfoLog
instance GHC.Classes.Eq Hasura.Server.Logging.HttpLogContext
instance GHC.Classes.Eq Hasura.Server.Logging.HttpLogQueryOnlyOnError
instance GHC.Classes.Eq Hasura.Server.Logging.LoggingSettings
instance GHC.Classes.Eq Hasura.Server.Logging.MetadataLog
instance GHC.Classes.Eq Hasura.Server.Logging.MetadataQueryLoggingMode
instance GHC.Classes.Eq Hasura.Server.Logging.OperationLog
instance GHC.Classes.Eq Hasura.Server.Logging.PGLog
instance GHC.Classes.Eq Hasura.Server.Logging.RequestMode
instance GHC.Classes.Eq Hasura.Server.Logging.RequestStatus
instance GHC.Classes.Eq Hasura.Server.Logging.SchemaSyncLog
instance GHC.Classes.Eq Hasura.Server.Logging.SchemaSyncThreadType
instance GHC.Classes.Eq Hasura.Server.Logging.StartupLog
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Logging.HttpLogQueryOnlyOnError
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Logging.MetadataQueryLoggingMode
instance GHC.Internal.Generics.Generic Hasura.Server.Logging.BatchOperationErrorLog
instance GHC.Internal.Generics.Generic Hasura.Server.Logging.BatchOperationSuccessLog
instance GHC.Internal.Generics.Generic Hasura.Server.Logging.GQLQueryOperationErrorLog
instance GHC.Internal.Generics.Generic Hasura.Server.Logging.GQLQueryOperationSuccessLog
instance GHC.Internal.Generics.Generic Hasura.Server.Logging.HttpLogContext
instance GHC.Internal.Generics.Generic Hasura.Server.Logging.ModelInfo
instance GHC.Internal.Generics.Generic Hasura.Server.Logging.ModelInfoLog
instance GHC.Internal.Generics.Generic Hasura.Server.Logging.OperationLog
instance Hasura.Server.Logging.HttpLog m => Hasura.Server.Logging.HttpLog (Control.Monad.Trans.Except.ExceptT e m)
instance Hasura.Server.Logging.HttpLog m => Hasura.Server.Logging.HttpLog (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.Server.Logging.HttpLog m => Hasura.Server.Logging.HttpLog (Hasura.Tracing.Monad.TraceT m)
instance GHC.Internal.Show.Show Hasura.Server.Logging.HttpLogQueryOnlyOnError
instance GHC.Internal.Show.Show Hasura.Server.Logging.MetadataQueryLoggingMode
instance GHC.Internal.Show.Show Hasura.Server.Logging.RequestStatus
instance GHC.Internal.Show.Show Hasura.Server.Logging.SchemaSyncLog
instance GHC.Internal.Show.Show Hasura.Server.Logging.SchemaSyncThreadType
instance Hasura.Logging.ToEngineLog Hasura.Server.Logging.HttpLogLine Hasura.Logging.Hasura
instance Hasura.Logging.ToEngineLog Hasura.Server.Logging.MetadataLog Hasura.Logging.Hasura
instance Hasura.Logging.ToEngineLog Hasura.Server.Logging.ModelInfoLog Hasura.Logging.Hasura
instance Hasura.Logging.ToEngineLog Hasura.Server.Logging.PGLog Hasura.Logging.Hasura
instance Hasura.Logging.ToEngineLog Hasura.Server.Logging.SchemaSyncLog Hasura.Logging.Hasura
instance Hasura.Logging.ToEngineLog Hasura.Server.Logging.StartupLog Hasura.Logging.Hasura
instance Hasura.Logging.ToEngineLog Hasura.Server.Logging.WebHookLog Hasura.Logging.Hasura
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Logging.BatchOperationErrorLog
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Logging.BatchOperationLog
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Logging.BatchOperationSuccessLog
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Logging.GQLBatchQueryOperationLog
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Logging.GQLQueryOperationErrorLog
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Logging.GQLQueryOperationSuccessLog
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Logging.HttpInfoLog
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Logging.HttpLogContext
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Logging.HttpLogQueryOnlyOnError
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Logging.MetadataLog
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Logging.MetadataQueryLoggingMode
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Logging.ModelInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Logging.OperationLog
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Logging.PGLog
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Logging.RequestMode
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Logging.SchemaSyncLog
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Logging.StartupLog
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Logging.WebHookLog

module Hasura.Server.Migrate.Version

-- | Represents the catalog version. This is stored in the database and
--   then compared with the latest version on startup.
data MetadataCatalogVersion

-- | A typical catalog version.
MetadataCatalogVersion :: Int -> MetadataCatalogVersion

-- | Maintained for compatibility with catalog version 0.8.
MetadataCatalogVersion08 :: MetadataCatalogVersion

-- | This is the source catalog version, used when deciding whether to
--   (re-)create event triggers.
newtype SourceCatalogVersion (backend :: BackendType)
SourceCatalogVersion :: Int -> SourceCatalogVersion (backend :: BackendType)
[unSourceCatalogVersion] :: SourceCatalogVersion (backend :: BackendType) -> Int
data SourceCatalogMigrationState

-- | Source has not been initialized yet.
SCMSUninitializedSource :: SourceCatalogMigrationState

-- | Source catalog is already at the latest catalog version.
SCMSNothingToDo :: Int -> SourceCatalogMigrationState

-- | Initialization of the source catalog along with the catalog version.
SCMSInitialized :: Int -> SourceCatalogMigrationState

-- | Source catalog migration <a>catalog version</a> to <a>catalog
--   version</a>.
SCMSMigratedTo :: Int -> Int -> SourceCatalogMigrationState

-- | Source catalog migration on hold with reason (Maintenance mode, read
--   only mode etc).
SCMSMigrationOnHold :: Text -> SourceCatalogMigrationState
SCMSNotSupported :: SourceCatalogMigrationState
instance GHC.Internal.Enum.Enum Hasura.Server.Migrate.Version.MetadataCatalogVersion
instance GHC.Internal.Enum.Enum (Hasura.Server.Migrate.Version.SourceCatalogVersion backend)
instance GHC.Classes.Eq Hasura.Server.Migrate.Version.MetadataCatalogVersion
instance GHC.Classes.Eq (Hasura.Server.Migrate.Version.SourceCatalogVersion backend)
instance Language.Haskell.TH.Syntax.Lift Hasura.Server.Migrate.Version.MetadataCatalogVersion
instance Language.Haskell.TH.Syntax.Lift (Hasura.Server.Migrate.Version.SourceCatalogVersion backend)
instance GHC.Classes.Ord Hasura.Server.Migrate.Version.MetadataCatalogVersion
instance GHC.Internal.Read.Read Hasura.Server.Migrate.Version.MetadataCatalogVersion
instance GHC.Internal.Read.Read (Hasura.Server.Migrate.Version.SourceCatalogVersion backend)
instance GHC.Internal.Show.Show Hasura.Server.Migrate.Version.MetadataCatalogVersion
instance GHC.Internal.Show.Show (Hasura.Server.Migrate.Version.SourceCatalogVersion backend)
instance Hasura.Logging.ToEngineLog (Hasura.RQL.Types.Common.SourceName, Hasura.Server.Migrate.Version.SourceCatalogMigrationState) Hasura.Logging.Hasura


-- | A module that defines the current catalog version and nothing else.
--   This is necessary to circumvent the unfortunate “GHC stage
--   restriction,” which prevents us from using a binding in a compile-time
--   splice unless it is defined in a different module. The actual
--   migration code is in <a>Hasura.Server.Migrate</a>.
module Hasura.Server.Migrate.LatestVersion

-- | The current catalog schema version. We store this in a file because we
--   want to append the current verson to the catalog_versions file when
--   tagging a new release, in <tt>tag-release.sh</tt>.
latestCatalogVersion :: MetadataCatalogVersion
latestCatalogVersionString :: Text

module Hasura.Server.Migrate.Internal

-- | The old 0.8 catalog version is non-integral, so the version has always
--   been stored as a string.
getCatalogVersion :: TxE QErr MetadataCatalogVersion
from3To4 :: (Backend ('Postgres 'Vanilla), MonadTx m) => m ()
setCatalogVersion :: MonadTx m => Text -> UTCTime -> m ()


-- | Postgres DDL Source Version
--   
--   Deals with catalog version - used by <a>Source</a>.
module Hasura.Backends.Postgres.DDL.Source.Version
type SourceCatalogVersion (pgKind :: PostgresKind) = SourceCatalogVersion 'Postgres pgKind
initialSourceCatalogVersion :: forall (pgKind :: PostgresKind). SourceCatalogVersion pgKind
latestSourceCatalogVersion :: forall (pgKind :: PostgresKind). SourceCatalogVersion pgKind
previousSourceCatalogVersions :: forall (pgKind :: PostgresKind). [SourceCatalogVersion pgKind]
getSourceCatalogVersion :: forall m (postgres :: PostgresKind). MonadTx m => m (SourceCatalogVersion postgres)
setSourceCatalogVersion :: MonadTx m => m ()

module Hasura.Backends.MSSQL.DDL.Source.Version
type SourceCatalogVersion = SourceCatalogVersion 'MSSQL
initialSourceCatalogVersion :: SourceCatalogVersion
latestSourceCatalogVersion :: SourceCatalogVersion
previousSourceCatalogVersions :: [SourceCatalogVersion]
setSourceCatalogVersion :: MonadMSSQLTx m => SourceCatalogVersion -> m ()
getSourceCatalogVersion :: MonadMSSQLTx m => m SourceCatalogVersion

module Hasura.Server.Auth.WebHook
data AuthHookType
AHTGet :: AuthHookType
AHTPost :: AuthHookType
data AuthHook
AuthHook :: Text -> AuthHookType -> Bool -> AuthHook
[ahUrl] :: AuthHook -> Text
[ahType] :: AuthHook -> AuthHookType

-- | Whether to send the request body to the auth hook
[ahSendRequestBody] :: AuthHook -> Bool

-- | Makes an authentication request to the given AuthHook and returns
--   UserInfo parsed from the response, plus an expiration time if one was
--   returned. Optionally passes a batch of raw GraphQL requests for
--   finer-grained auth. (#2666)
userInfoFromAuthHook :: (MonadIO m, MonadBaseControl IO m, MonadError QErr m) => Logger Hasura -> Manager -> AuthHook -> [Header] -> Maybe ReqsText -> m (UserInfo, Maybe UTCTime, [Header])
instance GHC.Classes.Eq Hasura.Server.Auth.WebHook.AuthHook
instance GHC.Classes.Eq Hasura.Server.Auth.WebHook.AuthHookType
instance GHC.Internal.Show.Show Hasura.Server.Auth.WebHook.AuthHook
instance GHC.Internal.Show.Show Hasura.Server.Auth.WebHook.AuthHookType

module Hasura.Server.Auth

-- | Authenticate the request using the headers and the configured
--   <a>AuthMode</a>.
getUserInfoWithExpTime :: (MonadIO m, MonadBaseControl IO m, MonadError QErr m) => Logger Hasura -> Manager -> [Header] -> AuthMode -> Maybe ReqsText -> m (UserInfo, Maybe UTCTime, [Header])

-- | The methods we'll use to derive roles for authenticating requests.
--   
--   <tt>Maybe RoleName</tt> below is the optionally-defined role for the
--   unauthenticated (anonymous) user.
--   
--   See:
--   <a>https://hasura.io/docs/latest/graphql/core/auth/authentication/unauthenticated-access.html</a>
data AuthMode
AMNoAuth :: AuthMode
AMAdminSecret :: !HashSet AdminSecretHash -> !Maybe RoleName -> AuthMode
AMAdminSecretAndHook :: !HashSet AdminSecretHash -> !AuthHook -> AuthMode
AMAdminSecretAndJWT :: !HashSet AdminSecretHash -> ![JWTCtx] -> !Maybe RoleName -> AuthMode

-- | In case JWT is used as an authentication mode, the JWKs are stored
--   inside JWTCtx as an <tt>IORef</tt>. <tt>IORef</tt> has pointer
--   equality, so we need to compare the values inside the <tt>IORef</tt>
--   to check if the <a>JWTCtx</a> is same.
compareAuthMode :: AuthMode -> AuthMode -> IO Bool

-- | Validate the user's requested authentication configuration, launching
--   any required maintenance threads for JWT etc.
--   
--   This must only be run once, on launch.
setupAuthMode :: (MonadError Text m, MonadIO m, MonadBaseControl IO m) => HashSet AdminSecretHash -> Maybe AuthHook -> [JWTConfig] -> Maybe RoleName -> Logger Hasura -> Manager -> m AuthMode

-- | The hashed admin password. <a>hashAdminSecret</a> is our public
--   interface for constructing the secret.
--   
--   To prevent misuse and leaking we keep this opaque and don't provide
--   instances that could leak information. Likewise for <a>AuthMode</a>.
--   
--   Although this exists only in memory we store only a hash of the admin
--   secret primarily in order to:
--   
--   <ul>
--   <li>prevent theoretical timing attacks from a naive <a>==</a>
--   check</li>
--   <li>prevent misuse or inadvertent leaking of the secret</li>
--   </ul>
data AdminSecretHash
unsafeMkAdminSecretHash :: Digest SHA512 -> AdminSecretHash
hashAdminSecret :: Text -> AdminSecretHash

-- | Update the JWK based on the expiry time specified in <tt>Expires</tt>
--   header or <tt>Cache-Control</tt> header
updateJwkCtx :: (MonadIO m, MonadBaseControl IO m) => AuthMode -> Manager -> Logger Hasura -> m ()
data AuthHookType
AHTGet :: AuthHookType
AHTPost :: AuthHookType
data AuthHook
AuthHook :: Text -> AuthHookType -> Bool -> AuthHook
[ahUrl] :: AuthHook -> Text
[ahType] :: AuthHook -> AuthHookType

-- | Whether to send the request body to the auth hook
[ahSendRequestBody] :: AuthHook -> Bool
data RawJWT

-- | The JWT configuration we got from the user.
data JWTConfig
JWTConfig :: !Either JWK URI -> !Maybe Audience -> !Maybe StringOrURI -> !JWTClaims -> !Maybe NominalDiffTime -> !Maybe JWTHeader -> JWTConfig
[jcKeyOrUrl] :: JWTConfig -> !Either JWK URI
[jcAudience] :: JWTConfig -> !Maybe Audience
[jcIssuer] :: JWTConfig -> !Maybe StringOrURI
[jcClaims] :: JWTConfig -> !JWTClaims
[jcAllowedSkew] :: JWTConfig -> !Maybe NominalDiffTime
[jcHeader] :: JWTConfig -> !Maybe JWTHeader

-- | The validated runtime JWT configuration returned by <tt>mkJwtCtx</tt>
--   in <tt>setupAuthMode</tt>.
data JWTCtx
JWTCtx :: !Maybe URI -> !IORef (JWKSet, Maybe UTCTime) -> !Maybe Audience -> !Maybe StringOrURI -> !JWTClaims -> !Maybe NominalDiffTime -> !JWTHeader -> JWTCtx
[jcxUrl] :: JWTCtx -> !Maybe URI

-- | This needs to be a mutable variable for <a>fetchJwk</a>. | We add the
--   expiry time of the JWK to the IORef, to determine | if the JWK has
--   expired and needs to be refreshed.
[jcxKeyConfig] :: JWTCtx -> !IORef (JWKSet, Maybe UTCTime)
[jcxAudience] :: JWTCtx -> !Maybe Audience
[jcxIssuer] :: JWTCtx -> !Maybe StringOrURI
[jcxClaims] :: JWTCtx -> !JWTClaims
[jcxAllowedSkew] :: JWTCtx -> !Maybe NominalDiffTime
[jcxHeader] :: JWTCtx -> !JWTHeader

-- | RFC 7517 §5. JWK Set Format
newtype JWKSet
JWKSet :: [JWK] -> JWKSet

-- | Process the request headers to verify the JWT and extract UserInfo
--   from it From the JWT config, we check which header to expect, it can
--   be the <a>Authorization</a> or <a>Cookie</a> header
--   
--   If no <a>Authorization</a>/<a>Cookie</a> header was passed, we will
--   fall back to the unauthenticated user role [1], if one was configured
--   at server start.
--   
--   When no 'x-hasura-user-role' is specified in the request, the
--   mandatory 'x-hasura-default-role' [2] from the JWT claims will be
--   used.
processJwt :: (MonadIO m, MonadError QErr m) => [JWTCtx] -> RequestHeaders -> Maybe RoleName -> m (UserInfo, Maybe UTCTime, [Header], Maybe JWTCtx)

-- | Typeclass representing the <tt>UserInfo</tt> authorization and
--   resolving effect
class Monad m => UserAuthentication (m :: Type -> Type)
resolveUserInfo :: UserAuthentication m => Logger Hasura -> Manager -> [Header] -> AuthMode -> Maybe ReqsText -> m (Either QErr (UserInfo, Maybe UTCTime, [Header], ExtraUserInfo))
mkJwtCtx :: (MonadIO m, MonadBaseControl IO m, MonadError Text m) => JWTConfig -> Logger Hasura -> Manager -> m JWTCtx
updateJwkFromUrl :: (MonadIO m, MonadBaseControl IO m) => JWTCtx -> Manager -> Logger Hasura -> m ()
getUserInfoWithExpTime_ :: forall m mgr logger. (MonadIO m, MonadError QErr m) => (logger -> mgr -> AuthHook -> [Header] -> Maybe ReqsText -> m (UserInfo, Maybe UTCTime, [Header])) -> ([JWTCtx] -> [Header] -> Maybe RoleName -> m (UserInfo, Maybe UTCTime, [Header], Maybe JWTCtx)) -> logger -> mgr -> [Header] -> AuthMode -> Maybe ReqsText -> m (UserInfo, Maybe UTCTime, [Header])
instance GHC.Classes.Eq Hasura.Server.Auth.AdminSecretHash
instance GHC.Classes.Eq Hasura.Server.Auth.AuthMode
instance Data.Hashable.Class.Hashable Hasura.Server.Auth.AdminSecretHash
instance GHC.Classes.Ord Hasura.Server.Auth.AdminSecretHash
instance GHC.Internal.Show.Show Hasura.Server.Auth.AdminSecretHash
instance GHC.Internal.Show.Show Hasura.Server.Auth.AuthMode

module Hasura.PingSources

-- | A forever running IO loop that performs regular pings for DBs that
--   need it these are used to send a fingerprint to third parties that
--   wish to attribute users to Hasura
runPingSources :: Environment -> (String -> IO ()) -> IO SourcePingCache -> IO a

module Hasura.Backends.BigQuery.DDL.Source
resolveSource :: MonadIO m => BigQuerySourceConfig -> m (Either QErr (DBObjectsIntrospection 'BigQuery))
postDropSourceHook :: MonadIO m => BigQuerySourceConfig -> TableEventTriggers 'BigQuery -> m ()
resolveSourceConfig :: MonadIO m => SourceName -> BigQueryConnSourceConfig -> BackendSourceKind 'BigQuery -> BackendConfig 'BigQuery -> Environment -> manager -> m (Either QErr BigQuerySourceConfig)
restTypeToScalarType :: RestType -> ScalarType


-- | BigQuery DDL ComputedField
--   
--   Implementation to build <a>ComputedFieldInfo</a> for a BigQuery table
--   from metadata
module Hasura.Backends.BigQuery.DDL.ComputedField

-- | Validate computed field metadata and build field information
buildComputedFieldInfo :: MonadError QErr m => HashSet TableName -> TableName -> HashSet ColumnName -> ComputedFieldName -> ComputedFieldDefinition -> RestRoutine -> Comment -> m (ComputedFieldInfo 'BigQuery)


-- | Helpers used in the implementations of <tt>metadataToOrdJSON</tt> and
--   <tt>metadataToDTO</tt>
module Hasura.RQL.Types.Metadata.Serialization
actionMetadataToOrdJSONList :: Actions -> Maybe Array
allowlistToOrdJSONList :: MetadataAllowlist -> Maybe Array
apiLimitsToOrdJSON :: ApiLimit -> Maybe Value
backendConfigsToOrdJSON :: BackendMap BackendConfigWrapper -> Maybe Value
openTelemetryConfigToOrdJSON :: OpenTelemetryConfig -> Maybe Value
cronTriggersToOrdJSONList :: CronTriggers -> Maybe Array
customTypesToOrdJSON :: CustomTypes -> Maybe Object
endpointsToOrdJSONList :: Endpoints -> Maybe Array
inheritedRolesToOrdJSONList :: InheritedRoles -> Maybe Array
introspectionDisabledRolesToOrdJSON :: SetGraphqlIntrospectionOptions -> Maybe Value
metricsConfigToOrdJSON :: MetricsConfig -> Maybe Value
networkConfigToOrdJSON :: Network -> Maybe Value
queryCollectionsToOrdJSONList :: QueryCollections -> Maybe Array
remoteSchemasToOrdJSONList :: RemoteSchemas -> Maybe Array
sourcesToOrdJSONList :: Sources -> Array

module Hasura.GraphQL.Execute.Action.Types
newtype ActionContext
ActionContext :: ActionName -> ActionContext
[_acName] :: ActionContext -> ActionName
newtype ActionExecution
ActionExecution :: (forall (m :: Type -> Type). (MonadIO m, MonadBaseControl IO m, MonadError QErr m, MonadTrace m) => m (EncJSON, ResponseHeaders)) -> ActionExecution
[unActionExecution] :: ActionExecution -> forall (m :: Type -> Type). (MonadIO m, MonadBaseControl IO m, MonadError QErr m, MonadTrace m) => m (EncJSON, ResponseHeaders)
data ActionExecutionPlan
AEPSync :: !ActionExecution -> ActionExecutionPlan
AEPAsyncQuery :: !AsyncActionQueryExecutionPlan -> ActionExecutionPlan
AEPAsyncMutation :: !ActionId -> ActionExecutionPlan
data ActionHandlerLog
ActionHandlerLog :: !Request -> !Maybe Request -> !Int64 -> !Maybe Int64 -> !Int64 -> !ActionName -> ActionHandlerLog
[_ahlRequest] :: ActionHandlerLog -> !Request
[_ahlRequestTrans] :: ActionHandlerLog -> !Maybe Request
[_ahlRequestSize] :: ActionHandlerLog -> !Int64
[_ahlTransformedRequestSize] :: ActionHandlerLog -> !Maybe Int64
[_ahlResponseSize] :: ActionHandlerLog -> !Int64
[_ahlActionName] :: ActionHandlerLog -> !ActionName
data ActionInternalError
ActionInternalError :: !Value -> !ActionRequestInfo -> !Maybe ActionResponseInfo -> ActionInternalError
[_aieError] :: ActionInternalError -> !Value
[_aieRequest] :: ActionInternalError -> !ActionRequestInfo
[_aieResponse] :: ActionInternalError -> !Maybe ActionResponseInfo
data ActionRequestInfo
ActionRequestInfo :: !Text -> !ActionContext -> !Value -> !Maybe GQLQueryText -> !Maybe Request -> ActionRequestInfo
[_areqiUrl] :: ActionRequestInfo -> !Text
[_areqiAction] :: ActionRequestInfo -> !ActionContext
[_areqiInput] :: ActionRequestInfo -> !Value
[_areqiRequestQuery] :: ActionRequestInfo -> !Maybe GQLQueryText
[_areqiTransformedRequest] :: ActionRequestInfo -> !Maybe Request
data ActionResponseInfo
ActionResponseInfo :: !Int -> !Value -> ![HeaderConf] -> ActionResponseInfo
[_aresiStatus] :: ActionResponseInfo -> !Int
[_aresiBody] :: ActionResponseInfo -> !Value
[_aresiHeaders] :: ActionResponseInfo -> ![HeaderConf]
data ActionWebhookErrorResponse
ActionWebhookErrorResponse :: !Text -> !Maybe Text -> !Maybe Value -> ActionWebhookErrorResponse
[_awerMessage] :: ActionWebhookErrorResponse -> !Text
[_awerCode] :: ActionWebhookErrorResponse -> !Maybe Text
[_awerExtensions] :: ActionWebhookErrorResponse -> !Maybe Value
data ActionWebhookPayload
ActionWebhookPayload :: !ActionContext -> !SessionVariables -> !Value -> !Maybe GQLQueryText -> ActionWebhookPayload
[_awpAction] :: ActionWebhookPayload -> !ActionContext
[_awpSessionVariables] :: ActionWebhookPayload -> !SessionVariables
[_awpInput] :: ActionWebhookPayload -> !Value
[_awpRequestQuery] :: ActionWebhookPayload -> !Maybe GQLQueryText
type ActionWebhookResponse = Value
data AsyncActionQueryExecution v

-- | Async actions associated with no relationships.
AAQENoRelationships :: !ActionLogResponse -> Either QErr EncJSON -> AsyncActionQueryExecution v

-- | Async actions with relationships defined to Postgres (as of now, we
--   may have support for other backends as well in further iterations)
--   tables.
AAQEOnSourceDB :: !SourceConfig ('Postgres 'Vanilla) -> !AsyncActionQuerySourceExecution v -> AsyncActionQueryExecution v

-- | A plan to execute async action query
data AsyncActionQueryExecutionPlan
AsyncActionQueryExecutionPlan :: !ActionId -> !AsyncActionQueryExecution (UnpreparedValue ('Postgres 'Vanilla)) -> AsyncActionQueryExecutionPlan
[_aaqepId] :: AsyncActionQueryExecutionPlan -> !ActionId
[_aaqepExecution] :: AsyncActionQueryExecutionPlan -> !AsyncActionQueryExecution (UnpreparedValue ('Postgres 'Vanilla))
data AsyncActionQuerySourceExecution v
AsyncActionQuerySourceExecution :: !SourceName -> !JsonAggSelect -> !ActionLogResponse -> AnnSimpleSelectG ('Postgres 'Vanilla) Void v -> AsyncActionQuerySourceExecution v
[_aaqseSource] :: AsyncActionQuerySourceExecution v -> !SourceName
[_aaqseJsonAggSelect] :: AsyncActionQuerySourceExecution v -> !JsonAggSelect
[_aaqseSelectBuilder] :: AsyncActionQuerySourceExecution v -> !ActionLogResponse -> AnnSimpleSelectG ('Postgres 'Vanilla) Void v
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Action.Types.ActionContext
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Action.Types.ActionResponseInfo
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Action.Types.ActionWebhookErrorResponse
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Action.Types.ActionWebhookPayload
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Execute.Action.Types.ActionContext
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Execute.Action.Types.ActionResponseInfo
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Execute.Action.Types.ActionWebhookErrorResponse
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Execute.Action.Types.ActionWebhookPayload
instance GHC.Internal.Generics.Generic Hasura.GraphQL.Execute.Action.Types.ActionContext
instance GHC.Internal.Generics.Generic Hasura.GraphQL.Execute.Action.Types.ActionHandlerLog
instance GHC.Internal.Generics.Generic Hasura.GraphQL.Execute.Action.Types.ActionInternalError
instance GHC.Internal.Generics.Generic Hasura.GraphQL.Execute.Action.Types.ActionRequestInfo
instance GHC.Internal.Generics.Generic Hasura.GraphQL.Execute.Action.Types.ActionResponseInfo
instance GHC.Internal.Generics.Generic Hasura.GraphQL.Execute.Action.Types.ActionWebhookErrorResponse
instance GHC.Internal.Generics.Generic Hasura.GraphQL.Execute.Action.Types.ActionWebhookPayload
instance GHC.Internal.Show.Show Hasura.GraphQL.Execute.Action.Types.ActionContext
instance GHC.Internal.Show.Show Hasura.GraphQL.Execute.Action.Types.ActionHandlerLog
instance GHC.Internal.Show.Show Hasura.GraphQL.Execute.Action.Types.ActionInternalError
instance GHC.Internal.Show.Show Hasura.GraphQL.Execute.Action.Types.ActionRequestInfo
instance GHC.Internal.Show.Show Hasura.GraphQL.Execute.Action.Types.ActionResponseInfo
instance GHC.Internal.Show.Show Hasura.GraphQL.Execute.Action.Types.ActionWebhookErrorResponse
instance GHC.Internal.Show.Show Hasura.GraphQL.Execute.Action.Types.ActionWebhookPayload
instance Hasura.Logging.ToEngineLog Hasura.GraphQL.Execute.Action.Types.ActionHandlerLog Hasura.Logging.Hasura
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Action.Types.ActionContext
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Action.Types.ActionHandlerLog
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Action.Types.ActionInternalError
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Action.Types.ActionRequestInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Action.Types.ActionResponseInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Action.Types.ActionWebhookErrorResponse
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Action.Types.ActionWebhookPayload

module Hasura.Eventing.Common
data LockedEventsCtx
LockedEventsCtx :: TVar (Set CronEventId) -> TVar (Set OneOffScheduledEventId) -> TVar (HashMap SourceName (Set EventId)) -> TVar (Set LockedActionEventId) -> LockedEventsCtx
[leCronEvents] :: LockedEventsCtx -> TVar (Set CronEventId)
[leOneOffEvents] :: LockedEventsCtx -> TVar (Set OneOffScheduledEventId)
[leEvents] :: LockedEventsCtx -> TVar (HashMap SourceName (Set EventId))
[leActionEvents] :: LockedEventsCtx -> TVar (Set LockedActionEventId)

-- | After the events are fetched from the DB, we store the locked events
--   in a hash set(order doesn't matter and look ups are faster) in the
--   event engine context
saveLockedEvents :: MonadIO m => [EventId] -> TVar (Set EventId) -> m ()

-- | Remove an event from the <a>LockedEventsCtx</a> after it has been
--   processed
removeEventFromLockedEvents :: MonadIO m => EventId -> TVar (Set EventId) -> m ()

-- | Generates next <tt>n events starting </tt>from according to
--   <a>CronSchedule</a>
generateScheduleTimes :: UTCTime -> Int -> CronSchedule -> [UTCTime]

-- | number of cleanup schedules to be generated in one iteration
cleanupSchedulesToBeGenerated :: Int
deleteEventTriggerLogsInBatchesWith :: (MonadIO m, MonadError QErr m) => IO (Maybe (TriggerLogCleanupConfig, EventTriggerCleanupStatus)) -> TriggerLogCleanupConfig -> (TriggerLogCleanupConfig -> IO (Either QErr DeletedEventLogStats)) -> m DeletedEventLogStats

module Hasura.RQL.IR.Action

-- | Internal representation for a selection of fields on the result of an
--   action. Type parameter r will be either r ~ (RemoteRelationshipField
--   UnpreparedValue) when the AST is emitted by the parser. r ~ Void when
--   an execution tree is constructed so that a backend is absolved of
--   dealing with remote relationships.
data ActionFieldG r

-- | Scalar value. G.Name is the original field name from the object type.
ACFScalar :: Name -> ActionFieldG r

-- | Remote relationship
ACFRemote :: ActionRemoteRelationshipSelect r -> ActionFieldG r

-- | Constant text value (used for __typename fields)
ACFExpression :: Text -> ActionFieldG r

-- | Nested object. G.Name is the original field name from the object type.
ACFNestedObject :: Name -> ActionFieldsG r -> ActionFieldG r
type ActionFieldsG r = Fields ActionFieldG r
type ActionFields = ActionFieldsG Void
data ActionRemoteRelationshipSelect r
ActionRemoteRelationshipSelect :: HashMap FieldName Name -> r -> ActionRemoteRelationshipSelect r

-- | The fields on the table that are required for the join condition of
--   the remote relationship
[_arrsLHSJoinFields] :: ActionRemoteRelationshipSelect r -> HashMap FieldName Name

-- | The field that captures the relationship r ~ (RemoteRelationshipField
--   UnpreparedValue) when the AST is emitted by the parser. r ~ Void when
--   an execution tree is constructed so that a backend is absolved of
--   dealing with remote relationships.
[_arrsRelationship] :: ActionRemoteRelationshipSelect r -> r
_ACFExpression :: forall r p f. (Choice p, Applicative f) => p Text (f Text) -> p (ActionFieldG r) (f (ActionFieldG r))
_ACFNestedObject :: forall r p f. (Choice p, Applicative f) => p (Name, ActionFieldsG r) (f (Name, ActionFieldsG r)) -> p (ActionFieldG r) (f (ActionFieldG r))
_ACFRemote :: forall r p f. (Choice p, Applicative f) => p (ActionRemoteRelationshipSelect r) (f (ActionRemoteRelationshipSelect r)) -> p (ActionFieldG r) (f (ActionFieldG r))
_ACFScalar :: forall r p f. (Choice p, Applicative f) => p Name (f Name) -> p (ActionFieldG r) (f (ActionFieldG r))
data AnnActionExecution r
AnnActionExecution :: ActionName -> GraphQLType -> ActionFieldsG r -> Value -> ActionOutputFields -> EnvRecord ResolvedWebhook -> [HeaderConf] -> Bool -> Timeout -> Maybe RequestTransform -> Maybe MetadataResponseTransform -> AnnActionExecution r
[_aaeName] :: AnnActionExecution r -> ActionName

-- | output type
[_aaeOutputType] :: AnnActionExecution r -> GraphQLType

-- | output selection
[_aaeFields] :: AnnActionExecution r -> ActionFieldsG r

-- | jsonified input arguments
[_aaePayload] :: AnnActionExecution r -> Value

-- | to validate the response fields from webhook
[_aaeOutputFields] :: AnnActionExecution r -> ActionOutputFields
[_aaeWebhook] :: AnnActionExecution r -> EnvRecord ResolvedWebhook
[_aaeHeaders] :: AnnActionExecution r -> [HeaderConf]
[_aaeForwardClientHeaders] :: AnnActionExecution r -> Bool
[_aaeTimeOut] :: AnnActionExecution r -> Timeout
[_aaeRequestTransform] :: AnnActionExecution r -> Maybe RequestTransform
[_aaeResponseTransform] :: AnnActionExecution r -> Maybe MetadataResponseTransform
aaeName :: forall r f. Functor f => (ActionName -> f ActionName) -> AnnActionExecution r -> f (AnnActionExecution r)
aaeOutputType :: forall r f. Functor f => (GraphQLType -> f GraphQLType) -> AnnActionExecution r -> f (AnnActionExecution r)
aaeFields :: forall r1 r2 f. Functor f => (ActionFieldsG r1 -> f (ActionFieldsG r2)) -> AnnActionExecution r1 -> f (AnnActionExecution r2)
aaePayload :: forall r f. Functor f => (Value -> f Value) -> AnnActionExecution r -> f (AnnActionExecution r)
aaeOutputFields :: forall r f. Functor f => (ActionOutputFields -> f ActionOutputFields) -> AnnActionExecution r -> f (AnnActionExecution r)
aaeWebhook :: forall r f. Functor f => (EnvRecord ResolvedWebhook -> f (EnvRecord ResolvedWebhook)) -> AnnActionExecution r -> f (AnnActionExecution r)
aaeHeaders :: forall r f. Functor f => ([HeaderConf] -> f [HeaderConf]) -> AnnActionExecution r -> f (AnnActionExecution r)
aaeForwardClientHeaders :: forall r f. Functor f => (Bool -> f Bool) -> AnnActionExecution r -> f (AnnActionExecution r)
aaeTimeOut :: forall r f. Functor f => (Timeout -> f Timeout) -> AnnActionExecution r -> f (AnnActionExecution r)
aaeRequestTransform :: forall r f. Functor f => (Maybe RequestTransform -> f (Maybe RequestTransform)) -> AnnActionExecution r -> f (AnnActionExecution r)
aaeResponseTransform :: forall r f. Functor f => (Maybe MetadataResponseTransform -> f (Maybe MetadataResponseTransform)) -> AnnActionExecution r -> f (AnnActionExecution r)
data AnnActionMutationAsync
AnnActionMutationAsync :: ActionName -> Bool -> Value -> AnnActionMutationAsync
[_aamaName] :: AnnActionMutationAsync -> ActionName
[_aamaForwardClientHeaders] :: AnnActionMutationAsync -> Bool

-- | jsonified input arguments
[_aamaPayload] :: AnnActionMutationAsync -> Value
data AsyncActionQueryFieldG r
AsyncTypename :: Text -> AsyncActionQueryFieldG r
AsyncOutput :: ActionFieldsG r -> AsyncActionQueryFieldG r
AsyncId :: AsyncActionQueryFieldG r
AsyncCreatedAt :: AsyncActionQueryFieldG r
AsyncErrors :: AsyncActionQueryFieldG r
_AsyncTypename :: forall r p f. (Choice p, Applicative f) => p Text (f Text) -> p (AsyncActionQueryFieldG r) (f (AsyncActionQueryFieldG r))
_AsyncOutput :: forall r1 r2 p f. (Choice p, Applicative f) => p (ActionFieldsG r1) (f (ActionFieldsG r2)) -> p (AsyncActionQueryFieldG r1) (f (AsyncActionQueryFieldG r2))
_AsyncId :: forall r p f. (Choice p, Applicative f) => p () (f ()) -> p (AsyncActionQueryFieldG r) (f (AsyncActionQueryFieldG r))
_AsyncCreatedAt :: forall r p f. (Choice p, Applicative f) => p () (f ()) -> p (AsyncActionQueryFieldG r) (f (AsyncActionQueryFieldG r))
_AsyncErrors :: forall r p f. (Choice p, Applicative f) => p () (f ()) -> p (AsyncActionQueryFieldG r) (f (AsyncActionQueryFieldG r))
data AnnActionAsyncQuery (b :: BackendType) r
AnnActionAsyncQuery :: ActionName -> ActionId -> GraphQLType -> AsyncActionQueryFieldsG r -> [(Column b, ScalarType b)] -> StringifyNumbers -> Bool -> ActionSourceInfo b -> AnnActionAsyncQuery (b :: BackendType) r
[_aaaqName] :: AnnActionAsyncQuery (b :: BackendType) r -> ActionName
[_aaaqActionId] :: AnnActionAsyncQuery (b :: BackendType) r -> ActionId
[_aaaqOutputType] :: AnnActionAsyncQuery (b :: BackendType) r -> GraphQLType
[_aaaqFields] :: AnnActionAsyncQuery (b :: BackendType) r -> AsyncActionQueryFieldsG r
[_aaaqDefinitionList] :: AnnActionAsyncQuery (b :: BackendType) r -> [(Column b, ScalarType b)]
[_aaaqStringifyNum] :: AnnActionAsyncQuery (b :: BackendType) r -> StringifyNumbers
[_aaaqForwardClientHeaders] :: AnnActionAsyncQuery (b :: BackendType) r -> Bool
[_aaaqSource] :: AnnActionAsyncQuery (b :: BackendType) r -> ActionSourceInfo b
aaaqName :: forall (b :: BackendType) r f. Functor f => (ActionName -> f ActionName) -> AnnActionAsyncQuery b r -> f (AnnActionAsyncQuery b r)
aaaqActionId :: forall (b :: BackendType) r f. Functor f => (ActionId -> f ActionId) -> AnnActionAsyncQuery b r -> f (AnnActionAsyncQuery b r)
aaaqOutputType :: forall (b :: BackendType) r f. Functor f => (GraphQLType -> f GraphQLType) -> AnnActionAsyncQuery b r -> f (AnnActionAsyncQuery b r)
aaaqFields :: forall (b :: BackendType) r1 r2 f. Functor f => (AsyncActionQueryFieldsG r1 -> f (AsyncActionQueryFieldsG r2)) -> AnnActionAsyncQuery b r1 -> f (AnnActionAsyncQuery b r2)
aaaqDefinitionList :: forall (b :: BackendType) r f. Functor f => ([(Column b, ScalarType b)] -> f [(Column b, ScalarType b)]) -> AnnActionAsyncQuery b r -> f (AnnActionAsyncQuery b r)
aaaqStringifyNum :: forall (b :: BackendType) r f. Functor f => (StringifyNumbers -> f StringifyNumbers) -> AnnActionAsyncQuery b r -> f (AnnActionAsyncQuery b r)
aaaqForwardClientHeaders :: forall (b :: BackendType) r f. Functor f => (Bool -> f Bool) -> AnnActionAsyncQuery b r -> f (AnnActionAsyncQuery b r)
aaaqSource :: forall (b :: BackendType) r f. Functor f => (ActionSourceInfo b -> f (ActionSourceInfo b)) -> AnnActionAsyncQuery b r -> f (AnnActionAsyncQuery b r)
data ActionSourceInfo (b :: BackendType)

-- | No relationships defined on the action output object
ASINoSource :: ActionSourceInfo (b :: BackendType)

-- | All relationships refer to tables in one source
ASISource :: SourceName -> SourceConfig b -> ActionSourceInfo (b :: BackendType)
type ActionOutputFields = HashMap Name GType
getActionOutputFields :: AnnotatedOutputType -> ActionOutputFields
instance GHC.Classes.Eq r => GHC.Classes.Eq (Hasura.RQL.IR.Action.ActionFieldG r)
instance GHC.Classes.Eq r => GHC.Classes.Eq (Hasura.RQL.IR.Action.ActionRemoteRelationshipSelect r)
instance GHC.Classes.Eq Hasura.RQL.IR.Action.AnnActionMutationAsync
instance GHC.Internal.Data.Foldable.Foldable Hasura.RQL.IR.Action.ActionFieldG
instance GHC.Internal.Data.Foldable.Foldable Hasura.RQL.IR.Action.ActionRemoteRelationshipSelect
instance GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.Action.AnnActionAsyncQuery b)
instance GHC.Internal.Data.Foldable.Foldable Hasura.RQL.IR.Action.AnnActionExecution
instance GHC.Internal.Data.Foldable.Foldable Hasura.RQL.IR.Action.AsyncActionQueryFieldG
instance GHC.Internal.Base.Functor Hasura.RQL.IR.Action.ActionFieldG
instance GHC.Internal.Base.Functor Hasura.RQL.IR.Action.ActionRemoteRelationshipSelect
instance GHC.Internal.Base.Functor (Hasura.RQL.IR.Action.AnnActionAsyncQuery b)
instance GHC.Internal.Base.Functor Hasura.RQL.IR.Action.AnnActionExecution
instance GHC.Internal.Base.Functor Hasura.RQL.IR.Action.AsyncActionQueryFieldG
instance GHC.Internal.Show.Show r => GHC.Internal.Show.Show (Hasura.RQL.IR.Action.ActionFieldG r)
instance GHC.Internal.Show.Show r => GHC.Internal.Show.Show (Hasura.RQL.IR.Action.ActionRemoteRelationshipSelect r)
instance GHC.Internal.Show.Show Hasura.RQL.IR.Action.AnnActionMutationAsync
instance GHC.Internal.Data.Traversable.Traversable Hasura.RQL.IR.Action.ActionFieldG
instance GHC.Internal.Data.Traversable.Traversable Hasura.RQL.IR.Action.ActionRemoteRelationshipSelect
instance GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.Action.AnnActionAsyncQuery b)
instance GHC.Internal.Data.Traversable.Traversable Hasura.RQL.IR.Action.AnnActionExecution
instance GHC.Internal.Data.Traversable.Traversable Hasura.RQL.IR.Action.AsyncActionQueryFieldG

module Hasura.RQL.IR.Root
data SourceConfigWith (db :: BackendType -> Type) (b :: BackendType)
SourceConfigWith :: SourceConfig b -> Maybe QueryTagsConfig -> db b -> SourceConfigWith (db :: BackendType -> Type) (b :: BackendType)
data RootField (db :: BackendType -> Type) remote action raw
[RFDB] :: forall (db :: BackendType -> Type) remote action raw. SourceName -> AnyBackend (SourceConfigWith db) -> RootField db remote action raw
[RFRemote] :: forall remote (db :: BackendType -> Type) action raw. RemoteSchemaName -> remote -> RootField db remote action raw
[RFAction] :: forall action (db :: BackendType -> Type) remote raw. action -> RootField db remote action raw
[RFRaw] :: forall raw (db :: BackendType -> Type) remote action. raw -> RootField db remote action raw
[RFMulti] :: forall (db :: BackendType -> Type) remote action raw. [RootField db remote action raw] -> RootField db remote action raw
data MutationDB (b :: BackendType) r v
MDBInsert :: AnnotatedInsert b r v -> MutationDB (b :: BackendType) r v
MDBUpdate :: AnnotatedUpdateG b r v -> MutationDB (b :: BackendType) r v
MDBDelete :: AnnDelG b r v -> MutationDB (b :: BackendType) r v

-- | This represents a VOLATILE function, and is AnnSimpleSelG for easy
--   re-use of non-VOLATILE function tracking code.
MDBFunction :: JsonAggSelect -> AnnSimpleSelectG b r v -> MutationDB (b :: BackendType) r v
data ActionQuery r
AQQuery :: AnnActionExecution r -> ActionQuery r
AQAsync :: AnnActionAsyncQuery ('Postgres 'Vanilla) r -> ActionQuery r
data ActionMutation r
AMSync :: AnnActionExecution r -> ActionMutation r
AMAsync :: AnnActionMutationAsync -> ActionMutation r
type QueryRootField (v :: BackendType -> Type) = RootField QueryDBRoot RemoteRelationshipField v v RemoteSchemaRootField RemoteRelationshipField v RemoteSchemaVariable QueryActionRoot v Value
type MutationRootField (v :: BackendType -> Type) = RootField MutationDBRoot RemoteRelationshipField v v RemoteSchemaRootField RemoteRelationshipField v RemoteSchemaVariable MutationActionRoot v Value
type SubscriptionRootField (v :: BackendType -> Type) = RootField QueryDBRoot RemoteRelationshipField v v RemoteSchemaRootField RemoteRelationshipField v RemoteSchemaVariable QueryActionRoot v Value
newtype QueryDBRoot r (v :: BackendType -> Type) (b :: BackendType)
QDBR :: QueryDB b r (v b) -> QueryDBRoot r (v :: BackendType -> Type) (b :: BackendType)
newtype MutationDBRoot r (v :: BackendType -> Type) (b :: BackendType)
MDBR :: MutationDB b r (v b) -> MutationDBRoot r (v :: BackendType -> Type) (b :: BackendType)

-- | IR of a remote relationship. A remote relationship currently can be to
--   either a remote schema or a database's table. See RemoteSourceSelect
--   for explanation on <tt>vf</tt>.
data RemoteRelationshipField (vf :: BackendType -> Type)
RemoteSchemaField :: RemoteSchemaSelect (RemoteRelationshipField vf) -> RemoteRelationshipField (vf :: BackendType -> Type)

-- | AnyBackend is used here to capture a relationship to an arbitrary
--   target
RemoteSourceField :: AnyBackend (RemoteSourceSelect (RemoteRelationshipField vf) vf) -> RemoteRelationshipField (vf :: BackendType -> Type)
instance GHC.Internal.Data.Foldable.Foldable Hasura.RQL.IR.Root.ActionQuery
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Foldable.Foldable (Hasura.RQL.IR.Root.MutationDB b r)
instance GHC.Internal.Base.Functor Hasura.RQL.IR.Root.ActionQuery
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Base.Functor (Hasura.RQL.IR.Root.MutationDB b r)
instance GHC.Internal.Generics.Generic (Hasura.RQL.IR.Root.MutationDB b r v)
instance Hasura.SQL.AnyBackend.SatisfiesForAllBackends vf GHC.Internal.Show.Show => GHC.Internal.Show.Show (Hasura.RQL.IR.Root.RemoteRelationshipField vf)
instance GHC.Internal.Data.Traversable.Traversable Hasura.RQL.IR.Root.ActionQuery
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Data.Traversable.Traversable (Hasura.RQL.IR.Root.MutationDB b r)

module Hasura.RQL.IR

module Hasura.RQL.IR.ModelInformation
data ModelType
ModelTypeTable :: ModelType
ModelTypeLogicalModels :: ModelType
ModelTypeFunction :: ModelType
ModelTypeIdentifier :: ModelType
ModelTypeNativeQuery :: ModelType
ModelTypeStoredProcedures :: ModelType
ModelTypeRemoteSchema :: ModelType
ModelTypeAction :: ModelType
data ModelSourceType
ModelSourceTypePostgres :: ModelSourceType
ModelSourceTypeMSSQL :: ModelSourceType
ModelSourceTypeBigQuery :: ModelSourceType
ModelSourceTypeDataConnector :: ModelSourceType
newtype ModelOperationType
ModelOperationType :: OperationType -> ModelOperationType
[unModelOperationType] :: ModelOperationType -> OperationType
data ModelInfoPart
ModelInfoPart :: !Text -> !ModelType -> !Maybe Text -> !Maybe ModelSourceType -> !ModelOperationType -> ModelInfoPart
[mipModelName] :: ModelInfoPart -> !Text
[mipModelType] :: ModelInfoPart -> !ModelType
[mipSourceName] :: ModelInfoPart -> !Maybe Text
[mipSourceType] :: ModelInfoPart -> !Maybe ModelSourceType
[mipQueryType] :: ModelInfoPart -> !ModelOperationType
getModelInfoPartfromModelNames :: [ModelNameInfo] -> ModelOperationType -> [ModelInfoPart]
getMutationInsertArgumentModelNamesPostgres :: forall (f :: Type -> Type) m (pgKind :: PostgresKind). (Traversable f, MonadState [ModelNameInfo] m, Backend ('Postgres pgKind)) => SourceName -> ModelSourceType -> AnnotatedInsertData ('Postgres pgKind) f (UnpreparedValue ('Postgres pgKind)) -> m ()
getMutationInsertArgumentModelNamesMSSQL :: forall (f :: Type -> Type) m. MonadState [ModelNameInfo] m => SourceName -> ModelSourceType -> AnnotatedInsertData 'MSSQL f (UnpreparedValue 'MSSQL) -> m ()
getMutationInsertArgumentModelNamesDC :: forall (f :: Type -> Type) m. MonadState [ModelNameInfo] m => SourceName -> ModelSourceType -> AnnotatedInsertData 'DataConnector f (UnpreparedValue 'DataConnector) -> m ()
irToModelInfoGen :: forall (b :: BackendType) m a. (Backend b, Monad m) => SourceName -> ModelSourceType -> QueryDB b Void a -> m [ModelNameInfo]
getArgumentModelNamesGen :: forall a m (b :: BackendType). (MonadState [ModelNameInfo] m, Backend b) => SourceName -> ModelSourceType -> AnnBoolExp b a -> m ()
getRSModelInfoGen :: forall (b :: BackendType) (a :: BackendType -> Type) m. (Monad m, Backend b) => SourceName -> ModelSourceType -> SourceRelationshipSelection b Void a -> m [ModelNameInfo]
getMutationOutputModelNamesGen :: forall (b :: BackendType) a. Backend b => SourceName -> ModelSourceType -> MutationOutputG b Void a -> [ModelNameInfo]


-- | A collection of types and utilities around the <tt>Node</tt> GraphQL
--   type exposed by the Relay API.
module Hasura.GraphQL.Schema.Node
data NodeId
NodeIdV1 :: V1NodeId -> NodeId
NodeIdV2 :: AnyBackend V2NodeId -> NodeId

-- | V1 format of a node.
--   
--   This id does NOT uniquely identify the table properly, as it only
--   knows the table's name, but doesn't store a source name.
data V1NodeId
V1NodeId :: QualifiedTable -> NESeq Value -> V1NodeId
[_ni1Table] :: V1NodeId -> QualifiedTable
[_ni1Columns] :: V1NodeId -> NESeq Value

-- | V2 format of a node.
--   
--   Uniquely identifies a table with source name and table name, and
--   uniquely identifies a row within that table with a list of primary key
--   values.
data V2NodeId (b :: BackendType)
V2NodeId :: SourceName -> TableName b -> NESeq Value -> V2NodeId (b :: BackendType)
[_ni2Source] :: V2NodeId (b :: BackendType) -> SourceName
[_ni2Table] :: V2NodeId (b :: BackendType) -> TableName b
[_ni2Columns] :: V2NodeId (b :: BackendType) -> NESeq Value

-- | Enum representing the supported versions of the API.
data NodeIdVersion
nodeIdVersionInt :: NodeIdVersion -> Int
currentNodeIdVersion :: NodeIdVersion
type NodeMap = HashMap SourceName AnyBackend TableMap
newtype TableMap (b :: BackendType)
TableMap :: HashMap (TableName b) (NodeInfo b) -> TableMap (b :: BackendType)

-- | All the information required to craft a query to a row pointed to by a
--   <a>NodeId</a>.
data NodeInfo (b :: BackendType)
NodeInfo :: SourceInfo b -> SelPermInfo b -> PrimaryKeyColumns b -> AnnFieldsG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b) -> NodeInfo (b :: BackendType)
[nvSourceInfo] :: NodeInfo (b :: BackendType) -> SourceInfo b
[nvSelectPermissions] :: NodeInfo (b :: BackendType) -> SelPermInfo b
[nvPrimaryKeys] :: NodeInfo (b :: BackendType) -> PrimaryKeyColumns b
[nvAnnotatedFields] :: NodeInfo (b :: BackendType) -> AnnFieldsG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b)

-- | Given a source name and table name, peform the double lookup within a
--   <a>NodeMap</a>.
findNode :: forall (b :: BackendType). Backend b => SourceName -> TableName b -> NodeMap -> Maybe (NodeInfo b)
instance GHC.Classes.Eq Hasura.GraphQL.Schema.Node.NodeIdVersion
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Schema.Node.NodeId
instance GHC.Internal.Show.Show Hasura.GraphQL.Schema.Node.NodeIdVersion

module Hasura.GraphQL.Context

-- | For storing both a normal GQLContext and one for the backend variant.
--   Currently, this is to enable the backend variant to have certain
--   insert<i>update</i>delete permissions which the frontend variant does
--   not.
data RoleContext a
RoleContext :: !a -> !Maybe a -> RoleContext a

-- | The default context for normal sessions
[_rctxDefault] :: RoleContext a -> !a

-- | The context for sessions with backend privilege.
[_rctxBackend] :: RoleContext a -> !Maybe a
data GQLContext
GQLContext :: ParserFn (RootFieldMap (QueryRootField UnpreparedValue)) -> Maybe (ParserFn (RootFieldMap (MutationRootField UnpreparedValue))) -> Maybe (ParserFn (RootFieldMap (QueryRootField UnpreparedValue))) -> GQLContext
[gqlQueryParser] :: GQLContext -> ParserFn (RootFieldMap (QueryRootField UnpreparedValue))
[gqlMutationParser] :: GQLContext -> Maybe (ParserFn (RootFieldMap (MutationRootField UnpreparedValue)))
[gqlSubscriptionParser] :: GQLContext -> Maybe (ParserFn (RootFieldMap (QueryRootField UnpreparedValue)))
type ParserFn a = SelectionSet NoFragments Variable -> Either QErr a
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.GraphQL.Context.RoleContext a)
instance GHC.Internal.Data.Foldable.Foldable Hasura.GraphQL.Context.RoleContext
instance GHC.Internal.Base.Functor Hasura.GraphQL.Context.RoleContext
instance GHC.Internal.Generics.Generic (Hasura.GraphQL.Context.RoleContext a)
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (Hasura.GraphQL.Context.RoleContext a)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Context.GQLContext
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.GraphQL.Context.RoleContext a)
instance GHC.Internal.Data.Traversable.Traversable Hasura.GraphQL.Context.RoleContext


-- | The modules in the <tt>Hasura.Backends.MSSQL.FromIr</tt> namespace
--   translates the RQL IR into TSQL, the SQL dialect of MSSQL, as defined
--   in abstract syntax in <a>Hasura.Backends.MSSQL.Types</a>.
--   
--   The translation happens in the <tt>FromIr</tt> monad, which manages
--   identifier scoping and error collection.
--   
--   The actual rendering of this AST into TSQL text happens in
--   <a>Hasura.Backends.MSSQL.ToQuery</a>.
module Hasura.Backends.MSSQL.FromIr

-- | The central Monad used throughout for all conversion functions.
--   
--   It has the following features:
--   
--   <ul>
--   <li>It's a <a>MonadValidate</a>, so it'll continue going when it
--   encounters <a>Error</a>s to accumulate as many as possible.</li>
--   <li>It has a facility for generating fresh, unique aliases, which lets
--   the translation output retain a resemblance with source names without
--   the translation process needing to be bothered about potential name
--   shadowing. See <a>generateAlias</a>.</li>
--   <li>It has a writer part for reporting native queries that need to be
--   wrapped in a CTE</li>
--   </ul>
--   
--   The Inner part <a>FromIrInner</a> containing the state and validate
--   are extracted to a different type so we can peel the writer for
--   queries and report errors in the process if needed.
data FromIr a

-- | Run a <a>FromIr</a> action, throwing errors that have been collected
--   using the supplied action, and discard CTEs created from native
--   queries to the select query.
--   
--   If CTEs were reported, we throw an error, since we don't support
--   native queries in this context yet.
runFromIrErrorOnCTEs :: MonadError QErr m => FromIr a -> m (QueryWithDDL a)

-- | Run a <a>FromIr</a> action, throwing errors that have been collected
--   using the supplied action, and attach CTEs created from native queries
--   to the select query.
runFromIrUseCTEs :: MonadError QErr m => FromIr Select -> m (QueryWithDDL Select)

-- | Run a <a>FromIr</a> action, throwing errors that have been collected
--   using the supplied action, and attach CTEs created from native queries
--   to the select query.
runFromIrUseCTEsT :: (Traversable t, MonadError QErr m) => t (FromIr Select) -> m (t (QueryWithDDL Select))

-- | Errors that may happen during translation.
data Error
UnsupportedOpExpG :: OpExpG 'MSSQL Expression -> Error
FunctionNotSupported :: Error
NativeQueriesNotSupported :: Error

-- | add a step to be run before the main query
tellBefore :: TempTableDDL -> FromIr ()

-- | add a step to be run after the main query
tellAfter :: TempTableDDL -> FromIr ()
tellCTE :: NativeQueryName -> InterpolatedQuery Expression -> FromIr Text

-- | Hints about the type of entity that <a>generateAlias</a> is producing
--   an alias for.
data NameTemplate
ArrayRelationTemplate :: Text -> NameTemplate
ArrayAggregateTemplate :: Text -> NameTemplate
ObjectRelationTemplate :: Text -> NameTemplate
TableTemplate :: Text -> NameTemplate
ForOrderAlias :: Text -> NameTemplate

-- | Generate a fresh alias for a given entity to remove ambiguity and
--   naming conflicts between scopes at the TSQL level.
--   
--   Names are generated in the form <tt>type_name_occurrence</tt>, where:
--   
--   <ul>
--   <li><tt>type</tt> hints at the type of entity,</li>
--   <li><tt>name</tt> refers to the source name being aliased, and</li>
--   <li><tt>occurrence</tt> is an integer counter that distinguishes each
--   occurrence of <tt>type_name</tt>.</li>
--   </ul>
--   
--   Example outputs:
--   
--   <pre>
--   do
--     "ar_articles_1" &lt;- generateAlias (ArrayRelationTemplate "articles")
--     "ar_articles_2" &lt;- generateAlias (ArrayRelationTemplate "articles")
--     "t_users_1"     &lt;- generateAlias (TableTemplate "users")
--   </pre>
generateAlias :: NameTemplate -> FromIr Text
instance GHC.Internal.Base.Applicative Hasura.Backends.MSSQL.FromIr.FromIr
instance GHC.Classes.Eq Hasura.Backends.MSSQL.FromIr.Error
instance GHC.Internal.Base.Functor Hasura.Backends.MSSQL.FromIr.FromIr
instance GHC.Internal.Base.Monad Hasura.Backends.MSSQL.FromIr.FromIr
instance Control.Monad.State.Class.MonadState Hasura.Backends.MSSQL.FromIr.IRState Hasura.Backends.MSSQL.FromIr.FromIr
instance Control.Monad.Validate.Class.MonadValidate (GHC.Internal.Base.NonEmpty Hasura.Backends.MSSQL.FromIr.Error) Hasura.Backends.MSSQL.FromIr.FromIr
instance Control.Monad.Writer.Class.MonadWriter Hasura.Backends.MSSQL.FromIr.IRWriter Hasura.Backends.MSSQL.FromIr.FromIr
instance GHC.Internal.Base.Monoid Hasura.Backends.MSSQL.FromIr.IRWriter
instance GHC.Internal.Base.Semigroup Hasura.Backends.MSSQL.FromIr.IRWriter
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.FromIr.Error


-- | This module translates the IR of boolean expressions into TSQL boolean
--   expressions.
--   
--   Boolean expressions typically arise from permissions and where-clause
--   filters.
module Hasura.Backends.MSSQL.FromIr.Expression

-- | Translate boolean expressions into TSQL <a>Expression</a>s.
--   
--   The <a>AnnBoolExpFld</a> references fields and columns. The entity
--   (e.g. table) that binds these columns is supplied in the `ReaderT
--   EntityAlias` environment, such that the columns can be referred to
--   unambiguously.
fromGBoolExp :: GBoolExp 'MSSQL (AnnBoolExpFld 'MSSQL Expression) -> ReaderT EntityAlias FromIr Expression


-- | This module defines the translation functions for update mutations.
module Hasura.Backends.MSSQL.FromIr.Update
fromUpdate :: AnnotatedUpdate 'MSSQL -> FromIr Update


-- | This module defines the translation functions for insert and upsert
--   mutations.
module Hasura.Backends.MSSQL.FromIr.Insert
fromInsert :: AnnotatedInsert 'MSSQL Void Expression -> Insert

-- | Construct a MERGE statement from AnnotatedInsert information. A MERGE
--   statement is responsible for actually inserting and/or updating the
--   data in the table.
toMerge :: TableName -> [AnnotatedInsertRow 'MSSQL Expression] -> [ColumnInfo 'MSSQL] -> IfMatched Expression -> FromIr Merge

-- | As part of an INSERT/UPSERT process, insert VALUES into a temporary
--   table. The content of the temporary table will later be inserted into
--   the original table using a MERGE statement.
--   
--   We insert the values into a temporary table first in order to replace
--   the missing fields with <tt>DEFAULT</tt> in
--   <tt>normalizeInsertRows</tt>, and we can't do that in a MERGE
--   statement directly.
toInsertValuesIntoTempTable :: TempTableName -> AnnotatedInsert 'MSSQL Void Expression -> InsertValuesIntoTempTable


-- | This module defines the translation function for delete mutations.
module Hasura.Backends.MSSQL.FromIr.Delete
fromDelete :: AnnDel 'MSSQL -> FromIr Delete


-- | Translate from the DML to the BigQuery dialect.
module Hasura.Backends.BigQuery.FromIr

-- | Here is where we apply a top-level annotation to the select to
--   indicate to the data loader that this select ought to produce a single
--   object or an array.
mkSQLSelect :: JsonAggSelect -> AnnSelectG 'BigQuery (AnnFieldG 'BigQuery Void) Expression -> FromIr Select

-- | Convert from the IR database query into a select.
fromRootField :: QueryDB 'BigQuery Void Expression -> FromIr Select
fromSelectAggregate :: Maybe (EntityAlias, HashMap ColumnName ColumnName) -> AnnSelectG 'BigQuery (TableAggregateFieldG 'BigQuery Void) Expression -> FromIr Select

-- | Most of these errors should be checked for legitimacy.
data Error
FromTypeUnsupported :: SelectFromG 'BigQuery Expression -> Error
NoOrderSpecifiedInOrderBy :: Error
MalformedAgg :: Error
FieldTypeUnsupportedForNow :: AnnFieldG 'BigQuery Void Expression -> Error
AggTypeUnsupportedForNow :: TableAggregateFieldG 'BigQuery Void Expression -> Error
NodesUnsupportedForNow :: TableAggregateFieldG 'BigQuery Void Expression -> Error
NoProjectionFields :: Error
NoAggregatesMustBeABug :: Error
UnsupportedArraySelect :: ArraySelectG 'BigQuery Void Expression -> Error
UnsupportedOpExpG :: OpExpG 'BigQuery Expression -> Error
UnsupportedSQLExp :: Expression -> Error
UnsupportedDistinctOn :: Error
UnexpectedEmptyList :: Error
InvalidIntegerishSql :: Expression -> Error
ConnectionsNotSupported :: Error
ActionsNotSupported :: Error

-- | <a>https://github.com/hasura/graphql-engine/issues/8526</a>
ComputedFieldsBooleanExpressionNotSupported :: Error

-- | <a>https://github.com/hasura/graphql-engine/issues/8526</a>
ComputedFieldsOrderByNotSupported :: Error

-- | <a>https://github.com/hasura/graphql-engine/issues/8521</a>
ScalarComputedFieldsNotSupported :: Error
NoParentEntityInternalError :: Error
runFromIr :: FromIrConfig -> FromIr a -> Validate (NonEmpty Error) (a, FromIrWriter)

-- | The base monad used throughout this module for all conversion
--   functions.
--   
--   It's a Validate, so it'll continue going when it encounters errors to
--   accumulate as many as possible.
--   
--   It also contains a mapping from entity prefixes to counters. So if my
--   prefix is "table" then there'll be a counter that lets me generate
--   table1, table2, etc. Same for any other prefix needed (e.g. names for
--   joins).
--   
--   A ReaderT is used around this in most of the module too, for setting
--   the current entity that a given field name refers to. See
--   <tt>fromColumn</tt>.
data FromIr a

-- | Collected from using a native query in a query. Each entry here
--   because a CTE to be prepended to the query.
newtype FromIrWriter
FromIrWriter :: Map (Aliased NativeQueryName) (InterpolatedQuery Expression) -> FromIrWriter
[fromIrWriterNativeQueries] :: FromIrWriter -> Map (Aliased NativeQueryName) (InterpolatedQuery Expression)

-- | Config values for the from-IR translator.
data FromIrConfig
FromIrConfig :: Top -> FromIrConfig

-- | Applies globally to all selects, and may be reduced to something even
--   smaller by permission/user args.
[globalSelectLimit] :: FromIrConfig -> Top

-- | A default config.
defaultFromIrConfig :: FromIrConfig
bigQuerySourceConfigToFromIrConfig :: BigQuerySourceConfig -> FromIrConfig
data Top
NoTop :: Top
Top :: Int64 -> Top
instance GHC.Internal.Base.Applicative Hasura.Backends.BigQuery.FromIr.FromIr
instance GHC.Classes.Eq Hasura.Backends.BigQuery.FromIr.FieldSource
instance GHC.Internal.Base.Functor Hasura.Backends.BigQuery.FromIr.FromIr
instance GHC.Internal.Base.Monad Hasura.Backends.BigQuery.FromIr.FromIr
instance Control.Monad.Validate.Class.MonadValidate (GHC.Internal.Base.NonEmpty Hasura.Backends.BigQuery.FromIr.Error) Hasura.Backends.BigQuery.FromIr.FromIr
instance Control.Monad.Writer.Class.MonadWriter Hasura.Backends.BigQuery.FromIr.FromIrWriter Hasura.Backends.BigQuery.FromIr.FromIr
instance GHC.Internal.Base.Monoid Hasura.Backends.BigQuery.FromIr.FromIrWriter
instance GHC.Internal.Base.Semigroup Hasura.Backends.BigQuery.FromIr.FromIrWriter
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.FromIr.Args
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.FromIr.Error
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.FromIr.FieldSource
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.FromIr.UnfurledJoin

module Hasura.Metadata.DTO.MetadataV3

-- | Revision 3 of the Metadata export format. Note that values of the
--   types, <tt>PlaceholderArray</tt> and <tt>PlaceholderObject</tt> will
--   eventually be expanded to represent more detail.
data MetadataV3
MetadataV3 :: Sources -> RemoteSchemas -> QueryCollections -> MetadataAllowlist -> Actions -> CustomTypes -> CronTriggers -> Endpoints -> ApiLimit -> MetricsConfig -> InheritedRoles -> SetGraphqlIntrospectionOptions -> Network -> BackendMap BackendConfigWrapper -> OpenTelemetryConfig -> MetadataV3
[metaV3Sources] :: MetadataV3 -> Sources
[metaV3RemoteSchemas] :: MetadataV3 -> RemoteSchemas
[metaV3QueryCollections] :: MetadataV3 -> QueryCollections
[metaV3Allowlist] :: MetadataV3 -> MetadataAllowlist
[metaV3Actions] :: MetadataV3 -> Actions
[metaV3CustomTypes] :: MetadataV3 -> CustomTypes
[metaV3CronTriggers] :: MetadataV3 -> CronTriggers
[metaV3RestEndpoints] :: MetadataV3 -> Endpoints
[metaV3ApiLimits] :: MetadataV3 -> ApiLimit
[metaV3MetricsConfig] :: MetadataV3 -> MetricsConfig
[metaV3InheritedRoles] :: MetadataV3 -> InheritedRoles
[metaV3GraphqlSchemaIntrospection] :: MetadataV3 -> SetGraphqlIntrospectionOptions
[metaV3Network] :: MetadataV3 -> Network
[metaV3BackendConfigs] :: MetadataV3 -> BackendMap BackendConfigWrapper
[metaV3OpenTelemetryConfig] :: MetadataV3 -> OpenTelemetryConfig
instance GHC.Classes.Eq Hasura.Metadata.DTO.MetadataV3.MetadataV3
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Metadata.DTO.MetadataV3.MetadataV3
instance GHC.Internal.Generics.Generic Hasura.Metadata.DTO.MetadataV3.MetadataV3
instance Autodocodec.Class.HasCodec Hasura.Metadata.DTO.MetadataV3.MetadataV3
instance GHC.Internal.Show.Show Hasura.Metadata.DTO.MetadataV3.MetadataV3
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Metadata.DTO.MetadataV3.MetadataV3
instance Data.OpenApi.Internal.Schema.ToSchema Hasura.Metadata.DTO.MetadataV3.MetadataV3

module Hasura.RQL.Types.Metadata

-- | A complete GraphQL Engine metadata representation to be stored,
--   exported/replaced via metadata queries.
data Metadata
Metadata :: Sources -> RemoteSchemas -> QueryCollections -> MetadataAllowlist -> CustomTypes -> Actions -> CronTriggers -> Endpoints -> ApiLimit -> MetricsConfig -> InheritedRoles -> SetGraphqlIntrospectionOptions -> Network -> BackendMap BackendConfigWrapper -> OpenTelemetryConfig -> Metadata
[_metaSources] :: Metadata -> Sources
[_metaRemoteSchemas] :: Metadata -> RemoteSchemas
[_metaQueryCollections] :: Metadata -> QueryCollections
[_metaAllowlist] :: Metadata -> MetadataAllowlist
[_metaCustomTypes] :: Metadata -> CustomTypes
[_metaActions] :: Metadata -> Actions
[_metaCronTriggers] :: Metadata -> CronTriggers
[_metaRestEndpoints] :: Metadata -> Endpoints
[_metaApiLimits] :: Metadata -> ApiLimit
[_metaMetricsConfig] :: Metadata -> MetricsConfig
[_metaInheritedRoles] :: Metadata -> InheritedRoles
[_metaSetGraphqlIntrospectionOptions] :: Metadata -> SetGraphqlIntrospectionOptions
[_metaNetwork] :: Metadata -> Network
[_metaBackendConfigs] :: Metadata -> BackendMap BackendConfigWrapper
[_metaOpenTelemetryConfig] :: Metadata -> OpenTelemetryConfig

-- | A simple monad class which enables fetching and setting
--   @<a>Metadata</a> in the state.
class Monad m => MetadataM (m :: Type -> Type)
getMetadata :: MetadataM m => m Metadata
putMetadata :: MetadataM m => Metadata -> m ()
newtype MetadataModifier
MetadataModifier :: (Metadata -> Metadata) -> MetadataModifier
[runMetadataModifier] :: MetadataModifier -> Metadata -> Metadata
data MetadataNoSources
MetadataNoSources :: Tables ('Postgres 'Vanilla) -> Functions ('Postgres 'Vanilla) -> RemoteSchemas -> QueryCollections -> MetadataAllowlist -> CustomTypes -> Actions -> CronTriggers -> MetadataNoSources
[_mnsTables] :: MetadataNoSources -> Tables ('Postgres 'Vanilla)
[_mnsFunctions] :: MetadataNoSources -> Functions ('Postgres 'Vanilla)
[_mnsRemoteSchemas] :: MetadataNoSources -> RemoteSchemas
[_mnsQueryCollections] :: MetadataNoSources -> QueryCollections
[_mnsAllowlist] :: MetadataNoSources -> MetadataAllowlist
[_mnsCustomTypes] :: MetadataNoSources -> CustomTypes
[_mnsActions] :: MetadataNoSources -> Actions
[_mnsCronTriggers] :: MetadataNoSources -> CronTriggers

-- | Versioning the <tt><a>Metadata</a> JSON structure to track backwards
--   incompatible changes. This value is included in the metadata JSON
--   object at top level <tt>version</tt> key. Always metadata is emitted
--   in the latest version via export metadata API
--   (</tt><tt>runExportMetadata</tt> handler). Adding a new value
--   constructor to @<a>MetadataVersion</a> type bumps the metadata
--   version.
--   
--   NOTE: When metadata version is bumped: 1. The Hasura CLI and Console
--   actively use export metadata API to read metadata. Hence, it is
--   necessary to update CLI and Console to read latest metadata. All
--   changes SHOULD be released hand in hand (preferebly in one pull
--   request) 2. There might be other third party services (developed by
--   Hasura users) which use the export metadata API. Apart from changelog,
--   we need to establish the metadata version update by bumping up the
--   minor version of the GraphQL Engine.
data MetadataVersion
MVVersion1 :: MetadataVersion
MVVersion2 :: MetadataVersion
MVVersion3 :: MetadataVersion

-- | This type serves to allow Metadata arguments to be distinguished
newtype MetadataDefaults
MetadataDefaults :: Metadata -> MetadataDefaults
currentMetadataVersion :: MetadataVersion
dropComputedFieldInMetadata :: forall (b :: BackendType). ComputedFieldName -> TableMetadata b -> TableMetadata b
dropEventTriggerInMetadata :: forall (b :: BackendType). TriggerName -> TableMetadata b -> TableMetadata b
dropFunctionInMetadata :: forall (b :: BackendType). Backend b => SourceName -> FunctionName b -> MetadataModifier
dropPermissionInMetadata :: forall (b :: BackendType). RoleName -> PermType -> TableMetadata b -> TableMetadata b
dropLogicalModelPermissionInMetadata :: forall (b :: BackendType). RoleName -> PermType -> LogicalModelMetadata b -> LogicalModelMetadata b
dropInlineLogicalModelPermissionInMetadata :: forall (b :: BackendType). RoleName -> PermType -> InlineLogicalModelMetadata b -> InlineLogicalModelMetadata b
dropRelationshipInMetadata :: forall (b :: BackendType). RelName -> TableMetadata b -> TableMetadata b
dropNativeQueryRelationshipInMetadata :: forall (b :: BackendType). RelName -> NativeQueryMetadata b -> NativeQueryMetadata b
dropRemoteRelationshipInMetadata :: forall (b :: BackendType). RelName -> TableMetadata b -> TableMetadata b
dropTableInMetadata :: forall (b :: BackendType). Backend b => SourceName -> TableName b -> MetadataModifier
dropRemoteSchemaInMetadata :: RemoteSchemaName -> MetadataModifier
dropRemoteSchemaPermissionInMetadata :: RemoteSchemaName -> RoleName -> MetadataModifier
dropRemoteSchemaRemoteRelationshipInMetadata :: RemoteSchemaName -> Name -> RelName -> MetadataModifier
emptyMetadata :: Metadata
emptyMetadataDefaults :: MetadataDefaults

-- | A lens setter for the metadata of a specific function as identified by
--   the source name and function name.
functionMetadataSetter :: forall (b :: BackendType). Backend b => SourceName -> FunctionName b -> ASetter' Metadata (FunctionMetadata b)

-- | A lens setter for the metadata of a logical model as identified by the
--   source name and root field name.
logicalModelMetadataSetter :: forall (b :: BackendType). Backend b => SourceName -> LogicalModelName -> ASetter' Metadata (LogicalModelMetadata b)

-- | A lens setter for the metadata of a native query as identified by the
--   source name and root field name.
nativeQueryMetadataSetter :: forall (b :: BackendType). Backend b => SourceName -> NativeQueryName -> ASetter' Metadata (NativeQueryMetadata b)

-- | A lens setter for the metadata of a stored procedure as identified by
--   the source name and root field name.
storedProcedureMetadataSetter :: forall (b :: BackendType). Backend b => SourceName -> FunctionName b -> ASetter' Metadata (StoredProcedureMetadata b)
metaActions :: Lens' Metadata Actions
metaAllowlist :: Lens' Metadata MetadataAllowlist
metaApiLimits :: Lens' Metadata ApiLimit
metaBackendConfigs :: Lens' Metadata (BackendMap BackendConfigWrapper)
metaCronTriggers :: Lens' Metadata CronTriggers
metaCustomTypes :: Lens' Metadata CustomTypes
metaInheritedRoles :: Lens' Metadata InheritedRoles
metaMetricsConfig :: Lens' Metadata MetricsConfig
metaNetwork :: Lens' Metadata Network
metaOpenTelemetryConfig :: Lens' Metadata OpenTelemetryConfig
metaQueryCollections :: Lens' Metadata QueryCollections
metaRemoteSchemas :: Lens' Metadata RemoteSchemas
metaRestEndpoints :: Lens' Metadata Endpoints
metaSetGraphqlIntrospectionOptions :: Lens' Metadata SetGraphqlIntrospectionOptions
metaSources :: Lens' Metadata Sources

-- | Convert <a>Metadata</a> to a DTO for serialization. In the near future
--   the plan is to use this function instead of the <a>ToJSON</a> instance
--   of <a>Metadata</a>. For the time being DTO serialization does not
--   match the same order of object keys as the <a>ToJSON</a> instance - we
--   can't switch to using this function until that issue is resolved. See
--   <a>https://hasurahq.atlassian.net/browse/MM-29</a>
metadataToDTO :: Metadata -> MetadataV3

-- | Encode <a>Metadata</a> to JSON with deterministic ordering (e.g.
--   "version" being at the top). The CLI system stores metadata in files
--   and has option to show changes in git diff style. The diff shouldn't
--   appear different for no metadata changes. So, the ordering of object
--   keys and array elements should remain consistent across versions of
--   graphql-engine if possible.
--   
--   Note: While modifying any part of the code below, make sure the
--   encoded JSON of each type is parsable via its <a>FromJSON</a>
--   instance.
--   
--   TODO: we can use 'aeson-pretty' to serialize in a consistent way, and
--   to specify a (partial) order of keys, while getting the benefits of
--   auto-generated To/FromJSON instances. `FromJSON TableMetadata`
--   complicates this though...
--   
--   See: <a>https://github.com/hasura/graphql-engine/issues/6348</a>
metadataToOrdJSON :: Metadata -> Value

-- | This acts like a Semigroup instance for Metadata, favouring the
--   non-default Metadata
overrideMetadataDefaults :: Metadata -> MetadataDefaults -> Metadata
tableMetadataSetter :: forall (b :: BackendType). Backend b => SourceName -> TableName b -> ASetter' Metadata (TableMetadata b)
instance GHC.Classes.Eq Hasura.RQL.Types.Metadata.Metadata
instance GHC.Classes.Eq Hasura.RQL.Types.Metadata.MetadataDefaults
instance GHC.Classes.Eq Hasura.RQL.Types.Metadata.MetadataNoSources
instance GHC.Classes.Eq Hasura.RQL.Types.Metadata.MetadataVersion
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Metadata.Metadata
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Metadata.MetadataDefaults
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Metadata.MetadataNoSources
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Metadata.MetadataVersion
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Metadata.Metadata
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Metadata.MetadataNoSources
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.Metadata.MetadataVersion
instance Hasura.RQL.Types.Metadata.MetadataM m => Hasura.RQL.Types.Metadata.MetadataM (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.RQL.Types.Metadata.MetadataM m => Hasura.RQL.Types.Metadata.MetadataM (Control.Monad.Trans.State.Strict.StateT r m)
instance Hasura.RQL.Types.Metadata.MetadataM m => Hasura.RQL.Types.Metadata.MetadataM (Hasura.Tracing.Monad.TraceT m)
instance GHC.Internal.Base.Monoid Hasura.RQL.Types.Metadata.MetadataModifier
instance Hasura.Incremental.Select.Select Hasura.RQL.Types.Metadata.Metadata
instance GHC.Internal.Base.Semigroup Hasura.RQL.Types.Metadata.MetadataModifier
instance GHC.Internal.Show.Show Hasura.RQL.Types.Metadata.Metadata
instance GHC.Internal.Show.Show Hasura.RQL.Types.Metadata.MetadataDefaults
instance GHC.Internal.Show.Show Hasura.RQL.Types.Metadata.MetadataVersion
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Metadata.Metadata
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Metadata.MetadataDefaults
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Metadata.MetadataNoSources
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Metadata.MetadataVersion


-- | Types and classes related to configuration when the server is
--   initialised
module Hasura.Server.Init.Config

-- | The collected default value, env var, and help message for an option.
--   If there should be no default value then use 'Option ()'.
data Option def
Option :: def -> String -> String -> Option def
[_default] :: Option def -> def
[_envVar] :: Option def -> String
[_helpMessage] :: Option def -> String

-- | Helper function for pretty printing <tt>Option a</tt>.
optionPP :: Option a -> (String, String)

-- | Raw HGE Options from the arg parser and the env.
data HGEOptionsRaw impl
HGEOptionsRaw :: PostgresConnInfo (Maybe PostgresConnInfoRaw) -> Maybe String -> HGECommand impl -> HGEOptionsRaw impl
[_horDatabaseUrl] :: HGEOptionsRaw impl -> PostgresConnInfo (Maybe PostgresConnInfoRaw)
[_horMetadataDbUrl] :: HGEOptionsRaw impl -> Maybe String
[_horCommand] :: HGEOptionsRaw impl -> HGECommand impl
horDatabaseUrl :: forall impl f. Functor f => (PostgresConnInfo (Maybe PostgresConnInfoRaw) -> f (PostgresConnInfo (Maybe PostgresConnInfoRaw))) -> HGEOptionsRaw impl -> f (HGEOptionsRaw impl)
horMetadataDbUrl :: forall impl f. Functor f => (Maybe String -> f (Maybe String)) -> HGEOptionsRaw impl -> f (HGEOptionsRaw impl)
horCommand :: forall impl f. Functor f => (HGECommand impl -> f (HGECommand impl)) -> HGEOptionsRaw impl -> f (HGEOptionsRaw impl)

-- | The final processed HGE options.
data HGEOptions impl
HGEOptions :: PostgresConnInfo (Maybe UrlConf) -> Maybe String -> HGECommand impl -> HGEOptions impl
[_hoDatabaseUrl] :: HGEOptions impl -> PostgresConnInfo (Maybe UrlConf)
[_hoMetadataDbUrl] :: HGEOptions impl -> Maybe String
[_hoCommand] :: HGEOptions impl -> HGECommand impl
hoCommand :: forall impl f. Functor f => (HGECommand impl -> f (HGECommand impl)) -> HGEOptions impl -> f (HGEOptions impl)

-- | Postgres connection info tupled with a retry count.
--   
--   In practice, the <tt>a</tt> here is one of the following: 1. 'Maybe
--   PostgresConnInfoRaw' 2. 'Maybe UrlConf' 3. 'Maybe Text' 4. 'Maybe
--   DatabaseUrl' where <tt>DatabaseUrl</tt> is an alias for <a>Text</a>
--   
--   If it contains a 'Maybe PostgresConnInfoRaw' then you have not yet
--   processed your arg parser results.
data PostgresConnInfo a
PostgresConnInfo :: a -> Maybe Int -> PostgresConnInfo a
[_pciDatabaseConn] :: PostgresConnInfo a -> a
[_pciRetries] :: PostgresConnInfo a -> Maybe Int
pciDatabaseConn :: forall a f. Functor f => (a -> f a) -> PostgresConnInfo a -> f (PostgresConnInfo a)
pciRetries :: forall a f. Functor f => (Maybe Int -> f (Maybe Int)) -> PostgresConnInfo a -> f (PostgresConnInfo a)

-- | Postgres Connection info in the form of a templated URI string or
--   structured data.
data PostgresConnInfoRaw
PGConnDatabaseUrl :: Template -> PostgresConnInfoRaw
PGConnDetails :: PostgresConnDetailsRaw -> PostgresConnInfoRaw
_PGConnDatabaseUrl :: Prism' PostgresConnInfoRaw Template
_PGConnDetails :: Prism' PostgresConnInfoRaw PostgresConnDetailsRaw
mkUrlConnInfo :: String -> PostgresConnInfoRaw

-- | Structured Postgres connection information as provided by the arg
--   parser or env vars.
data PostgresConnDetailsRaw
PostgresConnDetailsRaw :: String -> Int -> String -> String -> String -> Maybe String -> PostgresConnDetailsRaw
[connHost] :: PostgresConnDetailsRaw -> String
[connPort] :: PostgresConnDetailsRaw -> Int
[connUser] :: PostgresConnDetailsRaw -> String
[connPassword] :: PostgresConnDetailsRaw -> String
[connDatabase] :: PostgresConnDetailsRaw -> String
[connOptions] :: PostgresConnDetailsRaw -> Maybe String

-- | The HGE Arg parser Command choices.
--   
--   This is polymorphic so that we can pack either <a>ServeOptionsRaw</a>
--   or <tt>ProServeOptionsRaw</tt> in it.
data HGECommand a
HCServe :: a -> HGECommand a
HCExport :: HGECommand a
HCClean :: HGECommand a
HCVersion :: HGECommand a
HCDowngrade :: !DowngradeOptions -> HGECommand a
_HCServe :: forall a p f. (Choice p, Applicative f) => p a (f a) -> p (HGECommand a) (f (HGECommand a))

-- | The Serve Command options accumulated from the Arg and Env parsers.
--   
--   NOTE: A <a>Nothing</a> value indicates the absence of a particular
--   flag. Hence types such as 'Maybe (HashSet X)' or 'Maybe Bool'.
data ServeOptionsRaw impl
ServeOptionsRaw :: Maybe Port -> Maybe HostPreference -> ConnParamsRaw -> Maybe TxIsolation -> Maybe AdminSecretHash -> AuthHookRaw -> Maybe JWTConfig -> Maybe RoleName -> Maybe CorsConfig -> ConsoleStatus -> Maybe Text -> Maybe Text -> Maybe TelemetryStatus -> WsReadCookieStatus -> StringifyNumbers -> Maybe DangerouslyCollapseBooleans -> Maybe BackwardsCompatibleNullInNonNullableVariables -> Maybe RemoteNullForwardingPolicy -> Maybe (HashSet API) -> Maybe RefetchInterval -> Maybe BatchSize -> Maybe RefetchInterval -> Maybe BatchSize -> AllowListStatus -> Maybe (HashSet (EngineLogType impl)) -> Maybe LogLevel -> DevModeStatus -> Maybe AdminInternalErrorsStatus -> Maybe (Refined Positive Int) -> Maybe (Refined NonNegative Milliseconds) -> Maybe OptionalInterval -> RemoteSchemaPermissions -> CompressionOptions -> Maybe KeepAliveDelay -> Maybe InferFunctionPermissions -> MaintenanceMode () -> Maybe OptionalInterval -> Maybe (HashSet ExperimentalFeature) -> Maybe (Refined NonNegative Int) -> Maybe (Refined NonNegative Seconds) -> Maybe WSConnectionInitTimeout -> MetadataQueryLoggingMode -> HttpLogQueryOnlyOnError -> Maybe NamingCase -> Maybe ExtensionsSchema -> Maybe MetadataDefaults -> Maybe ApolloFederationStatus -> Maybe CloseWebsocketsOnMetadataChangeStatus -> Maybe Int -> Maybe TriggersErrorLogLevelStatus -> Maybe Int -> Maybe PersistedQueriesState -> Maybe Int -> Maybe TraceQueryStatus -> ServeOptionsRaw impl
[rsoPort] :: ServeOptionsRaw impl -> Maybe Port
[rsoHost] :: ServeOptionsRaw impl -> Maybe HostPreference
[rsoConnParams] :: ServeOptionsRaw impl -> ConnParamsRaw
[rsoTxIso] :: ServeOptionsRaw impl -> Maybe TxIsolation
[rsoAdminSecret] :: ServeOptionsRaw impl -> Maybe AdminSecretHash
[rsoAuthHook] :: ServeOptionsRaw impl -> AuthHookRaw
[rsoJwtSecret] :: ServeOptionsRaw impl -> Maybe JWTConfig
[rsoUnAuthRole] :: ServeOptionsRaw impl -> Maybe RoleName
[rsoCorsConfig] :: ServeOptionsRaw impl -> Maybe CorsConfig
[rsoConsoleStatus] :: ServeOptionsRaw impl -> ConsoleStatus
[rsoConsoleAssetsDir] :: ServeOptionsRaw impl -> Maybe Text
[rsoConsoleSentryDsn] :: ServeOptionsRaw impl -> Maybe Text
[rsoEnableTelemetry] :: ServeOptionsRaw impl -> Maybe TelemetryStatus
[rsoWsReadCookie] :: ServeOptionsRaw impl -> WsReadCookieStatus
[rsoStringifyNum] :: ServeOptionsRaw impl -> StringifyNumbers
[rsoDangerousBooleanCollapse] :: ServeOptionsRaw impl -> Maybe DangerouslyCollapseBooleans
[rsoBackwardsCompatibleNullInNonNullableVariables] :: ServeOptionsRaw impl -> Maybe BackwardsCompatibleNullInNonNullableVariables
[rsoRemoteNullForwardingPolicy] :: ServeOptionsRaw impl -> Maybe RemoteNullForwardingPolicy
[rsoEnabledAPIs] :: ServeOptionsRaw impl -> Maybe (HashSet API)
[rsoMxRefetchInt] :: ServeOptionsRaw impl -> Maybe RefetchInterval
[rsoMxBatchSize] :: ServeOptionsRaw impl -> Maybe BatchSize
[rsoStreamingMxRefetchInt] :: ServeOptionsRaw impl -> Maybe RefetchInterval
[rsoStreamingMxBatchSize] :: ServeOptionsRaw impl -> Maybe BatchSize
[rsoEnableAllowList] :: ServeOptionsRaw impl -> AllowListStatus
[rsoEnabledLogTypes] :: ServeOptionsRaw impl -> Maybe (HashSet (EngineLogType impl))
[rsoLogLevel] :: ServeOptionsRaw impl -> Maybe LogLevel
[rsoDevMode] :: ServeOptionsRaw impl -> DevModeStatus
[rsoAdminInternalErrors] :: ServeOptionsRaw impl -> Maybe AdminInternalErrorsStatus
[rsoEventsHttpPoolSize] :: ServeOptionsRaw impl -> Maybe (Refined Positive Int)
[rsoEventsFetchInterval] :: ServeOptionsRaw impl -> Maybe (Refined NonNegative Milliseconds)
[rsoAsyncActionsFetchInterval] :: ServeOptionsRaw impl -> Maybe OptionalInterval
[rsoEnableRemoteSchemaPermissions] :: ServeOptionsRaw impl -> RemoteSchemaPermissions
[rsoWebSocketCompression] :: ServeOptionsRaw impl -> CompressionOptions
[rsoWebSocketKeepAlive] :: ServeOptionsRaw impl -> Maybe KeepAliveDelay
[rsoInferFunctionPermissions] :: ServeOptionsRaw impl -> Maybe InferFunctionPermissions
[rsoEnableMaintenanceMode] :: ServeOptionsRaw impl -> MaintenanceMode ()
[rsoSchemaPollInterval] :: ServeOptionsRaw impl -> Maybe OptionalInterval

-- | See Note '$experimentalFeatures' at bottom of module
[rsoExperimentalFeatures] :: ServeOptionsRaw impl -> Maybe (HashSet ExperimentalFeature)
[rsoEventsFetchBatchSize] :: ServeOptionsRaw impl -> Maybe (Refined NonNegative Int)
[rsoGracefulShutdownTimeout] :: ServeOptionsRaw impl -> Maybe (Refined NonNegative Seconds)
[rsoWebSocketConnectionInitTimeout] :: ServeOptionsRaw impl -> Maybe WSConnectionInitTimeout
[rsoEnableMetadataQueryLoggingEnv] :: ServeOptionsRaw impl -> MetadataQueryLoggingMode
[rsoHttpLogQueryOnlyOnError] :: ServeOptionsRaw impl -> HttpLogQueryOnlyOnError

-- | stores global default naming convention
[rsoDefaultNamingConvention] :: ServeOptionsRaw impl -> Maybe NamingCase
[rsoExtensionsSchema] :: ServeOptionsRaw impl -> Maybe ExtensionsSchema
[rsoMetadataDefaults] :: ServeOptionsRaw impl -> Maybe MetadataDefaults
[rsoApolloFederationStatus] :: ServeOptionsRaw impl -> Maybe ApolloFederationStatus
[rsoCloseWebsocketsOnMetadataChangeStatus] :: ServeOptionsRaw impl -> Maybe CloseWebsocketsOnMetadataChangeStatus
[rsoMaxTotalHeaderLength] :: ServeOptionsRaw impl -> Maybe Int
[rsoTriggersErrorLogLevelStatus] :: ServeOptionsRaw impl -> Maybe TriggersErrorLogLevelStatus
[rsoAsyncActionsFetchBatchSize] :: ServeOptionsRaw impl -> Maybe Int
[rsoPersistedQueries] :: ServeOptionsRaw impl -> Maybe PersistedQueriesState
[rsoPersistedQueriesTtl] :: ServeOptionsRaw impl -> Maybe Int
[rsoTraceQueryStatus] :: ServeOptionsRaw impl -> Maybe TraceQueryStatus

-- | Whether or not to serve Console assets.
data ConsoleStatus
ConsoleEnabled :: ConsoleStatus
ConsoleDisabled :: ConsoleStatus
isConsoleEnabled :: ConsoleStatus -> Bool

-- | Whether or not internal errors will be sent in response to admin.
data AdminInternalErrorsStatus
AdminInternalErrorsEnabled :: AdminInternalErrorsStatus
AdminInternalErrorsDisabled :: AdminInternalErrorsStatus
isAdminInternalErrorsEnabled :: AdminInternalErrorsStatus -> Bool
isWebSocketCompressionEnabled :: CompressionOptions -> Bool

-- | A representation of whether or not to enable the GraphQL Query
--   AllowList.
--   
--   See:
--   <a>https://hasura.io/docs/latest/security/allow-list/#enable-allow-list</a>
data AllowListStatus
AllowListEnabled :: AllowListStatus
AllowListDisabled :: AllowListStatus
isAllowListEnabled :: AllowListStatus -> Bool

-- | A representation of whether or not to enable Hasura Dev Mode.
--   
--   See:
--   <a>https://hasura.io/docs/latest/deployment/graphql-engine-flags/config-examples/#dev-mode</a>
data DevModeStatus
DevModeEnabled :: DevModeStatus
DevModeDisabled :: DevModeStatus
isDevModeEnabled :: DevModeStatus -> Bool

-- | A representation of whether or not to enable telemetry that is
--   isomorphic to <a>Bool</a>.
data TelemetryStatus
TelemetryEnabled :: TelemetryStatus
TelemetryDisabled :: TelemetryStatus
isTelemetryEnabled :: TelemetryStatus -> Bool

-- | A representation of whether or not to read the websocket cookie on
--   initial handshake that is isomorphic to <a>Bool</a>. See
--   <tt>wsReadCookieOption</tt> for more details.
data WsReadCookieStatus
WsReadCookieEnabled :: WsReadCookieStatus
WsReadCookieDisabled :: WsReadCookieStatus
isWsReadCookieEnabled :: WsReadCookieStatus -> Bool

-- | An <a>Int</a> representing a Port number in the range 0 to 65536.
data Port
_getPort :: Port -> Int
mkPort :: Int -> Maybe Port
unsafePort :: Int -> Port
data API
METADATA :: API
GRAPHQL :: API
PGDUMP :: API
DEVELOPER :: API
CONFIG :: API
METRICS :: API
newtype KeepAliveDelay
KeepAliveDelay :: Refined NonNegative Seconds -> KeepAliveDelay
[unKeepAliveDelay] :: KeepAliveDelay -> Refined NonNegative Seconds

-- | Sleep time interval for recurring activities such as
--   (@<tt>asyncActionsProcessor</tt>) Presently
--   <a>msToOptionalInterval</a> interprets `0` as Skip.
data OptionalInterval

-- | No polling
Skip :: OptionalInterval

-- | Interval time
Interval :: Refined NonNegative Milliseconds -> OptionalInterval
data AuthHookRaw
AuthHookRaw :: Maybe Text -> Maybe AuthHookType -> Maybe Bool -> AuthHookRaw
[ahrUrl] :: AuthHookRaw -> Maybe Text
[ahrType] :: AuthHookRaw -> Maybe AuthHookType
[ahrSendRequestBody] :: AuthHookRaw -> Maybe Bool

-- | The Raw configuration data from the Arg and Env parsers needed to
--   construct a <tt>ConnParams</tt>
data ConnParamsRaw
ConnParamsRaw :: Maybe (Refined NonNegative Int) -> Maybe (Refined NonNegative Int) -> Maybe (Refined NonNegative Int) -> Maybe (Refined NonNegative NominalDiffTime) -> Maybe Bool -> Maybe (Refined NonNegative NominalDiffTime) -> ConnParamsRaw
[rcpStripes] :: ConnParamsRaw -> Maybe (Refined NonNegative Int)
[rcpConns] :: ConnParamsRaw -> Maybe (Refined NonNegative Int)
[rcpIdleTime] :: ConnParamsRaw -> Maybe (Refined NonNegative Int)

-- | Time from connection creation after which to destroy a connection and
--   choose a different/new one.
[rcpConnLifetime] :: ConnParamsRaw -> Maybe (Refined NonNegative NominalDiffTime)
[rcpAllowPrepare] :: ConnParamsRaw -> Maybe Bool

-- | See <tt>HASURA_GRAPHQL_PG_POOL_TIMEOUT</tt>
[rcpPoolTimeout] :: ConnParamsRaw -> Maybe (Refined NonNegative NominalDiffTime)

-- | <a>ResponseInternalErrorsConfig</a> represents the encoding of the
--   internal errors in the response to the client.
--   
--   For more details, see this github comment:
--   <a>https://github.com/hasura/graphql-engine/issues/4031#issuecomment-609747705</a>
data ResponseInternalErrorsConfig
InternalErrorsAllRequests :: ResponseInternalErrorsConfig
InternalErrorsAdminOnly :: ResponseInternalErrorsConfig
InternalErrorsDisabled :: ResponseInternalErrorsConfig

-- | The timeout duration in <a>Seconds</a> for a WebSocket connection.
newtype WSConnectionInitTimeout
WSConnectionInitTimeout :: Refined NonNegative Seconds -> WSConnectionInitTimeout
[unWSConnectionInitTimeout] :: WSConnectionInitTimeout -> Refined NonNegative Seconds
msToOptionalInterval :: Refined NonNegative Milliseconds -> OptionalInterval
rawConnDetailsToUrl :: PostgresConnDetailsRaw -> Template
rawConnDetailsToUrlText :: PostgresConnDetailsRaw -> Text
shouldIncludeInternal :: RoleName -> ResponseInternalErrorsConfig -> Bool

-- | The final Serve Command options accummulated from the Arg Parser and
--   the Environment, fully processed and ready to apply when running the
--   server.
data ServeOptions impl
ServeOptions :: Port -> HostPreference -> ConnParams -> TxIsolation -> HashSet AdminSecretHash -> Maybe AuthHook -> [JWTConfig] -> Maybe RoleName -> CorsConfig -> ConsoleStatus -> Maybe Text -> Maybe Text -> TelemetryStatus -> StringifyNumbers -> DangerouslyCollapseBooleans -> BackwardsCompatibleNullInNonNullableVariables -> RemoteNullForwardingPolicy -> HashSet API -> LiveQueriesOptions -> StreamQueriesOptions -> AllowListStatus -> HashSet (EngineLogType impl) -> LogLevel -> Refined Positive Int -> Refined NonNegative Milliseconds -> OptionalInterval -> RemoteSchemaPermissions -> ConnectionOptions -> KeepAliveDelay -> InferFunctionPermissions -> MaintenanceMode () -> OptionalInterval -> HashSet ExperimentalFeature -> Refined NonNegative Int -> DevModeStatus -> AdminInternalErrorsStatus -> Refined NonNegative Seconds -> WSConnectionInitTimeout -> EventingMode -> ReadOnlyMode -> MetadataQueryLoggingMode -> HttpLogQueryOnlyOnError -> NamingCase -> ExtensionsSchema -> MetadataDefaults -> ApolloFederationStatus -> CloseWebsocketsOnMetadataChangeStatus -> Int -> TriggersErrorLogLevelStatus -> Int -> PersistedQueriesState -> Int -> TraceQueryStatus -> ServeOptions impl
[soPort] :: ServeOptions impl -> Port
[soHost] :: ServeOptions impl -> HostPreference
[soConnParams] :: ServeOptions impl -> ConnParams
[soTxIso] :: ServeOptions impl -> TxIsolation
[soAdminSecret] :: ServeOptions impl -> HashSet AdminSecretHash
[soAuthHook] :: ServeOptions impl -> Maybe AuthHook
[soJwtSecret] :: ServeOptions impl -> [JWTConfig]
[soUnAuthRole] :: ServeOptions impl -> Maybe RoleName
[soCorsConfig] :: ServeOptions impl -> CorsConfig
[soConsoleStatus] :: ServeOptions impl -> ConsoleStatus
[soConsoleAssetsDir] :: ServeOptions impl -> Maybe Text
[soConsoleSentryDsn] :: ServeOptions impl -> Maybe Text
[soEnableTelemetry] :: ServeOptions impl -> TelemetryStatus
[soStringifyNum] :: ServeOptions impl -> StringifyNumbers
[soDangerousBooleanCollapse] :: ServeOptions impl -> DangerouslyCollapseBooleans
[soBackwardsCompatibleNullInNonNullableVariables] :: ServeOptions impl -> BackwardsCompatibleNullInNonNullableVariables
[soRemoteNullForwardingPolicy] :: ServeOptions impl -> RemoteNullForwardingPolicy
[soEnabledAPIs] :: ServeOptions impl -> HashSet API
[soLiveQueryOpts] :: ServeOptions impl -> LiveQueriesOptions
[soStreamingQueryOpts] :: ServeOptions impl -> StreamQueriesOptions
[soEnableAllowList] :: ServeOptions impl -> AllowListStatus
[soEnabledLogTypes] :: ServeOptions impl -> HashSet (EngineLogType impl)
[soLogLevel] :: ServeOptions impl -> LogLevel
[soEventsHttpPoolSize] :: ServeOptions impl -> Refined Positive Int
[soEventsFetchInterval] :: ServeOptions impl -> Refined NonNegative Milliseconds
[soAsyncActionsFetchInterval] :: ServeOptions impl -> OptionalInterval
[soEnableRemoteSchemaPermissions] :: ServeOptions impl -> RemoteSchemaPermissions
[soConnectionOptions] :: ServeOptions impl -> ConnectionOptions
[soWebSocketKeepAlive] :: ServeOptions impl -> KeepAliveDelay
[soInferFunctionPermissions] :: ServeOptions impl -> InferFunctionPermissions
[soEnableMaintenanceMode] :: ServeOptions impl -> MaintenanceMode ()
[soSchemaPollInterval] :: ServeOptions impl -> OptionalInterval

-- | See note '$experimentalFeatures'
[soExperimentalFeatures] :: ServeOptions impl -> HashSet ExperimentalFeature
[soEventsFetchBatchSize] :: ServeOptions impl -> Refined NonNegative Int
[soDevMode] :: ServeOptions impl -> DevModeStatus
[soAdminInternalErrors] :: ServeOptions impl -> AdminInternalErrorsStatus
[soGracefulShutdownTimeout] :: ServeOptions impl -> Refined NonNegative Seconds
[soWebSocketConnectionInitTimeout] :: ServeOptions impl -> WSConnectionInitTimeout
[soEventingMode] :: ServeOptions impl -> EventingMode

-- | See note '$readOnlyMode'
[soReadOnlyMode] :: ServeOptions impl -> ReadOnlyMode
[soEnableMetadataQueryLogging] :: ServeOptions impl -> MetadataQueryLoggingMode
[soHttpLogQueryOnlyOnError] :: ServeOptions impl -> HttpLogQueryOnlyOnError
[soDefaultNamingConvention] :: ServeOptions impl -> NamingCase
[soExtensionsSchema] :: ServeOptions impl -> ExtensionsSchema
[soMetadataDefaults] :: ServeOptions impl -> MetadataDefaults
[soApolloFederationStatus] :: ServeOptions impl -> ApolloFederationStatus
[soCloseWebsocketsOnMetadataChangeStatus] :: ServeOptions impl -> CloseWebsocketsOnMetadataChangeStatus
[soMaxTotalHeaderLength] :: ServeOptions impl -> Int
[soTriggersErrorLogLevelStatus] :: ServeOptions impl -> TriggersErrorLogLevelStatus
[soAsyncActionsFetchBatchSize] :: ServeOptions impl -> Int
[soPersistedQueries] :: ServeOptions impl -> PersistedQueriesState
[soPersistedQueriesTtl] :: ServeOptions impl -> Int
[soTraceQueryStatus] :: ServeOptions impl -> TraceQueryStatus

-- | The Downgrade Command options. These are only sourced from the Arg
--   Parser and are used directly in <a>Migrate</a>.
data DowngradeOptions
DowngradeOptions :: Text -> Bool -> DowngradeOptions
[dgoTargetVersion] :: DowngradeOptions -> Text
[dgoDryRun] :: DowngradeOptions -> Bool
instance GHC.Classes.Eq Hasura.Server.Init.Config.API
instance GHC.Classes.Eq Hasura.Server.Init.Config.AdminInternalErrorsStatus
instance GHC.Classes.Eq Hasura.Server.Init.Config.AllowListStatus
instance GHC.Classes.Eq Hasura.Server.Init.Config.ConnParamsRaw
instance GHC.Classes.Eq Hasura.Server.Init.Config.ConsoleStatus
instance GHC.Classes.Eq Hasura.Server.Init.Config.DevModeStatus
instance GHC.Classes.Eq Hasura.Server.Init.Config.DowngradeOptions
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.Server.Init.Config.HGECommand a)
instance GHC.Classes.Eq Hasura.Server.Init.Config.KeepAliveDelay
instance GHC.Classes.Eq Hasura.Server.Init.Config.OptionalInterval
instance GHC.Classes.Eq Hasura.Server.Init.Config.Port
instance GHC.Classes.Eq Hasura.Server.Init.Config.PostgresConnDetailsRaw
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.Server.Init.Config.PostgresConnInfo a)
instance GHC.Classes.Eq Hasura.Server.Init.Config.PostgresConnInfoRaw
instance GHC.Classes.Eq Hasura.Server.Init.Config.ResponseInternalErrorsConfig
instance GHC.Classes.Eq Hasura.Server.Init.Config.TelemetryStatus
instance GHC.Classes.Eq Hasura.Server.Init.Config.WSConnectionInitTimeout
instance GHC.Classes.Eq Hasura.Server.Init.Config.WsReadCookieStatus
instance GHC.Internal.Data.Foldable.Foldable Hasura.Server.Init.Config.PostgresConnInfo
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Init.Config.API
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Init.Config.AdminInternalErrorsStatus
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Init.Config.AllowListStatus
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Init.Config.ConsoleStatus
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Init.Config.DevModeStatus
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Init.Config.KeepAliveDelay
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Init.Config.OptionalInterval
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Init.Config.Port
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Init.Config.PostgresConnDetailsRaw
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Init.Config.TelemetryStatus
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Init.Config.WSConnectionInitTimeout
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Init.Config.WsReadCookieStatus
instance GHC.Internal.Base.Functor Hasura.Server.Init.Config.Option
instance GHC.Internal.Base.Functor Hasura.Server.Init.Config.PostgresConnInfo
instance GHC.Internal.Generics.Generic Hasura.Server.Init.Config.API
instance GHC.Internal.Generics.Generic Hasura.Server.Init.Config.AdminInternalErrorsStatus
instance GHC.Internal.Generics.Generic Hasura.Server.Init.Config.AllowListStatus
instance GHC.Internal.Generics.Generic Hasura.Server.Init.Config.ConsoleStatus
instance GHC.Internal.Generics.Generic Hasura.Server.Init.Config.DevModeStatus
instance GHC.Internal.Generics.Generic Hasura.Server.Init.Config.Port
instance GHC.Internal.Generics.Generic Hasura.Server.Init.Config.TelemetryStatus
instance GHC.Internal.Generics.Generic Hasura.Server.Init.Config.WsReadCookieStatus
instance Data.Hashable.Class.Hashable Hasura.Server.Init.Config.API
instance Data.Hashable.Class.Hashable Hasura.Server.Init.Config.AdminInternalErrorsStatus
instance Data.Hashable.Class.Hashable Hasura.Server.Init.Config.AllowListStatus
instance Data.Hashable.Class.Hashable Hasura.Server.Init.Config.ConsoleStatus
instance Data.Hashable.Class.Hashable Hasura.Server.Init.Config.DevModeStatus
instance Data.Hashable.Class.Hashable Hasura.Server.Init.Config.Port
instance Data.Hashable.Class.Hashable Hasura.Server.Init.Config.TelemetryStatus
instance Data.Hashable.Class.Hashable Hasura.Server.Init.Config.WsReadCookieStatus
instance Control.DeepSeq.NFData Hasura.Server.Init.Config.AdminInternalErrorsStatus
instance Control.DeepSeq.NFData Hasura.Server.Init.Config.AllowListStatus
instance Control.DeepSeq.NFData Hasura.Server.Init.Config.ConsoleStatus
instance Control.DeepSeq.NFData Hasura.Server.Init.Config.DevModeStatus
instance Control.DeepSeq.NFData Hasura.Server.Init.Config.Port
instance Control.DeepSeq.NFData Hasura.Server.Init.Config.TelemetryStatus
instance Control.DeepSeq.NFData Hasura.Server.Init.Config.WsReadCookieStatus
instance GHC.Classes.Ord Hasura.Server.Init.Config.AdminInternalErrorsStatus
instance GHC.Classes.Ord Hasura.Server.Init.Config.AllowListStatus
instance GHC.Classes.Ord Hasura.Server.Init.Config.ConsoleStatus
instance GHC.Classes.Ord Hasura.Server.Init.Config.DevModeStatus
instance GHC.Classes.Ord Hasura.Server.Init.Config.Port
instance GHC.Classes.Ord Hasura.Server.Init.Config.TelemetryStatus
instance GHC.Classes.Ord Hasura.Server.Init.Config.WSConnectionInitTimeout
instance GHC.Internal.Read.Read Hasura.Server.Init.Config.API
instance GHC.Internal.Read.Read Hasura.Server.Init.Config.PostgresConnDetailsRaw
instance GHC.Internal.Show.Show Hasura.Server.Init.Config.API
instance GHC.Internal.Show.Show Hasura.Server.Init.Config.AdminInternalErrorsStatus
instance GHC.Internal.Show.Show Hasura.Server.Init.Config.AllowListStatus
instance GHC.Internal.Show.Show Hasura.Server.Init.Config.ConnParamsRaw
instance GHC.Internal.Show.Show Hasura.Server.Init.Config.ConsoleStatus
instance GHC.Internal.Show.Show Hasura.Server.Init.Config.DevModeStatus
instance GHC.Internal.Show.Show Hasura.Server.Init.Config.DowngradeOptions
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (Hasura.Server.Init.Config.HGECommand a)
instance GHC.Internal.Show.Show Hasura.Server.Init.Config.KeepAliveDelay
instance GHC.Internal.Show.Show Hasura.Server.Init.Config.OptionalInterval
instance GHC.Internal.Show.Show Hasura.Server.Init.Config.Port
instance GHC.Internal.Show.Show Hasura.Server.Init.Config.PostgresConnDetailsRaw
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (Hasura.Server.Init.Config.PostgresConnInfo a)
instance GHC.Internal.Show.Show Hasura.Server.Init.Config.PostgresConnInfoRaw
instance GHC.Internal.Show.Show Hasura.Server.Init.Config.ResponseInternalErrorsConfig
instance GHC.Internal.Show.Show Hasura.Server.Init.Config.TelemetryStatus
instance GHC.Internal.Show.Show Hasura.Server.Init.Config.WSConnectionInitTimeout
instance GHC.Internal.Show.Show Hasura.Server.Init.Config.WsReadCookieStatus
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Init.Config.API
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Init.Config.AdminInternalErrorsStatus
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Init.Config.AllowListStatus
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Init.Config.ConsoleStatus
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Init.Config.DevModeStatus
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Init.Config.KeepAliveDelay
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Init.Config.OptionalInterval
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Init.Config.Port
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Init.Config.PostgresConnDetailsRaw
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Init.Config.TelemetryStatus
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Init.Config.WSConnectionInitTimeout
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Init.Config.WsReadCookieStatus
instance GHC.Internal.Data.Traversable.Traversable Hasura.Server.Init.Config.PostgresConnInfo


-- | Helpful functions and types for generating log statements and URIs
--   during Options fetching and merging.
module Hasura.Server.Init.Logging
censorQuery :: Text -> Query -> Query
updateQuery :: (Query -> Query) -> URI -> URI
censorURI :: Text -> URI -> URI
mkGenericLog :: ToJSON a => LogLevel -> Text -> a -> StartupLog

-- | Generate a <tt>StartupLog</tt> from the Postgres <tt>ConnInfo</tt>.
connInfoToLog :: ConnInfo -> StartupLog

-- | Generate a <tt>StartupLog</tt> from the final <tt>ServeOptions</tt>.
serveOptsToLog :: ToJSON (EngineLogType impl) => ServeOptions impl -> StartupLog
data StartupTimeInfo
StartupTimeInfo :: !Text -> !Double -> StartupTimeInfo
[_stiMessage] :: StartupTimeInfo -> !Text
[_stiTimeTaken] :: StartupTimeInfo -> !Double
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Init.Logging.StartupTimeInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Init.Logging.StartupTimeInfo

module Hasura.Server.Init.Env

-- | The monadic context for querying Env Vars.
newtype WithEnvT (m :: Type -> Type) a
WithEnvT :: ReaderT [(String, String)] (ExceptT String m) a -> WithEnvT (m :: Type -> Type) a
[unWithEnvT] :: WithEnvT (m :: Type -> Type) a -> ReaderT [(String, String)] (ExceptT String m) a
type WithEnv = WithEnvT Identity

-- | Given an environment run a <a>WithEnvT</a> action producing either a
--   parse error or an <tt>a</tt>.
runWithEnvT :: [(String, String)] -> WithEnvT m a -> m (Either String a)

-- | Given an environment run a <a>WithEnv</a> action producing either a
--   parse error or an <tt>a</tt>.
runWithEnv :: [(String, String)] -> WithEnv a -> Either String a

-- | Given the parse result for an option and the <tt>Option</tt> record
--   for that option, query the environment, and then merge the results
--   from the parser and environment.
withOption :: forall (m :: Type -> Type) option. (Monad m, FromEnv option) => Maybe option -> Option () -> WithEnvT m (Maybe option)

-- | Given the parse result for an option and the <tt>Option</tt> record
--   for that option, query the environment, and then merge the results
--   from the parser, environment, and the default.
withOptionDefault :: forall (m :: Type -> Type) option. (Monad m, FromEnv option) => Maybe option -> Option option -> WithEnvT m option

-- | Lookup a list of keys with <a>withOption</a> and return the first
--   value to parse successfully.
withOptions :: forall (m :: Type -> Type) option. (Monad m, FromEnv option) => Maybe option -> [Option ()] -> WithEnvT m (Maybe option)

-- | Switches in 'optparse-applicative' have different semantics then
--   ordinary flags. They are always optional and produce a <a>False</a>
--   when absent rather then a <a>Nothing</a>.
--   
--   In HGE we give Env Vars a higher precedence then an absent Switch but
--   the ordinary <tt>withEnv</tt> operation expects a <a>Nothing</a> for
--   an absent arg parser result.
--   
--   This function executes with 'withOption Nothing' when the Switch is
--   absent, otherwise it returns <a>True</a>.
--   
--   NOTE: An alternative solution might be to make Switches return 'Maybe
--   _', where '_' is an option specific sum type. This would allow us to
--   use <a>withOptionDefault</a> directly. Additionally, all fields of
--   <tt>ServeOptionsRaw</tt> would become <a>Maybe</a> or <tt>First</tt>
--   values which would allow us to write a 'Monoid ServeOptionsRaw'
--   instance for combing different option sources.
--   
--   A <a>Monoid</a> instance would be super valuable to cleanup arg/env
--   parsing but this solution feels somewhat unsatisfying.
withOptionSwitch :: forall (m :: Type -> Type). Monad m => Bool -> Option Bool -> WithEnvT m Bool

-- | Given an 'Iso a Bool' we can apply the same boolean env merging
--   semantics as we do for <a>Bool</a> in <tt>withOptionsSwitch</tt> to
--   <tt>a</tt>.
withOptionSwitch' :: forall (m :: Type -> Type) a. Monad m => a -> (a -> Bool, Bool -> a) -> Option a -> WithEnvT m a

-- | Lookup a key in the application environment then parse the value with
--   a <a>FromEnv</a> instance'
considerEnv :: forall (m :: Type -> Type) a. (Monad m, FromEnv a) => String -> WithEnvT m (Maybe a)

-- | Lookup a list of keys with <a>considerEnv</a> and return the first
--   value to parse successfully.
considerEnvs :: forall (m :: Type -> Type) a. (Monad m, FromEnv a) => [String] -> WithEnvT m (Maybe a)

-- | A <a>Read</a> style parser used for consuming Env Vars and building
--   <tt>ReadM</tt> parsers for 'optparse-applicative'.
class FromEnv a
fromEnv :: FromEnv a => String -> Either String a
instance GHC.Internal.Base.Monad m => GHC.Internal.Base.Applicative (Hasura.Server.Init.Env.WithEnvT m)
instance Hasura.Server.Init.Env.FromEnv Hasura.Server.Init.Config.AdminInternalErrorsStatus
instance Hasura.Server.Init.Env.FromEnv Hasura.Server.Auth.AdminSecretHash
instance Hasura.Server.Init.Env.FromEnv Hasura.Server.Types.ApolloFederationStatus
instance Hasura.Server.Init.Env.FromEnv Hasura.Server.Auth.WebHook.AuthHookType
instance Hasura.Server.Init.Env.FromEnv Hasura.RQL.Types.Schema.Options.BackwardsCompatibleNullInNonNullableVariables
instance Hasura.Server.Init.Env.FromEnv Hasura.GraphQL.Execute.Subscription.Options.BatchSize
instance Hasura.Server.Init.Env.FromEnv GHC.Types.Bool
instance Hasura.Server.Init.Env.FromEnv Hasura.Cache.Bounded.CacheSize
instance Hasura.Server.Init.Env.FromEnv Hasura.Server.Types.CloseWebsocketsOnMetadataChangeStatus
instance Hasura.Server.Init.Env.FromEnv Hasura.Server.Cors.CorsConfig
instance Hasura.Server.Init.Env.FromEnv Hasura.RQL.Types.Schema.Options.DangerouslyCollapseBooleans
instance Hasura.Server.Init.Env.FromEnv Data.Time.Clock.Internal.DiffTime.DiffTime
instance Hasura.Server.Init.Env.FromEnv Hasura.SQL.Types.ExtensionsSchema
instance Hasura.Server.Init.Env.FromEnv Hasura.Server.Types.GranularPrometheusMetricsState
instance Hasura.Server.Init.Env.FromEnv (Data.HashSet.Internal.HashSet Hasura.Server.Init.Config.API)
instance Hasura.Server.Init.Env.FromEnv (Data.HashSet.Internal.HashSet Hasura.Server.Types.ExperimentalFeature)
instance Hasura.Logging.EnabledLogTypes impl => Hasura.Server.Init.Env.FromEnv (Data.HashSet.Internal.HashSet (Hasura.Logging.EngineLogType impl))
instance Hasura.Server.Init.Env.FromEnv Data.Streaming.Network.Internal.HostPreference
instance Hasura.Server.Init.Env.FromEnv Hasura.Server.Logging.HttpLogQueryOnlyOnError
instance Hasura.Server.Init.Env.FromEnv Hasura.RQL.Types.Schema.Options.InferFunctionPermissions
instance Hasura.Server.Init.Env.FromEnv GHC.Types.Int
instance Hasura.Server.Init.Env.FromEnv GHC.Num.Integer.Integer
instance Hasura.Server.Init.Env.FromEnv Hasura.Server.Auth.JWT.JWTConfig
instance Hasura.Server.Init.Env.FromEnv Hasura.Server.Init.Config.KeepAliveDelay
instance Hasura.Server.Init.Env.FromEnv GHC.Internal.Base.String
instance Hasura.Server.Init.Env.FromEnv [Hasura.Server.Auth.JWT.JWTConfig]
instance Hasura.Server.Init.Env.FromEnv Hasura.Logging.LogLevel
instance Hasura.Server.Init.Env.FromEnv (Hasura.Server.Types.MaintenanceMode ())
instance Hasura.Server.Init.Env.FromEnv a => Hasura.Server.Init.Env.FromEnv (GHC.Internal.Maybe.Maybe a)
instance Hasura.Server.Init.Env.FromEnv Hasura.RQL.Types.Metadata.Metadata
instance Hasura.Server.Init.Env.FromEnv Hasura.RQL.Types.Metadata.MetadataDefaults
instance Hasura.Server.Init.Env.FromEnv Hasura.Server.Logging.MetadataQueryLoggingMode
instance Hasura.Server.Init.Env.FromEnv Data.Time.Clock.Units.Milliseconds
instance Hasura.Server.Init.Env.FromEnv Hasura.RQL.Types.NamingCase.NamingCase
instance Hasura.Server.Init.Env.FromEnv Data.Time.Clock.Internal.NominalDiffTime.NominalDiffTime
instance Hasura.Server.Init.Env.FromEnv Hasura.Server.Init.Config.OptionalInterval
instance Hasura.Server.Init.Env.FromEnv Hasura.Server.Types.PersistedQueriesState
instance Hasura.Server.Init.Env.FromEnv Hasura.Server.Init.Config.Port
instance Hasura.Server.Init.Env.FromEnv Hasura.GraphQL.Execute.Subscription.Options.RefetchInterval
instance (GHC.Internal.Num.Num a, GHC.Classes.Ord a, Hasura.Server.Init.Env.FromEnv a) => Hasura.Server.Init.Env.FromEnv (Refined.Unsafe.Type.Refined Refined.NonNegative a)
instance Hasura.Server.Init.Env.FromEnv (Refined.Unsafe.Type.Refined Refined.Positive GHC.Types.Int)
instance Hasura.Server.Init.Env.FromEnv Hasura.RQL.Types.Schema.Options.RemoteNullForwardingPolicy
instance Hasura.Server.Init.Env.FromEnv Hasura.RQL.Types.Schema.Options.RemoteSchemaPermissions
instance Hasura.Server.Init.Env.FromEnv Hasura.Authentication.Role.RoleName
instance Hasura.Server.Init.Env.FromEnv Data.Time.Clock.Units.Seconds
instance Hasura.Server.Init.Env.FromEnv Hasura.RQL.Types.Schema.Options.StringifyNumbers
instance Hasura.Server.Init.Env.FromEnv Hasura.Server.Init.Config.TelemetryStatus
instance Hasura.Server.Init.Env.FromEnv Data.URL.Template.Template
instance Hasura.Server.Init.Env.FromEnv Data.Text.Internal.Text
instance Hasura.Server.Init.Env.FromEnv Hasura.Server.Types.TraceQueryStatus
instance Hasura.Server.Init.Env.FromEnv Hasura.Server.Types.TriggersErrorLogLevelStatus
instance Hasura.Server.Init.Env.FromEnv Database.PG.Query.Transaction.TxIsolation
instance Hasura.Server.Init.Env.FromEnv Data.Aeson.Types.Internal.Value
instance Hasura.Server.Init.Env.FromEnv Hasura.Server.Init.Config.WSConnectionInitTimeout
instance Hasura.Server.Init.Env.FromEnv Hasura.Server.Init.Config.WsReadCookieStatus
instance GHC.Internal.Base.Functor m => GHC.Internal.Base.Functor (Hasura.Server.Init.Env.WithEnvT m)
instance Control.Monad.Morph.MFunctor Hasura.Server.Init.Env.WithEnvT
instance GHC.Internal.Base.Monad m => Control.Monad.Error.Class.MonadError GHC.Internal.Base.String (Hasura.Server.Init.Env.WithEnvT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Hasura.Server.Init.Env.WithEnvT m)
instance GHC.Internal.Base.Monad m => Control.Monad.Reader.Class.MonadReader [(GHC.Internal.Base.String, GHC.Internal.Base.String)] (Hasura.Server.Init.Env.WithEnvT m)
instance Control.Monad.Trans.Class.MonadTrans Hasura.Server.Init.Env.WithEnvT
instance GHC.Internal.Base.Monad m => GHC.Internal.Base.Monad (Hasura.Server.Init.Env.WithEnvT m)


-- | The Downgrade Command Parser
module Hasura.Server.Init.Arg.Command.Downgrade
downgradeCommandParser :: Parser DowngradeOptions


-- | API related to server configuration
module Hasura.Server.API.Config
data ServerConfig
ServerConfig :: !Version -> !InferFunctionPermissions -> !RemoteSchemaPermissions -> !Bool -> !Bool -> !Bool -> ![JWTInfo] -> !AllowListStatus -> !LiveQueriesOptions -> !SubscriptionsOptions -> !Maybe Text -> !HashSet ExperimentalFeature -> !Bool -> !NamingCase -> !HashSet FeatureFlagInfo -> !ApolloFederationStatus -> ServerConfig
[scfgVersion] :: ServerConfig -> !Version
[scfgIsFunctionPermissionsInferred] :: ServerConfig -> !InferFunctionPermissions
[scfgIsRemoteSchemaPermissionsEnabled] :: ServerConfig -> !RemoteSchemaPermissions
[scfgIsAdminSecretSet] :: ServerConfig -> !Bool
[scfgIsAuthHookSet] :: ServerConfig -> !Bool
[scfgIsJwtSet] :: ServerConfig -> !Bool
[scfgJwt] :: ServerConfig -> ![JWTInfo]
[scfgIsAllowListEnabled] :: ServerConfig -> !AllowListStatus
[scfgLiveQueries] :: ServerConfig -> !LiveQueriesOptions
[scfgStreamingQueries] :: ServerConfig -> !SubscriptionsOptions
[scfgConsoleAssetsDir] :: ServerConfig -> !Maybe Text
[scfgExperimentalFeatures] :: ServerConfig -> !HashSet ExperimentalFeature
[scfgIsPrometheusMetricsEnabled] :: ServerConfig -> !Bool
[scfgDefaultNamingConvention] :: ServerConfig -> !NamingCase
[scfgFeatureFlags] :: ServerConfig -> !HashSet FeatureFlagInfo
[scfgIsApolloFederationEnabled] :: ServerConfig -> !ApolloFederationStatus
runGetConfig :: InferFunctionPermissions -> RemoteSchemaPermissions -> AuthMode -> AllowListStatus -> LiveQueriesOptions -> SubscriptionsOptions -> Maybe Text -> HashSet ExperimentalFeature -> HashSet API -> NamingCase -> [(FeatureFlag, Text, Bool)] -> ApolloFederationStatus -> ServerConfig
instance GHC.Classes.Eq Hasura.Server.API.Config.FeatureFlagInfo
instance GHC.Classes.Eq Hasura.Server.API.Config.JWTInfo
instance GHC.Classes.Eq Hasura.Server.API.Config.ServerConfig
instance GHC.Internal.Generics.Generic Hasura.Server.API.Config.FeatureFlagInfo
instance GHC.Internal.Generics.Generic Hasura.Server.API.Config.JWTInfo
instance GHC.Internal.Generics.Generic Hasura.Server.API.Config.ServerConfig
instance Data.Hashable.Class.Hashable Hasura.Server.API.Config.FeatureFlagInfo
instance GHC.Internal.Show.Show Hasura.Server.API.Config.FeatureFlagInfo
instance GHC.Internal.Show.Show Hasura.Server.API.Config.JWTInfo
instance GHC.Internal.Show.Show Hasura.Server.API.Config.ServerConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.API.Config.FeatureFlagInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.API.Config.JWTInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.API.Config.ServerConfig


-- | The Arg Opt.Parser for the <tt>serve</tt> subcommand.
module Hasura.Server.Init.Arg.Command.Serve
serveCommandParser :: EnabledLogTypes impl => Parser (ServeOptionsRaw impl)
servePortOption :: Option Port
serveHostOption :: Option HostPreference
pgStripesOption :: Option (Refined NonNegative Int)
pgConnsOption :: Option (Refined NonNegative Int)
pgTimeoutOption :: Option (Refined NonNegative Int)
pgConnLifetimeOption :: Option (Refined NonNegative NominalDiffTime)
pgUsePreparedStatementsOption :: Option Bool
pgPoolTimeoutOption :: Option ()
txIsolationOption :: Option TxIsolation
adminSecretOption :: Option ()
accessKeyOption :: Option ()
authHookOption :: Option ()
authHookModeOption :: Option AuthHookType
authHookSendRequestBodyOption :: Option Bool
jwtSecretOption :: Option ()
unAuthRoleOption :: Option ()
corsDomainOption :: Option CorsConfig
disableCorsOption :: Option Bool
enableConsoleOption :: Option ConsoleStatus
consoleAssetsDirOption :: Option ()
consoleSentryDsnOption :: Option ()
enableTelemetryOption :: Option TelemetryStatus
wsReadCookieOption :: Option WsReadCookieStatus
stringifyNumOption :: Option StringifyNumbers
dangerousBooleanCollapseOption :: Option DangerouslyCollapseBooleans
backwardsCompatibleNullInNonNullableVariablesOption :: Option BackwardsCompatibleNullInNonNullableVariables
remoteNullForwardingPolicyOption :: Option RemoteNullForwardingPolicy
enabledAPIsOption :: Option (HashSet API)
mxRefetchDelayOption :: Option RefetchInterval
mxBatchSizeOption :: Option BatchSize
streamingMxRefetchDelayOption :: Option RefetchInterval
streamingMxBatchSizeOption :: Option BatchSize
enableAllowlistOption :: Option AllowListStatus
enabledLogsOption :: EnabledLogTypes impl => Option (HashSet (EngineLogType impl))
logLevelOption :: Option LogLevel
graphqlDevModeOption :: Option DevModeStatus
graphqlAdminInternalErrorsOption :: Option AdminInternalErrorsStatus
graphqlEventsHttpPoolSizeOption :: Option (Refined Positive Int)
graphqlEventsFetchIntervalOption :: Option (Refined NonNegative Milliseconds)
asyncActionsFetchIntervalOption :: Option OptionalInterval
enableRemoteSchemaPermsOption :: Option RemoteSchemaPermissions
webSocketCompressionOption :: Option CompressionOptions
webSocketKeepAliveOption :: Option KeepAliveDelay
inferFunctionPermsOption :: Option InferFunctionPermissions
enableMaintenanceModeOption :: Option (MaintenanceMode ())
schemaPollIntervalOption :: Option OptionalInterval
experimentalFeaturesOption :: Option (HashSet ExperimentalFeature)
eventsFetchBatchSizeOption :: Option (Refined NonNegative Int)
gracefulShutdownOption :: Option (Refined NonNegative Seconds)
webSocketConnectionInitTimeoutOption :: Option WSConnectionInitTimeout
enableMetadataQueryLoggingOption :: Option MetadataQueryLoggingMode
httpLogQueryOnlyOnErrorOption :: Option HttpLogQueryOnlyOnError
defaultNamingConventionOption :: Option NamingCase
metadataDBExtensionsSchemaOption :: Option ExtensionsSchema
parseMetadataDefaults :: Parser (Maybe MetadataDefaults)
metadataDefaultsOption :: Option MetadataDefaults
apolloFederationStatusOption :: Option (Maybe ApolloFederationStatus)
triggersErrorLogLevelStatusOption :: Option TriggersErrorLogLevelStatus
closeWebsocketsOnMetadataChangeOption :: Option CloseWebsocketsOnMetadataChangeStatus
maxTotalHeaderLengthOption :: Option Int
asyncActionsFetchBatchSizeOption :: Option Int
persistedQueriesOption :: Option PersistedQueriesState
persistedQueriesTtlOption :: Option Int
traceQueryStatusOption :: Option TraceQueryStatus
serveCmdFooter :: Doc

module Hasura.Server.Init.Arg

-- | The Main Arg <a>Parser</a>. It constructs a <a>HGEOptionsRaw</a> term:
--   
--   <ol>
--   <li>'(Config.PostgresConnInfo (Maybe PostgresConnInfoRaw))' - The DB
--   connection. 2: 'Maybe String' - Representing the metadata connection.
--   3: <a>HGECommand</a> <tt>a</tt> - The result of the supplied
--   Subcommand.</li>
--   </ol>
parseHgeOpts :: EnabledLogTypes impl => Parser (HGEOptionsRaw (ServeOptionsRaw impl))
parsePostgresConnInfo :: Parser (PostgresConnInfo (Maybe PostgresConnInfoRaw))
parseMetadataDbUrl :: Parser (Maybe String)
mainCmdFooter :: Doc
metadataDbUrlOption :: Option ()
retriesNumOption :: Option ()
databaseUrlOption :: Option ()

module Hasura.RQL.Types.SchemaCacheTypes

-- | The monad for doing schema dependency discovery for boolean
--   expressions. maintains the table context of the expressions being
--   translated.
newtype BoolExpM (b :: BackendType) a
BoolExpM :: Reader (BoolExpCtx b) a -> BoolExpM (b :: BackendType) a
[unBoolExpM] :: BoolExpM (b :: BackendType) a -> Reader (BoolExpCtx b) a

-- | Type class to collect schema dependencies from backend-specific
--   aggregation predicates.
class Backend b => GetAggregationPredicatesDeps (b :: BackendType)
getAggregationPredicateDeps :: GetAggregationPredicatesDeps b => AggregationPredicates b (PartialSQLExp b) -> BoolExpM b [SchemaDependency]
($dmgetAggregationPredicateDeps) :: (GetAggregationPredicatesDeps b, AggregationPredicates b ~ (Const Void :: Type -> Type)) => AggregationPredicates b (PartialSQLExp b) -> BoolExpM b [SchemaDependency]

-- | The table type context of schema dependency discovery. Boolean
--   expressions may refer to a so-called 'root table' (identified by a
--   <a>$</a>-sign in the expression input syntax) or the <tt>current</tt>
--   table.
data BoolExpCtx (b :: BackendType)
BoolExpCtx :: SourceName -> TableName b -> TableName b -> BoolExpCtx (b :: BackendType)
[source] :: BoolExpCtx (b :: BackendType) -> SourceName

-- | Reference to the <tt>current</tt> table type.
[currTable] :: BoolExpCtx (b :: BackendType) -> TableName b

-- | Reference to the <tt>root</tt> table type.
[rootTable] :: BoolExpCtx (b :: BackendType) -> TableName b
data DependencyReason
DRTable :: DependencyReason
DRColumn :: DependencyReason
DRRemoteTable :: DependencyReason
DRLeftColumn :: DependencyReason
DRRightColumn :: DependencyReason
DRUsingColumn :: DependencyReason
DRFkey :: DependencyReason
DRRemoteFkey :: DependencyReason
DRUntyped :: DependencyReason
DROnType :: DependencyReason
DRSessionVariable :: DependencyReason
DRPayload :: DependencyReason
DRParent :: DependencyReason
DRRemoteSchema :: DependencyReason
DRRemoteRelationship :: DependencyReason
DRParentRole :: DependencyReason
DRLogicalModel :: DependencyReason
DRReferencedLogicalModel :: DependencyReason
data SchemaDependency
SchemaDependency :: SchemaObjId -> DependencyReason -> SchemaDependency
[sdObjId] :: SchemaDependency -> SchemaObjId
[sdReason] :: SchemaDependency -> DependencyReason
data SchemaObjId
SOSource :: SourceName -> SchemaObjId
SOSourceObj :: SourceName -> AnyBackend SourceObjId -> SchemaObjId
SORemoteSchema :: RemoteSchemaName -> SchemaObjId
SORemoteSchemaPermission :: RemoteSchemaName -> RoleName -> SchemaObjId

-- | A remote relationship on a remote schema type, identified by 1. remote
--   schema name 2. remote schema type on which the relationship is defined
--   3. name of the relationship
SORemoteSchemaRemoteRelationship :: RemoteSchemaName -> Name -> RelName -> SchemaObjId
SORole :: RoleName -> SchemaObjId
data SourceObjId (b :: BackendType)
SOITable :: TableName b -> SourceObjId (b :: BackendType)
SOITableObj :: TableName b -> TableObjId b -> SourceObjId (b :: BackendType)
SOIFunction :: FunctionName b -> SourceObjId (b :: BackendType)
SOINativeQuery :: NativeQueryName -> SourceObjId (b :: BackendType)
SOINativeQueryObj :: NativeQueryName -> NativeQueryObjId b -> SourceObjId (b :: BackendType)
SOIStoredProcedure :: FunctionName b -> SourceObjId (b :: BackendType)
SOIStoredProcedureObj :: FunctionName b -> StoredProcedureObjId b -> SourceObjId (b :: BackendType)
SOILogicalModel :: LogicalModelName -> SourceObjId (b :: BackendType)
SOILogicalModelObj :: LogicalModelLocation -> LogicalModelObjId b -> SourceObjId (b :: BackendType)
data TableObjId (b :: BackendType)
TOCol :: Column b -> TableObjId (b :: BackendType)
TORel :: RelName -> TableObjId (b :: BackendType)
TOComputedField :: ComputedFieldName -> TableObjId (b :: BackendType)
TORemoteRel :: RelName -> TableObjId (b :: BackendType)
TOForeignKey :: ConstraintName b -> TableObjId (b :: BackendType)
TOPerm :: RoleName -> PermType -> TableObjId (b :: BackendType)
TOTrigger :: TriggerName -> TableObjId (b :: BackendType)

-- | Identifiers for components of logical models within the metadata.
--   These are used to track dependencies within the resolved schema (see
--   <tt>SourceInfo</tt>).
data LogicalModelObjId (b :: BackendType)
LMOPerm :: RoleName -> PermType -> LogicalModelObjId (b :: BackendType)
LMOCol :: Column b -> LogicalModelObjId (b :: BackendType)
LMOReferencedLogicalModel :: LogicalModelName -> LogicalModelObjId (b :: BackendType)

-- | Identifier for component of Native Queries within the metadata. These
--   are used to track dependencies between items in the resolved schema.
--   For instance, we use <a>NQOCol</a> along with <a>TOCol</a> from
--   <a>TableObjId</a> to ensure that the two columns that join an array
--   relationship actually exist.
data NativeQueryObjId (b :: BackendType)
NQOCol :: Column b -> NativeQueryObjId (b :: BackendType)

-- | Identifier for component of Stored Procedures within the metadata.
--   These are used to track dependencies between items in the resolved
--   schema. For instance, we use <a>SPOCol</a> along with <a>TOCol</a>
--   from <a>TableObjId</a> to ensure that the two columns that join an
--   array relationship actually exist.
newtype StoredProcedureObjId (b :: BackendType)
SPOCol :: Column b -> StoredProcedureObjId (b :: BackendType)
purgeDependentObject :: forall (b :: BackendType) m. (MonadError QErr m, Backend b) => SourceName -> SourceObjId b -> m MetadataModifier
purgeSourceAndSchemaDependencies :: forall (m :: Type -> Type). MonadError QErr m => SchemaObjId -> WriterT MetadataModifier m ()
reasonToTxt :: DependencyReason -> Text
reportDependentObjectsExist :: MonadError QErr m => [SchemaObjId] -> m ()
reportSchemaObj :: SchemaObjId -> Text
reportSchemaObjs :: [SchemaObjId] -> Text
runBoolExpM :: forall (b :: BackendType) a. BoolExpCtx b -> BoolExpM b a -> a
instance GHC.Internal.Base.Applicative (Hasura.RQL.Types.SchemaCacheTypes.BoolExpM b)
instance GHC.Classes.Eq Hasura.RQL.Types.SchemaCacheTypes.DependencyReason
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.SchemaCacheTypes.LogicalModelObjId b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.SchemaCacheTypes.NativeQueryObjId b)
instance GHC.Classes.Eq Hasura.RQL.Types.SchemaCacheTypes.SchemaDependency
instance GHC.Classes.Eq Hasura.RQL.Types.SchemaCacheTypes.SchemaObjId
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.SchemaCacheTypes.SourceObjId b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.SchemaCacheTypes.StoredProcedureObjId b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.SchemaCacheTypes.TableObjId b)
instance GHC.Internal.Base.Functor (Hasura.RQL.Types.SchemaCacheTypes.BoolExpM b)
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.SchemaCacheTypes.DependencyReason
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.SchemaCacheTypes.LogicalModelObjId b)
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.SchemaCacheTypes.NativeQueryObjId b)
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.SchemaCacheTypes.SchemaDependency
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.SchemaCacheTypes.SchemaObjId
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.SchemaCacheTypes.SourceObjId b)
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.SchemaCacheTypes.StoredProcedureObjId b)
instance GHC.Internal.Generics.Generic (Hasura.RQL.Types.SchemaCacheTypes.TableObjId b)
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.SchemaCacheTypes.DependencyReason
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.SchemaCacheTypes.LogicalModelObjId b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.SchemaCacheTypes.NativeQueryObjId b)
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.SchemaCacheTypes.SchemaDependency
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.SchemaCacheTypes.SchemaObjId
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.SchemaCacheTypes.SourceObjId b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.SchemaCacheTypes.StoredProcedureObjId b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.SchemaCacheTypes.TableObjId b)
instance GHC.Internal.Base.Monad (Hasura.RQL.Types.SchemaCacheTypes.BoolExpM b)
instance Control.Monad.Reader.Class.MonadReader (Hasura.RQL.Types.SchemaCacheTypes.BoolExpCtx b) (Hasura.RQL.Types.SchemaCacheTypes.BoolExpM b)
instance GHC.Internal.Show.Show Hasura.RQL.Types.SchemaCacheTypes.DependencyReason
instance GHC.Internal.Show.Show Hasura.RQL.Types.SchemaCacheTypes.SchemaDependency
instance GHC.Internal.Show.Show Hasura.RQL.Types.SchemaCacheTypes.SchemaObjId
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.Types.SchemaCacheTypes.SchemaObjId
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.SchemaCacheTypes.DependencyReason
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.SchemaCacheTypes.SchemaDependency
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.SchemaCacheTypes.SchemaObjId

module Hasura.Backends.MSSQL.Instances.SchemaCache
instance Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.MSSQL => Hasura.RQL.Types.SchemaCacheTypes.GetAggregationPredicatesDeps 'Hasura.RQL.Types.BackendType.MSSQL

module Hasura.Backends.DataConnector.Adapter.SchemaCache
instance Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.DataConnector => Hasura.RQL.Types.SchemaCacheTypes.GetAggregationPredicatesDeps 'Hasura.RQL.Types.BackendType.DataConnector

module Hasura.Backends.BigQuery.Instances.SchemaCache
instance Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.BigQuery => Hasura.RQL.Types.SchemaCacheTypes.GetAggregationPredicatesDeps 'Hasura.RQL.Types.BackendType.BigQuery

module Hasura.RQL.Types.SchemaCache
data SchemaCache
SchemaCache :: SourceCache -> ActionCache -> RemoteSchemaMap -> InlinedAllowlist -> SchemaIntrospection -> HashMap RoleName (RoleContext GQLContext) -> GQLContext -> HashMap RoleName (RoleContext GQLContext) -> GQLContext -> DepMap -> [InconsistentMetadata] -> HashMap TriggerName CronTriggerInfo -> EndpointTrie GQLQueryWithText -> ApiLimit -> MetricsConfig -> MetadataResourceVersion -> SetGraphqlIntrospectionOptions -> [TlsAllow] -> QueryCollections -> BackendCache -> SourceHealthCheckCache -> SourcePingCache -> OpenTelemetryInfo -> SchemaCache
[scSources] :: SchemaCache -> SourceCache
[scActions] :: SchemaCache -> ActionCache
[scRemoteSchemas] :: SchemaCache -> RemoteSchemaMap
[scAllowlist] :: SchemaCache -> InlinedAllowlist
[scAdminIntrospection] :: SchemaCache -> SchemaIntrospection
[scGQLContext] :: SchemaCache -> HashMap RoleName (RoleContext GQLContext)
[scUnauthenticatedGQLContext] :: SchemaCache -> GQLContext
[scRelayContext] :: SchemaCache -> HashMap RoleName (RoleContext GQLContext)
[scUnauthenticatedRelayContext] :: SchemaCache -> GQLContext
[scDepMap] :: SchemaCache -> DepMap
[scInconsistentObjs] :: SchemaCache -> [InconsistentMetadata]
[scCronTriggers] :: SchemaCache -> HashMap TriggerName CronTriggerInfo
[scEndpoints] :: SchemaCache -> EndpointTrie GQLQueryWithText
[scApiLimits] :: SchemaCache -> ApiLimit
[scMetricsConfig] :: SchemaCache -> MetricsConfig
[scMetadataResourceVersion] :: SchemaCache -> MetadataResourceVersion
[scSetGraphqlIntrospectionOptions] :: SchemaCache -> SetGraphqlIntrospectionOptions
[scTlsAllowlist] :: SchemaCache -> [TlsAllow]
[scQueryCollections] :: SchemaCache -> QueryCollections
[scBackendCache] :: SchemaCache -> BackendCache
[scSourceHealthChecks] :: SchemaCache -> SourceHealthCheckCache
[scSourcePingConfig] :: SchemaCache -> SourcePingCache
[scOpenTelemetryConfig] :: SchemaCache -> OpenTelemetryInfo
data TableConfig (b :: BackendType)
TableConfig :: TableCustomRootFields -> HashMap (Column b) ColumnConfig -> Maybe Name -> Comment -> TableConfig (b :: BackendType)
[_tcCustomRootFields] :: TableConfig (b :: BackendType) -> TableCustomRootFields
[_tcColumnConfig] :: TableConfig (b :: BackendType) -> HashMap (Column b) ColumnConfig
[_tcCustomName] :: TableConfig (b :: BackendType) -> Maybe Name
[_tcComment] :: TableConfig (b :: BackendType) -> Comment
emptyTableConfig :: forall (b :: BackendType). TableConfig b
getAllRemoteSchemas :: SchemaCache -> [RemoteSchemaName]

-- | Retrieves the function cache for a given source cache and source name.
--   
--   This function must be used with a _type annotation_, such as
--   `unsafeFunctionCache <tt>('Postgres 'Vanilla)`. It returns
--   </tt>Nothing@ if it fails to find that source or if the kind of the
--   source does not match the type annotation, and does not distinguish
--   between the two cases.
unsafeFunctionCache :: forall (b :: BackendType). Backend b => SourceName -> SourceCache -> Maybe (FunctionCache b)

-- | Retrieves the information about a function from the source cache, the
--   source name, and the function name.
--   
--   This function returns <tt>Nothing</tt> if it fails to find that source
--   or if the kind of the source does not match the type annotation, and
--   does not distinguish between the two cases.
unsafeFunctionInfo :: forall (b :: BackendType). Backend b => SourceName -> FunctionName b -> SourceCache -> Maybe (FunctionInfo b)

-- | Retrieves the table cache for a given source cache and source name.
--   
--   This function must be used with a _type annotation_, such as
--   `unsafeTableCache <tt>('Postgres 'Vanilla)`. It returns </tt>Nothing@
--   if it fails to find that source or if the kind of the source does not
--   match the type annotation, and does not distinguish between the two
--   cases.
unsafeTableCache :: forall (b :: BackendType). Backend b => SourceName -> SourceCache -> Maybe (TableCache b)

-- | Retrieves the information about a table from the source cache, the
--   source name, and the table name.
--   
--   This function returns <tt>Nothing</tt> if it fails to find that source
--   or if the kind of the source does not match the type annotation, and
--   does not distinguish between the two cases.
unsafeTableInfo :: forall (b :: BackendType). Backend b => SourceName -> TableName b -> SourceCache -> Maybe (TableInfo b)

-- | Retrieves the source info for a given source name.
--   
--   This function retrieves the schema cache from the monadic context, and
--   attempts to look the corresponding source up in the source cache. This
--   function must be used with a _type annotation_, such as `askSourceInfo
--   @('Postgres 'Vanilla)`. It throws an error if: 1. The function fails
--   to find the named source at all 2. The named source exists but does
--   not match the expected type 3. The named source exists, and is of the
--   expected type, but is inconsistent
askSourceInfo :: forall (b :: BackendType) m. (CacheRM m, MetadataM m, MonadError QErr m, Backend b) => SourceName -> m (SourceInfo b)
askSourceInfoMaybe :: forall (b :: BackendType) m. (CacheRM m, Backend b) => SourceName -> m (Maybe (SourceInfo b))

-- | Retrieves the source config for a given source name.
--   
--   This function relies on <a>askSourceInfo</a> and similarly throws an
--   error if the source isn't found.
askSourceConfig :: forall (b :: BackendType) m. (CacheRM m, MonadError QErr m, Backend b, MetadataM m) => SourceName -> m (SourceConfig b)
askSourceConfigMaybe :: forall (b :: BackendType) m. (CacheRM m, Backend b) => SourceName -> m (Maybe (SourceConfig b))

-- | Retrieves the table cache for a given source name.
--   
--   This function retrieves the schema cache from the monadic context, and
--   attempts to look the corresponding source up in the source cache. It
--   must be used with a _type annotation_, such as `unsafeTableCache
--   <tt>('Postgres 'Vanilla)`. It returns </tt>Nothing@ if it fails to
--   find that source or if the kind of the source does not match the type
--   annotation, and does not distinguish between the two cases.
askTableCache :: forall (b :: BackendType) m. (Backend b, CacheRM m) => SourceName -> m (Maybe (TableCache b))

-- | Retrieves the information about a table for a given source name and
--   table name.
--   
--   This function retrieves the schema cache from the monadic context, and
--   attempts to look the corresponding source up in the source cache. it
--   throws an error if it fails to find that source, in which case it
--   looks that source up in the metadata, to differentiate between the
--   source not existing or the type of the source not matching.
askTableInfo :: forall (b :: BackendType) m. (QErrM m, CacheRM m, Backend b) => SourceName -> TableName b -> m (TableInfo b)

-- | Similar to <a>askTableInfo</a>, but drills further down to extract the
--   underlying core info.
askTableCoreInfo :: forall (b :: BackendType) m. (QErrM m, CacheRM m, Backend b) => SourceName -> TableName b -> m (TableCoreInfo b)

-- | Similar to <a>askTableCoreInfo</a>, but drills further down to extract
--   the underlying field info map.
askTableFieldInfoMap :: forall (b :: BackendType) m. (QErrM m, CacheRM m, Backend b) => SourceName -> TableName b -> m (FieldInfoMap (FieldInfo b))
askLogicalModelCache :: forall (b :: BackendType) m. (Backend b, CacheRM m) => SourceName -> m (Maybe (LogicalModelCache b))

-- | Retrieves the metadata information about a table for a given source
--   name and table name.
--   
--   Unlike most other <tt>ask</tt> functions in this module, this function
--   does not drill through the schema cache, and instead inspects the
--   metadata. Like most others, it throws an error if it fails to find
--   that source, in which case it looks that source up in the metadata, to
--   differentiate between the source not existing or the type of the
--   source not matching.
askTableMetadata :: forall (b :: BackendType) m. (QErrM m, MetadataM m, Backend b) => SourceName -> TableName b -> m (TableMetadata b)

-- | Retrieves the information about a function cache for a given source
--   name and function name.
--   
--   This function retrieves the schema cache from the monadic context, and
--   attempts to look the corresponding source up in the source cache. It
--   throws an error if it fails to find that source, in which case it
--   looks that source up in the metadata, to differentiate between the
--   source not existing or the type of the source not matching.
askFunctionInfo :: forall (b :: BackendType) m. (QErrM m, CacheRM m, Backend b) => SourceName -> FunctionName b -> m (FunctionInfo b)

-- | Asking for a table's fields info without explicit
--   <tt><a>SourceName</a> argument. The source name is implicitly inferred
--   from </tt><tt>SourceM</tt> via @<a>TableCoreInfoRM</a>.
askFieldInfoMapSource :: forall m (b :: BackendType). (QErrM m, Backend b, TableCoreInfoRM b m) => TableName b -> m (FieldInfoMap (FieldInfo b))
type TableCoreCache (b :: BackendType) = HashMap TableName b TableCoreInfo b
type TableCache (b :: BackendType) = HashMap TableName b TableInfo b
type ActionCache = HashMap ActionName ActionInfo
type InheritedRolesCache = HashMap RoleName HashSet RoleName

-- | The <tt>field</tt> and <tt>primaryKeyColumn</tt> type parameters vary
--   as the schema cache is built and more information is accumulated. See
--   also <a>TableCoreInfo</a>.
data TableCoreInfoG (b :: BackendType) field primaryKeyColumn
TableCoreInfo :: TableName b -> Maybe PGDescription -> FieldInfoMap field -> Maybe (PrimaryKey b primaryKeyColumn) -> HashSet (UniqueConstraint b) -> HashSet (ForeignKey b) -> Maybe ViewInfo -> Maybe EnumValues -> TableConfig b -> ExtraTableMetadata b -> Maybe ApolloFederationConfig -> [RawColumnInfo b] -> TableCoreInfoG (b :: BackendType) field primaryKeyColumn
[_tciName] :: TableCoreInfoG (b :: BackendType) field primaryKeyColumn -> TableName b
[_tciDescription] :: TableCoreInfoG (b :: BackendType) field primaryKeyColumn -> Maybe PGDescription
[_tciFieldInfoMap] :: TableCoreInfoG (b :: BackendType) field primaryKeyColumn -> FieldInfoMap field
[_tciPrimaryKey] :: TableCoreInfoG (b :: BackendType) field primaryKeyColumn -> Maybe (PrimaryKey b primaryKeyColumn)

-- | Does <i>not</i> include the primary key; use
--   <tt>tciUniqueOrPrimaryKeyConstraints</tt> if you need both.
[_tciUniqueConstraints] :: TableCoreInfoG (b :: BackendType) field primaryKeyColumn -> HashSet (UniqueConstraint b)
[_tciForeignKeys] :: TableCoreInfoG (b :: BackendType) field primaryKeyColumn -> HashSet (ForeignKey b)
[_tciViewInfo] :: TableCoreInfoG (b :: BackendType) field primaryKeyColumn -> Maybe ViewInfo
[_tciEnumValues] :: TableCoreInfoG (b :: BackendType) field primaryKeyColumn -> Maybe EnumValues
[_tciCustomConfig] :: TableCoreInfoG (b :: BackendType) field primaryKeyColumn -> TableConfig b
[_tciExtraTableMetadata] :: TableCoreInfoG (b :: BackendType) field primaryKeyColumn -> ExtraTableMetadata b
[_tciApolloFederationConfig] :: TableCoreInfoG (b :: BackendType) field primaryKeyColumn -> Maybe ApolloFederationConfig
[_tciRawColumns] :: TableCoreInfoG (b :: BackendType) field primaryKeyColumn -> [RawColumnInfo b]

-- | Fully-processed table info that includes non-column fields.
type TableCoreInfo (b :: BackendType) = TableCoreInfoG b FieldInfo b ColumnInfo b
tciName :: forall (b :: BackendType) field primaryKeyColumn f. Functor f => (TableName b -> f (TableName b)) -> TableCoreInfoG b field primaryKeyColumn -> f (TableCoreInfoG b field primaryKeyColumn)
tciDescription :: forall (b :: BackendType) field primaryKeyColumn f. Functor f => (Maybe PGDescription -> f (Maybe PGDescription)) -> TableCoreInfoG b field primaryKeyColumn -> f (TableCoreInfoG b field primaryKeyColumn)
tciFieldInfoMap :: forall (b :: BackendType) field1 primaryKeyColumn field2 f. Functor f => (FieldInfoMap field1 -> f (FieldInfoMap field2)) -> TableCoreInfoG b field1 primaryKeyColumn -> f (TableCoreInfoG b field2 primaryKeyColumn)
tciPrimaryKey :: forall (b :: BackendType) field primaryKeyColumn1 primaryKeyColumn2 f. Functor f => (Maybe (PrimaryKey b primaryKeyColumn1) -> f (Maybe (PrimaryKey b primaryKeyColumn2))) -> TableCoreInfoG b field primaryKeyColumn1 -> f (TableCoreInfoG b field primaryKeyColumn2)
tciUniqueConstraints :: forall (b :: BackendType) field primaryKeyColumn f. Functor f => (HashSet (UniqueConstraint b) -> f (HashSet (UniqueConstraint b))) -> TableCoreInfoG b field primaryKeyColumn -> f (TableCoreInfoG b field primaryKeyColumn)
tciForeignKeys :: forall (b :: BackendType) field primaryKeyColumn f. Functor f => (HashSet (ForeignKey b) -> f (HashSet (ForeignKey b))) -> TableCoreInfoG b field primaryKeyColumn -> f (TableCoreInfoG b field primaryKeyColumn)
tciViewInfo :: forall (b :: BackendType) field primaryKeyColumn f. Functor f => (Maybe ViewInfo -> f (Maybe ViewInfo)) -> TableCoreInfoG b field primaryKeyColumn -> f (TableCoreInfoG b field primaryKeyColumn)
tciEnumValues :: forall (b :: BackendType) field primaryKeyColumn f. Functor f => (Maybe EnumValues -> f (Maybe EnumValues)) -> TableCoreInfoG b field primaryKeyColumn -> f (TableCoreInfoG b field primaryKeyColumn)
tciCustomConfig :: forall (b :: BackendType) field primaryKeyColumn f. Functor f => (TableConfig b -> f (TableConfig b)) -> TableCoreInfoG b field primaryKeyColumn -> f (TableCoreInfoG b field primaryKeyColumn)
tciUniqueOrPrimaryKeyConstraints :: forall (b :: BackendType) f. Hashable (Column b) => TableCoreInfoG b f (ColumnInfo b) -> Maybe (NonEmpty (UniqueConstraint b))
data TableInfo (b :: BackendType)
TableInfo :: TableCoreInfo b -> RolePermInfoMap b -> EventTriggerInfoMap b -> RolePermInfo b -> TableInfo (b :: BackendType)
[_tiCoreInfo] :: TableInfo (b :: BackendType) -> TableCoreInfo b
[_tiRolePermInfoMap] :: TableInfo (b :: BackendType) -> RolePermInfoMap b
[_tiEventTriggerInfoMap] :: TableInfo (b :: BackendType) -> EventTriggerInfoMap b
[_tiAdminRolePermInfo] :: TableInfo (b :: BackendType) -> RolePermInfo b
tiCoreInfo :: forall (b :: BackendType) f. Functor f => (TableCoreInfo b -> f (TableCoreInfo b)) -> TableInfo b -> f (TableInfo b)
tiRolePermInfoMap :: forall (b :: BackendType) f. Functor f => (RolePermInfoMap b -> f (RolePermInfoMap b)) -> TableInfo b -> f (TableInfo b)
tiEventTriggerInfoMap :: forall (b :: BackendType) f. Functor f => (EventTriggerInfoMap b -> f (EventTriggerInfoMap b)) -> TableInfo b -> f (TableInfo b)
data ViewInfo
ViewInfo :: Bool -> Bool -> Bool -> ViewInfo
[viIsUpdatable] :: ViewInfo -> Bool
[viIsDeletable] :: ViewInfo -> Bool
[viIsInsertable] :: ViewInfo -> Bool
isMutable :: (ViewInfo -> Bool) -> Maybe ViewInfo -> Bool
data IntrospectionResult
IntrospectionResult :: RemoteSchemaIntrospection -> Name -> Maybe Name -> Maybe Name -> IntrospectionResult
[irDoc] :: IntrospectionResult -> RemoteSchemaIntrospection
[irQueryRoot] :: IntrospectionResult -> Name
[irMutationRoot] :: IntrospectionResult -> Maybe Name
[irSubscriptionRoot] :: IntrospectionResult -> Maybe Name
data RemoteSchemaCustomizer
RemoteSchemaCustomizer :: Maybe Name -> HashMap Name Name -> HashMap Name (HashMap Name Name) -> RemoteSchemaCustomizer
[_rscNamespaceFieldName] :: RemoteSchemaCustomizer -> Maybe Name

-- | type name -&gt; type name
[_rscCustomizeTypeName] :: RemoteSchemaCustomizer -> HashMap Name Name

-- | type name -&gt; field name -&gt; field name
[_rscCustomizeFieldName] :: RemoteSchemaCustomizer -> HashMap Name (HashMap Name Name)
remoteSchemaCustomizeTypeName :: RemoteSchemaCustomizer -> MkTypename
remoteSchemaCustomizeFieldName :: RemoteSchemaCustomizer -> CustomizeRemoteFieldName
type RemoteSchemaRelationships = RemoteSchemaRelationshipsG RemoteFieldInfo Name

-- | The resolved information of a remote schema. It is parameterized by
--   <tt>remoteFieldInfo</tt> so as to work on an arbitrary 'remote
--   relationship' TODO: Get rid of this <tt>G</tt> suffix using pattern
--   synonyms or qualified usage
data RemoteSchemaCtxG remoteFieldInfo
RemoteSchemaCtx :: RemoteSchemaName -> IntrospectionResult -> RemoteSchemaInfo -> ByteString -> HashMap RoleName IntrospectionResult -> RemoteSchemaRelationshipsG remoteFieldInfo -> RemoteSchemaCtxG remoteFieldInfo
[_rscName] :: RemoteSchemaCtxG remoteFieldInfo -> RemoteSchemaName

-- | Original remote schema without customizations
[_rscIntroOriginal] :: RemoteSchemaCtxG remoteFieldInfo -> IntrospectionResult
[_rscInfo] :: RemoteSchemaCtxG remoteFieldInfo -> RemoteSchemaInfo

-- | The raw response from the introspection query against the remote
--   server. We store this so we can efficiently service
--   <tt>introspect_remote_schema</tt>.
[_rscRawIntrospectionResult] :: RemoteSchemaCtxG remoteFieldInfo -> ByteString
[_rscPermissions] :: RemoteSchemaCtxG remoteFieldInfo -> HashMap RoleName IntrospectionResult
[_rscRemoteRelationships] :: RemoteSchemaCtxG remoteFieldInfo -> RemoteSchemaRelationshipsG remoteFieldInfo
type PartiallyResolvedRemoteSchemaCtx = RemoteSchemaCtxG PartiallyResolvedRemoteRelationship RemoteRelationshipDefinition
type RemoteSchemaCtx = RemoteSchemaCtxG RemoteFieldInfo Name
type PartiallyResolvedRemoteSchemaMap = HashMap RemoteSchemaName PartiallyResolvedRemoteSchemaCtx
type RemoteSchemaMap = HashMap RemoteSchemaName RemoteSchemaCtx
type DepMap = HashMap SchemaObjId HashSet SchemaDependency
type WithDeps a = (a, Seq SchemaDependency)

-- | A more limited version of <a>CacheRM</a> that is used when building
--   the schema cache, since the entire schema cache has not been built
--   yet.
class Monad m => TableCoreInfoRM (b :: BackendType) (m :: Type -> Type)
lookupTableCoreInfo :: TableCoreInfoRM b m => TableName b -> m (Maybe (TableCoreInfo b))
newtype TableCoreCacheRT (b :: BackendType) (m :: Type -> Type) a
TableCoreCacheRT :: (TableCoreCache b -> m a) -> TableCoreCacheRT (b :: BackendType) (m :: Type -> Type) a
[runTableCoreCacheRT] :: TableCoreCacheRT (b :: BackendType) (m :: Type -> Type) a -> TableCoreCache b -> m a

-- | All our RQL DML queries operate over a single source. This typeclass
--   facilitates that.
class TableCoreInfoRM b m => TableInfoRM (b :: BackendType) (m :: Type -> Type)
lookupTableInfo :: TableInfoRM b m => TableName b -> m (Maybe (TableInfo b))
newtype TableCacheRT (b :: BackendType) (m :: Type -> Type) a
TableCacheRT :: (TableCache b -> m a) -> TableCacheRT (b :: BackendType) (m :: Type -> Type) a
[runTableCacheRT] :: TableCacheRT (b :: BackendType) (m :: Type -> Type) a -> TableCache b -> m a
class Monad m => CacheRM (m :: Type -> Type)
askSchemaCache :: CacheRM m => m SchemaCache
type FieldInfoMap = HashMap FieldName
data FieldInfo (b :: BackendType)
FIColumn :: StructuredColumnInfo b -> FieldInfo (b :: BackendType)
FIRelationship :: RelInfo b -> FieldInfo (b :: BackendType)
FIComputedField :: ComputedFieldInfo b -> FieldInfo (b :: BackendType)
FIRemoteRelationship :: RemoteFieldInfo (DBJoinField b) -> FieldInfo (b :: BackendType)
_FIColumn :: forall (b :: BackendType) p f. (Choice p, Applicative f) => p (StructuredColumnInfo b) (f (StructuredColumnInfo b)) -> p (FieldInfo b) (f (FieldInfo b))
_FIRelationship :: forall (b :: BackendType) p f. (Choice p, Applicative f) => p (RelInfo b) (f (RelInfo b)) -> p (FieldInfo b) (f (FieldInfo b))
_FIComputedField :: forall (b :: BackendType) p f. (Choice p, Applicative f) => p (ComputedFieldInfo b) (f (ComputedFieldInfo b)) -> p (FieldInfo b) (f (FieldInfo b))
fieldInfoName :: forall (b :: BackendType). Backend b => FieldInfo b -> FieldName

-- | Returns all the field names created for the given field. Columns,
--   object relationships, and computed fields only ever produce a single
--   field, but array relationships also contain an <tt>_aggregate</tt>
--   field.
fieldInfoGraphQLNames :: forall (b :: BackendType). FieldInfo b -> [Name]
getCols :: forall (backend :: BackendType). FieldInfoMap (FieldInfo backend) -> [StructuredColumnInfo backend]
getRels :: forall (backend :: BackendType). FieldInfoMap (FieldInfo backend) -> [RelInfo backend]
getComputedFieldInfos :: forall (backend :: BackendType). FieldInfoMap (FieldInfo backend) -> [ComputedFieldInfo backend]
type RolePermInfoMap (b :: BackendType) = HashMap RoleName RolePermInfo b
data InsPermInfo (b :: BackendType)
InsPermInfo :: HashSet (Column b) -> AnnBoolExpPartialSQL b -> PreSetColsPartial b -> Bool -> HashSet Text -> Maybe (ValidateInput ResolvedWebhook) -> InsPermInfo (b :: BackendType)
[ipiCols] :: InsPermInfo (b :: BackendType) -> HashSet (Column b)
[ipiCheck] :: InsPermInfo (b :: BackendType) -> AnnBoolExpPartialSQL b
[ipiSet] :: InsPermInfo (b :: BackendType) -> PreSetColsPartial b
[ipiBackendOnly] :: InsPermInfo (b :: BackendType) -> Bool
[ipiRequiredHeaders] :: InsPermInfo (b :: BackendType) -> HashSet Text
[ipiValidateInput] :: InsPermInfo (b :: BackendType) -> Maybe (ValidateInput ResolvedWebhook)
data UpdPermInfo (b :: BackendType)
UpdPermInfo :: HashSet (Column b) -> TableName b -> AnnBoolExpPartialSQL b -> Maybe (AnnBoolExpPartialSQL b) -> PreSetColsPartial b -> Bool -> HashSet Text -> Maybe (ValidateInput ResolvedWebhook) -> UpdPermInfo (b :: BackendType)
[upiCols] :: UpdPermInfo (b :: BackendType) -> HashSet (Column b)
[upiTable] :: UpdPermInfo (b :: BackendType) -> TableName b
[upiFilter] :: UpdPermInfo (b :: BackendType) -> AnnBoolExpPartialSQL b
[upiCheck] :: UpdPermInfo (b :: BackendType) -> Maybe (AnnBoolExpPartialSQL b)
[upiSet] :: UpdPermInfo (b :: BackendType) -> PreSetColsPartial b
[upiBackendOnly] :: UpdPermInfo (b :: BackendType) -> Bool
[upiRequiredHeaders] :: UpdPermInfo (b :: BackendType) -> HashSet Text
[upiValidateInput] :: UpdPermInfo (b :: BackendType) -> Maybe (ValidateInput ResolvedWebhook)
data DelPermInfo (b :: BackendType)
DelPermInfo :: TableName b -> AnnBoolExpPartialSQL b -> !Bool -> HashSet Text -> Maybe (ValidateInput ResolvedWebhook) -> DelPermInfo (b :: BackendType)
[dpiTable] :: DelPermInfo (b :: BackendType) -> TableName b
[dpiFilter] :: DelPermInfo (b :: BackendType) -> AnnBoolExpPartialSQL b
[dpiBackendOnly] :: DelPermInfo (b :: BackendType) -> !Bool
[dpiRequiredHeaders] :: DelPermInfo (b :: BackendType) -> HashSet Text
[dpiValidateInput] :: DelPermInfo (b :: BackendType) -> Maybe (ValidateInput ResolvedWebhook)
type PreSetColsPartial (b :: BackendType) = HashMap Column b PartialSQLExp b
data EventTriggerInfo (b :: BackendType)
EventTriggerInfo :: TriggerName -> TriggerOpsDef b -> RetryConf -> WebhookConfInfo -> [EventHeaderInfo] -> Maybe RequestTransform -> Maybe MetadataResponseTransform -> Maybe AutoTriggerLogCleanupConfig -> TriggerOnReplication -> EventTriggerInfo (b :: BackendType)
[etiName] :: EventTriggerInfo (b :: BackendType) -> TriggerName
[etiOpsDef] :: EventTriggerInfo (b :: BackendType) -> TriggerOpsDef b
[etiRetryConf] :: EventTriggerInfo (b :: BackendType) -> RetryConf

-- | The HTTP(s) URL which will be called with the event payload on
--   configured operation. Must be a POST handler. This URL can be entered
--   manually or can be picked up from an environment variable (the
--   environment variable needs to be set before using it for this
--   configuration).
[etiWebhookInfo] :: EventTriggerInfo (b :: BackendType) -> WebhookConfInfo

-- | Custom headers can be added to an event trigger. Each webhook request
--   will have these headers added.
[etiHeaders] :: EventTriggerInfo (b :: BackendType) -> [EventHeaderInfo]
[etiRequestTransform] :: EventTriggerInfo (b :: BackendType) -> Maybe RequestTransform
[etiResponseTransform] :: EventTriggerInfo (b :: BackendType) -> Maybe MetadataResponseTransform
[etiCleanupConfig] :: EventTriggerInfo (b :: BackendType) -> Maybe AutoTriggerLogCleanupConfig
[etiTriggerOnReplication] :: EventTriggerInfo (b :: BackendType) -> TriggerOnReplication
type EventTriggerInfoMap (b :: BackendType) = HashMap TriggerName EventTriggerInfo b
data TableObjId (b :: BackendType)
TOCol :: Column b -> TableObjId (b :: BackendType)
TORel :: RelName -> TableObjId (b :: BackendType)
TOComputedField :: ComputedFieldName -> TableObjId (b :: BackendType)
TORemoteRel :: RelName -> TableObjId (b :: BackendType)
TOForeignKey :: ConstraintName b -> TableObjId (b :: BackendType)
TOPerm :: RoleName -> PermType -> TableObjId (b :: BackendType)
TOTrigger :: TriggerName -> TableObjId (b :: BackendType)
data SchemaObjId
SOSource :: SourceName -> SchemaObjId
SOSourceObj :: SourceName -> AnyBackend SourceObjId -> SchemaObjId
SORemoteSchema :: RemoteSchemaName -> SchemaObjId
SORemoteSchemaPermission :: RemoteSchemaName -> RoleName -> SchemaObjId

-- | A remote relationship on a remote schema type, identified by 1. remote
--   schema name 2. remote schema type on which the relationship is defined
--   3. name of the relationship
SORemoteSchemaRemoteRelationship :: RemoteSchemaName -> Name -> RelName -> SchemaObjId
SORole :: RoleName -> SchemaObjId
reportSchemaObj :: SchemaObjId -> Text
reportSchemaObjs :: [SchemaObjId] -> Text
data DependencyReason
DRTable :: DependencyReason
DRColumn :: DependencyReason
DRRemoteTable :: DependencyReason
DRLeftColumn :: DependencyReason
DRRightColumn :: DependencyReason
DRUsingColumn :: DependencyReason
DRFkey :: DependencyReason
DRRemoteFkey :: DependencyReason
DRUntyped :: DependencyReason
DROnType :: DependencyReason
DRSessionVariable :: DependencyReason
DRPayload :: DependencyReason
DRParent :: DependencyReason
DRRemoteSchema :: DependencyReason
DRRemoteRelationship :: DependencyReason
DRParentRole :: DependencyReason
DRLogicalModel :: DependencyReason
DRReferencedLogicalModel :: DependencyReason
data SchemaDependency
SchemaDependency :: SchemaObjId -> DependencyReason -> SchemaDependency
[sdObjId] :: SchemaDependency -> SchemaObjId
[sdReason] :: SchemaDependency -> DependencyReason
mkParentDep :: forall (b :: BackendType). Backend b => SourceName -> TableName b -> SchemaDependency

-- | When we depend on anything to do with logical models, we also declare
--   that we depend on the logical model as a whole. This is the "parent"
--   dependency in the dependency tree for a given logical model.
mkLogicalModelParentDep :: forall (b :: BackendType). Backend b => SourceName -> LogicalModelLocation -> SchemaDependency
mkColDep :: forall (b :: BackendType). Backend b => DependencyReason -> SourceName -> TableName b -> Column b -> SchemaDependency

-- | Declare a dependency on a particular column of a logical model
mkLogicalModelColDep :: forall (b :: BackendType). Backend b => DependencyReason -> SourceName -> LogicalModelLocation -> Column b -> SchemaDependency
mkComputedFieldDep :: forall (b :: BackendType). Backend b => DependencyReason -> SourceName -> TableName b -> ComputedFieldName -> SchemaDependency
getDependentObjs :: SchemaCache -> SchemaObjId -> [SchemaObjId]
getDependentObjsWith :: (DependencyReason -> Bool) -> SchemaCache -> SchemaObjId -> [SchemaObjId]

-- | Compute all remote dependencies on a source.
--   
--   Given a source name, this function computes all of its dependencies,
--   direct or indirect, and returns all of the dependencies that are not
--   "local" to the source, i.e. that belong to another source or to a
--   remote schema, here dubbed "remote dependencies".
--   
--   This functions returns a <a>SchemaObjId</a> for each such dependency,
--   but makes no attempt at extracting the underlying <a>SourceObjId</a>
--   (if any), for two reasons: 1. a <a>SourceObjId</a> no longer contains
--   the source name, which most callers need to identify where the
--   corresponding dependency is 2. this would prevent us from returning
--   remote schema dependencies, which by definition do not have a
--   corresponding <a>SourceObjId</a>
getRemoteDependencies :: SchemaCache -> SourceName -> [SchemaObjId]

-- | <a>https://www.postgresql.org/docs/current/xfunc-volatility.html</a>
data FunctionVolatility
FTVOLATILE :: FunctionVolatility
FTIMMUTABLE :: FunctionVolatility
FTSTABLE :: FunctionVolatility
newtype FunctionArgName
FunctionArgName :: Text -> FunctionArgName
[getFuncArgNameTxt] :: FunctionArgName -> Text

-- | Tracked SQL function metadata. See <tt>buildFunctionInfo</tt>.
data FunctionInfo (b :: BackendType)
FunctionInfo :: FunctionName b -> Name -> Name -> Name -> SystemDefined -> FunctionVolatility -> FunctionExposedAs -> Seq (FunctionInputArgument b) -> TableName b -> Maybe Text -> FunctionPermissionsMap -> JsonAggSelect -> Maybe Text -> FunctionInfo (b :: BackendType)
[_fiSQLName] :: FunctionInfo (b :: BackendType) -> FunctionName b
[_fiGQLName] :: FunctionInfo (b :: BackendType) -> Name
[_fiGQLArgsName] :: FunctionInfo (b :: BackendType) -> Name
[_fiGQLAggregateName] :: FunctionInfo (b :: BackendType) -> Name
[_fiSystemDefined] :: FunctionInfo (b :: BackendType) -> SystemDefined
[_fiVolatility] :: FunctionInfo (b :: BackendType) -> FunctionVolatility

-- | In which part of the schema should this function be exposed?
--   
--   See <tt>mkFunctionInfo</tt> and <a>_fcExposedAs</a>.
[_fiExposedAs] :: FunctionInfo (b :: BackendType) -> FunctionExposedAs
[_fiInputArgs] :: FunctionInfo (b :: BackendType) -> Seq (FunctionInputArgument b)

-- | NOTE: when a table is created, a new composite type of the same name
--   is automatically created; so strictly speaking this field means "the
--   function returns the composite type corresponding to this table".
[_fiReturnType] :: FunctionInfo (b :: BackendType) -> TableName b

-- | this field represents the description of the function as present on
--   the database
[_fiDescription] :: FunctionInfo (b :: BackendType) -> Maybe Text

-- | Roles to which the function is accessible
[_fiPermissions] :: FunctionInfo (b :: BackendType) -> FunctionPermissionsMap
[_fiJsonAggSelect] :: FunctionInfo (b :: BackendType) -> JsonAggSelect
[_fiComment] :: FunctionInfo (b :: BackendType) -> Maybe Text
type FunctionCache (b :: BackendType) = HashMap FunctionName b FunctionInfo b
data CronTriggerInfo
CronTriggerInfo :: TriggerName -> CronSchedule -> Maybe Value -> STRetryConf -> EnvRecord ResolvedWebhook -> [EventHeaderInfo] -> Maybe Text -> Maybe RequestTransform -> Maybe MetadataResponseTransform -> CronTriggerInfo
[ctiName] :: CronTriggerInfo -> TriggerName
[ctiSchedule] :: CronTriggerInfo -> CronSchedule
[ctiPayload] :: CronTriggerInfo -> Maybe Value
[ctiRetryConf] :: CronTriggerInfo -> STRetryConf
[ctiWebhookInfo] :: CronTriggerInfo -> EnvRecord ResolvedWebhook
[ctiHeaders] :: CronTriggerInfo -> [EventHeaderInfo]
[ctiComment] :: CronTriggerInfo -> Maybe Text
[ctiRequestTransform] :: CronTriggerInfo -> Maybe RequestTransform
[ctiResponseTransform] :: CronTriggerInfo -> Maybe MetadataResponseTransform
newtype MetadataResourceVersion
MetadataResourceVersion :: Int64 -> MetadataResourceVersion
[getMetadataResourceVersion] :: MetadataResourceVersion -> Int64
showMetadataResourceVersion :: MetadataResourceVersion -> Text
initialResourceVersion :: MetadataResourceVersion
data MetadataWithResourceVersion
MetadataWithResourceVersion :: Metadata -> MetadataResourceVersion -> MetadataWithResourceVersion
[_mwrvMetadata] :: MetadataWithResourceVersion -> Metadata
[_mwrvResourceVersion] :: MetadataWithResourceVersion -> MetadataResourceVersion

-- | What schema dependencies does a given row permission for a logical
--   model have? This will almost certainly involve some number of
--   dependencies on logical models, but may also involve dependencies on
--   tables. Although we can't relate tables and logical models yet, we can
--   still declare permissions like, "you can only see this logical model
--   if your user ID exists in this table".
getLogicalModelBoolExpDeps :: forall (b :: BackendType). GetAggregationPredicatesDeps b => SourceName -> LogicalModelLocation -> AnnBoolExpPartialSQL b -> [SchemaDependency]

-- | Discover the schema dependencies of an <tt>AnnBoolExpPartialSQL</tt>.
getBoolExpDeps :: forall (b :: BackendType). GetAggregationPredicatesDeps b => SourceName -> TableName b -> AnnBoolExpPartialSQL b -> [SchemaDependency]

-- | InlinedAllowlist is the data type with which the allowlist is
--   represented in the schema cache, it contains a global and a per role
--   allowlist and when allowlist is enabled in the graphql-engine, the
--   incoming query for a non-admin role should either be in the global
--   allowlist or in the given role's role based allowlist.
--   
--   Essentially, it's a memoization of <a>allowlistAllowsQuery</a>
--   implemented in terms of <a>MetadataAllowlist</a>.
data InlinedAllowlist

-- | The monad for doing schema dependency discovery for boolean
--   expressions. maintains the table context of the expressions being
--   translated.
newtype BoolExpM (b :: BackendType) a
BoolExpM :: Reader (BoolExpCtx b) a -> BoolExpM (b :: BackendType) a
[unBoolExpM] :: BoolExpM (b :: BackendType) a -> Reader (BoolExpCtx b) a

-- | The table type context of schema dependency discovery. Boolean
--   expressions may refer to a so-called 'root table' (identified by a
--   <a>$</a>-sign in the expression input syntax) or the <tt>current</tt>
--   table.
data BoolExpCtx (b :: BackendType)
BoolExpCtx :: SourceName -> TableName b -> TableName b -> BoolExpCtx (b :: BackendType)
[source] :: BoolExpCtx (b :: BackendType) -> SourceName

-- | Reference to the <tt>current</tt> table type.
[currTable] :: BoolExpCtx (b :: BackendType) -> TableName b

-- | Reference to the <tt>root</tt> table type.
[rootTable] :: BoolExpCtx (b :: BackendType) -> TableName b
getOpExpDeps :: forall (b :: BackendType). Backend b => [OpExpG b (PartialSQLExp b)] -> BoolExpM b [SchemaDependency]
newtype BackendInfoWrapper (b :: BackendType)
BackendInfoWrapper :: BackendInfo b -> BackendInfoWrapper (b :: BackendType)
[unBackendInfoWrapper] :: BackendInfoWrapper (b :: BackendType) -> BackendInfo b
type BackendCache = BackendMap BackendInfoWrapper
getBackendInfo :: forall (b :: BackendType) m. (CacheRM m, HasTag b) => m (Maybe (BackendInfo b))
instance GHC.Internal.Base.Applicative m => GHC.Internal.Base.Applicative (Hasura.RQL.Types.SchemaCache.TableCacheRT b m)
instance GHC.Internal.Base.Applicative m => GHC.Internal.Base.Applicative (Hasura.RQL.Types.SchemaCache.TableCoreCacheRT b m)
instance Hasura.RQL.Types.SchemaCache.CacheRM m => Hasura.RQL.Types.SchemaCache.CacheRM (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.RQL.Types.SchemaCache.CacheRM m => Hasura.RQL.Types.SchemaCache.CacheRM (Control.Monad.Trans.State.Strict.StateT s m)
instance Hasura.RQL.Types.SchemaCache.CacheRM m => Hasura.RQL.Types.SchemaCache.CacheRM (Hasura.Tracing.Monad.TraceT m)
instance Hasura.RQL.Types.SchemaCache.CacheRM m => Hasura.RQL.Types.SchemaCache.CacheRM (Database.MSSQL.Transaction.TxET e m)
instance Hasura.RQL.Types.SchemaCache.CacheRM m => Hasura.RQL.Types.SchemaCache.CacheRM (Database.PG.Query.Transaction.TxET Hasura.Base.Error.QErr m)
instance (GHC.Internal.Base.Monoid w, Hasura.RQL.Types.SchemaCache.CacheRM m) => Hasura.RQL.Types.SchemaCache.CacheRM (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance GHC.Classes.Eq Hasura.RQL.Types.SchemaCache.CronTriggerInfo
instance GHC.Classes.Eq Hasura.RQL.Types.SchemaCache.MetadataResourceVersion
instance GHC.Classes.Eq Hasura.RQL.Types.SchemaCache.MetadataWithResourceVersion
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.SchemaCache.MetadataResourceVersion
instance GHC.Internal.Base.Functor m => GHC.Internal.Base.Functor (Hasura.RQL.Types.SchemaCache.TableCacheRT b m)
instance GHC.Internal.Base.Functor m => GHC.Internal.Base.Functor (Hasura.RQL.Types.SchemaCache.TableCoreCacheRT b m)
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.SchemaCache.CronTriggerInfo
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Hasura.RQL.Types.SchemaCache.TableCacheRT b m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Hasura.RQL.Types.SchemaCache.TableCoreCacheRT b m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Hasura.RQL.Types.SchemaCache.TableCacheRT b m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Hasura.RQL.Types.SchemaCache.TableCoreCacheRT b m)
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (Hasura.RQL.Types.SchemaCache.TableCoreCacheRT b m)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (Hasura.RQL.Types.SchemaCache.TableCacheRT b m)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (Hasura.RQL.Types.SchemaCache.TableCoreCacheRT b m)
instance GHC.Internal.Base.Monad m => GHC.Internal.Base.Monad (Hasura.RQL.Types.SchemaCache.TableCacheRT b m)
instance GHC.Internal.Base.Monad m => GHC.Internal.Base.Monad (Hasura.RQL.Types.SchemaCache.TableCoreCacheRT b m)
instance Control.Monad.Trans.Class.MonadTrans (Hasura.RQL.Types.SchemaCache.TableCacheRT b)
instance Control.Monad.Trans.Class.MonadTrans (Hasura.RQL.Types.SchemaCache.TableCoreCacheRT b)
instance Hasura.Backends.Postgres.Connection.MonadTx.MonadTx m => Hasura.Backends.Postgres.Connection.MonadTx.MonadTx (Hasura.RQL.Types.SchemaCache.TableCacheRT b m)
instance Hasura.Backends.Postgres.Connection.MonadTx.MonadTx m => Hasura.Backends.Postgres.Connection.MonadTx.MonadTx (Hasura.RQL.Types.SchemaCache.TableCoreCacheRT b m)
instance Control.Monad.Writer.Class.MonadWriter w m => Control.Monad.Writer.Class.MonadWriter w (Hasura.RQL.Types.SchemaCache.TableCacheRT b m)
instance Control.Monad.Writer.Class.MonadWriter w m => Control.Monad.Writer.Class.MonadWriter w (Hasura.RQL.Types.SchemaCache.TableCoreCacheRT b m)
instance GHC.Internal.Base.Monoid (Hasura.RQL.Types.Backend.BackendInfo b) => GHC.Internal.Base.Monoid (Hasura.RQL.Types.SchemaCache.BackendInfoWrapper b)
instance GHC.Internal.Num.Num Hasura.RQL.Types.SchemaCache.MetadataResourceVersion
instance GHC.Internal.Base.Semigroup (Hasura.RQL.Types.Backend.BackendInfo b) => GHC.Internal.Base.Semigroup (Hasura.RQL.Types.SchemaCache.BackendInfoWrapper b)
instance GHC.Internal.Show.Show Hasura.RQL.Types.SchemaCache.CronTriggerInfo
instance GHC.Internal.Show.Show Hasura.RQL.Types.SchemaCache.MetadataResourceVersion
instance Hasura.RQL.Types.SchemaCache.TableCoreInfoRM b m => Hasura.RQL.Types.SchemaCache.TableCoreInfoRM b (Hasura.LogicalModel.Fields.LogicalModelFieldsLookupRT b m)
instance Hasura.RQL.Types.SchemaCache.TableCoreInfoRM b m => Hasura.RQL.Types.SchemaCache.TableCoreInfoRM b (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.RQL.Types.SchemaCache.TableCoreInfoRM b m => Hasura.RQL.Types.SchemaCache.TableCoreInfoRM b (Control.Monad.Trans.State.Strict.StateT s m)
instance (GHC.Internal.Base.Monad m, Hasura.RQL.Types.Backend.Backend b) => Hasura.RQL.Types.SchemaCache.TableCoreInfoRM b (Hasura.RQL.Types.SchemaCache.TableCacheRT b m)
instance (GHC.Internal.Base.Monad m, Hasura.RQL.Types.Backend.Backend b) => Hasura.RQL.Types.SchemaCache.TableCoreInfoRM b (Hasura.RQL.Types.SchemaCache.TableCoreCacheRT b m)
instance Hasura.RQL.Types.SchemaCache.TableCoreInfoRM b m => Hasura.RQL.Types.SchemaCache.TableCoreInfoRM b (Hasura.Tracing.Monad.TraceT m)
instance (GHC.Internal.Base.Monoid w, Hasura.RQL.Types.SchemaCache.TableCoreInfoRM b m) => Hasura.RQL.Types.SchemaCache.TableCoreInfoRM b (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance Hasura.RQL.Types.SchemaCache.TableInfoRM b m => Hasura.RQL.Types.SchemaCache.TableInfoRM b (Hasura.LogicalModel.Fields.LogicalModelFieldsLookupRT b m)
instance Hasura.RQL.Types.SchemaCache.TableInfoRM b m => Hasura.RQL.Types.SchemaCache.TableInfoRM b (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.RQL.Types.SchemaCache.TableInfoRM b m => Hasura.RQL.Types.SchemaCache.TableInfoRM b (Control.Monad.Trans.State.Strict.StateT s m)
instance (GHC.Internal.Base.Monad m, Hasura.RQL.Types.Backend.Backend b) => Hasura.RQL.Types.SchemaCache.TableInfoRM b (Hasura.RQL.Types.SchemaCache.TableCacheRT b m)
instance Hasura.RQL.Types.SchemaCache.TableInfoRM b m => Hasura.RQL.Types.SchemaCache.TableInfoRM b (Hasura.Tracing.Monad.TraceT m)
instance (GHC.Internal.Base.Monoid w, Hasura.RQL.Types.SchemaCache.TableInfoRM b m) => Hasura.RQL.Types.SchemaCache.TableInfoRM b (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Backend.BackendInfo b) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.SchemaCache.BackendInfoWrapper b)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.SchemaCache.CronTriggerInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.SchemaCache.MetadataResourceVersion
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.SchemaCache.SchemaCache
instance Hasura.Authentication.User.UserInfoM m => Hasura.Authentication.User.UserInfoM (Hasura.RQL.Types.SchemaCache.TableCacheRT b m)

module Hasura.Server.OpenAPI
buildOpenAPI :: (MonadError QErr m, MonadFix m) => SchemaCache -> m OpenApi


-- | Types and functions used in the process of building the schema cache
--   from metadata information stored in the <tt>hdb_catalog</tt> schema in
--   Postgres.
module Hasura.RQL.Types.SchemaCache.Build
data MetadataDependency
MetadataDependency :: MetadataObject -> SchemaObjId -> SchemaDependency -> MetadataDependency
recordInconsistencies :: (ArrowWriter (Seq CollectItem) arr, Functor f, Foldable f) => arr ((Maybe Value, f MetadataObject), Text) ()
recordInconsistencyM :: MonadWriter (Seq CollectItem) m => Maybe Value -> MetadataObject -> Text -> m ()
recordInconsistenciesM :: MonadWriter (Seq CollectItem) m => [MetadataObject] -> Text -> m ()
recordDependencies :: ArrowWriter (Seq CollectItem) arr => arr (MetadataObject, SchemaObjId, Seq SchemaDependency) ()
recordDependenciesM :: MonadWriter (Seq CollectItem) m => MetadataObject -> SchemaObjId -> Seq SchemaDependency -> m ()

-- | Record any errors resulting from a computation as inconsistencies
withRecordInconsistency :: (ArrowChoice arr, ArrowWriter (Seq CollectItem) arr) => ErrorA QErr arr (e, s) a -> arr (e, (MetadataObject, s)) (Maybe a)

-- | Monadic version of <a>withRecordInconsistency</a>
withRecordInconsistencyM :: MonadWriter (Seq CollectItem) m => MetadataObject -> ExceptT QErr m a -> m (Maybe a)
withRecordInconsistencies :: (ArrowChoice arr, ArrowWriter (Seq CollectItem) arr) => ErrorA QErr arr (e, s) a -> arr (e, ([MetadataObject], s)) (Maybe a)
class CacheRM m => CacheRWM (m :: Type -> Type)
tryBuildSchemaCacheWithOptions :: CacheRWM m => BuildReason -> CacheInvalidations -> Metadata -> Maybe MetadataResourceVersion -> ValidateNewSchemaCache a -> m a
setMetadataResourceVersionInSchemaCache :: CacheRWM m => MetadataResourceVersion -> m ()
buildSchemaCacheWithOptions :: CacheRWM m => BuildReason -> CacheInvalidations -> Metadata -> Maybe MetadataResourceVersion -> m ()
data BuildReason

-- | The build was triggered by an update this instance made to the catalog
--   (in the currently-active transaction), so information in Postgres that
--   needs to be kept in sync with the catalog (i.e. table event triggers
--   in <tt>hdb_catalog</tt> schema) should be updated.
CatalogUpdate :: Maybe (HashSet SourceName) -> BuildReason

-- | The build was triggered by a notification that some other
--   currently-running Hasura instance updated the catalog. Since that
--   instance already updated table event triggers in <tt>hdb_catalog</tt>,
--   this build should be read-only.
CatalogSync :: BuildReason
data CacheInvalidations
CacheInvalidations :: Bool -> HashSet RemoteSchemaName -> HashSet SourceName -> HashSet DataConnectorName -> CacheInvalidations

-- | Force reloading of all database information, including information not
--   technically stored in metadata (currently just enum values). Set by
--   the <tt>reload_metadata</tt> API.
[ciMetadata] :: CacheInvalidations -> Bool

-- | Force refetching of the given remote schemas, even if their definition
--   has not changed. Set by the <tt>reload_remote_schema</tt> API.
[ciRemoteSchemas] :: CacheInvalidations -> HashSet RemoteSchemaName

-- | Force re-establishing connections of the given data sources, even if
--   their configuration has not changed. Set by the
--   <tt>pg_reload_source</tt> API.
[ciSources] :: CacheInvalidations -> HashSet SourceName

-- | Force re-fetching of <tt>DataConnectorInfo</tt> from the named data
--   connectors.
[ciDataConnectors] :: CacheInvalidations -> HashSet DataConnectorName

-- | Function that validates the new schema cache (usually involves
--   checking for any metadata inconsistencies) and can decide whether or
--   not to keep or discard the new schema cache
--   (<a>ValidateNewSchemaCacheResult</a>). It can also return some
--   arbitrary extra information that will be returned from
--   <a>tryBuildSchemaCacheWithOptions</a>.
--   
--   First parameter is the old schema cache, the second is the new schema
--   cache.
type ValidateNewSchemaCache a = SchemaCache -> SchemaCache -> (ValidateNewSchemaCacheResult, a)
data ValidateNewSchemaCacheResult
KeepNewSchemaCache :: ValidateNewSchemaCacheResult
DiscardNewSchemaCache :: ValidateNewSchemaCacheResult

-- | A simple monad class which enables fetching and setting
--   @<a>Metadata</a> in the state.
class Monad m => MetadataM (m :: Type -> Type)
getMetadata :: MetadataM m => m Metadata
putMetadata :: MetadataM m => Metadata -> m ()
newtype MetadataT (m :: Type -> Type) a
MetadataT :: StateT Metadata m a -> MetadataT (m :: Type -> Type) a
[unMetadataT] :: MetadataT (m :: Type -> Type) a -> StateT Metadata m a

-- | <tt>runMetadataT</tt> puts a stateful metadata in scope.
--   <tt>MetadataDefaults</tt> is provided so that it can be considered
--   from the --metadataDefaults arguments.
runMetadataT :: Metadata -> MetadataDefaults -> MetadataT m a -> m (a, Metadata)
buildSchemaCacheWithInvalidations :: (MetadataM m, CacheRWM m) => CacheInvalidations -> MetadataModifier -> m ()
buildSchemaCache :: (MetadataM m, CacheRWM m) => MetadataModifier -> m ()

-- | Rebuilds the schema cache after modifying metadata and returns any
--   _new_ metadata inconsistencies. If there are any new inconsistencies,
--   the changes to the metadata and the schema cache are abandoned.
tryBuildSchemaCache :: (CacheRWM m, MetadataM m) => MetadataModifier -> m (HashMap MetadataObjId (NonEmpty InconsistentMetadata))

-- | Rebuilds the schema cache after modifying metadata sequentially and
--   returns any _new_ metadata inconsistencies. If there are any new
--   inconsistencies, the changes to the metadata and the schema cache are
--   abandoned. If the metadata modifiers run into validation issues (e.g.
--   a native query is already tracked in the metadata), we throw these
--   errors back without changing the metadata and schema cache.
tryBuildSchemaCacheWithModifiers :: (CacheRWM m, MetadataM m) => [Metadata -> m Metadata] -> m (HashMap MetadataObjId (NonEmpty InconsistentMetadata))

-- | Tries to modify the metadata for all the specified metadata objects.
--   If the modification fails, any objects that directly caused a new
--   metadata inconsistency are removed and the modification is attempted
--   again without those failing objects. The failing objects are raised as
--   warnings in <a>MonadWarnings</a> and the successful objects are
--   returned. If there are metadata inconsistencies that are not directly
--   related to the specified metadata objects, an error is thrown.
tryBuildSchemaCacheAndWarnOnFailingObjects :: (CacheRWM m, MonadWarnings m, QErrM m, MetadataM m) => (a -> m MetadataModifier) -> WarningCode -> HashMap MetadataObjId a -> m (HashMap MetadataObjId a)

-- | Rebuilds the schema cache after modifying metadata. If an object with
--   the given object id became newly inconsistent, raises an error about
--   it specifically. Otherwise, raises a generic metadata inconsistency
--   error.
buildSchemaCacheFor :: (QErrM m, CacheRWM m, MetadataM m) => MetadataObjId -> MetadataModifier -> m ()

-- | Requests the schema cache, and fails if there is any inconsistent
--   metadata.
throwOnInconsistencies :: (QErrM m, CacheRWM m) => m ()

-- | Executes the given action, and if any new <a>InconsistentMetadata</a>s
--   are added to the schema cache as a result of its execution, raises an
--   error.
withNewInconsistentObjsCheck :: (QErrM m, CacheRM m) => m a -> m a

-- | getInconsistentQueryCollections is a helper function that runs the
--   static analysis over the saved queries and reports any inconsistenties
--   with the current schema.
getInconsistentQueryCollections :: SchemaIntrospection -> QueryCollections -> ((CollectionName, ListedQuery) -> MetadataObject) -> EndpointTrie GQLQueryWithText -> [NormalizedQuery] -> [InconsistentMetadata]
data StoredIntrospection
StoredIntrospection :: HashMap SourceName EncJSON -> HashMap RemoteSchemaName EncJSON -> StoredIntrospection
[siBackendIntrospection] :: StoredIntrospection -> HashMap SourceName EncJSON
[siRemotes] :: StoredIntrospection -> HashMap RemoteSchemaName EncJSON

-- | Represents remote schema or source introspection data to be persisted
--   in a storage (database).
data StoredIntrospectionItem
SourceIntrospectionItem :: SourceName -> EncJSON -> StoredIntrospectionItem
RemoteSchemaIntrospectionItem :: RemoteSchemaName -> EncJSON -> StoredIntrospectionItem

-- | Items to be collected while building schema cache See
--   @<tt>buildSchemaCacheRule</tt> for more details.
data CollectItem
CollectInconsistentMetadata :: InconsistentMetadata -> CollectItem
CollectMetadataDependency :: MetadataDependency -> CollectItem
CollectStoredIntrospection :: StoredIntrospectionItem -> CollectItem
instance GHC.Internal.Base.Monad m => GHC.Internal.Base.Applicative (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Hasura.RQL.Types.SchemaCache.CacheRM m => Hasura.RQL.Types.SchemaCache.CacheRM (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Hasura.RQL.Types.SchemaCache.Build.CacheRWM m => Hasura.RQL.Types.SchemaCache.Build.CacheRWM (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Hasura.RQL.Types.SchemaCache.Build.CacheRWM m => Hasura.RQL.Types.SchemaCache.Build.CacheRWM (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.RQL.Types.SchemaCache.Build.CacheRWM m => Hasura.RQL.Types.SchemaCache.Build.CacheRWM (Control.Monad.Trans.State.Strict.StateT s m)
instance Hasura.RQL.Types.SchemaCache.Build.CacheRWM m => Hasura.RQL.Types.SchemaCache.Build.CacheRWM (Hasura.Tracing.Monad.TraceT m)
instance Hasura.RQL.Types.SchemaCache.Build.CacheRWM m => Hasura.RQL.Types.SchemaCache.Build.CacheRWM (Database.PG.Query.Transaction.TxET Hasura.Base.Error.QErr m)
instance GHC.Classes.Eq Hasura.RQL.Types.SchemaCache.Build.BuildReason
instance GHC.Classes.Eq Hasura.RQL.Types.SchemaCache.Build.CollectItem
instance GHC.Classes.Eq Hasura.RQL.Types.SchemaCache.Build.MetadataDependency
instance GHC.Classes.Eq Hasura.RQL.Types.SchemaCache.Build.StoredIntrospection
instance GHC.Classes.Eq Hasura.RQL.Types.SchemaCache.Build.StoredIntrospectionItem
instance GHC.Classes.Eq Hasura.RQL.Types.SchemaCache.Build.ValidateNewSchemaCacheResult
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.SchemaCache.Build.CacheInvalidations
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.SchemaCache.Build.StoredIntrospection
instance GHC.Internal.Base.Functor m => GHC.Internal.Base.Functor (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.SchemaCache.Build.CacheInvalidations
instance GHC.Internal.Generics.Generic Hasura.RQL.Types.SchemaCache.Build.StoredIntrospection
instance Hasura.Server.Init.FeatureFlag.HasFeatureFlagChecker m => Hasura.Server.Init.FeatureFlag.HasFeatureFlagChecker (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Control.Monad.Morph.MFunctor Hasura.RQL.Types.SchemaCache.Build.MetadataT
instance GHC.Internal.Base.Monad m => Hasura.RQL.Types.Metadata.MetadataM (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Control.Monad.Trans.Control.MonadBaseControl b m => Control.Monad.Trans.Control.MonadBaseControl b (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Control.Monad.Base.MonadBase b m => Control.Monad.Base.MonadBase b (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Hasura.Server.Types.MonadGetPolicies m => Hasura.Server.Types.MonadGetPolicies (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance GHC.Internal.Base.Monad m => GHC.Internal.Base.Monad (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Hasura.QueryTags.MonadQueryTags m => Hasura.QueryTags.MonadQueryTags (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Hasura.Tracing.Class.MonadTraceContext m => Hasura.Tracing.Class.MonadTraceContext (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Hasura.Tracing.Class.MonadTrace m => Hasura.Tracing.Class.MonadTrace (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Control.Monad.Trans.Class.MonadTrans Hasura.RQL.Types.SchemaCache.Build.MetadataT
instance Hasura.Backends.Postgres.Connection.MonadTx.MonadTx m => Hasura.Backends.Postgres.Connection.MonadTx.MonadTx (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance GHC.Internal.Base.Monoid Hasura.RQL.Types.SchemaCache.Build.CacheInvalidations
instance GHC.Classes.Ord Hasura.RQL.Types.SchemaCache.Build.ValidateNewSchemaCacheResult
instance Hasura.Services.Network.ProvidesNetwork m => Hasura.Services.Network.ProvidesNetwork (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance GHC.Internal.Base.Semigroup Hasura.RQL.Types.SchemaCache.Build.CacheInvalidations
instance GHC.Internal.Show.Show Hasura.RQL.Types.SchemaCache.Build.BuildReason
instance GHC.Internal.Show.Show Hasura.RQL.Types.SchemaCache.Build.CollectItem
instance GHC.Internal.Show.Show Hasura.RQL.Types.SchemaCache.Build.MetadataDependency
instance GHC.Internal.Show.Show Hasura.RQL.Types.SchemaCache.Build.StoredIntrospectionItem
instance GHC.Internal.Show.Show Hasura.RQL.Types.SchemaCache.Build.ValidateNewSchemaCacheResult
instance Hasura.RQL.Types.SchemaCache.TableCoreInfoRM b m => Hasura.RQL.Types.SchemaCache.TableCoreInfoRM b (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.SchemaCache.Build.CacheInvalidations
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.SchemaCache.Build.StoredIntrospection
instance Hasura.Authentication.User.UserInfoM m => Hasura.Authentication.User.UserInfoM (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)


-- | This module defines the schema dependency gathering aspect of the
--   default implementation of aggregation predicates.
module Hasura.RQL.Types.SchemaCache.AggregationPredicates
defaultGetAggregationPredicateDeps :: forall (b :: BackendType). GetAggregationPredicatesDeps b => AggregationPredicatesImplementation b (PartialSQLExp b) -> BoolExpM b [SchemaDependency]

module Hasura.Backends.Postgres.Instances.SchemaCache
instance Hasura.RQL.Types.Backend.Backend ('Hasura.RQL.Types.BackendType.Postgres pgKind) => Hasura.RQL.Types.SchemaCacheTypes.GetAggregationPredicatesDeps ('Hasura.RQL.Types.BackendType.Postgres pgKind)

module Hasura.RQL.Types.SchemaCache.Instances

module Hasura.RQL.Types.Roles.Internal

-- | <a>CheckPermission</a> is a type which can be used to combine multiple
--   permissions when the permission type implements the
--   <tt>OnlyRelevantEq</tt> instance
data CheckPermission permissionType
CPUndefined :: CheckPermission permissionType
CPInconsistent :: CheckPermission permissionType
CPDefined :: permissionType -> CheckPermission permissionType

-- | CombineRolePermInfo acts as an intermediate type to be able to combine
--   multiple role permissions into one, using the <a>Monoid</a> instance.
--   Multiple role permissions are combined for inherited role permissions
--   where this is used.
data CombineRolePermInfo (b :: BackendType)
CombineRolePermInfo :: CheckPermission (InsPermInfo b) -> Maybe (CombinedSelPermInfo b) -> CheckPermission (UpdPermInfo b) -> CheckPermission (DelPermInfo b) -> CombineRolePermInfo (b :: BackendType)
[crpiInsPerm] :: CombineRolePermInfo (b :: BackendType) -> CheckPermission (InsPermInfo b)
[crpiSelPerm] :: CombineRolePermInfo (b :: BackendType) -> Maybe (CombinedSelPermInfo b)
[crpiUpdPerm] :: CombineRolePermInfo (b :: BackendType) -> CheckPermission (UpdPermInfo b)
[crpiDelPerm] :: CombineRolePermInfo (b :: BackendType) -> CheckPermission (DelPermInfo b)
rolePermInfoToCombineRolePermInfo :: forall (b :: BackendType). RolePermInfo b -> CombineRolePermInfo b
maybeToCheckPermission :: Maybe a -> CheckPermission a
instance GHC.Classes.Eq permissionType => GHC.Classes.Eq (Hasura.RQL.Types.Roles.Internal.CheckPermission permissionType)
instance Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq permissionType => GHC.Internal.Base.Monoid (Hasura.RQL.Types.Roles.Internal.CheckPermission permissionType)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Base.Monoid (Hasura.RQL.Types.Roles.Internal.CheckPermission (Hasura.Table.Cache.DelPermInfo b)), GHC.Internal.Base.Monoid (Hasura.RQL.Types.Roles.Internal.CheckPermission (Hasura.Table.Cache.InsPermInfo b)), GHC.Internal.Base.Monoid (Hasura.RQL.Types.Roles.Internal.CheckPermission (Hasura.Table.Cache.UpdPermInfo b)), GHC.Internal.Base.Monoid (GHC.Internal.Maybe.Maybe (Hasura.Table.Cache.CombinedSelPermInfo b))) => GHC.Internal.Base.Monoid (Hasura.RQL.Types.Roles.Internal.CombineRolePermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.OpExpG b a), Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (Hasura.RQL.IR.BoolExp.AnnBoolExp b a), Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (Hasura.RQL.IR.BoolExp.AnnComputedFieldBoolExp b a)) => Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (Hasura.RQL.IR.BoolExp.AnnBoolExpFld b a)
instance GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnComputedFieldBoolExp b a) => Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (Hasura.RQL.IR.BoolExp.AnnComputedFieldBoolExp b a)
instance Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (Hasura.RQL.IR.BoolExp.GBoolExp b (Hasura.RQL.IR.BoolExp.AnnBoolExpFld b v)) => Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (Hasura.RQL.IR.BoolExp.AnnRedactionExp b v)
instance (Hasura.RQL.Types.Backend.Backend b, Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b)) => Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (Hasura.Table.Cache.DelPermInfo b)
instance Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq Language.GraphQL.Draft.Syntax.EnumTypeDefinition
instance Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq Language.GraphQL.Draft.Syntax.EnumValueDefinition
instance (Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq a, GHC.Classes.Ord a) => Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (Language.GraphQL.Draft.Syntax.FieldDefinition a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable a) => Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (Hasura.RQL.IR.BoolExp.GBoolExp b a)
instance (Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq a, GHC.Classes.Ord a) => Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (Language.GraphQL.Draft.Syntax.InputObjectTypeDefinition a)
instance Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq Language.GraphQL.Draft.Syntax.InputValueDefinition
instance (Hasura.RQL.Types.Backend.Backend b, Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b)) => Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (Hasura.Table.Cache.InsPermInfo b)
instance (Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq a, GHC.Classes.Ord a) => Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (Language.GraphQL.Draft.Syntax.InterfaceTypeDefinition [Language.GraphQL.Draft.Syntax.Name.Name] a)
instance Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq Hasura.RemoteSchema.SchemaCache.Types.IntrospectionResult
instance Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq a => Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq [a]
instance Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq a => Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (GHC.Internal.Maybe.Maybe a)
instance Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq Language.GraphQL.Draft.Syntax.Name.Name
instance (Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq a, GHC.Classes.Ord a) => Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (Language.GraphQL.Draft.Syntax.ObjectTypeDefinition a)
instance Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaInputValueDefinition
instance Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaIntrospection
instance Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq Language.GraphQL.Draft.Syntax.ScalarTypeDefinition
instance (Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq a, GHC.Classes.Ord a) => Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (Language.GraphQL.Draft.Syntax.TypeDefinition [Language.GraphQL.Draft.Syntax.Name.Name] a)
instance Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq Language.GraphQL.Draft.Syntax.UnionTypeDefinition
instance (Hasura.RQL.Types.Backend.Backend b, Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b)) => Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (Hasura.Table.Cache.UpdPermInfo b)
instance Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq permissionType => GHC.Internal.Base.Semigroup (Hasura.RQL.Types.Roles.Internal.CheckPermission permissionType)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Base.Semigroup (Hasura.RQL.Types.Roles.Internal.CheckPermission (Hasura.Table.Cache.DelPermInfo b)), GHC.Internal.Base.Semigroup (Hasura.RQL.Types.Roles.Internal.CheckPermission (Hasura.Table.Cache.InsPermInfo b)), GHC.Internal.Base.Semigroup (Hasura.RQL.Types.Roles.Internal.CheckPermission (Hasura.Table.Cache.UpdPermInfo b)), GHC.Internal.Base.Semigroup (Hasura.Table.Cache.CombinedSelPermInfo b)) => GHC.Internal.Base.Semigroup (Hasura.RQL.Types.Roles.Internal.CombineRolePermInfo b)
instance GHC.Internal.Show.Show permissionType => GHC.Internal.Show.Show (Hasura.RQL.Types.Roles.Internal.CheckPermission permissionType)

module Hasura.GraphQL.Transport.WebSocket.Server
data AcceptWith a
AcceptWith :: !a -> !AcceptRequest -> !WSConn a -> IO () -> !WSConn a -> IO () -> AcceptWith a

-- | aka generalized <a>ServerApp</a> over <tt>m</tt>, which takes an
--   IPAddress
type HasuraServerApp (m :: Type -> Type) = IpAddress -> PendingConnection -> m ()

-- | Websocket message and other details
data MessageDetails
MessageDetails :: !SerializableBlob -> !Int64 -> MessageDetails
class Monad m => MonadWSLog (m :: Type -> Type)

-- | Takes WS server log data and logs it logWSServer
logWSLog :: MonadWSLog m => Logger Hasura -> WSLog -> m ()
type OnConnH (m :: Type -> Type) a = WSId -> RequestHead -> IpAddress -> WSActions a -> m Either RejectRequest AcceptWith a

-- | Used for specific actions within the <tt>onConn</tt> and
--   <tt>onMessage</tt> handlers
data WSActions a
WSActions :: !WSPostExecErrMessageAction a -> !WSOnErrorMessageAction a -> !WSCloseConnAction a -> !WSKeepAliveMessageAction a -> !DataMsg -> ServerMsg -> !AcceptRequest -> ![Encoding] -> Encoding -> WSActions a
[_wsaPostExecErrMessageAction] :: WSActions a -> !WSPostExecErrMessageAction a
[_wsaOnErrorMessageAction] :: WSActions a -> !WSOnErrorMessageAction a
[_wsaConnectionCloseAction] :: WSActions a -> !WSCloseConnAction a

-- | NOTE: keep alive action was made redundant because we need to send
--   this message after the connection has been successfully established
--   after <tt>connection_init</tt>
[_wsaKeepAliveAction] :: WSActions a -> !WSKeepAliveMessageAction a
[_wsaGetDataMessageType] :: WSActions a -> !DataMsg -> ServerMsg
[_wsaAcceptRequest] :: WSActions a -> !AcceptRequest
[_wsaErrorMsgFormat] :: WSActions a -> ![Encoding] -> Encoding
data WSConn a
data WSErrorMessage
ClientMessageParseFailed :: WSErrorMessage
ConnInitFailed :: WSErrorMessage
data WSEvent
EMessageSent :: !MessageDetails -> WSEvent
data WSEventInfo
WSEventInfo :: !Maybe ServerMsgType -> !Maybe OperationId -> !Maybe OperationName -> !Maybe Double -> !Maybe Int64 -> !Maybe ParameterizedQueryHash -> WSEventInfo
[_wseiEventType] :: WSEventInfo -> !Maybe ServerMsgType
[_wseiOperationId] :: WSEventInfo -> !Maybe OperationId
[_wseiOperationName] :: WSEventInfo -> !Maybe OperationName
[_wseiQueryExecutionTime] :: WSEventInfo -> !Maybe Double
[_wseiResponseSize] :: WSEventInfo -> !Maybe Int64
[_wseiParameterizedQueryHash] :: WSEventInfo -> !Maybe ParameterizedQueryHash

-- | NOTE: The types of <a>_hOnConn</a> and <a>_hOnMessage</a> were updated
--   from <a>OnConnH</a> and <tt>OnMessageH</tt> because we needed to pass
--   the subprotcol here to these methods to eventually get to
--   <a>OnConnH</a> and <tt>OnMessageH</tt>. Please see
--   <a>createServerApp</a> to get a better understanding of how these
--   handlers are used.
data WSHandlers (m :: Type -> Type) a
WSHandlers :: (WSId -> RequestHead -> IpAddress -> WSSubProtocol -> m (Either RejectRequest (AcceptWith a))) -> (WSConn a -> ByteString -> WSSubProtocol -> m ()) -> OnCloseH m a -> WSHandlers (m :: Type -> Type) a
data WSId

-- | These set of functions or message handlers is used by the server while
--   communicating with the client. They are particularly useful for the
--   case when the messages being sent to the client are different for each
--   of the sub-protocol(s) supported by the server.
type WSKeepAliveMessageAction a = WSConn a -> IO ()
data WSLog
WSLog :: !WSId -> !WSEvent -> !Maybe WSEventInfo -> WSLog
type WSOnErrorMessageAction a = WSConn a -> ConnErrMsg -> WSErrorMessage -> IO ()
data WSQueueResponse
WSQueueResponse :: ByteString -> Maybe WSEventInfo -> IO DiffTime -> WSQueueResponse
data WSServer a
WSServer :: Logger Hasura -> TVar SecuritySensitiveUserConfig -> TVar (ServerStatus a) -> WSServer a
[_wssLogger] :: WSServer a -> Logger Hasura

-- | Keep track of the security sensitive user configuration to perform
--   maintenance actions
[_wssSecuritySensitiveUserConfig] :: WSServer a -> TVar SecuritySensitiveUserConfig

-- | See e.g. createServerApp.onAccept for how we use STM to preserve
--   consistency
[_wssStatus] :: WSServer a -> TVar (ServerStatus a)

-- | The background thread responsible for closing all websocket
--   connections when security sensitive user configuration changes. It
--   checks for changes in the auth mode, allowlist, cors config, stringify
--   num, dangerous boolean collapse, stringify big query numeric,
--   experimental features and invalidates/closes all connections if there
--   are any changes.
websocketConnectionReaper :: IO (AuthMode, AllowListStatus, CorsPolicy, SQLGenCtx, HashSet ExperimentalFeature, NamingCase) -> IO SchemaCache -> WSServer a -> IO Void
closeConn :: WSConn a -> ByteString -> IO ()
sendMsgAndCloseConn :: WSConn a -> Word16 -> ByteString -> ServerMsg -> IO ()
createServerApp :: (MonadIO m, MonadBaseControl IO m, Forall (Pure m), MonadWSLog m, MonadGetPolicies m) => IO MetricsConfig -> WSConnectionInitTimeout -> WSServer a -> PrometheusMetrics -> WSHandlers m a -> HasuraServerApp m
createWSServer :: AuthMode -> AllowListStatus -> InlinedAllowlist -> CorsPolicy -> SQLGenCtx -> HashSet ExperimentalFeature -> NamingCase -> Logger Hasura -> STM (WSServer a)
closeAllConnectionsWithReason :: WSServer a -> String -> ByteString -> (SecuritySensitiveUserConfig -> SecuritySensitiveUserConfig) -> IO ()
getData :: WSConn a -> a
getRawWebSocketConnection :: WSConn a -> Connection
getWSId :: WSConn a -> WSId
setConnInitialized :: WSConn a -> IO ()
mkWSServerErrorCode :: WSSubProtocol -> WSErrorMessage -> ConnErrMsg -> ServerErrorCode
sendMsg :: WSConn a -> WSQueueResponse -> IO ()
shutdown :: WSServer a -> IO ()
mkUnsafeWSId :: UUID -> WSId
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.Server.WSEventInfo
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.Server.WSId
instance Data.Hashable.Class.Hashable Hasura.GraphQL.Transport.WebSocket.Server.WSId
instance Hasura.GraphQL.Transport.WebSocket.Server.MonadWSLog m => Hasura.GraphQL.Transport.WebSocket.Server.MonadWSLog (Control.Monad.Trans.Except.ExceptT e m)
instance Hasura.GraphQL.Transport.WebSocket.Server.MonadWSLog m => Hasura.GraphQL.Transport.WebSocket.Server.MonadWSLog (Control.Monad.Trans.Reader.ReaderT r m)
instance GHC.Internal.Show.Show Hasura.GraphQL.Transport.WebSocket.Server.MessageDetails
instance GHC.Internal.Show.Show Hasura.GraphQL.Transport.WebSocket.Server.WSEvent
instance GHC.Internal.Show.Show Hasura.GraphQL.Transport.WebSocket.Server.WSEventInfo
instance GHC.Internal.Show.Show Hasura.GraphQL.Transport.WebSocket.Server.WSId
instance GHC.Internal.Show.Show Hasura.GraphQL.Transport.WebSocket.Server.WSLog
instance GHC.Internal.Show.Show Hasura.GraphQL.Transport.WebSocket.Server.WSReaperThreadLog
instance Hasura.Logging.ToEngineLog Hasura.GraphQL.Transport.WebSocket.Server.WSLog Hasura.Logging.Hasura
instance Hasura.Logging.ToEngineLog Hasura.GraphQL.Transport.WebSocket.Server.WSReaperThreadLog Hasura.Logging.Hasura
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.Server.MessageDetails
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.Server.WSEvent
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.Server.WSEventInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.Server.WSId
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.Server.WSLog


-- | Multiplexed subscription poller threads; see
--   <a>Hasura.GraphQL.Execute.Subscription</a> for details.
module Hasura.GraphQL.Execute.Subscription.Poll.Common

-- | A unique, multiplexed query. Each <a>Poller</a> has its own polling
--   thread that periodically polls Postgres and pushes results to each of
--   its listening <a>Cohort</a>s.
--   
--   In SQL, an <a>Poller</a> corresponds to a single, multiplexed query,
--   though in practice, <a>Poller</a>s with large numbers of
--   <a>Cohort</a>s are batched into multiple concurrent queries for
--   performance reasons.
data Poller streamCursor
Poller :: CohortMap streamCursor -> TVar PollerResponseState -> TMVar PollerIOState -> ParameterizedQueryHash -> TMap (Maybe OperationName) Int -> Poller streamCursor
[_pCohorts] :: Poller streamCursor -> CohortMap streamCursor
[_pPollerState] :: Poller streamCursor -> TVar PollerResponseState

-- | This is in a separate <a>TMVar</a> because it’s important that we are
--   able to construct <a>Poller</a> values in <a>STM</a> --- we need the
--   insertion into the <a>PollerMap</a> to be atomic to ensure that we
--   don’t accidentally create two for the same query due to a race.
--   However, we can’t spawn the worker thread or create the metrics store
--   in <a>STM</a>, so we insert it into the <a>Poller</a> only after we’re
--   certain we won’t create any duplicates.
--   
--   This var is "write once", moving monotonically from empty to full.
--   TODO this could probably be tightened up to something like 'STM
--   PollerIOState'
[_pIOState] :: Poller streamCursor -> TMVar PollerIOState
[_pParameterizedQueryHash] :: Poller streamCursor -> ParameterizedQueryHash
[_pOperationNamesMap] :: Poller streamCursor -> TMap (Maybe OperationName) Int

-- | An ID to track unique <a>Poller</a>s, so that we can gather metrics
--   about each poller
newtype PollerId
PollerId :: UUID -> PollerId
[unPollerId] :: PollerId -> UUID
data PollerIOState
PollerIOState :: !Thread -> !PollerId -> PollerIOState

-- | a handle on the poller’s worker thread that can be used to <a>stop</a>
--   it if all its cohorts stop listening
[_pThread] :: PollerIOState -> !Thread
[_pId] :: PollerIOState -> !PollerId
data PollerKey (b :: BackendType)
PollerKey :: SourceName -> RoleName -> Text -> ResolvedConnectionTemplate b -> ParameterizedQueryHash -> PollerKey (b :: BackendType)
[_lgSource] :: PollerKey (b :: BackendType) -> SourceName
[_lgRole] :: PollerKey (b :: BackendType) -> RoleName
[_lgQuery] :: PollerKey (b :: BackendType) -> Text
[_lgConnectionKey] :: PollerKey (b :: BackendType) -> ResolvedConnectionTemplate b
[_lgParameterizedQueryHash] :: PollerKey (b :: BackendType) -> ParameterizedQueryHash
newtype BackendPollerKey
BackendPollerKey :: AnyBackend PollerKey -> BackendPollerKey
[unBackendPollerKey] :: BackendPollerKey -> AnyBackend PollerKey
type PollerMap streamCursor = Map BackendPollerKey Poller streamCursor

-- | For dev debugging, output subject to change.
dumpPollerMap :: Bool -> PollerMap streamCursor -> IO Value
data PollDetailsError
PollDetailsError :: BatchId -> QErr -> PollDetailsError
[_pdeBatchId] :: PollDetailsError -> BatchId
[_pdeErrorDetails] :: PollDetailsError -> QErr
data PollDetails
PollDetails :: PollerId -> SubscriptionType -> Text -> DiffTime -> [BatchExecutionDetails] -> DiffTime -> SubscriptionsOptions -> SourceName -> RoleName -> ParameterizedQueryHash -> LogLevel -> Maybe [PollDetailsError] -> PollDetails

-- | the unique ID (basically a thread that run as a <a>Poller</a>) for the
--   <a>Poller</a>
[_pdPollerId] :: PollDetails -> PollerId

-- | distinguish between the subscription type (i.e. live-query or
--   streaming subscription)
[_pdKind] :: PollDetails -> SubscriptionType

-- | the multiplexed SQL query to be run against the database with all the
--   variables together
[_pdGeneratedSql] :: PollDetails -> Text

-- | the time taken to get a snapshot of cohorts from our
--   <tt>SubscriptionsState</tt> data structure
[_pdSnapshotTime] :: PollDetails -> DiffTime

-- | list of execution batches and their details
[_pdBatches] :: PollDetails -> [BatchExecutionDetails]

-- | total time spent on a poll cycle
[_pdTotalTime] :: PollDetails -> DiffTime
[_pdLiveQueryOptions] :: PollDetails -> SubscriptionsOptions
[_pdSource] :: PollDetails -> SourceName
[_pdRole] :: PollDetails -> RoleName
[_pdParameterizedQueryHash] :: PollDetails -> ParameterizedQueryHash
[_pdLogLevel] :: PollDetails -> LogLevel
[_pdErrors] :: PollDetails -> Maybe [PollDetailsError]

-- | Execution information related to a single batched execution
data BatchExecutionDetails
BatchExecutionDetails :: Maybe DiffTime -> DiffTime -> DiffTime -> BatchId -> [CohortExecutionDetails] -> Maybe Int -> BatchExecutionDetails

-- | postgres execution time of each batch (<a>Nothing</a> in case of
--   non-PG dbs)
[_bedPgExecutionTime] :: BatchExecutionDetails -> Maybe DiffTime

-- | database execution time of each batch
[_bedDbExecutionTime] :: BatchExecutionDetails -> DiffTime

-- | time to taken to push to all cohorts belonging to this batch
[_bedPushTime] :: BatchExecutionDetails -> DiffTime

-- | id of the batch
[_bedBatchId] :: BatchExecutionDetails -> BatchId

-- | execution details of the cohorts belonging to this batch
[_bedCohorts] :: BatchExecutionDetails -> [CohortExecutionDetails]
[_bedBatchResponseSizeBytes] :: BatchExecutionDetails -> Maybe Int

-- | Execution information related to a cohort on a poll cycle
data CohortExecutionDetails
CohortExecutionDetails :: !CohortId -> !CohortVariables -> !Maybe Int -> ![SubscriberExecutionDetails] -> ![SubscriberExecutionDetails] -> !BatchId -> CohortExecutionDetails
[_cedCohortId] :: CohortExecutionDetails -> !CohortId
[_cedVariables] :: CohortExecutionDetails -> !CohortVariables

-- | Nothing in case of an error
[_cedResponseSize] :: CohortExecutionDetails -> !Maybe Int

-- | The response on this cycle has been pushed to these above subscribers
--   New subscribers (those which haven't been around during the previous
--   poll cycle) will always be part of this
[_cedPushedTo] :: CohortExecutionDetails -> ![SubscriberExecutionDetails]

-- | The response on this cycle has *not* been pushed to these above
--   subscribers. This would when the response hasn't changed from the
--   previous polled cycle
[_cedIgnored] :: CohortExecutionDetails -> ![SubscriberExecutionDetails]
[_cedBatchId] :: CohortExecutionDetails -> !BatchId
type SubscriptionPostPollHook = PollDetails -> IO ()
defaultSubscriptionPostPollHook :: Logger Hasura -> SubscriptionPostPollHook
data PollerResponseState
PRSSuccess :: PollerResponseState
PRSError :: PollerResponseState

-- | A batched group of <a>Subscriber</a>s who are not only listening to
--   the same query but also have identical session and query variables.
--   Each result pushed to a <a>Cohort</a> is forwarded along to each of
--   its <a>Subscriber</a>s.
--   
--   In SQL, each <a>Cohort</a> corresponds to a single row in the
--   laterally-joined <tt>_subs</tt> table (and therefore a single row in
--   the query result).
--   
--   See also <a>CohortMap</a>.
data Cohort streamCursorVars
Cohort :: CohortId -> TVar (Maybe ResponseHash) -> SubscriberMap -> SubscriberMap -> streamCursorVars -> Cohort streamCursorVars

-- | a unique identifier used to identify the cohort in the generated query
[_cCohortId] :: Cohort streamCursorVars -> CohortId

-- | Contains a hash of the previous poll's DB query result, if any, used
--   to determine if we need to push an updated result to the subscribers
--   or not.
[_cPreviousResponse] :: Cohort streamCursorVars -> TVar (Maybe ResponseHash)

-- | the subscribers we’ve already pushed a result to; we push new results
--   to them if the response changes
[_cExistingSubscribers] :: Cohort streamCursorVars -> SubscriberMap

-- | subscribers we haven’t yet pushed any results to; we push results to
--   them regardless if the result changed, then merge them in the map of
--   existing subscribers
[_cNewSubscribers] :: Cohort streamCursorVars -> SubscriberMap

-- | a mutable type which holds the latest value of the subscription stream
--   cursor. In case of live query subscription, this field is ignored by
--   setting <tt>streamCursorVars</tt> to <tt>()</tt>
[_cStreamCursorVariables] :: Cohort streamCursorVars -> streamCursorVars
data CohortSnapshot
CohortSnapshot :: CohortVariables -> TVar (Maybe ResponseHash) -> [Subscriber] -> [Subscriber] -> CohortSnapshot
[_csVariables] :: CohortSnapshot -> CohortVariables
[_csPreviousResponse] :: CohortSnapshot -> TVar (Maybe ResponseHash)
[_csExistingSubscribers] :: CohortSnapshot -> [Subscriber]
[_csNewSubscribers] :: CohortSnapshot -> [Subscriber]
newtype CursorVariableValues
CursorVariableValues :: HashMap Name TxtEncodedVal -> CursorVariableValues
data CohortId
newCohortId :: MonadIO m => m CohortId
data CohortVariables

-- | A key we use to determine if two <a>Subscriber</a>s belong in the same
--   <a>Cohort</a> (assuming they already meet the criteria to be in the
--   same <a>Poller</a>). Note the distinction between this and
--   <a>CohortId</a>; the latter is a completely synthetic key used only to
--   identify the cohort in the generated SQL query.
type CohortKey = CohortVariables

-- | This has the invariant, maintained in <tt>removeLiveQuery</tt>, that
--   it contains no <a>Cohort</a> with zero total (existing + new)
--   subscribers.
type CohortMap streamCursor = TMap CohortKey Cohort streamCursor
data Subscriber
Subscriber :: !SubscriberId -> !SubscriberMetadata -> !RequestId -> !Maybe OperationName -> !OnChange -> Subscriber
[_sId] :: Subscriber -> !SubscriberId
[_sMetadata] :: Subscriber -> !SubscriberMetadata
[_sRequestId] :: Subscriber -> !RequestId
[_sOperationName] :: Subscriber -> !Maybe OperationName
[_sOnChangeCallback] :: Subscriber -> !OnChange
data SubscriberId
newSubscriberId :: IO SubscriberId

-- | Allows a user of the live query subsystem (currently websocket
--   transport) to attach arbitrary metadata about a subscriber. This
--   information is available as part of Subscriber in
--   CohortExecutionDetails and can be logged by customizing in pollerlog
data SubscriberMetadata
mkSubscriberMetadata :: WSId -> OperationId -> Maybe OperationName -> RequestId -> SubscriberMetadata
unSubscriberMetadata :: SubscriberMetadata -> Value
type SubscriberMap = TMap SubscriberId Subscriber
type OnChange = SubscriptionGQResponse -> IO ()
type SubscriptionGQResponse = GQResult SubscriptionResponse
data SubscriptionResponse
SubscriptionResponse :: !ByteString -> !DiffTime -> SubscriptionResponse
[_lqrPayload] :: SubscriptionResponse -> !ByteString
[_lqrExecutionTime] :: SubscriptionResponse -> !DiffTime

-- | Subscription onChange metadata, used for adding more extra analytics
--   data
data SubscriptionMetadata
SubscriptionMetadata :: !DiffTime -> SubscriptionMetadata
[_sqmExecutionTime] :: SubscriptionMetadata -> !DiffTime
data SubscriberExecutionDetails
SubscriberExecutionDetails :: !SubscriberId -> !SubscriberMetadata -> SubscriberExecutionDetails
[_sedSubscriberId] :: SubscriberExecutionDetails -> !SubscriberId
[_sedSubscriberMetadata] :: SubscriberExecutionDetails -> !SubscriberMetadata

-- | The <tt>BatchId</tt> is a number based ID to uniquely identify a batch
--   in a single poll and it's used to identify the batch to which a cohort
--   belongs to.
newtype BatchId
BatchId :: Int -> BatchId
[_unBatchId] :: BatchId -> Int

-- | A hash used to determine if the result changed without having to keep
--   the entire result in memory. Using a cryptographic hash ensures that a
--   hash collision is almost impossible: with 256 bits, even if a
--   subscription changes once per second for an entire year, the
--   probability of a hash collision is ~4.294417×10-63. See Note [Blake2b
--   faster than SHA-256].
newtype ResponseHash
ResponseHash :: Digest Blake2b_256 -> ResponseHash
[unResponseHash] :: ResponseHash -> Digest Blake2b_256
mkRespHash :: ByteString -> ResponseHash
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Poll.Common.BackendPollerKey
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Poll.Common.BatchExecutionDetails
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Poll.Common.BatchId
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Poll.Common.CohortExecutionDetails
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Poll.Common.PollDetails
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Poll.Common.PollDetailsError
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Poll.Common.PollerId
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.GraphQL.Execute.Subscription.Poll.Common.PollerKey b)
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Poll.Common.PollerResponseState
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Poll.Common.ResponseHash
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Poll.Common.SubscriberExecutionDetails
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Poll.Common.SubscriberId
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Poll.Common.SubscriberMetadata
instance GHC.Internal.Generics.Generic Hasura.GraphQL.Execute.Subscription.Poll.Common.PollerId
instance GHC.Internal.Generics.Generic (Hasura.GraphQL.Execute.Subscription.Poll.Common.PollerKey b)
instance GHC.Internal.Generics.Generic Hasura.GraphQL.Execute.Subscription.Poll.Common.SubscriberId
instance Data.Hashable.Class.Hashable Hasura.GraphQL.Execute.Subscription.Poll.Common.BackendPollerKey
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.GraphQL.Execute.Subscription.Poll.Common.PollerKey b)
instance Data.Hashable.Class.Hashable Hasura.GraphQL.Execute.Subscription.Poll.Common.SubscriberId
instance GHC.Internal.Show.Show Hasura.GraphQL.Execute.Subscription.Poll.Common.BackendPollerKey
instance GHC.Internal.Show.Show Hasura.GraphQL.Execute.Subscription.Poll.Common.BatchExecutionDetails
instance GHC.Internal.Show.Show Hasura.GraphQL.Execute.Subscription.Poll.Common.BatchId
instance GHC.Internal.Show.Show Hasura.GraphQL.Execute.Subscription.Poll.Common.CohortExecutionDetails
instance GHC.Internal.Show.Show Hasura.GraphQL.Execute.Subscription.Poll.Common.PollDetails
instance GHC.Internal.Show.Show Hasura.GraphQL.Execute.Subscription.Poll.Common.PollDetailsError
instance GHC.Internal.Show.Show Hasura.GraphQL.Execute.Subscription.Poll.Common.PollerId
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.GraphQL.Execute.Subscription.Poll.Common.PollerKey b)
instance GHC.Internal.Show.Show Hasura.GraphQL.Execute.Subscription.Poll.Common.ResponseHash
instance GHC.Internal.Show.Show Hasura.GraphQL.Execute.Subscription.Poll.Common.SubscriberExecutionDetails
instance GHC.Internal.Show.Show Hasura.GraphQL.Execute.Subscription.Poll.Common.SubscriberId
instance GHC.Internal.Show.Show Hasura.GraphQL.Execute.Subscription.Poll.Common.SubscriberMetadata
instance Hasura.Logging.ToEngineLog Hasura.GraphQL.Execute.Subscription.Poll.Common.PollDetails Hasura.Logging.Hasura
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Subscription.Poll.Common.BatchId
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Subscription.Poll.Common.PollDetailsError
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Subscription.Poll.Common.PollerId
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.GraphQL.Execute.Subscription.Poll.Common.PollerKey b)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Subscription.Poll.Common.ResponseHash
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Subscription.Poll.Common.SubscriberId
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Subscription.Poll.Common.SubscriberMetadata

module Hasura.GraphQL.Execute.Subscription.Types
class SubscriptionTypes (s :: SubscriptionType) where {
    type Cohort (s :: SubscriptionType);
    type CohortSnapshot (s :: SubscriptionType);
    type CohortMap (s :: SubscriptionType);
    type Poller (s :: SubscriptionType);
    type PollerMap (s :: SubscriptionType);
}
instance Hasura.GraphQL.Execute.Subscription.Types.SubscriptionTypes 'Hasura.RQL.Types.Subscription.LiveQuery
instance Hasura.GraphQL.Execute.Subscription.Types.SubscriptionTypes 'Hasura.RQL.Types.Subscription.Streaming

module Hasura.GraphQL.Schema.Common

-- | Aggregation of contextual information required to build the schema.
data SchemaContext
SchemaContext :: SchemaKind -> RemoteRelationshipParserBuilder -> RoleName -> SchemaSampledFeatureFlags -> SchemaContext

-- | the kind of schema being built
[scSchemaKind] :: SchemaContext -> SchemaKind

-- | how to process remote relationships
[scRemoteRelationshipParserBuilder] :: SchemaContext -> RemoteRelationshipParserBuilder

-- | the role for which the schema is being built
[scRole] :: SchemaContext -> RoleName
[scSampledFeatureFlags] :: SchemaContext -> SchemaSampledFeatureFlags

-- | We want to be able to probe feature flags in the schema parsers, but
--   we also want to be able to run schema actions without requiring IO, in
--   part because we want to be able to run them in tests and in part
--   because we want some assurance that the schema we parse doesn't change
--   without our knowledge, as that precludes safely caching schema
--   introspection.
newtype SchemaSampledFeatureFlags
SchemaSampledFeatureFlags :: [(FeatureFlag, Bool)] -> SchemaSampledFeatureFlags
sampleFeatureFlags :: CheckFeatureFlag -> IO SchemaSampledFeatureFlags

-- | Monad transformer that lets you use the sampled feature flags from a
--   reader environment. This is necessary because we want 'ReaderT r m` to
--   be transparent wrt. 'HasFeatureFlagChecker m'.
data WithSchemaSampledFeatureFlags (m :: Type -> Type) a
withSchemaSampledFeatureFlags :: SchemaSampledFeatureFlags -> WithSchemaSampledFeatureFlags m a -> m a

-- | The kind of schema we're building, and its associated options.
data SchemaKind
HasuraSchema :: SchemaKind
RelaySchema :: NodeInterfaceParserBuilder -> SchemaKind

-- | How a remote relationship field should be processed when building a
--   schema. Injecting this function from the top level avoids having to
--   know how to do top-level dispatch from deep within the schema code.
--   
--   Note: the inner function type uses an existential qualifier: it is
--   expected that the given function will work for _any_ monad <tt>m</tt>
--   that has the relevant constraints. This prevents us from passing a
--   function that is specfic to the monad in which the schema construction
--   will run, but avoids having to propagate type annotations to each call
--   site.
newtype RemoteRelationshipParserBuilder
RemoteRelationshipParserBuilder :: (forall lhsJoinField r (n :: Type -> Type) (m :: Type -> Type). MonadBuildSchemaBase m n => RemoteFieldInfo lhsJoinField -> SchemaT r m (Maybe [FieldParser n (RemoteRelationshipField UnpreparedValue)])) -> RemoteRelationshipParserBuilder

-- | How to build the <tt>Relay</tt> node.
--   
--   Similarly to what we do for remote relationships, we pass in the
--   context the builder function required to build the <tt>Node</tt>
--   interface, in order to avoid the cross-sources cycles it creates
--   otherwise.
newtype NodeInterfaceParserBuilder
NodeInterfaceParserBuilder :: (forall (m :: Type -> Type) (n :: Type -> Type). MonadBuildSchemaBase m n => SchemaContext -> SchemaOptions -> m (Parser 'Output n NodeMap)) -> NodeInterfaceParserBuilder
[runNodeBuilder] :: NodeInterfaceParserBuilder -> forall (m :: Type -> Type) (n :: Type -> Type). MonadBuildSchemaBase m n => SchemaContext -> SchemaOptions -> m (Parser 'Output n NodeMap)

-- | The set of common constraints required to build the schema.
type MonadBuildSchemaBase (m :: Type -> Type) (n :: Type -> Type) = (MonadError QErr m, MonadMemoize m, MonadParse n)
retrieve :: (MonadReader r m, Has a r) => (a -> b) -> m b

-- | The monad in which the schema is built.
--   
--   The implementation of <a>SchemaT</a> is intended to be opaque: running
--   a computation in <a>SchemaT</a> is intended to be done via calls to
--   <a>runSourceSchema</a> and <a>runRemoteSchema</a>, which also enforce
--   what the <tt>r</tt> parameter should be in each case.
--   
--   The reason why we want to enforce that the schema is built in a reader
--   on top of an arbitrary base monad is for performance: see Note
--   [SchemaT and stacking] for more information.
--   
--   In the future, we might monomorphize this further to make
--   <tt>MemoizeT</tt> explicit.
newtype SchemaT r (m :: Type -> Type) a
SchemaT :: ReaderT r m a -> SchemaT r (m :: Type -> Type) a
[runSchemaT] :: SchemaT r (m :: Type -> Type) a -> ReaderT r m a
type MonadBuildSourceSchema (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type) = (MonadBuildSchemaBase m n, Has SchemaContext r, Has SchemaOptions r, Has SourceInfo b r)
type MonadBuildRemoteSchema r (m :: Type -> Type) (n :: Type -> Type) = (MonadBuildSchemaBase m n, Has SchemaContext r, Has RemoteNullForwardingPolicy r, Has CustomizeRemoteFieldName r, Has MkTypename r)
type MonadBuildActionSchema r (m :: Type -> Type) (n :: Type -> Type) = (MonadBuildSchemaBase m n, Has SchemaContext r, Has SchemaOptions r)

-- | Runs a schema-building computation with all the context required to
--   build a source.
runSourceSchema :: forall (b :: BackendType) m a. SchemaContext -> SchemaOptions -> SourceInfo b -> SchemaT (SchemaContext, SchemaOptions, SourceInfo b) m a -> m a

-- | Runs a schema-building computation with all the context required to
--   build a remote schema.
runRemoteSchema :: SchemaContext -> RemoteNullForwardingPolicy -> SchemaT (SchemaContext, RemoteNullForwardingPolicy, MkTypename, CustomizeRemoteFieldName) m a -> m a

-- | Runs a schema-building computation with all the context required to
--   build actions.
runActionSchema :: SchemaContext -> SchemaOptions -> SchemaT (SchemaContext, SchemaOptions) m a -> m a

-- | A <a>RemoteRelationshipParserBuilder</a> that ignores the field
--   altogether, that can be used in tests or to build a source or remote
--   schema in isolation.
ignoreRemoteRelationship :: RemoteRelationshipParserBuilder
isHasuraSchema :: SchemaKind -> Bool
type AggSelectExp (b :: BackendType) = AnnAggregateSelectG b RemoteRelationshipField UnpreparedValue UnpreparedValue b
type AnnotatedField (b :: BackendType) = AnnFieldG b RemoteRelationshipField UnpreparedValue UnpreparedValue b
type AnnotatedFields (b :: BackendType) = AnnFieldsG b RemoteRelationshipField UnpreparedValue UnpreparedValue b
type ConnectionFields (b :: BackendType) = ConnectionFields b RemoteRelationshipField UnpreparedValue UnpreparedValue b
type ConnectionSelectExp (b :: BackendType) = ConnectionSelect b RemoteRelationshipField UnpreparedValue UnpreparedValue b
type AnnotatedActionField = ActionFieldG RemoteRelationshipField UnpreparedValue
type AnnotatedActionFields = ActionFieldsG RemoteRelationshipField UnpreparedValue
type AnnotatedNestedObjectSelect (b :: BackendType) = AnnNestedObjectSelectG b RemoteRelationshipField UnpreparedValue UnpreparedValue b
type AnnotatedNestedArraySelect (b :: BackendType) = AnnNestedArraySelectG b RemoteRelationshipField UnpreparedValue UnpreparedValue b
type EdgeFields (b :: BackendType) = EdgeFields b RemoteRelationshipField UnpreparedValue UnpreparedValue b

-- | Whether the request is sent with
--   `x-hasura-use-backend-only-permissions` set to <tt>true</tt>.
data Scenario
Backend :: Scenario
Frontend :: Scenario
type SelectArgs (b :: BackendType) = SelectArgsG b UnpreparedValue b
type SelectStreamArgs (b :: BackendType) = SelectStreamArgsG b UnpreparedValue b
type SelectExp (b :: BackendType) = AnnSimpleSelectG b RemoteRelationshipField UnpreparedValue UnpreparedValue b
type StreamSelectExp (b :: BackendType) = AnnSimpleStreamSelectG b RemoteRelationshipField UnpreparedValue UnpreparedValue b
type TablePerms (b :: BackendType) = TablePermG b UnpreparedValue b
getTableRoles :: BackendSourceInfo -> [RoleName]
getLogicalModelRoles :: BackendSourceInfo -> [RoleName]
askScalarTypeParsingContext :: forall (b :: BackendType) r m. (MonadReader r m, Has (SourceInfo b) r, Has (ScalarTypeParsingContext b) (SourceConfig b)) => m (ScalarTypeParsingContext b)

-- | Looks up table information for the given table name. This function
--   should never fail, since the schema cache construction process is
--   supposed to ensure all dependencies are resolved. TODO: deduplicate
--   this with <a>CacheRM</a>.
askTableInfo :: forall (b :: BackendType) r m. (Backend b, MonadError QErr m, MonadReader r m, Has (SourceInfo b) r) => TableName b -> m (TableInfo b)

-- | Looks up logical model information for the given logical model name.
--   This function should never fail, since the schema cache construction
--   process is supposed to ensure all dependencies are resolved. TODO:
--   deduplicate this with <a>CacheRM</a>.
askLogicalModelInfo :: forall (b :: BackendType) r m. (MonadError QErr m, MonadReader r m, Has (SourceInfo b) r) => LogicalModelName -> m (LogicalModelInfo b)

-- | Looks up native query information for the given native query name.
--   This function should never fail, since the schema cache construction
--   process is supposed to ensure all dependencies are resolved. TODO:
--   deduplicate this with <a>CacheRM</a>.
askNativeQueryInfo :: forall (b :: BackendType) r m. (MonadError QErr m, MonadReader r m, Has (SourceInfo b) r) => NativeQueryName -> m (NativeQueryInfo b)
comparisonAggOperators :: [GQLNameIdentifier]
mapField :: forall (m :: Type -> Type) a b. Functor m => InputFieldsParser m (Maybe a) -> (a -> b) -> InputFieldsParser m (Maybe b)
mkDescriptionWith :: Maybe PGDescription -> Text -> Description
numericAggOperators :: [GQLNameIdentifier]
optionalFieldParser :: forall (n :: Type -> Type) m a b. (Functor n, Functor m) => (a -> b) -> m (Maybe (FieldParser n a)) -> m (Maybe (FieldParser n b))
parsedSelectionsToFields :: (Text -> a) -> InsOrdHashMap Name (ParsedSelection a) -> Fields a
partialSQLExpToUnpreparedValue :: forall (b :: BackendType). PartialSQLExp b -> UnpreparedValue b
getRedactionExprForColumn :: forall (b :: BackendType). Backend b => SelPermInfo b -> Column b -> Maybe (AnnRedactionExpUnpreparedValue b)
getRedactionExprForComputedField :: forall (b :: BackendType). Backend b => SelPermInfo b -> ComputedFieldName -> Maybe (AnnRedactionExpUnpreparedValue b)
requiredFieldParser :: forall (n :: Type -> Type) m a b. (Functor n, Functor m) => (a -> b) -> m (FieldParser n a) -> m (Maybe (FieldParser n b))

-- | @TODO: Currently we do no validation on native queries in schema.
--   Should we?
takeValidNativeQueries :: forall (b :: BackendType). NativeQueryCache b -> NativeQueryCache b

-- | @TODO: Currently we do no validation on stored procedures in schema.
--   Should we?
takeValidStoredProcedures :: forall (b :: BackendType). StoredProcedureCache b -> StoredProcedureCache b
takeValidFunctions :: forall (b :: BackendType). FunctionCache b -> FunctionCache b
takeValidTables :: forall (b :: BackendType). Backend b => TableCache b -> TableCache b
textToName :: MonadError QErr m => Text -> m Name
textToGQLIdentifier :: MonadError QErr m => Text -> m GQLNameIdentifier
data RemoteSchemaParser (n :: Type -> Type)
RemoteSchemaParser :: [FieldParser n (NamespacedField (RemoteSchemaRootField (RemoteRelationshipField UnpreparedValue) RemoteSchemaVariable))] -> Maybe [FieldParser n (NamespacedField (RemoteSchemaRootField (RemoteRelationshipField UnpreparedValue) RemoteSchemaVariable))] -> Maybe [FieldParser n (NamespacedField (RemoteSchemaRootField (RemoteRelationshipField UnpreparedValue) RemoteSchemaVariable))] -> RemoteSchemaParser (n :: Type -> Type)
[piQuery] :: RemoteSchemaParser (n :: Type -> Type) -> [FieldParser n (NamespacedField (RemoteSchemaRootField (RemoteRelationshipField UnpreparedValue) RemoteSchemaVariable))]
[piMutation] :: RemoteSchemaParser (n :: Type -> Type) -> Maybe [FieldParser n (NamespacedField (RemoteSchemaRootField (RemoteRelationshipField UnpreparedValue) RemoteSchemaVariable))]
[piSubscription] :: RemoteSchemaParser (n :: Type -> Type) -> Maybe [FieldParser n (NamespacedField (RemoteSchemaRootField (RemoteRelationshipField UnpreparedValue) RemoteSchemaVariable))]

-- | Builds the type name for referenced enum tables.
mkEnumTypeName :: forall (b :: BackendType) r (m :: Type -> Type). (Backend b, MonadError QErr m, Has (SourceInfo b) r) => TableName b -> Maybe Name -> SchemaT r m Name
addEnumSuffix :: ResolvedSourceCustomization -> GQLNameIdentifier -> Maybe Name -> Name
peelWithOrigin :: forall (m :: Type -> Type) a. MonadParse m => Parser 'Both m a -> Parser 'Both m (ValueWithOrigin a)
getIntrospectionResult :: RemoteSchemaPermissions -> RoleName -> RemoteSchemaCtxG remoteFieldInfo -> Maybe IntrospectionResult
tablePermissionsInfo :: forall (b :: BackendType). Backend b => SelPermInfo b -> TablePerms b
instance GHC.Internal.Base.Applicative m => GHC.Internal.Base.Applicative (Hasura.GraphQL.Schema.Common.SchemaT r m)
instance GHC.Internal.Base.Applicative m => GHC.Internal.Base.Applicative (Hasura.GraphQL.Schema.Common.WithSchemaSampledFeatureFlags m)
instance GHC.Internal.Enum.Enum Hasura.GraphQL.Schema.Common.Scenario
instance GHC.Classes.Eq Hasura.GraphQL.Schema.Common.Scenario
instance GHC.Classes.Eq Hasura.GraphQL.Schema.Common.SchemaSampledFeatureFlags
instance GHC.Internal.Base.Functor m => GHC.Internal.Base.Functor (Hasura.GraphQL.Schema.Common.SchemaT r m)
instance GHC.Internal.Base.Functor m => GHC.Internal.Base.Functor (Hasura.GraphQL.Schema.Common.WithSchemaSampledFeatureFlags m)
instance (Data.Has.Has Hasura.GraphQL.Schema.Common.SchemaContext r, GHC.Internal.Base.Monad m) => Hasura.Server.Init.FeatureFlag.HasFeatureFlagChecker (Hasura.GraphQL.Schema.Common.SchemaT r m)
instance GHC.Internal.Base.Monad m => Hasura.Server.Init.FeatureFlag.HasFeatureFlagChecker (Hasura.GraphQL.Schema.Common.WithSchemaSampledFeatureFlags m)
instance (Control.Monad.Trans.Control.MonadBaseControl GHC.Types.IO m, Control.Monad.Base.MonadBase GHC.Types.IO m) => Control.Monad.Trans.Control.MonadBaseControl GHC.Types.IO (Hasura.GraphQL.Schema.Common.WithSchemaSampledFeatureFlags m)
instance Control.Monad.Base.MonadBase GHC.Types.IO m => Control.Monad.Base.MonadBase GHC.Types.IO (Hasura.GraphQL.Schema.Common.WithSchemaSampledFeatureFlags m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Hasura.GraphQL.Schema.Common.SchemaT r m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Hasura.GraphQL.Schema.Common.WithSchemaSampledFeatureFlags m)
instance Control.Monad.Memoize.MonadMemoize m => Control.Monad.Memoize.MonadMemoize (Hasura.GraphQL.Schema.Common.SchemaT r m)
instance GHC.Internal.Base.Monad m => Control.Monad.Reader.Class.MonadReader r (Hasura.GraphQL.Schema.Common.SchemaT r m)
instance Hasura.RQL.Types.Source.MonadResolveSource m => Hasura.RQL.Types.Source.MonadResolveSource (Hasura.GraphQL.Schema.Common.WithSchemaSampledFeatureFlags m)
instance Control.Monad.Trans.Class.MonadTrans (Hasura.GraphQL.Schema.Common.SchemaT r)
instance Control.Monad.Trans.Class.MonadTrans Hasura.GraphQL.Schema.Common.WithSchemaSampledFeatureFlags
instance GHC.Internal.Base.Monad m => GHC.Internal.Base.Monad (Hasura.GraphQL.Schema.Common.SchemaT r m)
instance GHC.Internal.Base.Monad m => GHC.Internal.Base.Monad (Hasura.GraphQL.Schema.Common.WithSchemaSampledFeatureFlags m)
instance GHC.Internal.Show.Show Hasura.GraphQL.Schema.Common.Scenario
instance GHC.Internal.Show.Show Hasura.GraphQL.Schema.Common.SchemaSampledFeatureFlags

module Hasura.LogicalModel.Common
columnsFromFields :: forall k (b :: BackendType). InsOrdHashMap k (LogicalModelField b) -> InsOrdHashMap k (NullableScalarType b)
logicalModelFieldsToFieldInfo :: forall (b :: BackendType). Backend b => InsOrdHashMap (Column b) (LogicalModelField b) -> FieldInfoMap (FieldInfo b)
getSelPermInfoForLogicalModel :: forall (b :: BackendType). Backend b => RoleName -> LogicalModelInfo b -> Maybe (SelPermInfo b)

-- | build select permissions for logical model
logicalModelPermissions :: forall (b :: BackendType). Backend b => LogicalModelInfo b -> RoleName -> Maybe (TablePermG b (UnpreparedValue b))


-- | This module defines translation functions for queries which select
--   data. Principally this includes translating the <tt>query</tt> root
--   field, but parts are also reused for serving the responses for
--   mutations.
module Hasura.Backends.MSSQL.FromIr.Query

-- | This is the top-level entry point for translation of Query root
--   fields.
fromQueryRootField :: QueryDB 'MSSQL Void Expression -> FromIr Select
fromSelect :: JsonAggSelect -> AnnSelectG 'MSSQL (AnnFieldG 'MSSQL Void) Expression -> FromIr Select

-- | Used in <a>planSourceRelationship</a>, which is in turn used by to
--   implement <tt>mkDBRemoteRelationship</tt> for <tt>BackendExecute</tt>.
--   For more information, see the module/documentation of <a>Source</a>.
fromSourceRelationship :: NonEmpty Object -> HashMap FieldName (ColumnName, ScalarType) -> FieldName -> (FieldName, SourceRelationshipSelection 'MSSQL Void (Const Expression :: BackendType -> Type)) -> FromIr Select
instance GHC.Classes.Eq Hasura.Backends.MSSQL.FromIr.Query.FieldSource
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.FromIr.Query.Args
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.FromIr.Query.FieldSource
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.FromIr.Query.UnfurledJoin


-- | MSSQL Plan
--   
--   Planning T-SQL queries and subscription by translating IR to
--   MSSQL-specific SQL query types.
module Hasura.Backends.MSSQL.Plan
data PrepareState
PrepareState :: [ColumnValue 'MSSQL] -> HashMap Name (ColumnValue 'MSSQL) -> HashSet SessionVariable -> PrepareState
[positionalArguments] :: PrepareState -> [ColumnValue 'MSSQL]
[namedArguments] :: PrepareState -> HashMap Name (ColumnValue 'MSSQL)
[sessionVariables] :: PrepareState -> HashSet SessionVariable
planQuery :: MonadError QErr m => SessionVariables -> QueryDB 'MSSQL Void (UnpreparedValue 'MSSQL) -> m (QueryWithDDL Select)

-- | For more information, see the module/documentation of <a>Source</a>.
planSourceRelationship :: MonadError QErr m => SessionVariables -> NonEmpty Object -> HashMap FieldName (ColumnName, ScalarType) -> FieldName -> (FieldName, SourceRelationshipSelection 'MSSQL Void UnpreparedValue) -> m Select
planSubscription :: MonadError QErr m => InsOrdHashMap Name (QueryDB 'MSSQL Void (UnpreparedValue 'MSSQL)) -> SessionVariables -> m (Reselect, PrepareState)

-- | Prepare a value without any query planning; we just execute the query
--   with the values embedded.
prepareValueQuery :: MonadError QErr m => SessionVariables -> UnpreparedValue 'MSSQL -> m Expression
resultAlias :: Text
resultIdAlias :: Text
resultVarsAlias :: Text
rowAlias :: Text


-- | This module defines translation functions that yield the results of
--   mutation requests that return the data of rows that were affected.
module Hasura.Backends.MSSQL.FromIr.MutationResponse

-- | Generate a SQL SELECT statement which outputs the mutation response
--   
--   For multi row inserts:
--   
--   SELECT (SELECT COUNT(*) FROM [with_alias]) AS [affected_rows],
--   (select_from_returning) AS [returning] FOR JSON PATH,
--   INCLUDE_NULL_VALUES, WITHOUT_ARRAY_WRAPPER
--   
--   For single row insert: the selection set is translated to SQL query
--   using @<a>fromSelect</a>
mkMutationOutputSelect :: StringifyNumbers -> Text -> MutationOutputG 'MSSQL Void Expression -> FromIr Select

-- | Generate a SQL SELECT statement which outputs both mutation response
--   and check constraint result.
--   
--   A <tt>check constraint</tt> applies to the data that has been changed,
--   while <tt>permissions</tt> filter the data that is made available.
--   
--   This function applies to <tt>insert</tt> and <tt>update</tt>
--   mutations.
--   
--   The check constraint boolean expression is evaluated on mutated rows
--   in a CASE expression so that the int value "0" is returned when check
--   constraint is true otherwise the int value "1" is returned. We use
--   <a>SUM</a> aggregation on the returned value and if check constraint
--   on any row is not met, the summed value will not equal to "0" (always
--   &gt; 1).
--   
--   <pre>
--   &lt;check_constraint_select&gt; :=
--     SELECT SUM([check_sub_query].[check_evaluation])
--     FROM
--       ( SELECT
--           (CASE WHEN &lt;check_boolean_expression&gt; THEN 0 ELSE 1 END) AS [check_evaluation]
--         FROM
--           [with_alias]
--       ) AS [check_sub_query]
--   
--   &lt;mutation_output_select&gt; :=
--     SELECT
--       (SELECT COUNT(*) FROM [with_alias]) AS [affected_rows],
--       (select_from_returning) AS [returning]
--     FOR JSON PATH, INCLUDE_NULL_VALUES, WITHOUT_ARRAY_WRAPPER
--   
--   SELECT
--     (&lt;mutation_output_select&gt;) AS [mutation_response],
--     (&lt;check_constraint_select&gt;) AS [check_constraint_select]
--   </pre>
selectMutationOutputAndCheckCondition :: Text -> Select -> Expression -> Select

module Hasura.GraphQL.Schema.Remote
buildRemoteParser :: forall r (m :: Type -> Type) (n :: Type -> Type). MonadBuildRemoteSchema r m n => IntrospectionResult -> RemoteSchemaRelationships -> RemoteSchemaInfo -> SchemaT r m (RemoteSchemaParser n)

-- | <a>remoteField</a> accepts a <a>TypeDefinition</a> and will returns a
--   <a>FieldParser</a> for it. Note that the <a>TypeDefinition</a> should
--   be of the GraphQL <a>Output</a> kind, when an GraphQL <a>Input</a>
--   kind is provided, then error will be thrown.
remoteField :: forall r (m :: Type -> Type) (n :: Type -> Type). MonadBuildRemoteSchema r m n => RemoteSchemaIntrospection -> RemoteSchemaRelationships -> Name -> Name -> Maybe Description -> ArgumentsDefinition RemoteSchemaInputValueDefinition -> TypeDefinition [Name] RemoteSchemaInputValueDefinition -> SchemaT r m (FieldParser n (GraphQLField (RemoteRelationshipField UnpreparedValue) RemoteSchemaVariable))
makeResultCustomizer :: RemoteSchemaCustomizer -> GraphQLField (RemoteRelationshipField UnpreparedValue) RemoteSchemaVariable -> ResultCustomizer
withRemoteSchemaCustomization :: forall m r a. (MonadReader r m, Has MkTypename r, Has CustomizeRemoteFieldName r) => RemoteSchemaCustomizer -> m a -> m a
instance GHC.Internal.Base.Monoid Hasura.GraphQL.Schema.Remote.Altered
instance GHC.Internal.Base.Semigroup Hasura.GraphQL.Schema.Remote.Altered
instance GHC.Internal.Show.Show Hasura.GraphQL.Schema.Remote.Altered

module Hasura.GraphQL.RemoteServer

-- | Make an introspection query to the remote graphql server for the data
--   we need to present and stitch the remote schema. This powers
--   add_remote_schema, and also is called by schema cache rebuilding code
--   in <a>Hasura.RQL.DDL.Schema.Cache</a>.
fetchRemoteSchema :: (MonadIO m, MonadError QErr m, MonadTrace m, ProvidesNetwork m) => Environment -> SchemaSampledFeatureFlags -> ValidatedRemoteSchemaDef -> m (IntrospectionResult, ByteString, RemoteSchemaInfo)

-- | Parses the remote schema introspection result, and check whether it
--   looks like it's a valid GraphQL endpoint even under the configured
--   customization.
stitchRemoteSchema :: (MonadIO m, MonadError QErr m) => SchemaSampledFeatureFlags -> ByteString -> ValidatedRemoteSchemaDef -> m (IntrospectionResult, RemoteSchemaInfo)

-- | Sends a GraphQL query to the given server.
execRemoteGQ :: (MonadIO m, MonadError QErr m, MonadTrace m, ProvidesNetwork m) => Environment -> HttpPropagator -> UserInfo -> [Header] -> ValidatedRemoteSchemaDef -> GQLReqOutgoing -> m (DiffTime, [Header], ByteString)

-- | Parsing the introspection query result. We use this newtype wrapper to
--   avoid orphan instances and parse JSON in the way that we need for
--   GraphQL introspection results.
newtype FromIntrospection a
FromIntrospection :: a -> FromIntrospection a
[fromIntrospection] :: FromIntrospection a -> a
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.GraphQL.RemoteServer.FromIntrospection a)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.GraphQL.RemoteServer.FromIntrospection Language.GraphQL.Draft.Syntax.Description)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.GraphQL.RemoteServer.FromIntrospection a) => Data.Aeson.Types.FromJSON.FromJSON (Hasura.GraphQL.RemoteServer.FromIntrospection (Language.GraphQL.Draft.Syntax.FieldDefinition a))
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.GraphQL.RemoteServer.FromIntrospection Language.GraphQL.Draft.Syntax.GType)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.GraphQL.RemoteServer.FromIntrospection Language.GraphQL.Draft.Syntax.InputValueDefinition)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.GraphQL.RemoteServer.FromIntrospection (Language.GraphQL.Draft.Syntax.Value GHC.Internal.Base.Void))
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.GraphQL.RemoteServer.FromIntrospection Language.GraphQL.Draft.Syntax.EnumValueDefinition)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.GraphQL.RemoteServer.FromIntrospection (Language.GraphQL.Draft.Syntax.TypeDefinition [Language.GraphQL.Draft.Syntax.Name.Name] Language.GraphQL.Draft.Syntax.InputValueDefinition))
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.GraphQL.RemoteServer.FromIntrospection Hasura.RemoteSchema.SchemaCache.Types.IntrospectionResult)
instance GHC.Internal.Base.Functor Hasura.GraphQL.RemoteServer.FromIntrospection
instance GHC.Internal.Generics.Generic (Hasura.GraphQL.RemoteServer.FromIntrospection a)
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (Hasura.GraphQL.RemoteServer.FromIntrospection a)


-- | Tools for generating fields for Apollo federation
module Hasura.GraphQL.ApolloFederation
apolloRootFields :: ApolloFederationStatus -> [(Name, Parser 'Output Parse (ApolloFederationParserFunction Parse))] -> [FieldParser Parse (SchemaIntrospection -> QueryRootField UnpreparedValue)]

-- | Internal parser function for entities field
data ApolloFederationParserFunction (n :: Type -> Type)
ApolloFederationParserFunction :: (ApolloFederationAnyType -> n (QueryRootField UnpreparedValue)) -> ApolloFederationParserFunction (n :: Type -> Type)
[aafuGetRootField] :: ApolloFederationParserFunction (n :: Type -> Type) -> ApolloFederationAnyType -> n (QueryRootField UnpreparedValue)
convertToApolloFedParserFunc :: forall (n :: Type -> Type) (b :: BackendType). (MonadParse n, Backend b) => SourceInfo b -> TableInfo b -> SelPermInfo b -> StringifyNumbers -> Maybe NamingCase -> NESeq (ColumnInfo b) -> Parser 'Output n (AnnotatedFields b) -> Parser 'Output n (ApolloFederationParserFunction n)

-- | Check if the Apollo Federation feature is enabled or not. If the user
--   has explicitly set the Apollo Federation status, then we use that else
--   we fallback to the experimental feature flag
getApolloFederationStatus :: HashSet ExperimentalFeature -> Maybe ApolloFederationStatus -> ApolloFederationStatus
generateSDLWithAllTypes :: SchemaIntrospection -> Text
generateSDL :: SchemaIntrospection -> Text
instance GHC.Classes.Eq Hasura.GraphQL.ApolloFederation.GenerateSDLType
instance GHC.Internal.Show.Show Hasura.GraphQL.ApolloFederation.ApolloFederationAnyType


-- | Arg and Env Parsing for initialisation of the engine along with
--   corresponding logging and other helper functionality.
--   
--   This module is intended as the interface for options parsing and its
--   submodules should not need to be imported directly.
module Hasura.Server.Init

-- | Given the <a>ServeOptionsRaw</a> parsed from the arg parser,
--   postprocess the db url and fetch env vars associated with the main
--   command parser, then process the subcommand raw values if necessary.
mkHGEOptions :: EnabledLogTypes impl => HGEOptionsRaw (ServeOptionsRaw impl) -> WithEnv (HGEOptions (ServeOptions impl))

-- | Merge the results of the serve subcommmand arg parser with
--   corresponding values from the <a>WithEnv</a> context.
mkServeOptions :: EnabledLogTypes impl => ServeOptionsRaw impl -> WithEnv (ServeOptions impl)

-- | <tt>PostressConnInfo</tt> is a a tuple of some <tt>a</tt> with a
--   'Maybe Int' representing the retries setting. This function thus takes
--   a retries setting and a <a>PostgresConnInfoRaw</a> from the arg parser
--   and merges those results with the contents of their corresponding env
--   vars.
processPostgresConnInfo :: PostgresConnInfo (Maybe PostgresConnInfoRaw) -> WithEnv (PostgresConnInfo (Maybe UrlConf))

-- | Query the Metadata DB for the Metadata DB UUID. TODO: Move into a
--   dedicated Metadata module (ala Pro).
getDbId :: TxE QErr MetadataDbId
getPgVersion :: TxE QErr PGVersion


-- | This module defines the type class <a>BackendSchema</a> and auxiliary
--   types.
--   
--   <a>BackendSchema</a> represents the part of the interface that a
--   backend driver presents to the GraphQL Engine core that is responsible
--   for generating the backend's Schema Parsers.
--   
--   The Schema Parsers recognise (and reflect) the schema that a backend
--   exposes.
--   
--   The <a>BackendSchema</a> methods are used by <a>buildGQLContext</a>,
--   which is the core's entrypoint to schema generation.
--   
--   Many of the <a>BackendSchema</a> methods will have default
--   implementations that a backend driver may use. These may be found
--   (chiefly) in the modules:
--   
--   <ul>
--   <li>The module <a>Hasura.GraphQL.Schema.Build</a>, commonly qualified
--   <tt>GSB</tt></li>
--   <li><a>Hasura.GraphQL.Schema.Select</a>, commonly qualified
--   <tt>GSS</tt></li>
--   <li><a>Hasura.GraphQL.Schema.BoolExp</a></li>
--   </ul>
--   
--   For more information see:
--   
--   <ul>
--   <li><a>Technical overview of Schema Generation</a></li>
--   <li>The type <a>Parser</a>, and associated source code notes in the
--   same folder (not exposed with Haddock unfortunately)</li>
--   </ul>
module Hasura.GraphQL.Schema.Backend

-- | This type class is responsible for generating the schema of a backend.
--   Its methods are called by the common core that orchestrates the
--   various backend drivers.
--   
--   Its purpose in life is to make it convenient to express the GraphQL
--   schema we want to expose for the backends that we support. This means
--   balancing the desire to have consistency with the desire to
--   differentiate the schema of a backend.
--   
--   This means that it is expected to evolve over time as we add new
--   backends, and that you have the license to change it: Whatever form it
--   currently takes only reflects status quo current implementation.
--   
--   The module <a>Hasura.GraphQL.Schema.Build</a> (commonly qualified as
--   <tt>GSB</tt>) provides standard building blocks for implementing many
--   methods of this class. And as such, these two modules are very much
--   expected to evolve in tandem.
--   
--   See <a>Note BackendSchema modelling principles</a>.
class Backend b => BackendSchema (b :: BackendType)
buildTableQueryAndSubscriptionFields :: forall r (m :: Type -> Type) (n :: Type -> Type). (BackendSchema b, MonadBuildSchema b r m n) => MkRootFieldName -> TableName b -> TableInfo b -> GQLNameIdentifier -> SchemaT r m ([FieldParser n (QueryDB b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))], [FieldParser n (QueryDB b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))], Maybe (Name, Parser 'Output n (ApolloFederationParserFunction n)))
buildTableStreamingSubscriptionFields :: forall r (m :: Type -> Type) (n :: Type -> Type). (BackendSchema b, MonadBuildSchema b r m n) => MkRootFieldName -> TableName b -> TableInfo b -> GQLNameIdentifier -> SchemaT r m [FieldParser n (QueryDB b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))]
buildTableRelayQueryFields :: forall r (m :: Type -> Type) (n :: Type -> Type). (BackendSchema b, MonadBuildSchema b r m n) => MkRootFieldName -> TableName b -> TableInfo b -> GQLNameIdentifier -> NESeq (ColumnInfo b) -> SchemaT r m [FieldParser n (QueryDB b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))]
buildTableInsertMutationFields :: forall r (m :: Type -> Type) (n :: Type -> Type). (BackendSchema b, MonadBuildSchema b r m n) => MkRootFieldName -> Scenario -> TableName b -> TableInfo b -> GQLNameIdentifier -> SchemaT r m [FieldParser n (AnnotatedInsert b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))]

-- | This method is responsible for building the GraphQL Schema for
--   mutations backed by <tt>UPDATE</tt> statements on some table, as
--   described in
--   <tt><a>https://hasura.io/docs/latest/graphql/core/databases/postgres/mutations/update.html</a></tt>.
--   
--   The suggested way to implement this is using building blocks in GSB,
--   c.f. its namesake <tt>GSB.</tt><a>buildTableUpdateMutationFields</a>.
buildTableUpdateMutationFields :: forall r (m :: Type -> Type) (n :: Type -> Type). (BackendSchema b, MonadBuildSchema b r m n) => Scenario -> TableInfo b -> GQLNameIdentifier -> SchemaT r m [FieldParser n (AnnotatedUpdateG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))]
buildTableDeleteMutationFields :: forall r (m :: Type -> Type) (n :: Type -> Type). (BackendSchema b, MonadBuildSchema b r m n) => MkRootFieldName -> Scenario -> TableName b -> TableInfo b -> GQLNameIdentifier -> SchemaT r m [FieldParser n (AnnDelG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))]
buildFunctionQueryFields :: forall r (m :: Type -> Type) (n :: Type -> Type). (BackendSchema b, MonadBuildSchema b r m n) => MkRootFieldName -> FunctionName b -> FunctionInfo b -> TableName b -> SchemaT r m [FieldParser n (QueryDB b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))]
buildFunctionRelayQueryFields :: forall r (m :: Type -> Type) (n :: Type -> Type). (BackendSchema b, MonadBuildSchema b r m n) => MkRootFieldName -> FunctionName b -> FunctionInfo b -> TableName b -> NESeq (ColumnInfo b) -> SchemaT r m [FieldParser n (QueryDB b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))]
buildFunctionMutationFields :: forall r (m :: Type -> Type) (n :: Type -> Type). (BackendSchema b, MonadBuildSchema b r m n) => MkRootFieldName -> FunctionName b -> FunctionInfo b -> TableName b -> SchemaT r m [FieldParser n (MutationDB b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))]
buildNativeQueryRootFields :: forall r (m :: Type -> Type) (n :: Type -> Type). (BackendSchema b, MonadBuildSchema b r m n) => NativeQueryInfo b -> SchemaT r m (Maybe (FieldParser n (QueryDB b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))))
buildStoredProcedureRootFields :: forall r (m :: Type -> Type) (n :: Type -> Type). (BackendSchema b, MonadBuildSchema b r m n) => StoredProcedureInfo b -> SchemaT r m (Maybe (FieldParser n (QueryDB b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))))

-- | Make a parser for relationships. Default implementaton elides
--   relationships altogether.
mkRelationshipParser :: forall r (m :: Type -> Type) (n :: Type -> Type). (BackendSchema b, MonadBuildSchema b r m n) => RelInfo b -> SchemaT r m (Maybe (InputFieldsParser n (Maybe (AnnotatedInsertField b (UnpreparedValue b)))))
relayExtension :: BackendSchema b => Maybe (XRelay b)
nodesAggExtension :: BackendSchema b => Maybe (XNodesAgg b)
streamSubscriptionExtension :: BackendSchema b => Maybe (XStreamingSubscription b)
groupByExtension :: BackendSchema b => Maybe (XGroupBy b)
columnParser :: forall r (m :: Type -> Type) (n :: Type -> Type). (BackendSchema b, MonadBuildSchema b r m n) => ColumnType b -> Nullability -> SchemaT r m (Parser 'Both n (ValueWithOrigin (ColumnValue b)))
enumParser :: forall r (m :: Type -> Type) (n :: Type -> Type). (BackendSchema b, MonadBuildSchema b r m n) => TableName b -> NonEmpty (EnumValue, EnumValueInfo) -> Maybe Name -> Nullability -> SchemaT r m (Parser 'Both n (ScalarValue b))
possiblyNullable :: forall (m :: Type -> Type). (BackendSchema b, MonadParse m) => ScalarType b -> Nullability -> Parser 'Both m (ScalarValue b) -> Parser 'Both m (ScalarValue b)

-- | Parser for arguments on scalar fields in a selection set
scalarSelectionArgumentsParser :: forall (n :: Type -> Type). (BackendSchema b, MonadParse n) => ColumnType b -> InputFieldsParser n (Maybe (ScalarSelectionArguments b))
orderByOperators :: BackendSchema b => SourceInfo b -> NamingCase -> (Name, NonEmpty (Definition EnumValueInfo, (BasicOrderType b, NullsOrderType b)))
comparisonExps :: forall r (m :: Type -> Type) (n :: Type -> Type). (BackendSchema b, MonadBuildSchema b r m n) => ColumnType b -> SchemaT r m (Parser 'Input n [ComparisonExp b])

-- | The input fields parser, for "count" aggregate field, yielding a
--   function which generates @'CountType b' from optional "distinct" field
--   value
countTypeInput :: forall (n :: Type -> Type). (BackendSchema b, MonadParse n) => Maybe (Parser 'Both n (Column b, AnnRedactionExpUnpreparedValue b)) -> InputFieldsParser n (CountDistinct -> CountType b (UnpreparedValue b))
aggregateOrderByCountType :: BackendSchema b => ScalarType b

-- | Computed field parser
computedField :: forall r (m :: Type -> Type) (n :: Type -> Type). (BackendSchema b, MonadBuildSchema b r m n) => ComputedFieldInfo b -> TableName b -> TableInfo b -> SchemaT r m (Maybe (FieldParser n (AnnotatedField b)))

-- | The public interface for the schema of table queries exposed by a
--   backend.
--   
--   Remote Schemas and the Relay schema are the chief backend-agnostic
--   clients of this typeclass.
--   
--   Some of schema building components in the <a>Hasura.GraphQL.Schema</a>
--   namespace also make use of these methods, ensuring backends expose a
--   consistent schema regardless of the mode it's referenced.
--   
--   Default implementations exist for all of these in <a>Select</a>.
class Backend b => BackendTableSelectSchema (b :: BackendType)
tableArguments :: forall r (m :: Type -> Type) (n :: Type -> Type). (BackendTableSelectSchema b, MonadBuildSourceSchema b r m n) => TableInfo b -> SchemaT r m (InputFieldsParser n (SelectArgsG b (UnpreparedValue b)))
tableSelectionSet :: forall r (m :: Type -> Type) (n :: Type -> Type). (BackendTableSelectSchema b, MonadBuildSourceSchema b r m n) => TableInfo b -> SchemaT r m (Maybe (Parser 'Output n (AnnotatedFields b)))
selectTable :: forall r (m :: Type -> Type) (n :: Type -> Type). (BackendTableSelectSchema b, MonadBuildSourceSchema b r m n) => TableInfo b -> Name -> Maybe Description -> SchemaT r m (Maybe (FieldParser n (SelectExp b)))
selectTableAggregate :: forall r (m :: Type -> Type) (n :: Type -> Type). (BackendTableSelectSchema b, MonadBuildSourceSchema b r m n) => TableInfo b -> Name -> Maybe Description -> SchemaT r m (Maybe (FieldParser n (AggSelectExp b)))
class Backend b => BackendLogicalModelSelectSchema (b :: BackendType)
logicalModelArguments :: forall r (m :: Type -> Type) (n :: Type -> Type). (BackendLogicalModelSelectSchema b, MonadBuildSourceSchema b r m n) => LogicalModelInfo b -> SchemaT r m (InputFieldsParser n (SelectArgsG b (UnpreparedValue b)))
logicalModelSelectionSet :: forall r (m :: Type -> Type) (n :: Type -> Type). (BackendLogicalModelSelectSchema b, MonadBuildSourceSchema b r m n) => LogicalModelInfo b -> SchemaT r m (Maybe (Parser 'Output n (AnnotatedFields b)))
class BackendLogicalModelSelectSchema b => BackendNativeQuerySelectSchema (b :: BackendType)
selectNativeQuery :: forall r (m :: Type -> Type) (n :: Type -> Type). (BackendNativeQuerySelectSchema b, MonadBuildSourceSchema b r m n) => NativeQueryInfo b -> Name -> Nullable -> Maybe Description -> SchemaT r m (Maybe (FieldParser n (AnnSimpleSelectG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))))
selectNativeQueryObject :: forall r (m :: Type -> Type) (n :: Type -> Type). (BackendNativeQuerySelectSchema b, MonadBuildSchema b r m n) => NativeQueryInfo b -> Name -> Maybe Description -> SchemaT r m (Maybe (FieldParser n (AnnObjectSelectG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))))
class Backend b => BackendUpdateOperatorsSchema (b :: BackendType) where {
    
    -- | Intermediate Representation of the set of update operators that act
    --   upon table fields during an update mutation. (For example, _set and
    --   _inc)
    --   
    --   It is parameterised over the type of fields, which changes during the
    --   IR translation phases.
    type UpdateOperators (b :: BackendType) :: Type -> Type;
}
parseUpdateOperators :: forall (m :: Type -> Type) (n :: Type -> Type) r. (BackendUpdateOperatorsSchema b, MonadBuildSchema b r m n) => TableInfo b -> UpdPermInfo b -> SchemaT r m (InputFieldsParser n (HashMap (Column b) (UpdateOperators b (UnpreparedValue b))))

-- | Bag of constraints available to the methods of <tt>BackendSchema</tt>.
--   
--   Note that <tt>BackendSchema b</tt> is itself part of this, so a
--   methods may also call other methods. This might seem trivial, but it
--   can be easy to miss when the functions used to implement a class
--   instance are defined in multiple modules.
type MonadBuildSchema (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type) = (BackendSchema b, MonadBuildSourceSchema b r m n)
type ComparisonExp (b :: BackendType) = OpExpG b UnpreparedValue b


-- | Schema parsers for common functionality of logical model resolvers.
module Hasura.LogicalModelResolver.Schema

-- | Schema parser for native query or stored procedure arguments.
argumentsSchema :: forall (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type). MonadBuildSchema b r m n => Text -> Name -> HashMap ArgumentName (NullableScalarType b) -> MaybeT (SchemaT r m) (InputFieldsParser n (HashMap ArgumentName (ColumnValue b)))


-- | Helper functions for generating the schema of database tables
module Hasura.GraphQL.Schema.Table

-- | Helper function to get the table GraphQL name. A table may have a
--   custom name configured with it. When the custom name exists, the
--   GraphQL nodes that are generated according to the custom name. For
--   example: Let's say, we have a table called `users address`, the name
--   of the table is not GraphQL compliant so we configure the table with a
--   GraphQL compliant name, say <tt>users_address</tt> The generated
--   top-level nodes of this table will be like <tt>users_address</tt>,
--   <tt>insert_users_address</tt> etc
getTableGQLName :: forall (b :: BackendType) m. (Backend b, MonadError QErr m) => TableInfo b -> m Name

-- | Table select columns enum
--   
--   Parser for an enum type that matches the columns of the given table.
--   Used as a parameter for "distinct", among others. Maps to the
--   table_select_column object.
--   
--   Return Nothing if there's no column the current user has "select"
--   permissions for.
tableSelectColumnsEnum :: forall (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type). MonadBuildSchema b r m n => TableInfo b -> SchemaT r m (Maybe (Parser 'Both n (Column b, AnnRedactionExpUnpreparedValue b)))

-- | Table select columns enum of a certain type.
--   
--   Parser for an enum type that matches, of a given table, certain
--   columns which satisfy a predicate. Used as a parameter for aggregation
--   predicate arguments, among others. Maps to the table_select_column
--   object.
--   
--   Return Nothing if there's no column the current user has "select"
--   permissions for.
tableSelectColumnsPredEnum :: forall (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type). MonadBuildSchema b r m n => (ColumnType b -> Bool) -> GQLNameIdentifier -> TableInfo b -> SchemaT r m (Maybe (Parser 'Both n (Column b, AnnRedactionExpUnpreparedValue b)))

-- | Table update columns enum
--   
--   Parser for an enum type that matches the columns of the given table.
--   Used for conflict resolution in "insert" mutations, among others. Maps
--   to the table_update_column object.
tableUpdateColumnsEnum :: forall (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type). MonadBuildSchema b r m n => TableInfo b -> SchemaT r m (Maybe (Parser 'Both n (Column b)))
updateColumnsPlaceholderParser :: forall (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type). MonadBuildSchema b r m n => TableInfo b -> SchemaT r m (Parser 'Both n (Maybe (Column b)))
tableSelectPermissions :: forall (b :: BackendType). RoleName -> TableInfo b -> Maybe (SelPermInfo b)
tableSelectFields :: forall (b :: BackendType) r m. (Backend b, MonadError QErr m, MonadReader r m, Has SchemaContext r, Has (SourceInfo b) r) => TableInfo b -> m [FieldInfo b]
tableColumns :: forall (b :: BackendType). TableInfo b -> [ColumnInfo b]

-- | Get the columns of a table that may be selected under the given select
--   permissions.
tableSelectColumns :: forall (b :: BackendType) r m. (Backend b, MonadError QErr m, MonadReader r m, Has SchemaContext r, Has (SourceInfo b) r) => TableInfo b -> m [(StructuredColumnInfo b, AnnRedactionExpUnpreparedValue b)]

-- | Get the computed fields of a table that may be selected under the
--   given select permissions.
tableSelectComputedFields :: forall (b :: BackendType) r m. (Backend b, MonadError QErr m, MonadReader r m, Has SchemaContext r, Has (SourceInfo b) r) => TableInfo b -> m [ComputedFieldInfo b]

-- | Get the columns of a table that my be updated under the given update
--   permissions.
tableUpdateColumns :: forall (b :: BackendType). Backend b => RoleName -> TableInfo b -> [ColumnInfo b]

-- | similar to <tt>getTableGQLName</tt> but returns table name as a list
--   with name pieces instead of concatenating schema and table name
--   together.
getTableIdentifierName :: forall (b :: BackendType) m. (Backend b, MonadError QErr m) => TableInfo b -> m GQLNameIdentifier


-- | This module provides common building blocks for composing Schema
--   Parsers used in the schema of Update Mutations.
module Hasura.GraphQL.Schema.Update

-- | <tt>UpdateOperator b m n op</tt> represents one single update operator
--   for a backend <tt>b</tt>.
--   
--   The type variable <tt>op</tt> is the backend-specific data type that
--   represents update operators, typically in the form of a sum-type with
--   an <tt>UnpreparedValue b</tt> in each constructor.
--   
--   The <tt>UpdateOperator b m n</tt> is a <tt>Functor</tt>. There exist
--   building blocks of common update operators (such as <a>setOp</a>,
--   etc.) which have <tt>op ~ UnpreparedValue b</tt>. The Functor instance
--   lets you wrap the generic update operators in backend-specific tags.
data UpdateOperator (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type) op
UpdateOperator :: (ColumnInfo b -> Bool) -> (GQLNameIdentifier -> TableName b -> NonEmpty (ColumnInfo b) -> SchemaT r m (InputFieldsParser n (HashMap (Column b) op))) -> UpdateOperator (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type) op
[updateOperatorApplicableColumn] :: UpdateOperator (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type) op -> ColumnInfo b -> Bool
[updateOperatorParser] :: UpdateOperator (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type) op -> GQLNameIdentifier -> TableName b -> NonEmpty (ColumnInfo b) -> SchemaT r m (InputFieldsParser n (HashMap (Column b) op))

-- | Construct a parser for a single update operator.
--   
--   <tt>updateOperator _ "op" fp MkOp ["col1","col2"]</tt> gives a parser
--   that accepts objects in the shape of:
--   
--   <pre>
--   op: {
--     col1: "x",
--     col2: "y"
--   }
--   </pre>
--   
--   And (morally) parses into values:
--   
--   <pre>
--   HashMap.fromList [("col1", MkOp (fp "x")), ("col2", MkOp (fp "y"))]
--   </pre>
updateOperator :: forall (n :: Type -> Type) r (m :: Type -> Type) (b :: BackendType) a. MonadBuildSchema b r m n => GQLNameIdentifier -> GQLNameIdentifier -> GQLNameIdentifier -> (ColumnInfo b -> SchemaT r m (Parser 'Both n a)) -> NonEmpty (ColumnInfo b) -> Description -> Description -> SchemaT r m (InputFieldsParser n (HashMap (Column b) a))

-- | The top-level component for building update operators parsers.
--   
--   <ul>
--   <li>It implements the <tt>preset</tt> functionality from Update
--   Permissions (see
--   &lt;<a>https://hasura.io/docs/latest/graphql/core/auth/authorization/permission-rules.html#column-presets</a>
--   Permissions user docs&gt;). Use the <a>presetColumns</a> function to
--   extract those from the update permissions.</li>
--   <li>It validates that that the update fields parsed are sound when
--   taken as a whole, i.e. that some changes are actually specified
--   (either in the mutation query text or in update preset columns) and
--   that each column is only used in one operator.</li>
--   </ul>
buildUpdateOperators :: forall (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type) op. MonadBuildSchema b r m n => HashMap (Column b) op -> [UpdateOperator b r m n op] -> TableInfo b -> SchemaT r m (InputFieldsParser n (HashMap (Column b) op))

-- | The columns that have <tt>preset</tt> definitions applied to them.
--   (see
--   &lt;<a>https://hasura.io/docs/latest/graphql/core/auth/authorization/permission-rules.html#column-presets</a>
--   Permissions user docs&gt;)
presetColumns :: forall (b :: BackendType). UpdPermInfo b -> HashMap (Column b) (UnpreparedValue b)
setOp :: forall (b :: BackendType) (n :: Type -> Type) r (m :: Type -> Type). MonadBuildSchema b r m n => UpdateOperator b r m n (UnpreparedValue b)
incOp :: forall (b :: BackendType) (m :: Type -> Type) (n :: Type -> Type) r. MonadBuildSchema b r m n => UpdateOperator b r m n (UnpreparedValue b)
instance (GHC.Internal.Base.Functor m, GHC.Internal.Base.Functor n) => GHC.Internal.Base.Functor (Hasura.GraphQL.Schema.Update.UpdateOperator b r m n)

module Hasura.GraphQL.Schema.OrderBy

-- | Corresponds to an object type for an order by.
--   
--   <pre>
--   input table_order_by {
--     col1: order_by
--     col2: order_by
--     .     .
--     .     .
--     coln: order_by
--     obj-rel: &lt;remote-table&gt;_order_by
--   }
--   </pre>
tableOrderByExp :: forall (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type). MonadBuildSchema b r m n => TableInfo b -> SchemaT r m (Parser 'Input n [AnnotatedOrderByItemG b (UnpreparedValue b)])

-- | Corresponds to an object type for an order by.
--   
--   <pre>
--   input table_order_by {
--     col1: order_by
--     col2: order_by
--     .     .
--     .     .
--     coln: order_by
--     obj-rel: &lt;remote-table&gt;_order_by
--   }
--   </pre>
--   
--   TODO: When there are no columns accessible to a role, the
--   `<a>table</a>_order_by` will be an empty input object. In such a case,
--   we can avoid exposing the <tt>order_by</tt> argument.
logicalModelOrderByExp :: forall (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type). MonadBuildSchema b r m n => LogicalModelInfo b -> SchemaT r m (Parser 'Input n [AnnotatedOrderByItemG b (UnpreparedValue b)])

module Hasura.GraphQL.Schema.BoolExp

-- | Backends implement this type class to specify the schema of
--   aggregation predicates.
--   
--   The default implementation results in a parser that does not parse
--   anything.
--   
--   The scope of this class is local to the function <tt>boolExp</tt>. In
--   particular, methods in `class BackendSchema` and `type
--   MonadBuildSchema` should *NOT* include this class as a constraint.
class AggregationPredicatesSchema (b :: BackendType)
aggregationPredicatesParser :: forall r (m :: Type -> Type) (n :: Type -> Type). (AggregationPredicatesSchema b, MonadBuildSourceSchema b r m n) => TableInfo b -> SchemaT r m (Maybe (InputFieldsParser n [AggregationPredicates b (UnpreparedValue b)]))

-- | <pre>
--   input type_bool_exp {
--     _or: [type_bool_exp!]
--     _and: [type_bool_exp!]
--     _not: type_bool_exp
--     column: type_comparison_exp
--     ...
--   }
--   </pre>
--   
--   | Booleans expressions for tables
tableBoolExp :: forall (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type). (MonadBuildSchema b r m n, AggregationPredicatesSchema b) => TableInfo b -> SchemaT r m (Parser 'Input n (AnnBoolExp b (UnpreparedValue b)))

-- | <pre>
--   input type_bool_exp {
--     _or: [type_bool_exp!]
--     _and: [type_bool_exp!]
--     _not: type_bool_exp
--     column: type_comparison_exp
--     ...
--   }
--   </pre>
--   
--   | Boolean expression for logical models
logicalModelBoolExp :: forall (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type). (MonadBuildSchema b r m n, AggregationPredicatesSchema b) => LogicalModelInfo b -> SchemaT r m (Parser 'Input n (AnnBoolExp b (UnpreparedValue b)))
mkBoolOperator :: forall (n :: Type -> Type) (k :: Kind) a. (MonadParse n, 'Input <: k) => NamingCase -> DangerouslyCollapseBooleans -> GQLNameIdentifier -> Maybe Description -> Parser k n a -> InputFieldsParser n (Maybe a)
equalityOperators :: forall (n :: Type -> Type) (k :: Kind) (b :: BackendType). (MonadParse n, 'Input <: k) => NamingCase -> DangerouslyCollapseBooleans -> Parser k n (UnpreparedValue b) -> Parser k n (UnpreparedValue b) -> [InputFieldsParser n (Maybe (OpExpG b (UnpreparedValue b)))]
comparisonOperators :: forall (n :: Type -> Type) (k :: Kind) (b :: BackendType). (MonadParse n, 'Input <: k) => NamingCase -> DangerouslyCollapseBooleans -> Parser k n (UnpreparedValue b) -> [InputFieldsParser n (Maybe (OpExpG b (UnpreparedValue b)))]
instance (Hasura.RQL.Types.Backend.AggregationPredicates b GHC.Types.~ GHC.Internal.Data.Functor.Const.Const GHC.Internal.Base.Void) => Hasura.GraphQL.Schema.BoolExp.AggregationPredicatesSchema b


-- | Generate table selection schema both for ordinary Hasura-type and
--   relay-type queries. All schema with "relay" or "connection" in the
--   name is used exclusively by relay.
module Hasura.GraphQL.Schema.Select

-- | Table selection by primary key.
--   
--   <pre>
--   table_name(id: 42) {
--     col1: col1_type
--     col2: col2_type
--   }: table
--   </pre>
--   
--   Returns Nothing if there's nothing that can be selected with current
--   permissions or if there are primary keys the user doesn't have select
--   permissions for.
selectTableByPk :: forall (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type). (MonadBuildSchema b r m n, BackendTableSelectSchema b) => TableInfo b -> Name -> Maybe Description -> SchemaT r m (Maybe (FieldParser n (SelectExp b)))

-- | Simple table connection selection.
--   
--   The field for the table accepts table connection selection argument,
--   and expects a selection of connection fields
--   
--   <pre>
--   table_name_connection(first: 1) {
--     pageInfo: {
--       hasNextPage: Boolean!
--       endCursor: String!
--     }
--     edges: {
--       cursor: String!
--       node: {
--         id: ID!
--         col1: col1_type
--         col2: col2_type
--       }
--     }
--   }: table_nameConnection!
--   </pre>
selectTableConnection :: forall (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type). (MonadBuildSchema b r m n, BackendTableSelectSchema b, AggregationPredicatesSchema b) => TableInfo b -> Name -> Maybe Description -> PrimaryKeyColumns b -> SchemaT r m (Maybe (FieldParser n (ConnectionSelectExp b)))

-- | Simple table selection.
--   
--   The field for the table accepts table selection arguments, and expects
--   a selection of fields
--   
--   <pre>
--   table_name(limit: 10) {
--     col1: col1_type
--     col2: col2_type
--   }: [table!]!
--   </pre>
defaultSelectTable :: forall (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type). (MonadBuildSchema b r m n, BackendTableSelectSchema b) => TableInfo b -> Name -> Maybe Description -> SchemaT r m (Maybe (FieldParser n (SelectExp b)))

-- | Table aggregation selection
--   
--   Parser for an aggregation selection of a table. &gt;
--   table_aggregate(limit: 10) { &gt; aggregate: table_aggregate_fields
--   &gt; group_by(...): table_group_by &gt; nodes: [table!]! &gt; } ::
--   table_aggregate!
--   
--   Returns Nothing if there's nothing that can be selected with current
--   permissions.
defaultSelectTableAggregate :: forall (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type). (MonadBuildSchema b r m n, BackendTableSelectSchema b) => TableInfo b -> Name -> Maybe Description -> SchemaT r m (Maybe (FieldParser n (AggSelectExp b)))

-- | Arguments for a table selection. Default implementation for
--   BackendSchema.
--   
--   <pre>
--   distinct_on: [table_select_column!]
--   limit: Int
--   offset: Int
--   order_by: [table_order_by!]
--   where: table_bool_exp
--   </pre>
defaultTableArgs :: forall (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type). (MonadBuildSchema b r m n, AggregationPredicatesSchema b) => TableInfo b -> SchemaT r m (InputFieldsParser n (SelectArgs b))

-- | Fields of a table
--   
--   <pre>
--   type table{
--     # table columns
--     column_1: column1_type
--     .
--     column_n: columnn_type
--   
--     # table relationships
--     object_relationship: remote_table
--     array_relationship: [remote_table!]!
--   
--     # computed fields
--     computed_field: field_type
--   
--     # remote relationships
--     remote_field: field_type
--   }
--   </pre>
defaultTableSelectionSet :: forall (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type). (AggregationPredicatesSchema b, BackendTableSelectSchema b, BackendNativeQuerySelectSchema b, Eq (AnnBoolExp b (UnpreparedValue b)), MonadBuildSchema b r m n) => TableInfo b -> SchemaT r m (Maybe (Parser 'Output n (AnnotatedFields b)))

-- | shared implementation between tables and logical models
defaultArgsParser :: forall (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type). MonadBuildSchema b r m n => InputFieldsParser n (Maybe (AnnBoolExp b (UnpreparedValue b))) -> InputFieldsParser n (Maybe (NonEmpty (AnnotatedOrderByItemG b (UnpreparedValue b)))) -> InputFieldsParser n (Maybe (NonEmpty (AnnDistinctColumn b (UnpreparedValue b)))) -> SchemaT r m (InputFieldsParser n (SelectArgs b))

-- | Aggregation fields
--   
--   <pre>
--   type table_aggregate_fields{
--     count(distinct: Boolean, columns: [table_select_column!]): Int!
--     sum: table_sum_fields
--     avg: table_avg_fields
--     stddev: table_stddev_fields
--     stddev_pop: table_stddev_pop_fields
--     variance: table_variance_fields
--     var_pop: table_var_pop_fields
--     max: table_max_fields
--     min: table_min_fields
--   }
--   </pre>
tableAggregationFields :: forall (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type). MonadBuildSchema b r m n => TableInfo b -> SchemaT r m (Parser 'Output n (AggregateFields b (UnpreparedValue b)))

-- | Arguments for a table connection selection
--   
--   <pre>
--   distinct_on: [table_select_column!]
--   order_by: [table_order_by!]
--   where: table_bool_exp
--   first: Int
--   last: Int
--   before: String
--   after: String
--   </pre>
tableConnectionArgs :: forall (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type). (MonadBuildSchema b r m n, AggregationPredicatesSchema b) => PrimaryKeyColumns b -> TableInfo b -> SelPermInfo b -> SchemaT r m (InputFieldsParser n (SelectArgs b, Maybe (NonEmpty (ConnectionSplit b (UnpreparedValue b))), Maybe ConnectionSlice))

-- | Connection fields of a table
--   
--   <pre>
--   type tableConnection{
--     pageInfo: PageInfo!
--     edges: [tableEdge!]!
--   }
--   </pre>
--   
--   <pre>
--   type PageInfo{
--     startCursor: String!
--     endCursor: String!
--     hasNextPage: Boolean!
--     hasPreviousPage: Boolean!
--   }
--   </pre>
--   
--   <pre>
--   type tableEdge{
--     cursor: String!
--     node: table!
--   }
--   </pre>
tableConnectionSelectionSet :: forall (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type). (MonadBuildSchema b r m n, BackendTableSelectSchema b) => TableInfo b -> SchemaT r m (Maybe (Parser 'Output n (ConnectionFields b)))

-- | Argument to filter rows returned from table selection &gt; where:
--   table_bool_exp
tableWhereArg :: forall (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type). (AggregationPredicatesSchema b, MonadBuildSchema b r m n) => TableInfo b -> SchemaT r m (InputFieldsParser n (Maybe (AnnBoolExp b (UnpreparedValue b))))

-- | Argument to sort rows returned from table selection &gt; order_by:
--   [table_order_by!]
tableOrderByArg :: forall (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type). MonadBuildSchema b r m n => TableInfo b -> SchemaT r m (InputFieldsParser n (Maybe (NonEmpty (AnnotatedOrderByItemG b (UnpreparedValue b)))))

-- | Argument to distinct select on columns returned from table selection
--   &gt; distinct_on: [table_select_column!]
tableDistinctArg :: forall (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type). MonadBuildSchema b r m n => TableInfo b -> SchemaT r m (InputFieldsParser n (Maybe (NonEmpty (AnnDistinctColumn b (UnpreparedValue b)))))

-- | Argument to limit rows returned from table selection &gt; limit:
--   NonNegativeInt
tableLimitArg :: forall (n :: Type -> Type). MonadParse n => InputFieldsParser n (Maybe Int)

-- | Argument to skip some rows, in conjunction with order_by &gt; offset:
--   BigInt
tableOffsetArg :: forall (n :: Type -> Type). MonadParse n => InputFieldsParser n (Maybe Int64)

-- | List of table fields object. Just a <tt><a>nonNullableObjectList</a>
--   wrapper over </tt><a>tableSelectionSet</a>. &gt; table_name: [table!]!
tableSelectionList :: forall (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type). (MonadBuildSchema b r m n, BackendTableSelectSchema b) => TableInfo b -> SchemaT r m (Maybe (Parser 'Output n (AnnotatedFields b)))


-- | Schema parsers for logical models
module Hasura.LogicalModel.Schema
getSelPermInfoForLogicalModel :: forall (b :: BackendType). Backend b => RoleName -> LogicalModelInfo b -> Maybe (SelPermInfo b)

-- | turn post-schema cache LogicalModelInfo into IR
buildLogicalModelIR :: forall (b :: BackendType). LogicalModelInfo b -> LogicalModel b

-- | top-level select permissions for a logical model
buildLogicalModelPermissions :: forall (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type). MonadBuildSchema b r m n => LogicalModelInfo b -> SchemaT r m (Maybe (TablePermG b (UnpreparedValue b)))

-- | Argument to sort rows returned from table selection &gt; order_by:
--   [table_order_by!]
logicalModelOrderByArg :: forall (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type). MonadBuildSchema b r m n => LogicalModelInfo b -> SchemaT r m (InputFieldsParser n (Maybe (NonEmpty (AnnotatedOrderByItemG b (UnpreparedValue b)))))
logicalModelSelectionList :: forall (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type). (MonadBuildSchema b r m n, BackendLogicalModelSelectSchema b) => Nullable -> LogicalModelInfo b -> SchemaT r m (Maybe (Parser 'Output n (AnnotatedFields b)))

-- | Argument to filter rows returned from table selection &gt; where:
--   table_bool_exp
logicalModelWhereArg :: forall (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type). (MonadBuildSchema b r m n, AggregationPredicatesSchema b) => LogicalModelInfo b -> SchemaT r m (InputFieldsParser n (Maybe (AnnBoolExp b (UnpreparedValue b))))
defaultLogicalModelArgs :: forall (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type). (MonadBuildSchema b r m n, AggregationPredicatesSchema b) => LogicalModelInfo b -> SchemaT r m (InputFieldsParser n (SelectArgs b))
defaultLogicalModelSelectionSet :: forall (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type). MonadBuildSchema b r m n => LogicalModelInfo b -> SchemaT r m (Maybe (Parser 'Output n (AnnotatedFields b)))
logicalModelFieldParsers :: forall (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type). MonadBuildSchema b r m n => Set RelName -> LogicalModelInfo b -> SchemaT r m [FieldParser MetadataObjId n (AnnotatedField b)]


-- | Schema parsers for stored procedures.
module Hasura.StoredProcedure.Schema
defaultBuildStoredProcedureRootFields :: forall (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type). (MonadBuildSchema b r m n, BackendLogicalModelSelectSchema b) => StoredProcedureInfo b -> SchemaT r m (Maybe (FieldParser n (QueryDB b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))))


-- | Schema parsers for native queries.
module Hasura.NativeQuery.Schema

-- | select a native query - implementation is the same for root fields and
--   array relationships
defaultSelectNativeQuery :: forall (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type). (MonadBuildSchema b r m n, BackendNativeQuerySelectSchema b, BackendTableSelectSchema b) => NativeQueryInfo b -> Name -> Nullable -> Maybe Description -> SchemaT r m (Maybe (FieldParser n (AnnSimpleSelectG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))))
defaultSelectNativeQueryObject :: forall (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type). (MonadBuildSchema b r m n, BackendNativeQuerySelectSchema b, BackendTableSelectSchema b) => NativeQueryInfo b -> Name -> Maybe Description -> SchemaT r m (Maybe (FieldParser n (AnnObjectSelectG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))))
defaultBuildNativeQueryRootFields :: forall (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type). (MonadBuildSchema b r m n, BackendNativeQuerySelectSchema b, BackendTableSelectSchema b) => NativeQueryInfo b -> SchemaT r m (Maybe (FieldParser n (QueryDB b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))))


-- | Generate the GraphQL schema types related to streaming subscriptions.
module Hasura.GraphQL.Schema.SubscriptionStream

-- | Field parser for a streaming subscription for a table.
selectStreamTable :: forall (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type). (MonadBuildSchema b r m n, AggregationPredicatesSchema b, BackendTableSelectSchema b) => TableInfo b -> Name -> Maybe Description -> SchemaT r m (Maybe (FieldParser n (StreamSelectExp b)))

module Hasura.GraphQL.Schema.Mutation

-- | Construct the parser for a field that can be used to add several rows
--   to a DB table.
--   
--   This function is used to create the insert_tablename root field. The
--   field accepts the following arguments: - objects: the list of objects
--   to insert into the table (see <a>tableFieldsInput</a>) - parser for
--   backend-specific fields, e.g. upsert fields on_conflict or if_matched
insertIntoTable :: forall (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type). (MonadBuildSchema b r m n, BackendTableSelectSchema b) => (TableInfo b -> SchemaT r m (InputFieldsParser n (BackendInsert b (UnpreparedValue b)))) -> Scenario -> TableInfo b -> Name -> Maybe Description -> SchemaT r m (Maybe (FieldParser n (AnnotatedInsert b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))))

-- | Variant of <a>insertIntoTable</a> that inserts a single row.
--   
--   Instead of expecting a list of rows to insert in a <tt>objects</tt>
--   argument, this field instead expects a single <tt>object</tt>. Its
--   selection set is also slightly different: it only allows selecting
--   columns from the row being inserted.
insertOneIntoTable :: forall (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type). (MonadBuildSchema b r m n, BackendTableSelectSchema b) => (TableInfo b -> SchemaT r m (InputFieldsParser n (BackendInsert b (UnpreparedValue b)))) -> Scenario -> TableInfo b -> Name -> Maybe Description -> SchemaT r m (Maybe (FieldParser n (AnnotatedInsert b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))))

-- | Construct a root field, normally called delete_tablename, that can be
--   used to delete several rows from a DB table
deleteFromTable :: forall (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type). (MonadBuildSchema b r m n, AggregationPredicatesSchema b, BackendTableSelectSchema b) => Scenario -> TableInfo b -> Name -> Maybe Description -> SchemaT r m (Maybe (FieldParser n (AnnDelG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))))

-- | Construct a root field, normally called delete_tablename_by_pk, that
--   can be used to delete an individual rows from a DB table, specified by
--   primary key. Select permissions are required, as the user must be
--   allowed to access all the primary keys of the table.
deleteFromTableByPk :: forall (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type). (MonadBuildSchema b r m n, BackendTableSelectSchema b) => Scenario -> TableInfo b -> Name -> Maybe Description -> SchemaT r m (Maybe (FieldParser n (AnnDelG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))))
mkDefaultRelationshipParser :: forall (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type). MonadBuildSchema b r m n => (TableInfo b -> SchemaT r m (InputFieldsParser n (BackendInsert b (UnpreparedValue b)))) -> XNestedInserts b -> RelInfo b -> SchemaT r m (Maybe (InputFieldsParser n (Maybe (AnnotatedInsertField b (UnpreparedValue b)))))

-- | All mutations allow returning results, such as what the updated
--   database rows look like. This parser allows a query to specify what
--   data to fetch.
mutationSelectionSet :: forall (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type). (MonadBuildSchema b r m n, BackendTableSelectSchema b) => TableInfo b -> SchemaT r m (Parser 'Output n (MutFldsG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b)))

-- | How to specify a database row by primary key.
--   
--   This will give <tt>Nothing</tt> when either there are no primary keys
--   defined for the table or when the given permissions do not permit
--   selecting from all the columns that make up the key.
primaryKeysArguments :: forall (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type). MonadBuildSchema b r m n => TableInfo b -> SchemaT r m (Maybe (InputFieldsParser n (AnnBoolExp b (UnpreparedValue b))))

module Hasura.GraphQL.Schema.Update.Batch

-- | Construct a root field, normally called update_tablename, that can be
--   used to update rows in a DB table specified by filters. Only returns a
--   parser if there are columns the user is allowed to update; otherwise
--   returns Nothing.
updateTable :: forall (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type). (MonadBuildSchema b r m n, AggregationPredicatesSchema b, BackendTableSelectSchema b, BackendUpdateOperatorsSchema b) => (UpdateBatch b (UpdateOperators b) (UnpreparedValue b) -> UpdateVariant b (UnpreparedValue b)) -> Scenario -> TableInfo b -> GQLNameIdentifier -> SchemaT r m (Maybe (FieldParser n (AnnotatedUpdateG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))))
updateTableMany :: forall (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type). (MonadBuildSchema b r m n, AggregationPredicatesSchema b, BackendTableSelectSchema b, BackendUpdateOperatorsSchema b) => ([UpdateBatch b (UpdateOperators b) (UnpreparedValue b)] -> UpdateVariant b (UnpreparedValue b)) -> Scenario -> TableInfo b -> GQLNameIdentifier -> SchemaT r m (Maybe (FieldParser n (AnnotatedUpdateG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))))

-- | Construct a root field, normally called
--   <tt>update_tablename_by_pk</tt>, that can be used to update a single
--   in a DB table, specified by primary key. Only returns a parser if
--   there are columns the user is allowed to update and if the user has
--   select permissions on all primary keys; otherwise returns Nothing.
updateTableByPk :: forall (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type). (MonadBuildSchema b r m n, BackendTableSelectSchema b, BackendUpdateOperatorsSchema b) => (UpdateBatch b (UpdateOperators b) (UnpreparedValue b) -> UpdateVariant b (UnpreparedValue b)) -> Scenario -> TableInfo b -> GQLNameIdentifier -> SchemaT r m (Maybe (FieldParser n (AnnotatedUpdateG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))))


-- | This module provides building blocks for the GraphQL Schema that the
--   GraphQL Engine presents.
--   
--   The functions defined here are used to serve as default
--   implementations for their namesakes in the <tt>BackendSchema</tt> type
--   class.
--   
--   When, for some backend, you want to implement a new feature that
--   manifests itself visibly in the schema (e.g., if you're developing
--   support for update mutations), this module is likely where your
--   efforts should start.
--   
--   Using these functions help us present a consistent GraphQL schema
--   across different backends.
--   
--   There is a bit of tension however, as sometimes we intentionally do
--   want the GraphQL Schema relating to some backend to be different in
--   some way.
--   
--   It could be that a backend only has limited support for some common
--   feature, or, more interestingly, that some backend just does things
--   differently (c.f. MSSQL's <tt>MERGE</tt> statement with PostgreSQL's
--   <tt>INSERT .. ON CONFLICT</tt>, which are similar enough that we want
--   to use the same overall upsert schema but different enough that we
--   want to use different field names)
--   
--   When you want to implement new schema for a backend, there is overall
--   three different ways do deal with this tension:
--   
--   <ol>
--   <li>You can duplicate existing code and implement the new behavior in
--   the duplicate.</li>
--   <li>You can infuse the new behavior into existing code and switch
--   dynamically at runtime (or via type class instance dispatch, which is
--   the same for our purposes)</li>
--   <li>You can refactor the existing building blocks and compose them
--   differently at use sites to get the desired behavior nuances.</li>
--   </ol>
--   
--   Of these three, steps 1. and 2. are by far the easiest to execute,
--   while 3. requires some critical thought. However, both 1. and 2.
--   produce legacy code that is difficult to maintain and understand.
--   
--   As a guideline, if you find yourself wanting add new behavior to some
--   of these functions it's very likely that you should consider
--   refactoring them instead, thus shifting the responsibility deciding on
--   the correct behavior to use sites.
--   
--   It an ongoing effort to adapt and refactor these building blocks such
--   that they have the sizes and shapes that result in the most elegant
--   uses of them that we can manage.
module Hasura.GraphQL.Schema.Build
buildTableDeleteMutationFields :: forall (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type). (MonadBuildSchema b r m n, AggregationPredicatesSchema b, BackendTableSelectSchema b) => MkRootFieldName -> Scenario -> TableName b -> TableInfo b -> GQLNameIdentifier -> SchemaT r m [FieldParser n (AnnDelG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))]
buildTableInsertMutationFields :: forall (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type). (MonadBuildSchema b r m n, BackendTableSelectSchema b) => (TableInfo b -> SchemaT r m (InputFieldsParser n (BackendInsert b (UnpreparedValue b)))) -> MkRootFieldName -> Scenario -> TableName b -> TableInfo b -> GQLNameIdentifier -> SchemaT r m [FieldParser n (AnnotatedInsert b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))]

-- | buildTableQueryAndSubscriptionFields builds the field parsers of a
--   table. It returns a tuple with array of field parsers that correspond
--   to the field parsers of the query root and the field parsers of the
--   subscription root
buildTableQueryAndSubscriptionFields :: forall (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type). (MonadBuildSchema b r m n, AggregationPredicatesSchema b, BackendTableSelectSchema b) => MkRootFieldName -> TableName b -> TableInfo b -> GQLNameIdentifier -> SchemaT r m ([FieldParser n (QueryDB b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))], [FieldParser n (QueryDB b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))], Maybe (Name, Parser 'Output n (ApolloFederationParserFunction n)))
buildTableStreamingSubscriptionFields :: forall (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type). (MonadBuildSchema b r m n, AggregationPredicatesSchema b, BackendTableSelectSchema b) => MkRootFieldName -> TableName b -> TableInfo b -> GQLNameIdentifier -> SchemaT r m [FieldParser n (QueryDB b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))]

-- | This function implements the parsers for the basic, single batch,
--   update mutations. It implements the mutation schema in the general
--   shape described in
--   <tt><a>https://hasura.io/docs/latest/graphql/core/databases/postgres/mutations/update.html</a></tt>.
--   (ie. update_<a>table</a> and update_<a>table</a>_by_pk root fields)
--   
--   Different backends can have different update types (single batch,
--   multiple batches, etc), and so the parsed UpdateBatch needs to be
--   embedded in the custom UpdateVariant defined by the backend, which is
--   done by passing a function to this function.
buildSingleBatchTableUpdateMutationFields :: forall (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type). (MonadBuildSchema b r m n, AggregationPredicatesSchema b, BackendTableSelectSchema b, BackendUpdateOperatorsSchema b) => (UpdateBatch b (UpdateOperators b) (UnpreparedValue b) -> UpdateVariant b (UnpreparedValue b)) -> Scenario -> TableInfo b -> GQLNameIdentifier -> SchemaT r m [FieldParser n (AnnotatedUpdateG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))]

-- | Builds field name with proper case. Please note that this is a pure
--   function as all the validation has already been done while preparing
--   <tt>GQLNameIdentifier</tt>.
setFieldNameCase :: forall (b :: BackendType). NamingCase -> TableInfo b -> CustomRootField -> (GQLNameIdentifier -> GQLNameIdentifier) -> GQLNameIdentifier -> Name
buildFieldDescription :: Text -> Comment -> Maybe Description


-- | This module defines the schema aspect of the default implementation of
--   aggregation predicates.
module Hasura.GraphQL.Schema.BoolExp.AggregationPredicates

-- | This function is meant to serve as the default schema for Aggregation
--   Predicates represented in the IR by the type
--   <a>AggregationPredicates</a>.
defaultAggregationPredicatesParser :: forall (b :: BackendType) r (m :: Type -> Type) (n :: Type -> Type). (MonadBuildSchema b r m n, AggregationPredicatesSchema b) => [FunctionSignature b] -> TableInfo b -> SchemaT r m (Maybe (InputFieldsParser n [AggregationPredicatesImplementation b (UnpreparedValue b)]))
data FunctionSignature (b :: BackendType)
FunctionSignature :: Text -> Name -> ArgumentsSignature b -> ScalarType b -> FunctionSignature (b :: BackendType)
[fnName] :: FunctionSignature (b :: BackendType) -> Text
[fnGQLName] :: FunctionSignature (b :: BackendType) -> Name
[fnArguments] :: FunctionSignature (b :: BackendType) -> ArgumentsSignature b
[fnReturnType] :: FunctionSignature (b :: BackendType) -> ScalarType b
data ArgumentsSignature (b :: BackendType)
ArgumentsStar :: ArgumentsSignature (b :: BackendType)
SingleArgument :: ScalarType b -> ArgumentsSignature (b :: BackendType)
Arguments :: NonEmpty (ArgumentSignature b) -> ArgumentsSignature (b :: BackendType)
data ArgumentSignature (b :: BackendType)
ArgumentSignature :: ScalarType b -> Name -> ArgumentSignature (b :: BackendType)
[argType] :: ArgumentSignature (b :: BackendType) -> ScalarType b
[argName] :: ArgumentSignature (b :: BackendType) -> Name

module Hasura.Backends.DataConnector.Adapter.Schema
instance Hasura.GraphQL.Schema.Backend.BackendLogicalModelSelectSchema 'Hasura.RQL.Types.BackendType.DataConnector
instance Hasura.GraphQL.Schema.Backend.BackendNativeQuerySelectSchema 'Hasura.RQL.Types.BackendType.DataConnector
instance Hasura.GraphQL.Schema.Backend.BackendSchema 'Hasura.RQL.Types.BackendType.DataConnector
instance Hasura.GraphQL.Schema.Backend.BackendTableSelectSchema 'Hasura.RQL.Types.BackendType.DataConnector
instance Hasura.GraphQL.Schema.Backend.BackendUpdateOperatorsSchema 'Hasura.RQL.Types.BackendType.DataConnector

module Hasura.Backends.Postgres.Schema.Select

-- | User-defined function (AKA custom function)
selectFunction :: forall r (m :: Type -> Type) (n :: Type -> Type) (pgKind :: PostgresKind). (MonadBuildSchema ('Postgres pgKind) r m n, BackendTableSelectSchema ('Postgres pgKind)) => MkRootFieldName -> FunctionInfo ('Postgres pgKind) -> Maybe Description -> SchemaT r m (Maybe (FieldParser n (SelectExp ('Postgres pgKind))))
selectFunctionAggregate :: forall r (m :: Type -> Type) (n :: Type -> Type) (pgKind :: PostgresKind). (MonadBuildSchema ('Postgres pgKind) r m n, BackendTableSelectSchema ('Postgres pgKind)) => MkRootFieldName -> FunctionInfo ('Postgres pgKind) -> Maybe Description -> SchemaT r m (Maybe (FieldParser n (AggSelectExp ('Postgres pgKind))))
selectFunctionConnection :: forall (pgKind :: PostgresKind) r (m :: Type -> Type) (n :: Type -> Type). (MonadBuildSchema ('Postgres pgKind) r m n, AggregationPredicatesSchema ('Postgres pgKind), BackendTableSelectSchema ('Postgres pgKind)) => MkRootFieldName -> FunctionInfo ('Postgres pgKind) -> Maybe Description -> PrimaryKeyColumns ('Postgres pgKind) -> SchemaT r m (Maybe (FieldParser n (ConnectionSelectExp ('Postgres pgKind))))

-- | Computed field parser
computedFieldPG :: forall (pgKind :: PostgresKind) r (m :: Type -> Type) (n :: Type -> Type). (MonadBuildSchema ('Postgres pgKind) r m n, BackendTableSelectSchema ('Postgres pgKind)) => ComputedFieldInfo ('Postgres pgKind) -> TableName ('Postgres pgKind) -> TableInfo ('Postgres pgKind) -> SchemaT r m (Maybe (FieldParser n (AnnotatedField ('Postgres pgKind))))
buildFunctionQueryFieldsPG :: forall r (m :: Type -> Type) (n :: Type -> Type) (pgKind :: PostgresKind). (MonadBuildSchema ('Postgres pgKind) r m n, BackendTableSelectSchema ('Postgres pgKind)) => MkRootFieldName -> FunctionName ('Postgres pgKind) -> FunctionInfo ('Postgres pgKind) -> TableName ('Postgres pgKind) -> SchemaT r m [FieldParser n (QueryDB ('Postgres pgKind) (RemoteRelationshipField UnpreparedValue) (UnpreparedValue ('Postgres pgKind)))]
buildFunctionMutationFieldsPG :: forall r (m :: Type -> Type) (n :: Type -> Type) (pgKind :: PostgresKind). (MonadBuildSchema ('Postgres pgKind) r m n, BackendTableSelectSchema ('Postgres pgKind)) => MkRootFieldName -> FunctionName ('Postgres pgKind) -> FunctionInfo ('Postgres pgKind) -> TableName ('Postgres pgKind) -> SchemaT r m [FieldParser n (MutationDB ('Postgres pgKind) (RemoteRelationshipField UnpreparedValue) (UnpreparedValue ('Postgres pgKind)))]


-- | Postgres Schema OnConflict
--   
--   This module contains the building blocks for parsing
--   <tt>on_conflict</tt> clauses, which in the Postgres backend are used
--   to implement upsert functionality. These are used by
--   <a>backendInsertParser</a> to construct a postgres-specific schema
--   parser for insert (and upsert) mutations.
module Hasura.Backends.Postgres.Schema.OnConflict

-- | Parser for a field name <tt>on_conflict</tt> of type
--   <tt>tablename_on_conflict</tt>.
--   
--   The <tt>tablename_on_conflict</tt> object is used to generate the
--   <tt>ON CONFLICT</tt> SQL clause, indicating what should be done if an
--   insert raises a conflict.
--   
--   The types ordinarily produced by this parser are only created if the
--   table has unique or primary keys constraints.
--   
--   If there are no columns for which the current role has update
--   permissions, we must still accept an empty list for
--   <tt>update_columns</tt> to support the "ON CONFLICT DO NOTHING" case.
--   We do this by adding a placeholder value to the enum. See
--   <a>https://github.com/hasura/graphql-engine/issues/6804</a>.
onConflictFieldParser :: forall (pgKind :: PostgresKind) r (m :: Type -> Type) (n :: Type -> Type). (MonadBuildSchema ('Postgres pgKind) r m n, AggregationPredicatesSchema ('Postgres pgKind)) => TableInfo ('Postgres pgKind) -> SchemaT r m (InputFieldsParser n (Maybe (OnConflictClause ('Postgres pgKind) (UnpreparedValue ('Postgres pgKind)))))


-- | Postgres DDL Function
--   
--   This module describes building information about Postgres functions by
--   validating the passed raw information.
--   
--   See <a>Backend</a>.
module Hasura.Backends.Postgres.DDL.Function
buildFunctionInfo :: forall (pgKind :: PostgresKind) m. (Backend ('Postgres pgKind), QErrM m) => SourceName -> QualifiedFunction -> SystemDefined -> FunctionConfig ('Postgres pgKind) -> FunctionPermissionsMap -> RawFunctionInfo ('Postgres pgKind) -> Maybe Text -> NamingCase -> m (FunctionInfo ('Postgres pgKind), SchemaDependency)
mkFunctionArgs :: Int -> [QualifiedPGType] -> [FunctionArgName] -> [FunctionArg]
instance GHC.Classes.Eq Hasura.Backends.Postgres.DDL.Function.FunctionIntegrityError
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.DDL.Function.FunctionIntegrityError


-- | Postgres DDL ComputedField
--   
--   How to build the <a>ComputedFieldInfo</a> for a field.
--   
--   See <a>Backend</a>.
module Hasura.Backends.Postgres.DDL.ComputedField
buildComputedFieldInfo :: forall (pgKind :: PostgresKind) m. QErrM m => HashSet QualifiedTable -> QualifiedTable -> HashSet PGCol -> ComputedFieldName -> ComputedFieldDefinition -> PGRawFunctionInfo -> Comment -> m (ComputedFieldInfo ('Postgres pgKind))
instance GHC.Classes.Eq Hasura.Backends.Postgres.DDL.ComputedField.ComputedFieldValidateError
instance GHC.Classes.Eq Hasura.Backends.Postgres.DDL.ComputedField.InvalidSessionArgument
instance GHC.Classes.Eq Hasura.Backends.Postgres.DDL.ComputedField.InvalidTableArgument
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.DDL.ComputedField.ComputedFieldValidateError
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.DDL.ComputedField.InvalidSessionArgument
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.DDL.ComputedField.InvalidTableArgument


-- | Postgres DDL BoolExp
--   
--   How to parse the boolean expressions, specifically for Postgres.
--   
--   See <a>Backend</a>.
module Hasura.Backends.Postgres.DDL.BoolExp
parseBoolExpOperations :: forall (pgKind :: PostgresKind) m v. (Backend ('Postgres pgKind), MonadError QErr m) => ValueParser ('Postgres pgKind) m v -> FieldInfoMap (FieldInfo ('Postgres pgKind)) -> FieldInfoMap (FieldInfo ('Postgres pgKind)) -> ColumnReference ('Postgres pgKind) -> Value -> m [OpExpG ('Postgres pgKind) v]
buildComputedFieldBooleanExp :: forall (pgKind :: PostgresKind) m v. (MonadError QErr m, Backend ('Postgres pgKind), TableCoreInfoRM ('Postgres pgKind) m) => BoolExpResolver ('Postgres pgKind) m v -> BoolExpRHSParser ('Postgres pgKind) m v -> FieldInfoMap (FieldInfo ('Postgres pgKind)) -> FieldInfoMap (FieldInfo ('Postgres pgKind)) -> ComputedFieldInfo ('Postgres pgKind) -> Value -> m (AnnComputedFieldBoolExp ('Postgres pgKind) v)


-- | MSSQL Schema IfMatched
--   
--   This module contains the building blocks for parsing
--   <tt>if_matched</tt> clauses (represented as <a>IfMatched</a>), which
--   in the MSSQL backend are used to implement upsert functionality.
--   
--   These are used by <a>backendInsertParser</a> to construct a
--   mssql-specific schema parser for insert (and upsert) mutations.
module Hasura.Backends.MSSQL.Schema.IfMatched

-- | Field-parser for:
--   
--   <pre>
--   if_matched: tablename_if_matched
--   
--   input tablename_if_matched {
--     match_columns: [tablename_select_column!]
--     update_columns: [tablename_update_columns!]
--     where: tablename_bool_exp
--   }
--   </pre>
--   
--   Note that the types ordinarily produced by this parser are only
--   created if the active role has <i>both</i> select and update
--   permissions to the table <tt>tablename</tt> defined <i>and</i> these
--   grant non-empty column permissions.
ifMatchedFieldParser :: forall r (m :: Type -> Type) (n :: Type -> Type). (MonadBuildSchema 'MSSQL r m n, AggregationPredicatesSchema 'MSSQL) => TableInfo 'MSSQL -> SchemaT r m (InputFieldsParser n (Maybe (IfMatched (UnpreparedValue 'MSSQL))))


-- | MSSQL Instances Schema
--   
--   Defines a <a>BackendSchema</a> type class instance for MSSQL.
module Hasura.Backends.MSSQL.Instances.Schema
instance Hasura.GraphQL.Schema.Backend.BackendLogicalModelSelectSchema 'Hasura.RQL.Types.BackendType.MSSQL
instance Hasura.GraphQL.Schema.Backend.BackendNativeQuerySelectSchema 'Hasura.RQL.Types.BackendType.MSSQL
instance Hasura.GraphQL.Schema.Backend.BackendSchema 'Hasura.RQL.Types.BackendType.MSSQL
instance Hasura.GraphQL.Schema.Backend.BackendTableSelectSchema 'Hasura.RQL.Types.BackendType.MSSQL
instance Hasura.GraphQL.Schema.Backend.BackendUpdateOperatorsSchema 'Hasura.RQL.Types.BackendType.MSSQL


-- | MSSQL DDL BoolExp
--   
--   How to parse the boolean expressions and operations relevant for
--   MSSQL.
module Hasura.Backends.MSSQL.DDL.BoolExp
parseBoolExpOperations :: MonadError QErr m => ValueParser 'MSSQL m v -> FieldInfoMap (FieldInfo 'MSSQL) -> FieldInfoMap (FieldInfo 'MSSQL) -> ColumnReference 'MSSQL -> Value -> m [OpExpG 'MSSQL v]

module Hasura.Backends.BigQuery.DDL.BoolExp
parseBoolExpOperations :: MonadError QErr m => ValueParser 'BigQuery m v -> FieldInfoMap (FieldInfo 'BigQuery) -> FieldInfoMap (FieldInfo 'BigQuery) -> ColumnReference 'BigQuery -> Value -> m [OpExpG 'BigQuery v]

module Hasura.Backends.BigQuery.DDL
fetchAndValidateEnumValues :: Monad m => SourceConfig 'BigQuery -> TableName 'BigQuery -> Maybe (PrimaryKey 'BigQuery (RawColumnInfo 'BigQuery)) -> [RawColumnInfo 'BigQuery] -> m (Either QErr EnumValues)
buildFunctionInfo :: MonadError QErr m => SourceName -> FunctionName 'BigQuery -> SystemDefined -> FunctionConfig 'BigQuery -> FunctionPermissionsMap -> RawFunctionInfo 'BigQuery -> Maybe Text -> NamingCase -> m (FunctionInfo 'BigQuery, SchemaDependency)
updateColumnInEventTrigger :: TableName 'BigQuery -> Column 'BigQuery -> Column 'BigQuery -> TableName 'BigQuery -> EventTriggerConf 'BigQuery -> EventTriggerConf 'BigQuery
parseBoolExpOperations :: MonadError QErr m => ValueParser 'BigQuery m v -> FieldInfoMap (FieldInfo 'BigQuery) -> FieldInfoMap (FieldInfo 'BigQuery) -> ColumnReference 'BigQuery -> Value -> m [OpExpG 'BigQuery v]
parseCollectableType :: MonadError QErr m => CollectableType (ColumnType 'BigQuery) -> Value -> m (PartialSQLExp 'BigQuery)
scalarTypeFromColumnType :: ColumnType 'BigQuery -> ScalarType


-- | Planning T-SQL queries and subscriptions.
module Hasura.Backends.BigQuery.Plan
planNoPlan :: MonadError QErr m => FromIrConfig -> UserInfo -> QueryDB 'BigQuery Void (UnpreparedValue 'BigQuery) -> m Select

module Hasura.Backends.BigQuery.Instances.Schema
instance Hasura.GraphQL.Schema.Backend.BackendLogicalModelSelectSchema 'Hasura.RQL.Types.BackendType.BigQuery
instance Hasura.GraphQL.Schema.Backend.BackendNativeQuerySelectSchema 'Hasura.RQL.Types.BackendType.BigQuery
instance Hasura.GraphQL.Schema.Backend.BackendSchema 'Hasura.RQL.Types.BackendType.BigQuery
instance Hasura.GraphQL.Schema.Backend.BackendTableSelectSchema 'Hasura.RQL.Types.BackendType.BigQuery

module Hasura.RQL.Types.Metadata.Backend
class (Backend b, Eq AggregationPredicates b PartialSQLExp b, Eq BooleanOperators b PartialSQLExp b, Eq FunctionArgumentExp b PartialSQLExp b, Ord BackendInvalidationKeys b, Hashable AggregationPredicates b PartialSQLExp b, Hashable BooleanOperators b PartialSQLExp b, Hashable FunctionArgumentExp b PartialSQLExp b, Monoid BackendInvalidationKeys b) => BackendMetadata (b :: BackendType) where {
    type BackendInvalidationKeys (b :: BackendType);
    type BackendInvalidationKeys b :: BackendType = ();
}
buildComputedFieldInfo :: (BackendMetadata b, MonadError QErr m) => HashSet (TableName b) -> TableName b -> HashSet (Column b) -> ComputedFieldName -> ComputedFieldDefinition b -> RawFunctionInfo b -> Comment -> m (ComputedFieldInfo b)
fetchAndValidateEnumValues :: (BackendMetadata b, MonadIO m, MonadBaseControl IO m) => SourceConfig b -> TableName b -> Maybe (PrimaryKey b (RawColumnInfo b)) -> [RawColumnInfo b] -> m (Either QErr EnumValues)
resolveBackendInfo :: forall arr (m :: Type -> Type). (BackendMetadata b, ArrowChoice arr, ArrowCache m arr, ArrowDistribute arr, ArrowWriter (Seq CollectItem) arr, MonadIO m, MonadBaseControl IO m, ProvidesNetwork m) => Logger Hasura -> arr (Dependency (Maybe (BackendInvalidationKeys b)), BackendConfig b) (BackendInfo b)
($dmresolveBackendInfo) :: (BackendMetadata b, Arrow arr, BackendInfo b ~ ()) => Logger Hasura -> arr (Dependency (Maybe (BackendInvalidationKeys b)), BackendConfig b) (BackendInfo b)

-- | Function that resolves the connection related source configuration,
--   and creates a connection pool (and other related parameters) in the
--   process
resolveSourceConfig :: (BackendMetadata b, MonadIO m, MonadBaseControl IO m, MonadResolveSource m) => SourceName -> SourceConnConfiguration b -> BackendSourceKind b -> BackendInfo b -> Environment -> Manager -> m (Either QErr (SourceConfig b))

-- | Function that introspects a database for tables, columns, functions
--   etc.
resolveDatabaseMetadata :: (BackendMetadata b, MonadIO m, MonadBaseControl IO m, MonadResolveSource m, HasFeatureFlagChecker m) => Logger Hasura -> SourceMetadata b -> SourceConfig b -> m (Either QErr (DBObjectsIntrospection b))
parseBoolExpOperations :: (BackendMetadata b, MonadError QErr m) => ValueParser b m v -> FieldInfoMap (FieldInfo b) -> FieldInfoMap (FieldInfo b) -> ColumnReference b -> Value -> m [OpExpG b v]
buildObjectRelationshipInfo :: (BackendMetadata b, MonadError QErr m) => SourceConfig b -> SourceName -> HashMap (TableName b) (HashSet (ForeignKey b)) -> TableName b -> ObjRelDef b -> m (RelInfo b, Seq SchemaDependency)
buildArrayRelationshipInfo :: (BackendMetadata b, MonadError QErr m) => SourceConfig b -> SourceName -> HashMap (TableName b) (HashSet (ForeignKey b)) -> TableName b -> ArrRelDef b -> m (RelInfo b, Seq SchemaDependency)
buildFunctionInfo :: (BackendMetadata b, MonadError QErr m) => SourceName -> FunctionName b -> SystemDefined -> FunctionConfig b -> FunctionPermissionsMap -> RawFunctionInfo b -> Maybe Text -> NamingCase -> m (FunctionInfo b, SchemaDependency)
updateColumnInEventTrigger :: BackendMetadata b => TableName b -> Column b -> Column b -> TableName b -> EventTriggerConf b -> EventTriggerConf b
parseCollectableType :: (BackendMetadata b, MonadError QErr m, MonadReader r m, Has (ScalarTypeParsingContext b) r) => CollectableType (ColumnType b) -> Value -> m (PartialSQLExp b)
postDropSourceHook :: (BackendMetadata b, MonadError QErr m, MonadIO m, MonadBaseControl IO m) => SourceConfig b -> TableEventTriggers b -> m ()
validateRelationship :: (BackendMetadata b, MonadError QErr m) => TableCache b -> TableName b -> Either (ObjRelDef b) (ArrRelDef b) -> m ()
($dmvalidateRelationship) :: (BackendMetadata b, MonadError QErr m) => TableCache b -> TableName b -> Either (ObjRelDef b) (ArrRelDef b) -> m ()

-- | Function that that builds a boolean expression field out of a computed
--   field
buildComputedFieldBooleanExp :: (BackendMetadata b, MonadError QErr m, TableCoreInfoRM b m) => BoolExpResolver b m v -> BoolExpRHSParser b m v -> FieldInfoMap (FieldInfo b) -> FieldInfoMap (FieldInfo b) -> ComputedFieldInfo b -> Value -> m (AnnComputedFieldBoolExp b v)

-- | Run all operations required to create, update, or migrate the internal
--   catalog used by the backend for internal bookkeeping, if any. The
--   return type indicates whether the performed operations subsequently
--   require re-creating event trigers.
prepareCatalog :: forall (m :: Type -> Type). (BackendMetadata b, MonadIO m, MonadBaseControl IO m) => SourceConfig b -> ExceptT QErr m (RecreateEventTriggers, SourceCatalogMigrationState)

-- | List all the tables on a given data source, including those not
--   tracked by Hasura. Primarily useful for user interfaces to allow
--   untracked tables to be tracked.
listAllTables :: (BackendMetadata b, CacheRM m, MonadBaseControl IO m, MetadataM m, MonadError QErr m, MonadIO m, MonadReader r m, Has (Logger Hasura) r, ProvidesNetwork m) => SourceName -> m [TableName b]

-- | List all the functions on a given data source, including those not
--   tracked by Hasura. Primarily useful for user interfaces to allow
--   untracked functions to be tracked.
listAllTrackables :: (BackendMetadata b, CacheRM m, MonadBaseControl IO m, MetadataM m, MonadError QErr m, MonadIO m, MonadReader r m, Has (Logger Hasura) r, ProvidesNetwork m) => SourceName -> m (TrackableInfo b)

-- | Get information about a given table on a given source, whether tracked
--   or not. Primarily useful for user interfaces.
getTableInfo :: (BackendMetadata b, CacheRM m, MetadataM m, MonadError QErr m, MonadBaseControl IO m, MonadIO m) => SourceName -> TableName b -> m (Maybe (SourceTableInfo b))
validateNativeQuery :: (BackendMetadata b, MonadIO m, MonadError QErr m) => Environment -> SourceName -> SourceConnConfiguration b -> SourceConfig b -> LogicalModelInfo b -> NativeQueryMetadata b -> m (InterpolatedQuery ArgumentName)
validateStoredProcedure :: (BackendMetadata b, MonadIO m, MonadError QErr m) => Environment -> SourceConnConfiguration b -> LogicalModelInfo b -> StoredProcedureMetadata b -> m ()
getStoredProcedureGraphqlName :: (BackendMetadata b, MonadError QErr m) => FunctionName b -> StoredProcedureConfig -> m Name

-- | Allows the backend to control whether or not a particular source
--   supports being the target of remote relationships or not
supportsBeingRemoteRelationshipTarget :: BackendMetadata b => SourceConfig b -> Bool


-- | Define and handle v1/metadata API operations to track, untrack, and
--   get stored procedures.
module Hasura.StoredProcedure.API

-- | API payload for the <tt>get_stored_procedure</tt> endpoint.
data GetStoredProcedure (b :: BackendType)
GetStoredProcedure :: SourceName -> GetStoredProcedure (b :: BackendType)
[gspSource] :: GetStoredProcedure (b :: BackendType) -> SourceName

-- | Default implementation of the <tt>track_stored_procedure_query</tt>
--   request payload.
data TrackStoredProcedure (b :: BackendType)
TrackStoredProcedure :: SourceName -> FunctionName b -> StoredProcedureConfig -> HashMap ArgumentName (NullableScalarType b) -> Maybe Text -> LogicalModelName -> TrackStoredProcedure (b :: BackendType)
[tspSource] :: TrackStoredProcedure (b :: BackendType) -> SourceName
[tspStoredProcedure] :: TrackStoredProcedure (b :: BackendType) -> FunctionName b
[tspConfig] :: TrackStoredProcedure (b :: BackendType) -> StoredProcedureConfig
[tspArguments] :: TrackStoredProcedure (b :: BackendType) -> HashMap ArgumentName (NullableScalarType b)
[tspDescription] :: TrackStoredProcedure (b :: BackendType) -> Maybe Text
[tspReturns] :: TrackStoredProcedure (b :: BackendType) -> LogicalModelName

-- | API payload for the <tt>untrack_stored_procedure</tt> endpoint.
data UntrackStoredProcedure (b :: BackendType)
UntrackStoredProcedure :: SourceName -> FunctionName b -> UntrackStoredProcedure (b :: BackendType)
[utspSource] :: UntrackStoredProcedure (b :: BackendType) -> SourceName
[utspStoredProcedure] :: UntrackStoredProcedure (b :: BackendType) -> FunctionName b

-- | Handler for the <tt>track_stored_procedure</tt> endpoint. The type
--   'TrackStoredProcedure b' (appearing here in wrapped as
--   'BackendTrackStoredProcedure b' for <tt>AnyBackend</tt> compatibility)
--   is defined in 'class StoredProcedureMetadata'.
execTrackStoredProcedure :: forall (b :: BackendType) m. (BackendMetadata b, MonadError QErr m) => TrackStoredProcedure b -> Metadata -> m (MetadataObjId, MetadataModifier)

-- | Handler for the <tt>untrack_stored_procedure</tt> endpoint.
execUntrackStoredProcedure :: forall (b :: BackendType) m. (BackendMetadata b, MonadError QErr m) => UntrackStoredProcedure b -> Metadata -> m (MetadataObjId, MetadataModifier)

-- | Handler for the <tt>get_stored_procedure</tt> endpoint.
runGetStoredProcedure :: forall (b :: BackendType) m. (BackendMetadata b, MetadataM m) => GetStoredProcedure b -> m EncJSON
dropStoredProcedureInMetadata :: forall (b :: BackendType). BackendMetadata b => SourceName -> FunctionName b -> MetadataModifier
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.StoredProcedure.API.GetStoredProcedure b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.StoredProcedure.API.UntrackStoredProcedure b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.StoredProcedure.API.GetStoredProcedure b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.StoredProcedure.API.TrackStoredProcedure b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.StoredProcedure.API.UntrackStoredProcedure b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.StoredProcedure.API.TrackStoredProcedure b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.StoredProcedure.API.GetStoredProcedure b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.StoredProcedure.API.UntrackStoredProcedure b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.StoredProcedure.API.GetStoredProcedure b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.StoredProcedure.API.TrackStoredProcedure b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.StoredProcedure.API.UntrackStoredProcedure b)


-- | This module provides an API for suggesting relationships so that the
--   console (or client) does not need to construct and submit relationship
--   queries itself.
--   
--   This suggests reciprocal object relationships A -&gt; object -&gt; B
--   -&gt; object -&gt; A if there is a unique constraint on the column(s)
--   in A mapping A-&gt;B, and if not then a reciprocal array relationship
--   A -&gt; object -&gt; B -&gt; array -&gt; A is suggested.
--   
--   All JSON fields to the main exported function <a>runSuggestRels</a>
--   are optional and behave as follows:
--   
--   <ul>
--   <li>_srsSource: The source to suggest relationships for - Defaults to
--   <a>defaultSource</a></li>
--   <li>_srsTables: The tables to suggest relationships between - Defaults
--   to all tables</li>
--   <li>_srsOmitTracked: Only suggest untracked relationships - Defaults
--   to False</li>
--   </ul>
--   
--   Autodocodec Codecs instances are implemented for these datatypes.
module Hasura.RQL.DDL.Relationship.Suggest

-- | Datatype used by Metadata API to represent Request for Suggested
--   Relationships
data SuggestRels (b :: BackendType)

-- | The method invoked when dispatching on metadata calls in POST
--   <i>v1</i>metadata
runSuggestRels :: forall (b :: BackendType) m. (MonadError QErr m, CacheRWM m, BackendMetadata b) => SuggestRels b -> m EncJSON
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Relationship.Suggest.Mapping b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Relationship.Suggest.Relationship b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Relationship.Suggest.SuggestRels b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Relationship.Suggest.SuggestedRelationships b)
instance GHC.Internal.Generics.Generic (Hasura.RQL.DDL.Relationship.Suggest.Mapping b)
instance GHC.Internal.Generics.Generic (Hasura.RQL.DDL.Relationship.Suggest.Relationship b)
instance GHC.Internal.Generics.Generic (Hasura.RQL.DDL.Relationship.Suggest.SuggestRels b)
instance GHC.Internal.Generics.Generic (Hasura.RQL.DDL.Relationship.Suggest.SuggestedRelationships b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.DDL.Relationship.Suggest.Mapping b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.DDL.Relationship.Suggest.Relationship b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.DDL.Relationship.Suggest.SuggestRels b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.DDL.Relationship.Suggest.SuggestedRelationships b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.DDL.Relationship.Suggest.Mapping b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.DDL.Relationship.Suggest.Relationship b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.DDL.Relationship.Suggest.SuggestRels b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.DDL.Relationship.Suggest.SuggestedRelationships b)
instance Hasura.RQL.Types.Backend.Backend b => Data.OpenApi.Internal.Schema.ToSchema (Hasura.RQL.DDL.Relationship.Suggest.Mapping b)
instance Hasura.RQL.Types.Backend.Backend b => Data.OpenApi.Internal.Schema.ToSchema (Hasura.RQL.DDL.Relationship.Suggest.Relationship b)
instance Hasura.RQL.Types.Backend.Backend b => Data.OpenApi.Internal.Schema.ToSchema (Hasura.RQL.DDL.Relationship.Suggest.SuggestRels b)
instance Hasura.RQL.Types.Backend.Backend b => Data.OpenApi.Internal.Schema.ToSchema (Hasura.RQL.DDL.Relationship.Suggest.SuggestedRelationships b)

module Hasura.RQL.DDL.Permission.Internal
newtype CreatePerm (a :: BackendType -> Type) (b :: BackendType)
CreatePerm :: WithTable b (PermDef b a) -> CreatePerm (a :: BackendType -> Type) (b :: BackendType)
data DropPerm (b :: BackendType)
DropPerm :: SourceName -> TableName b -> RoleName -> DropPerm (b :: BackendType)
[dipSource] :: DropPerm (b :: BackendType) -> SourceName
[dipTable] :: DropPerm (b :: BackendType) -> TableName b
[dipRole] :: DropPerm (b :: BackendType) -> RoleName
permissionIsDefined :: forall (backend :: BackendType). PermType -> RolePermInfo backend -> Bool
assertPermDefined :: forall (backend :: BackendType) m. (Backend backend, MonadError QErr m) => RoleName -> PermType -> TableInfo backend -> m ()

-- | Intrepet a <a>PermColSpec</a> column specification, which can either
--   refer to a list of named columns or all columns.
interpColSpec :: forall (b :: BackendType). [Column b] -> PermColSpec b -> [Column b]
getDepHeadersFromVal :: Value -> [Text]
getDependentHeaders :: forall (b :: BackendType). BoolExp b -> HashSet Text
annBoolExp :: forall m (b :: BackendType) v. (QErrM m, TableCoreInfoRM b m, LogicalModelFieldsRM b m, BackendMetadata b) => BoolExpRHSParser b m v -> FieldInfoMap (FieldInfo b) -> FieldInfoMap (FieldInfo b) -> GBoolExp b ColExp -> m (AnnBoolExp b v)
procBoolExp :: forall m (b :: BackendType) r. (QErrM m, TableCoreInfoRM b m, LogicalModelFieldsRM b m, BackendMetadata b, GetAggregationPredicatesDeps b, MonadReader r m, Has (ScalarTypeParsingContext b) r) => SourceName -> TableName b -> FieldInfoMap (FieldInfo b) -> BoolExp b -> m (AnnBoolExpPartialSQL b, Seq SchemaDependency)

-- | Interpret a <a>BoolExp</a> into an <a>AnnBoolExp</a>, collecting any
--   dependencies as we go. At the moment, the only dependencies we're
--   likely to encounter are independent dependencies on other tables. For
--   example, "this user can only select from this logical model if their
--   ID is in the <tt>allowed_users</tt> table".
procLogicalModelBoolExp :: forall (b :: BackendType) m r. (QErrM m, TableCoreInfoRM b m, LogicalModelFieldsRM b m, BackendMetadata b, GetAggregationPredicatesDeps b, MonadReader r m, Has (ScalarTypeParsingContext b) r) => SourceName -> LogicalModelLocation -> FieldInfoMap (FieldInfo b) -> BoolExp b -> m (AnnBoolExpPartialSQL b, Seq SchemaDependency)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.RQL.DDL.Permission.Internal.CreatePermP1Res a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Permission.PermDef b a)) => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Permission.Internal.CreatePerm a b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Permission.Internal.DropPerm b)
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (Hasura.RQL.DDL.Permission.Internal.CreatePermP1Res a)


-- | Metadata API Actions relating to Source Kinds
module Hasura.RQL.DDL.SourceKinds
data ListSourceKinds
ListSourceKinds :: ListSourceKinds
runListSourceKinds :: (MetadataM m, MonadError QErr m, CacheRM m) => ListSourceKinds -> m EncJSON
agentSourceKinds :: MetadataM m => m SourceKinds
data SourceKindInfo
SourceKindInfo :: Text -> Maybe Text -> Maybe Text -> SourceType -> Bool -> SourceKindInfo
[_skiSourceKind] :: SourceKindInfo -> Text
[_skiDisplayName] :: SourceKindInfo -> Maybe Text
[_skiReleaseName] :: SourceKindInfo -> Maybe Text
[_skiBuiltin] :: SourceKindInfo -> SourceType
[_skiAvailable] :: SourceKindInfo -> Bool
data SourceType
Builtin :: SourceType
Agent :: SourceType
newtype SourceKinds
SourceKinds :: [SourceKindInfo] -> SourceKinds
[unSourceKinds] :: SourceKinds -> [SourceKindInfo]
newtype GetSourceKindCapabilities
GetSourceKindCapabilities :: NonEmptyText -> GetSourceKindCapabilities
[_gskcKind] :: GetSourceKindCapabilities -> NonEmptyText

-- | List Backend Capabilities. Currently this only supports Data Connector
--   Backends.
runGetSourceKindCapabilities :: (MonadError QErr m, CacheRM m) => GetSourceKindCapabilities -> m EncJSON
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.SourceKinds.GetSourceKindCapabilities
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.SourceKinds.ListSourceKinds
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.SourceKinds.SourceKindInfo
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.SourceKinds.SourceType
instance GHC.Internal.Base.Monoid Hasura.RQL.DDL.SourceKinds.SourceKinds
instance GHC.Internal.Base.Semigroup Hasura.RQL.DDL.SourceKinds.SourceKinds
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.SourceKinds.ListSourceKinds
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.SourceKinds.SourceKindInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.SourceKinds.SourceKinds
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.SourceKinds.SourceType

module Hasura.RQL.DDL.SchemaRegistry
newtype SchemaProjectId
SchemaProjectId :: Text -> SchemaProjectId
[_spiProjectId] :: SchemaProjectId -> Text
newtype IsMetadataInconsistent
IsMetadataInconsistent :: Bool -> IsMetadataInconsistent
[_isMdInconsistent] :: IsMetadataInconsistent -> Bool
newtype SchemaSDL
SchemaSDL :: Text -> SchemaSDL
[_sdl] :: SchemaSDL -> Text
newtype SchemaHash
SchemaHash :: Text -> SchemaHash
[_schemaHash] :: SchemaHash -> Text
data ProjectGQLSchemaInformation
ProjectGQLSchemaInformation :: SchemaRegistryMap -> IsMetadataInconsistent -> SchemaHash -> MetadataResourceVersion -> UTCTime -> Metadata -> ProjectGQLSchemaInformation
[_pgsiSchemaRegistryMap] :: ProjectGQLSchemaInformation -> SchemaRegistryMap
[_pgsiIsMetadataInconsistent] :: ProjectGQLSchemaInformation -> IsMetadataInconsistent
[_pgsiAdminSchemaHash] :: ProjectGQLSchemaInformation -> SchemaHash
[_pgsiMetadataResourceVersion] :: ProjectGQLSchemaInformation -> MetadataResourceVersion
[_pgsiChangeRecordedAt] :: ProjectGQLSchemaInformation -> UTCTime
[_pgsiMetadata] :: ProjectGQLSchemaInformation -> Metadata
data SchemaRegistryConfig
SchemaRegistryConfig :: Text -> Maybe Text -> SchemaRegistryConfig
[_srcSchemaRegistryWebhook] :: SchemaRegistryConfig -> Text
[_srcSchemaRegistryAccessKey] :: SchemaRegistryConfig -> Maybe Text
data SchemaRegistryDetails
SchemaRegistryDetails :: RoleName -> GQLSchemaInformation -> SchemaRegistryDetails
[_srdlSchemaRole] :: SchemaRegistryDetails -> RoleName
[_srdlSchemaInfo] :: SchemaRegistryDetails -> GQLSchemaInformation
data GQLSchemaInformation
GQLSchemaInformation :: SchemaSDL -> SchemaHash -> GQLSchemaInformation
[_gsiSchemaSDL] :: GQLSchemaInformation -> SchemaSDL
[_gsiSchemaHash] :: GQLSchemaInformation -> SchemaHash

-- | Context required to upate schema registry everytime the schema is
--   updated
data SchemaRegistryContext
SchemaRegistryContext :: TQueue ProjectGQLSchemaInformation -> PGPool -> SchemaRegistryContext
[_srpaSchemaRegistryTQueueRef] :: SchemaRegistryContext -> TQueue ProjectGQLSchemaInformation
[_srpaMetadataDbPoolRef] :: SchemaRegistryContext -> PGPool
newtype SchemaRegistryControlRole
SchemaRegistryControlRole :: Text -> SchemaRegistryControlRole
[unSchemaRegistryControlRole] :: SchemaRegistryControlRole -> Text
type SchemaRegistryMap = HashMap RoleName GQLSchemaInformation
type SchemaRegistryDetailsList = [SchemaRegistryDetails]
type SchemaRegistryAction = Maybe MetadataResourceVersion -> [InconsistentMetadata] -> Metadata -> IO ()
data SchemaRegistryConfigRaw
SchemaRegistryConfigRaw :: Maybe Text -> Maybe Text -> SchemaRegistryConfigRaw
[_srcrSchemaRegistryWebhook] :: SchemaRegistryConfigRaw -> Maybe Text
[_srcrSchemaRegistryAccessKey] :: SchemaRegistryConfigRaw -> Maybe Text
calculateSchemaSDLHash :: Text -> RoleName -> SchemaHash
selectNowQuery :: TxE QErr UTCTime
instance GHC.Classes.Eq Hasura.RQL.DDL.SchemaRegistry.GQLSchemaInformation
instance GHC.Classes.Eq Hasura.RQL.DDL.SchemaRegistry.IsMetadataInconsistent
instance GHC.Classes.Eq Hasura.RQL.DDL.SchemaRegistry.ProjectGQLSchemaInformation
instance GHC.Classes.Eq Hasura.RQL.DDL.SchemaRegistry.SchemaHash
instance GHC.Classes.Eq Hasura.RQL.DDL.SchemaRegistry.SchemaProjectId
instance GHC.Classes.Eq Hasura.RQL.DDL.SchemaRegistry.SchemaRegistryConfig
instance GHC.Classes.Eq Hasura.RQL.DDL.SchemaRegistry.SchemaRegistryConfigRaw
instance GHC.Classes.Eq Hasura.RQL.DDL.SchemaRegistry.SchemaRegistryControlRole
instance GHC.Classes.Eq Hasura.RQL.DDL.SchemaRegistry.SchemaRegistryDetails
instance GHC.Classes.Eq Hasura.RQL.DDL.SchemaRegistry.SchemaSDL
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.SchemaRegistry.GQLSchemaInformation
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.SchemaRegistry.IsMetadataInconsistent
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.SchemaRegistry.ProjectGQLSchemaInformation
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.SchemaRegistry.SchemaHash
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.SchemaRegistry.SchemaProjectId
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.SchemaRegistry.SchemaRegistryDetails
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.SchemaRegistry.SchemaSDL
instance GHC.Internal.Generics.Generic Hasura.RQL.DDL.SchemaRegistry.GQLSchemaInformation
instance GHC.Internal.Generics.Generic Hasura.RQL.DDL.SchemaRegistry.IsMetadataInconsistent
instance GHC.Internal.Generics.Generic Hasura.RQL.DDL.SchemaRegistry.ProjectGQLSchemaInformation
instance GHC.Internal.Generics.Generic Hasura.RQL.DDL.SchemaRegistry.SchemaHash
instance GHC.Internal.Generics.Generic Hasura.RQL.DDL.SchemaRegistry.SchemaProjectId
instance GHC.Internal.Generics.Generic Hasura.RQL.DDL.SchemaRegistry.SchemaRegistryDetails
instance GHC.Internal.Generics.Generic Hasura.RQL.DDL.SchemaRegistry.SchemaSDL
instance GHC.Internal.Show.Show Hasura.RQL.DDL.SchemaRegistry.GQLSchemaInformation
instance GHC.Internal.Show.Show Hasura.RQL.DDL.SchemaRegistry.IsMetadataInconsistent
instance GHC.Internal.Show.Show Hasura.RQL.DDL.SchemaRegistry.ProjectGQLSchemaInformation
instance GHC.Internal.Show.Show Hasura.RQL.DDL.SchemaRegistry.SchemaHash
instance GHC.Internal.Show.Show Hasura.RQL.DDL.SchemaRegistry.SchemaProjectId
instance GHC.Internal.Show.Show Hasura.RQL.DDL.SchemaRegistry.SchemaRegistryConfig
instance GHC.Internal.Show.Show Hasura.RQL.DDL.SchemaRegistry.SchemaRegistryConfigRaw
instance GHC.Internal.Show.Show Hasura.RQL.DDL.SchemaRegistry.SchemaRegistryControlRole
instance GHC.Internal.Show.Show Hasura.RQL.DDL.SchemaRegistry.SchemaRegistryDetails
instance GHC.Internal.Show.Show Hasura.RQL.DDL.SchemaRegistry.SchemaSDL
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.SchemaRegistry.GQLSchemaInformation
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.SchemaRegistry.IsMetadataInconsistent
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.SchemaRegistry.ProjectGQLSchemaInformation
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.SchemaRegistry.SchemaHash
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.SchemaRegistry.SchemaProjectId
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.SchemaRegistry.SchemaRegistryDetails
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.SchemaRegistry.SchemaSDL


-- | Functions for fetching and updating @<a>Metadata</a> in the catalog.
module Hasura.RQL.DDL.Schema.Catalog
fetchMetadataFromCatalog :: TxE QErr Metadata
fetchMetadataAndResourceVersionFromCatalog :: TxE QErr MetadataWithResourceVersion
fetchMetadataResourceVersionFromCatalog :: TxE QErr MetadataResourceVersion
fetchMetadataNotificationsFromCatalog :: MetadataResourceVersion -> InstanceId -> TxE QErr [(MetadataResourceVersion, CacheInvalidations)]
insertMetadataInCatalog :: Metadata -> TxE QErr ()

-- | Check that the specified resource version matches the currently stored
--   one, and...
--   
--   <ul>
--   <li>If so: Update the metadata and bump the version</li>
--   <li>If not: Throw a 409 error</li>
--   </ul>
setMetadataInCatalog :: MetadataResourceVersion -> Metadata -> TxE QErr MetadataResourceVersion
bumpMetadataVersionInCatalog :: TxE QErr ()

module Hasura.RQL.DDL.Schema.Cache.Config

-- | This type aggregates all of the "static" configuration of the cache
--   build.
--   
--   Static arguments are the ones that will not change during the
--   execution of the engine. They are a subset of the environment of the
--   engine (see <tt>AppEnv</tt> and Note [Hasura Application State] for
--   more information).
--   
--   While <tt>AppEnv</tt> has access to the union of *all* the static
--   configuration of the engine, more specific parts of the code should
--   avoid relying directly on it to avoid being tied to unrelated parts of
--   the codebase. (See FIXME).
data CacheStaticConfig
CacheStaticConfig :: MaintenanceMode () -> EventingMode -> ReadOnlyMode -> Logger Hasura -> (BackendType -> Bool) -> Bool -> CacheStaticConfig
[_cscMaintenanceMode] :: CacheStaticConfig -> MaintenanceMode ()
[_cscEventingMode] :: CacheStaticConfig -> EventingMode
[_cscReadOnlyMode] :: CacheStaticConfig -> ReadOnlyMode
[_cscLogger] :: CacheStaticConfig -> Logger Hasura

-- | Native queries can be enabled or disabled on the fly via a feature
--   flag, however we only recognise a change on a restart
[_cscAreNativeQueriesEnabled] :: CacheStaticConfig -> BackendType -> Bool

-- | Stored procedures can be enabled or disabled on the fly via a feature
--   flag, however we only recognise a change on a restart
[_cscAreStoredProceduresEnabled] :: CacheStaticConfig -> Bool
class Monad m => HasCacheStaticConfig (m :: Type -> Type)
askCacheStaticConfig :: HasCacheStaticConfig m => m CacheStaticConfig

-- | This type aggregates all of the "dynamic" configuration of the cache
--   build.
--   
--   Dynamic arguments are the ones that might change during the execution
--   of the engine. They are a subset of the <tt>AppContext</tt> (see Note
--   [Hasura Application State] for more information).
--   
--   While <tt>AppContext</tt> has access to the union of *all* the dynamic
--   configuration of the engine, more specific parts of the code should
--   avoid relying directly on it to avoid being tied to unrelated parts of
--   the codebase. (See FIXME).
data CacheDynamicConfig
CacheDynamicConfig :: InferFunctionPermissions -> RemoteSchemaPermissions -> SQLGenCtx -> HashSet ExperimentalFeature -> NamingCase -> MetadataDefaults -> ApolloFederationStatus -> CloseWebsocketsOnMetadataChangeStatus -> SchemaSampledFeatureFlags -> CacheDynamicConfig
[_cdcFunctionPermsCtx] :: CacheDynamicConfig -> InferFunctionPermissions
[_cdcRemoteSchemaPermsCtx] :: CacheDynamicConfig -> RemoteSchemaPermissions
[_cdcSQLGenCtx] :: CacheDynamicConfig -> SQLGenCtx
[_cdcExperimentalFeatures] :: CacheDynamicConfig -> HashSet ExperimentalFeature
[_cdcDefaultNamingConvention] :: CacheDynamicConfig -> NamingCase
[_cdcMetadataDefaults] :: CacheDynamicConfig -> MetadataDefaults
[_cdcApolloFederationStatus] :: CacheDynamicConfig -> ApolloFederationStatus
[_cdcCloseWebsocketsOnMetadataChangeStatus] :: CacheDynamicConfig -> CloseWebsocketsOnMetadataChangeStatus
[_cdcSchemaSampledFeatureFlags] :: CacheDynamicConfig -> SchemaSampledFeatureFlags
instance GHC.Classes.Eq Hasura.RQL.DDL.Schema.Cache.Config.CacheDynamicConfig
instance Hasura.RQL.DDL.Schema.Cache.Config.HasCacheStaticConfig m => Hasura.RQL.DDL.Schema.Cache.Config.HasCacheStaticConfig (Control.Monad.Trans.Except.ExceptT e m)
instance Hasura.RQL.DDL.Schema.Cache.Config.HasCacheStaticConfig m => Hasura.RQL.DDL.Schema.Cache.Config.HasCacheStaticConfig (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.RQL.DDL.Schema.Cache.Config.HasCacheStaticConfig m => Hasura.RQL.DDL.Schema.Cache.Config.HasCacheStaticConfig (Control.Monad.Trans.State.Strict.StateT s m)

module Hasura.RQL.DDL.QueryTags
data SetQueryTagsConfig
runSetQueryTagsConfig :: (MonadError QErr m, MetadataM m, CacheRWM m) => SetQueryTagsConfig -> m EncJSON
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.QueryTags.SetQueryTagsConfig
instance GHC.Internal.Generics.Generic Hasura.RQL.DDL.QueryTags.SetQueryTagsConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.QueryTags.SetQueryTagsConfig

module Hasura.RQL.DDL.QueryCollection
runCreateCollection :: (QErrM m, CacheRWM m, MetadataM m) => CreateCollection -> m EncJSON
runRenameCollection :: (QErrM m, CacheRWM m, MetadataM m) => RenameCollection -> m EncJSON
runDropCollection :: (MonadError QErr m, MetadataM m, CacheRWM m) => DropCollection -> m EncJSON
runAddQueryToCollection :: (CacheRWM m, MonadError QErr m, MetadataM m) => AddQueryToCollection -> m EncJSON
runDropQueryFromCollection :: (CacheRWM m, MonadError QErr m, MetadataM m) => DropQueryFromCollection -> m EncJSON
runAddCollectionToAllowlist :: (MonadError QErr m, MetadataM m, CacheRWM m) => AllowlistEntry -> m EncJSON
runDropCollectionFromAllowlist :: (MonadError QErr m, MetadataM m, CacheRWM m) => DropCollectionFromAllowlist -> m EncJSON
runUpdateScopeOfCollectionInAllowlist :: (MonadError QErr m, MetadataM m, CacheRWM m) => UpdateScopeOfCollectionInAllowlist -> m EncJSON

module Hasura.RQL.DDL.Permission
data CreatePerm (a :: BackendType -> Type) (b :: BackendType)
runCreatePerm :: forall m (b :: BackendType) (a :: BackendType -> Type). (UserInfoM m, CacheRWM m, MonadError QErr m, MetadataM m, BackendMetadata b) => CreatePerm a b -> m EncJSON
data PermDef (b :: BackendType) (perm :: BackendType -> Type)
PermDef :: RoleName -> PermDefPermission b perm -> Maybe Text -> PermDef (b :: BackendType) (perm :: BackendType -> Type)
[_pdRole] :: PermDef (b :: BackendType) (perm :: BackendType -> Type) -> RoleName
[_pdPermission] :: PermDef (b :: BackendType) (perm :: BackendType -> Type) -> PermDefPermission b perm
[_pdComment] :: PermDef (b :: BackendType) (perm :: BackendType -> Type) -> Maybe Text
data InsPerm (b :: BackendType)
InsPerm :: BoolExp b -> Maybe (ColumnValues b Value) -> Maybe (PermColSpec b) -> Bool -> Maybe (ValidateInput InputWebhook) -> InsPerm (b :: BackendType)
[ipCheck] :: InsPerm (b :: BackendType) -> BoolExp b
[ipSet] :: InsPerm (b :: BackendType) -> Maybe (ColumnValues b Value)
[ipColumns] :: InsPerm (b :: BackendType) -> Maybe (PermColSpec b)
[ipBackendOnly] :: InsPerm (b :: BackendType) -> Bool
[ipValidateInput] :: InsPerm (b :: BackendType) -> Maybe (ValidateInput InputWebhook)
type InsPermDef (b :: BackendType) = PermDef b InsPerm
buildInsPermInfo :: forall (b :: BackendType) m r. (QErrM m, TableCoreInfoRM b m, LogicalModelFieldsRM b m, BackendMetadata b, GetAggregationPredicatesDeps b, MonadReader r m, Has (ScalarTypeParsingContext b) r) => Environment -> SourceName -> TableName b -> FieldInfoMap (FieldInfo b) -> InsPerm b -> m (WithDeps (InsPermInfo b))
data SelPerm (b :: BackendType)
SelPerm :: PermColSpec b -> BoolExp b -> Maybe Int -> Bool -> [ComputedFieldName] -> AllowedRootFields QueryRootFieldType -> AllowedRootFields SubscriptionRootFieldType -> SelPerm (b :: BackendType)

-- | Allowed columns
[spColumns] :: SelPerm (b :: BackendType) -> PermColSpec b

-- | Filter expression
[spFilter] :: SelPerm (b :: BackendType) -> BoolExp b

-- | Limit value
[spLimit] :: SelPerm (b :: BackendType) -> Maybe Int

-- | Allow aggregation
[spAllowAggregations] :: SelPerm (b :: BackendType) -> Bool

-- | Allowed computed fields which should not include the fields returning
--   rows of existing table.
[spComputedFields] :: SelPerm (b :: BackendType) -> [ComputedFieldName]
[spAllowedQueryRootFields] :: SelPerm (b :: BackendType) -> AllowedRootFields QueryRootFieldType
[spAllowedSubscriptionRootFields] :: SelPerm (b :: BackendType) -> AllowedRootFields SubscriptionRootFieldType
type SelPermDef (b :: BackendType) = PermDef b SelPerm
buildSelPermInfo :: forall (b :: BackendType) m r. (QErrM m, TableCoreInfoRM b m, LogicalModelFieldsRM b m, BackendMetadata b, GetAggregationPredicatesDeps b, MonadReader r m, Has (ScalarTypeParsingContext b) r) => SourceName -> TableName b -> FieldInfoMap (FieldInfo b) -> RoleName -> SelPerm b -> m (WithDeps (SelPermInfo b))
data UpdPerm (b :: BackendType)
UpdPerm :: PermColSpec b -> Maybe (ColumnValues b Value) -> BoolExp b -> Maybe (BoolExp b) -> Bool -> Maybe (ValidateInput InputWebhook) -> UpdPerm (b :: BackendType)
[ucColumns] :: UpdPerm (b :: BackendType) -> PermColSpec b
[ucSet] :: UpdPerm (b :: BackendType) -> Maybe (ColumnValues b Value)
[ucFilter] :: UpdPerm (b :: BackendType) -> BoolExp b

-- | Check expression, which must be true after update. This is optional
--   because we don't want to break the v1 API but Nothing should be
--   equivalent to the expression which always returns true.
[ucCheck] :: UpdPerm (b :: BackendType) -> Maybe (BoolExp b)
[ucBackendOnly] :: UpdPerm (b :: BackendType) -> Bool
[ucValidateInput] :: UpdPerm (b :: BackendType) -> Maybe (ValidateInput InputWebhook)
type UpdPermDef (b :: BackendType) = PermDef b UpdPerm
buildUpdPermInfo :: forall (b :: BackendType) m r. (QErrM m, TableCoreInfoRM b m, LogicalModelFieldsRM b m, BackendMetadata b, GetAggregationPredicatesDeps b, MonadReader r m, Has (ScalarTypeParsingContext b) r) => Environment -> SourceName -> TableName b -> FieldInfoMap (FieldInfo b) -> UpdPerm b -> m (WithDeps (UpdPermInfo b))
data DelPerm (b :: BackendType)
DelPerm :: BoolExp b -> Bool -> Maybe (ValidateInput InputWebhook) -> DelPerm (b :: BackendType)
[dcFilter] :: DelPerm (b :: BackendType) -> BoolExp b
[dcBackendOnly] :: DelPerm (b :: BackendType) -> Bool
[dcValidateInput] :: DelPerm (b :: BackendType) -> Maybe (ValidateInput InputWebhook)
type DelPermDef (b :: BackendType) = PermDef b DelPerm
buildDelPermInfo :: forall (b :: BackendType) m r. (QErrM m, TableCoreInfoRM b m, LogicalModelFieldsRM b m, BackendMetadata b, GetAggregationPredicatesDeps b, MonadReader r m, Has (ScalarTypeParsingContext b) r) => Environment -> SourceName -> TableName b -> FieldInfoMap (FieldInfo b) -> DelPerm b -> m (WithDeps (DelPermInfo b))
data DropPerm (b :: BackendType)
runDropPerm :: forall (b :: BackendType) m. (UserInfoM m, CacheRWM m, MonadError QErr m, MetadataM m, BackendMetadata b) => PermType -> DropPerm b -> m EncJSON
dropPermissionInMetadata :: forall (b :: BackendType). RoleName -> PermType -> TableMetadata b -> TableMetadata b
data SetPermComment (b :: BackendType)
SetPermComment :: SourceName -> TableName b -> RoleName -> PermType -> Maybe Text -> SetPermComment (b :: BackendType)
[apSource] :: SetPermComment (b :: BackendType) -> SourceName
[apTable] :: SetPermComment (b :: BackendType) -> TableName b
[apRole] :: SetPermComment (b :: BackendType) -> RoleName
[apPermission] :: SetPermComment (b :: BackendType) -> PermType
[apComment] :: SetPermComment (b :: BackendType) -> Maybe Text
runSetPermComment :: forall (b :: BackendType) m. (QErrM m, CacheRWM m, MetadataM m, BackendMetadata b) => SetPermComment b -> m EncJSON
type family PermInfo (perm :: BackendType -> Type) :: BackendType -> Type
buildPermInfo :: forall (b :: BackendType) m r (perm :: BackendType -> Type). (BackendMetadata b, QErrM m, TableCoreInfoRM b m, LogicalModelFieldsRM b m, GetAggregationPredicatesDeps b, MonadReader r m, Has (ScalarTypeParsingContext b) r) => Environment -> SourceName -> TableName b -> FieldInfoMap (FieldInfo b) -> RoleName -> PermDefPermission b perm -> m (WithDeps (PermInfo perm b))

-- | Given the logical model's definition and the permissions as defined in
--   the logical model's metadata, try to construct the permission
--   definition.
buildLogicalModelPermInfo :: forall (b :: BackendType) m r (perm :: BackendType -> Type). (BackendMetadata b, QErrM m, TableCoreInfoRM b m, LogicalModelFieldsRM b m, GetAggregationPredicatesDeps b, MonadReader r m, Has (ScalarTypeParsingContext b) r) => SourceName -> LogicalModelLocation -> InsOrdHashMap (Column b) (LogicalModelField b) -> PermDefPermission b perm -> m (WithDeps (PermInfo perm b))
addPermissionToMetadata :: forall (b :: BackendType) (a :: BackendType -> Type). PermDef b a -> TableMetadata b -> TableMetadata b
annBoolExp :: forall m (b :: BackendType) v. (QErrM m, TableCoreInfoRM b m, LogicalModelFieldsRM b m, BackendMetadata b) => BoolExpRHSParser b m v -> FieldInfoMap (FieldInfo b) -> FieldInfoMap (FieldInfo b) -> GBoolExp b ColExp -> m (AnnBoolExp b v)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Permission.SetPermComment b)


-- | Functions for updating the metadata (with integrity checking) to
--   incorporate schema changes discovered after applying a user-supplied
--   SQL query. None of these functions modify the schema cache, so it must
--   be reloaded after the metadata is updated.
module Hasura.RQL.DDL.Schema.Rename

-- | Replace all references to a given table name by its new name across
--   the entire metadata.
--   
--   This function will make use of the metadata dependency graph (see
--   <a>getDependentObjs</a>) to identify all places that refer to the old
--   table name, and replace it accordingly. Most operations will occur
--   within the same source, such as table references in relationships and
--   permissions. Dependencies across sources can happen in the case of
--   cross-source relationships.
--   
--   This function will fail if it encounters a nonsensical dependency; for
--   instance, if there's a dependency from that table to a source.
--   
--   For more information about the dependency graph, see
--   <a>SchemaObjId</a>.
renameTableInMetadata :: forall (b :: BackendType) m. (MonadError QErr m, CacheRM m, MonadWriter MetadataModifier m, BackendMetadata b) => SourceName -> TableName b -> TableName b -> m ()

-- | Replace all references to a given column name by its new name across
--   the entire metadata.
--   
--   This function will make use of the metadata dependency graph (see
--   <a>getDependentObjs</a>) to identify all places that refer to the old
--   column name, and replace it accordingly. Most operations will occur
--   within the same source, such as column references in relationships and
--   permissions. Dependencies across sources can happen in the case of
--   cross-source relationships.
--   
--   This function will fail if it encounters a nonsensical dependency; for
--   instance, if there's a dependency from that table to a source.
--   
--   For more information about the dependency graph, see
--   <a>SchemaObjId</a>.
renameColumnInMetadata :: forall (b :: BackendType) m. (MonadError QErr m, CacheRM m, MonadWriter MetadataModifier m, BackendMetadata b, Column b ~ ColumnPath b) => Column b -> Column b -> SourceName -> TableName b -> FieldInfoMap (FieldInfo b) -> m ()
renameRelationshipInMetadata :: forall (b :: BackendType) m. (MonadError QErr m, CacheRM m, MonadWriter MetadataModifier m, BackendMetadata b) => SourceName -> TableName b -> RelName -> RelType -> RelName -> m ()

module Hasura.RQL.DDL.Relationship
newtype CreateArrRel (b :: BackendType)
CreateArrRel :: WithTable b (ArrRelDef b) -> CreateArrRel (b :: BackendType)
[unCreateArrRel] :: CreateArrRel (b :: BackendType) -> WithTable b (ArrRelDef b)
newtype CreateObjRel (b :: BackendType)
CreateObjRel :: WithTable b (ObjRelDef b) -> CreateObjRel (b :: BackendType)
[unCreateObjRel] :: CreateObjRel (b :: BackendType) -> WithTable b (ObjRelDef b)
execCreateRelationship :: forall (b :: BackendType) m a. (BackendMetadata b, CacheRM m, MonadError QErr m, ToJSON a) => RelType -> WithTable b (RelDef a) -> Metadata -> m (MetadataObjId, MetadataModifier)
runCreateRelationship :: forall m (b :: BackendType) a. (MonadError QErr m, CacheRWM m, ToJSON a, MetadataM m, BackendMetadata b) => RelType -> WithTable b (RelDef a) -> m EncJSON
defaultBuildObjectRelationshipInfo :: forall (b :: BackendType) m. (QErrM m, Backend b) => SourceName -> HashMap (TableName b) (HashSet (ForeignKey b)) -> TableName b -> ObjRelDef b -> m (RelInfo b, Seq SchemaDependency)
defaultBuildArrayRelationshipInfo :: forall (b :: BackendType) m. (QErrM m, Backend b) => SourceName -> HashMap (TableName b) (HashSet (ForeignKey b)) -> TableName b -> ArrRelDef b -> m (RelInfo b, Seq SchemaDependency)
data DropRel (b :: BackendType)
execDropRel :: forall (b :: BackendType) m. (MonadError QErr m, CacheRWM m, BackendMetadata b) => DropRel b -> m MetadataModifier
runDropRel :: forall m (b :: BackendType). (MonadError QErr m, CacheRWM m, MetadataM m, BackendMetadata b) => DropRel b -> m EncJSON
dropRelationshipInMetadata :: forall (b :: BackendType). RelName -> TableMetadata b -> TableMetadata b
data SetRelComment (b :: BackendType)
runSetRelComment :: forall m (b :: BackendType). (CacheRWM m, MonadError QErr m, MetadataM m, BackendMetadata b) => SetRelComment b -> m EncJSON

-- | set up a relationship from a Native Query onto another data source
nativeQueryRelationshipSetup :: forall (b :: BackendType) m. (QErrM m, Backend b) => SourceName -> NativeQueryName -> RelType -> RelDef (RelManualConfig b) -> m (RelInfo b, Seq SchemaDependency)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.DDL.Relationship.SetRelComment b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Relationship.CreateArrRel b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Relationship.CreateObjRel b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Relationship.DropRel b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Relationship.SetRelComment b)
instance GHC.Internal.Generics.Generic (Hasura.RQL.DDL.Relationship.SetRelComment b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.DDL.Relationship.SetRelComment b)


-- | Types related to metadata management API
module Hasura.RQL.DDL.Metadata.Types

-- | <a>ExportMetadata</a> is used to export the current metadata from the
--   server as a JSON file.
--   
--   
--   <a>https://hasura.io/docs/latest/api-reference/metadata-api/manage-metadata/#metadata-export-metadata</a>
data ExportMetadata
ExportMetadata :: ExportMetadata

-- | <a>ReplaceMetadata</a> is used to replace/import metadata into Hasura.
--   Existing metadata will be replaced with the new one.
--   
--   
--   <a>https://hasura.io/docs/latest/api-reference/metadata-api/manage-metadata/#metadata-replace-metadata</a>
--   TODO: If additional API versions are supported in future it would be
--   ideal to include a version field Rather than differentiating on the
--   "metadata" field.
data ReplaceMetadata
RMReplaceMetadataV1 :: ReplaceMetadataV1 -> ReplaceMetadata
RMReplaceMetadataV2 :: ReplaceMetadataV2 -> ReplaceMetadata

-- | Replace metadata either with or without metadata sources.
data ReplaceMetadataV1
RMWithSources :: Metadata -> ReplaceMetadataV1
RMWithoutSources :: MetadataNoSources -> ReplaceMetadataV1

-- | Replace metadata while allowing for inconsitency in the metadata
--   object.
--   
--   
--   <a>https://hasura.io/docs/latest/api-reference/metadata-api/manage-metadata/#metadata-replace-metadata-syntax</a>
data ReplaceMetadataV2
ReplaceMetadataV2 :: AllowInconsistentMetadata -> AllowWarnings -> ReplaceMetadataV1 -> ReplaceMetadataV2
[_rmv2AllowInconsistentMetadata] :: ReplaceMetadataV2 -> AllowInconsistentMetadata
[_rmv2AllowWarningss] :: ReplaceMetadataV2 -> AllowWarnings
[_rmv2Metadata] :: ReplaceMetadataV2 -> ReplaceMetadataV1
data AllowInconsistentMetadata
AllowInconsistentMetadata :: AllowInconsistentMetadata
NoAllowInconsistentMetadata :: AllowInconsistentMetadata

-- | <a>ReloadMetadata</a> should be used when there is a change in
--   underlying Postgres database that Hasura should be aware of. Example:
--   a new column is added to a table using psql and this column should now
--   be added to the GraphQL schema.
--   
--   
--   <a>https://hasura.io/docs/latest/api-reference/metadata-api/manage-metadata/#metadata-reload-metadata</a>
data ReloadMetadata
ReloadMetadata :: ReloadRemoteSchemas -> ReloadSources -> ReloadSources -> ReloadDataConnectors -> ReloadMetadata
[_rmReloadRemoteSchemas] :: ReloadMetadata -> ReloadRemoteSchemas
[_rmReloadSources] :: ReloadMetadata -> ReloadSources

-- | Provides a way for the user to allow to explicitly recreate event
--   triggers for some or all the sources. This is useful when a user may
--   have fiddled with the SQL trigger in the source and they'd simply want
--   the event trigger to be recreated without deleting and creating the
--   event trigger. By default, no source's event triggers will be
--   recreated.
[_rmRecreateEventTriggers] :: ReloadMetadata -> ReloadSources
[_rmReloadDataConnectors] :: ReloadMetadata -> ReloadDataConnectors
data ReloadSpec a
RSReloadAll :: ReloadSpec a
RSReloadList :: HashSet a -> ReloadSpec a

-- | <a>ClearMetadata</a> can be used to reset the state of Hasura -- clean
--   the current state by forgetting the tables tracked, relationships,
--   permissions, event triggers etc.
--   
--   
--   <a>https://hasura.io/docs/latest/api-reference/metadata-api/manage-metadata/#metadata-clear-metadata</a>
data ClearMetadata
ClearMetadata :: ClearMetadata

-- | <a>GetInconsistentMetadata</a> can be used to fetch all inconsistent
--   metadata objects.
--   
--   
--   <a>https://hasura.io/docs/latest/api-reference/schema-metadata-api/manage-metadata/#schema-metadata-get-inconsistent-metadata</a>
data GetInconsistentMetadata
GetInconsistentMetadata :: GetInconsistentMetadata

-- | <a>DropInconsistentMetadata</a> can be used to purge all inconsistent
--   objects from the metadata.
--   
--   
--   <a>https://hasura.io/docs/latest/api-reference/metadata-api/manage-metadata/#metadata-drop-inconsistent-metadata</a>
data DropInconsistentMetadata
DropInconsistentMetadata :: DropInconsistentMetadata

-- | <a>TestWebhookTransform</a> can be used to test out request
--   transformations using mock data.
--   
--   
--   <a>https://hasura.io/docs/latest/api-reference/metadata-api/manage-metadata/#test-webhook-transform</a>
data TestWebhookTransform
TestWebhookTransform :: Environment -> [Header] -> WebHookUrl -> Value -> RequestTransform -> Maybe MetadataResponseTransform -> Maybe SessionVariables -> TestWebhookTransform
[_twtEnv] :: TestWebhookTransform -> Environment
[_twtHeaders] :: TestWebhookTransform -> [Header]
[_twtWebhookUrl] :: TestWebhookTransform -> WebHookUrl
[_twtPayload] :: TestWebhookTransform -> Value
[_twtTransformer] :: TestWebhookTransform -> RequestTransform
[_twtResponseTransformer] :: TestWebhookTransform -> Maybe MetadataResponseTransform
[_twtSessionVariables] :: TestWebhookTransform -> Maybe SessionVariables
twtRequestTransformer :: Lens' TestWebhookTransform RequestTransform
twtResponseTransformer :: Lens' TestWebhookTransform (Maybe MetadataResponseTransform)
data WebHookUrl
EnvVar :: String -> WebHookUrl
URL :: Text -> WebHookUrl

-- | Undocumented Metadata API action which serializes the entire
--   <tt>SchemaCache</tt>.
data DumpInternalState
DumpInternalState :: DumpInternalState
instance GHC.Classes.Eq Hasura.RQL.DDL.Metadata.Types.AllowInconsistentMetadata
instance GHC.Classes.Eq Hasura.RQL.DDL.Metadata.Types.ClearMetadata
instance GHC.Classes.Eq Hasura.RQL.DDL.Metadata.Types.DropInconsistentMetadata
instance GHC.Classes.Eq Hasura.RQL.DDL.Metadata.Types.DumpInternalState
instance GHC.Classes.Eq Hasura.RQL.DDL.Metadata.Types.ExportMetadata
instance GHC.Classes.Eq Hasura.RQL.DDL.Metadata.Types.GetInconsistentMetadata
instance GHC.Classes.Eq Hasura.RQL.DDL.Metadata.Types.ReloadMetadata
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.RQL.DDL.Metadata.Types.ReloadSpec a)
instance GHC.Classes.Eq Hasura.RQL.DDL.Metadata.Types.ReplaceMetadata
instance GHC.Classes.Eq Hasura.RQL.DDL.Metadata.Types.ReplaceMetadataV1
instance GHC.Classes.Eq Hasura.RQL.DDL.Metadata.Types.ReplaceMetadataV2
instance GHC.Classes.Eq Hasura.RQL.DDL.Metadata.Types.TestWebhookTransform
instance GHC.Classes.Eq Hasura.RQL.DDL.Metadata.Types.WebHookUrl
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Metadata.Types.AllowInconsistentMetadata
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Metadata.Types.ClearMetadata
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Metadata.Types.DropInconsistentMetadata
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Metadata.Types.DumpInternalState
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Metadata.Types.ExportMetadata
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Metadata.Types.GetInconsistentMetadata
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Metadata.Types.ReloadMetadata
instance (Data.Aeson.Types.FromJSON.FromJSON a, Data.Hashable.Class.Hashable a) => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Metadata.Types.ReloadSpec a)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Metadata.Types.ReplaceMetadata
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Metadata.Types.ReplaceMetadataV1
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Metadata.Types.ReplaceMetadataV2
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Metadata.Types.TestWebhookTransform
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Metadata.Types.WebHookUrl
instance GHC.Internal.Generics.Generic Hasura.RQL.DDL.Metadata.Types.ClearMetadata
instance GHC.Internal.Generics.Generic Hasura.RQL.DDL.Metadata.Types.DropInconsistentMetadata
instance GHC.Internal.Generics.Generic Hasura.RQL.DDL.Metadata.Types.DumpInternalState
instance GHC.Internal.Generics.Generic Hasura.RQL.DDL.Metadata.Types.GetInconsistentMetadata
instance GHC.Internal.Generics.Generic Hasura.RQL.DDL.Metadata.Types.ReloadMetadata
instance GHC.Internal.Show.Show Hasura.RQL.DDL.Metadata.Types.AllowInconsistentMetadata
instance GHC.Internal.Show.Show Hasura.RQL.DDL.Metadata.Types.ClearMetadata
instance GHC.Internal.Show.Show Hasura.RQL.DDL.Metadata.Types.DropInconsistentMetadata
instance GHC.Internal.Show.Show Hasura.RQL.DDL.Metadata.Types.DumpInternalState
instance GHC.Internal.Show.Show Hasura.RQL.DDL.Metadata.Types.ExportMetadata
instance GHC.Internal.Show.Show Hasura.RQL.DDL.Metadata.Types.GetInconsistentMetadata
instance GHC.Internal.Show.Show Hasura.RQL.DDL.Metadata.Types.ReloadMetadata
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (Hasura.RQL.DDL.Metadata.Types.ReloadSpec a)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Metadata.Types.AllowInconsistentMetadata
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Metadata.Types.ClearMetadata
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Metadata.Types.DropInconsistentMetadata
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Metadata.Types.DumpInternalState
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Metadata.Types.ExportMetadata
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Metadata.Types.GetInconsistentMetadata
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Metadata.Types.ReloadMetadata
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.DDL.Metadata.Types.ReloadSpec a)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Metadata.Types.ReplaceMetadata
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Metadata.Types.ReplaceMetadataV1
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Metadata.Types.ReplaceMetadataV2
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Metadata.Types.TestWebhookTransform
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Metadata.Types.WebHookUrl

module Hasura.RQL.DDL.InheritedRoles
runAddInheritedRole :: (MonadError QErr m, CacheRWM m, MetadataM m) => InheritedRole -> m EncJSON
runDropInheritedRole :: (MonadError QErr m, CacheRWM m, MetadataM m) => DropInheritedRole -> m EncJSON
dropInheritedRoleInMetadata :: RoleName -> MetadataModifier

-- | <a>resolveInheritedRole</a> resolves an inherited role by checking if
--   all the parent roles of an inherited role exists and report the
--   dependencies of the inherited role which will be the list of the
--   parent roles
resolveInheritedRole :: MonadError QErr m => HashSet RoleName -> InheritedRole -> m (Role, Seq SchemaDependency)

module Hasura.RQL.DDL.Endpoint
runCreateEndpoint :: (MonadError QErr m, CacheRWM m, MetadataM m) => CreateEndpoint -> m EncJSON
runDropEndpoint :: (MonadError QErr m, CacheRWM m, MetadataM m) => DropEndpoint -> m EncJSON
dropEndpointInMetadata :: EndpointName -> MetadataModifier

module Hasura.RQL.DDL.CustomTypes
runSetCustomTypes :: (MonadError QErr m, CacheRWM m, MetadataM m) => CustomTypes -> m EncJSON
clearCustomTypesInMetadata :: MetadataModifier
resolveCustomTypes :: MonadError QErr m => SourceCache -> CustomTypes -> BackendMap ScalarParsingMap -> m AnnotatedCustomTypes
lookupBackendScalar :: BackendMap ScalarParsingMap -> Name -> Maybe AnnotatedScalarType

-- | A map from GraphQL name to equivalent scalar type for a given backend.
newtype ScalarParsingMap (b :: BackendType)
ScalarParsingMap :: HashMap Name (ScalarWrapper b) -> ScalarParsingMap (b :: BackendType)
instance GHC.Classes.Eq Hasura.RQL.DDL.CustomTypes.CustomTypeValidationError
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.DDL.CustomTypes.ScalarParsingMap b)
instance GHC.Internal.Base.Monoid (Hasura.RQL.DDL.CustomTypes.ScalarParsingMap b)
instance GHC.Internal.Base.Semigroup (Hasura.RQL.DDL.CustomTypes.ScalarParsingMap b)
instance GHC.Internal.Show.Show Hasura.RQL.DDL.CustomTypes.CustomTypeValidationError


-- | ConnectionTemplate
--   
--   This module defines the needed types/functions for implementing the
--   metadata API `<a>backend</a>_test_connection_template`.
module Hasura.RQL.DDL.ConnectionTemplate

-- | Resolver for the metadata API
--   `<a>backend</a>_test_connection_template`
runTestConnectionTemplate :: forall (b :: BackendType) m. (MonadError QErr m, CacheRM m, Backend b, MetadataM m) => TestConnectionTemplate b -> m EncJSON

-- | The input type for the metadata API
--   `<a>backend</a>_test_connection_template`
data TestConnectionTemplate (b :: BackendType)
TestConnectionTemplate :: SourceName -> ConnectionTemplateRequestContext b -> Maybe ConnectionTemplate -> TestConnectionTemplate (b :: BackendType)
[_tctSourceName] :: TestConnectionTemplate (b :: BackendType) -> SourceName
[_tctRequestContext] :: TestConnectionTemplate (b :: BackendType) -> ConnectionTemplateRequestContext b
[_tctConnectionTemplate] :: TestConnectionTemplate (b :: BackendType) -> Maybe ConnectionTemplate
newtype BackendResolvedConnectionTemplate
BackendResolvedConnectionTemplate :: AnyBackend ResolvedConnectionTemplateWrapper -> BackendResolvedConnectionTemplate
[getBackendResolvedConnectionTemplate] :: BackendResolvedConnectionTemplate -> AnyBackend ResolvedConnectionTemplateWrapper
newtype ResolvedConnectionTemplateWrapper (b :: BackendType)
ResolvedConnectionTemplateWrapper :: ResolvedConnectionTemplate b -> ResolvedConnectionTemplateWrapper (b :: BackendType)
[getResolvedConnectionTemplateWrapper] :: ResolvedConnectionTemplateWrapper (b :: BackendType) -> ResolvedConnectionTemplate b
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.ConnectionTemplate.TestConnectionTemplate b)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.ConnectionTemplate.BackendResolvedConnectionTemplate


-- | This module holds functions and data types used for logging at the
--   GraphQL layer. In contrast with, logging at the HTTP server layer.
module Hasura.GraphQL.Logging.QueryLog

-- | A GraphQL query, optionally generated SQL, and the request id makes up
--   the | <a>QueryLog</a>
data QueryLog
QueryLog :: !GQLReqUnparsed -> !Maybe (RootFieldAlias, GeneratedQuery) -> !RequestId -> !QueryLogKind -> QueryLog
[_qlQuery] :: QueryLog -> !GQLReqUnparsed
[_qlGeneratedSql] :: QueryLog -> !Maybe (RootFieldAlias, GeneratedQuery)
[_qlRequestId] :: QueryLog -> !RequestId
[_qlKind] :: QueryLog -> !QueryLogKind
data GeneratedQuery
GeneratedQuery :: Text -> Value -> GeneratedQuery
[_gqQueryString] :: GeneratedQuery -> Text
[_gqPreparedArgs] :: GeneratedQuery -> Value
class Monad m => MonadQueryLog (m :: Type -> Type)
logQueryLog :: MonadQueryLog m => Logger Hasura -> QueryLog -> m ()
data QueryLogKind
QueryLogKindDatabase :: Maybe BackendResolvedConnectionTemplate -> QueryLogKind
QueryLogKindAction :: QueryLogKind
QueryLogKindRemoteSchema :: QueryLogKind
QueryLogKindCached :: QueryLogKind
QueryLogKindIntrospection :: QueryLogKind
instance Hasura.GraphQL.Logging.QueryLog.MonadQueryLog m => Hasura.GraphQL.Logging.QueryLog.MonadQueryLog (Control.Monad.Trans.Except.ExceptT e m)
instance Hasura.GraphQL.Logging.QueryLog.MonadQueryLog m => Hasura.GraphQL.Logging.QueryLog.MonadQueryLog (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.GraphQL.Logging.QueryLog.MonadQueryLog m => Hasura.GraphQL.Logging.QueryLog.MonadQueryLog (Hasura.Tracing.Monad.TraceT m)
instance Hasura.Logging.ToEngineLog Hasura.GraphQL.Logging.QueryLog.QueryLog Hasura.Logging.Hasura
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Logging.QueryLog.GeneratedQuery
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Logging.QueryLog.QueryLog
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Logging.QueryLog.QueryLogKind


module Hasura.RQL.DDL.ComputedField
data AddComputedField (b :: BackendType)
AddComputedField :: SourceName -> TableName b -> ComputedFieldName -> ComputedFieldDefinition b -> Comment -> AddComputedField (b :: BackendType)
[_afcSource] :: AddComputedField (b :: BackendType) -> SourceName
[_afcTable] :: AddComputedField (b :: BackendType) -> TableName b
[_afcName] :: AddComputedField (b :: BackendType) -> ComputedFieldName
[_afcDefinition] :: AddComputedField (b :: BackendType) -> ComputedFieldDefinition b
[_afcComment] :: AddComputedField (b :: BackendType) -> Comment
runAddComputedField :: forall (b :: BackendType) m. (BackendMetadata b, MonadError QErr m, CacheRWM m, MetadataM m) => AddComputedField b -> m EncJSON
data DropComputedField (b :: BackendType)
runDropComputedField :: forall (b :: BackendType) m. (QErrM m, CacheRWM m, MetadataM m, BackendMetadata b) => DropComputedField b -> m EncJSON
dropComputedFieldInMetadata :: forall (b :: BackendType). ComputedFieldName -> TableMetadata b -> TableMetadata b
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.ComputedField.AddComputedField b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.ComputedField.DropComputedField b)
instance GHC.Internal.Generics.Generic (Hasura.RQL.DDL.ComputedField.AddComputedField b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.DDL.ComputedField.AddComputedField b)

module Hasura.RQL.DDL.ApiLimit
runRemoveApiLimits :: (MonadError QErr m, MetadataM m, CacheRWM m) => m EncJSON
runSetApiLimits :: (MonadError QErr m, MetadataM m, CacheRWM m, MonadGetPolicies m) => ApiLimit -> m EncJSON
warningMessage :: MaxTime -> MaxTime -> MetadataWarning
compareTimeLimitWith :: MonadGetPolicies m => Maybe MaxTime -> m (Either MetadataWarning ())


-- | Define and handle v1/metadata API operations to track, untrack, and
--   get native queries.
module Hasura.NativeQuery.API

-- | API payload for the <tt>get_native_query</tt> endpoint.
data GetNativeQuery (b :: BackendType)
GetNativeQuery :: SourceName -> GetNativeQuery (b :: BackendType)
[gnqSource] :: GetNativeQuery (b :: BackendType) -> SourceName

-- | Default implementation of the <tt>track_native_query</tt> request
--   payload.
data TrackNativeQuery (b :: BackendType)
TrackNativeQuery :: SourceName -> NativeQueryName -> Text -> HashMap ArgumentName (NullableScalarType b) -> InsOrdHashMap RelName (RelDef (RelManualConfig b)) -> InsOrdHashMap RelName (RelDef (RelManualConfig b)) -> Maybe Text -> LogicalModelIdentifier b -> TrackNativeQuery (b :: BackendType)
[tnqSource] :: TrackNativeQuery (b :: BackendType) -> SourceName
[tnqRootFieldName] :: TrackNativeQuery (b :: BackendType) -> NativeQueryName
[tnqCode] :: TrackNativeQuery (b :: BackendType) -> Text
[tnqArguments] :: TrackNativeQuery (b :: BackendType) -> HashMap ArgumentName (NullableScalarType b)
[tnqArrayRelationships] :: TrackNativeQuery (b :: BackendType) -> InsOrdHashMap RelName (RelDef (RelManualConfig b))
[tnqObjectRelationships] :: TrackNativeQuery (b :: BackendType) -> InsOrdHashMap RelName (RelDef (RelManualConfig b))
[tnqDescription] :: TrackNativeQuery (b :: BackendType) -> Maybe Text
[tnqReturns] :: TrackNativeQuery (b :: BackendType) -> LogicalModelIdentifier b

-- | API payload for the <tt>untrack_native_query</tt> endpoint.
data UntrackNativeQuery (b :: BackendType)
UntrackNativeQuery :: SourceName -> NativeQueryName -> UntrackNativeQuery (b :: BackendType)
[utnqSource] :: UntrackNativeQuery (b :: BackendType) -> SourceName
[utnqRootFieldName] :: UntrackNativeQuery (b :: BackendType) -> NativeQueryName

-- | Handler for the <tt>get_native_query</tt> endpoint.
runGetNativeQuery :: forall (b :: BackendType) m. (BackendMetadata b, MetadataM m, MonadError QErr m) => GetNativeQuery b -> m EncJSON

-- | Handler for the <tt>track_native_query</tt> endpoint. The type
--   'TrackNativeQuery b' (appearing here in wrapped as
--   'BackendTrackNativeQuery b' for <tt>AnyBackend</tt> compatibility) is
--   defined in 'class NativeQueryMetadata'.
execTrackNativeQuery :: forall (b :: BackendType) m. (BackendMetadata b, MonadError QErr m) => TrackNativeQuery b -> Metadata -> m (MetadataObjId, MetadataModifier)

-- | Handler for the <tt>untrack_native_query</tt> endpoint.
execUntrackNativeQuery :: forall (b :: BackendType) m. (BackendMetadata b, MonadError QErr m) => UntrackNativeQuery b -> Metadata -> m (MetadataObjId, MetadataModifier)
dropNativeQueryInMetadata :: forall (b :: BackendType). BackendMetadata b => SourceName -> NativeQueryName -> MetadataModifier

-- | Check whether a native query with the given root field name exists for
--   the given source.
assertNativeQueryExists :: forall (b :: BackendType) m. (Backend b, MonadError QErr m) => SourceName -> NativeQueryName -> Metadata -> m ()
data NativeQueryName

-- | A ScalarType that can be nullable with an optional description
data NullableScalarType (b :: BackendType)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.NativeQuery.API.GetNativeQuery b)
instance GHC.Classes.Eq (Hasura.NativeQuery.API.UntrackNativeQuery b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.NativeQuery.API.GetNativeQuery b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.NativeQuery.API.TrackNativeQuery b)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.NativeQuery.API.UntrackNativeQuery b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.NativeQuery.API.TrackNativeQuery b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.NativeQuery.API.GetNativeQuery b)
instance GHC.Internal.Show.Show (Hasura.NativeQuery.API.UntrackNativeQuery b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.NativeQuery.API.GetNativeQuery b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.NativeQuery.API.TrackNativeQuery b)
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.NativeQuery.API.UntrackNativeQuery b)


-- | This module has type class and types which implements the Metadata
--   Storage Abstraction
module Hasura.Metadata.Class
data SchemaSyncEventProcessResult
SchemaSyncEventProcessResult :: !Bool -> !CacheInvalidations -> SchemaSyncEventProcessResult
[_sseprShouldReload] :: SchemaSyncEventProcessResult -> !Bool
[_sseprCacheInvalidations] :: SchemaSyncEventProcessResult -> !CacheInvalidations

-- | Metadata storage abstraction via a type class.
--   
--   This type class enables storing and managing Hasura metadata in an
--   isolated database which will not interfere with user's database where
--   tables/functions are defined. Hence, it'll enable support for
--   databases of multiple backends like MSSQL etc.
--   
--   Error-handling is handled explicitly, with every function returning an
--   `Either QErr`. This is inelegant, but is required: we want the caller
--   to explictly deal with errors, rather than letting them surface to a
--   "lower" monad, because we want to implement this as a <a>Service</a>,
--   on the base monad, so that different implementations of the engine can
--   choose how to implement it; and those base monads do not include error
--   handling, all error handling must be done at the endpoint level. As a
--   result, we choose to make the errors explicit in the return type
--   rather than making assumptions about the stack.
--   
--   This class has functions broadly related to:
--   
--   <ol>
--   <li>Metadata Management ---------------------- Basic metadata
--   management functions such as retrieving metadata from storage database
--   and replacing the given metadata. TODO: Console specific
--   operations</li>
--   <li>Scheduled Triggers --------------------- Eventing sub-system for
--   scheduled triggers is implemented via metadata storage. For more
--   details, refer description in <a>ScheduledTrigger</a> module.</li>
--   </ol>
--   
--   TODO: Functions need to be added to the type class - Retrieving
--   invocation logs from storage (console requirement) - Deleting an
--   scheduled event - Creating an one-off scheduled event
--   
--   <ol>
--   <li>Async Actions ---------------- Operations to implement async
--   actions sub-system. This includes recording an async action event and
--   retreiving the details of action delivery to the webhook. For more
--   details see Note [Async action architecture] in <a>Action</a>
--   module.</li>
--   </ol>
--   
--   It is believed that all the above three are implemented in a single
--   storage system (ex: a Postgres database). We can split the functions
--   into appropriate and specific type classes in future iterations if
--   required.
class Monad m => MonadMetadataStorage (m :: Type -> Type)
fetchMetadataResourceVersion :: MonadMetadataStorage m => m (Either QErr MetadataResourceVersion)
fetchMetadata :: MonadMetadataStorage m => m (Either QErr MetadataWithResourceVersion)
fetchMetadataNotifications :: MonadMetadataStorage m => MetadataResourceVersion -> InstanceId -> m (Either QErr [(MetadataResourceVersion, CacheInvalidations)])
setMetadata :: MonadMetadataStorage m => MetadataResourceVersion -> Metadata -> m (Either QErr MetadataResourceVersion)
notifySchemaCacheSync :: MonadMetadataStorage m => MetadataResourceVersion -> InstanceId -> CacheInvalidations -> m (Either QErr ())
getCatalogState :: MonadMetadataStorage m => m (Either QErr CatalogState)
setCatalogState :: MonadMetadataStorage m => CatalogStateType -> Value -> m (Either QErr ())
fetchSourceIntrospection :: MonadMetadataStorage m => MetadataResourceVersion -> m (Either QErr (Maybe StoredIntrospection))
storeSourceIntrospection :: MonadMetadataStorage m => StoredIntrospection -> MetadataResourceVersion -> m (Either QErr ())
getMetadataDbUid :: MonadMetadataStorage m => m (Either QErr MetadataDbId)
checkMetadataStorageHealth :: MonadMetadataStorage m => m (Either QErr ())
getDeprivedCronTriggerStats :: MonadMetadataStorage m => [TriggerName] -> m (Either QErr [CronTriggerStats])
getScheduledEventsForDelivery :: MonadMetadataStorage m => [TriggerName] -> m (Either QErr ([CronEvent], [OneOffScheduledEvent]))
insertCronEvents :: MonadMetadataStorage m => [CronEventSeed] -> m (Either QErr ())
insertOneOffScheduledEvent :: MonadMetadataStorage m => OneOffEvent -> m (Either QErr EventId)
insertScheduledEventInvocation :: MonadMetadataStorage m => Invocation 'ScheduledType -> ScheduledEventType -> m (Either QErr ())
setScheduledEventOp :: MonadMetadataStorage m => ScheduledEventId -> ScheduledEventOp -> ScheduledEventType -> m (Either QErr ())
unlockScheduledEvents :: MonadMetadataStorage m => ScheduledEventType -> [ScheduledEventId] -> m (Either QErr Int)
unlockAllLockedScheduledEvents :: MonadMetadataStorage m => m (Either QErr ())
clearFutureCronEvents :: MonadMetadataStorage m => ClearCronEvents -> m (Either QErr ())
getOneOffScheduledEvents :: MonadMetadataStorage m => ScheduledEventPagination -> [ScheduledEventStatus] -> RowsCountOption -> m (Either QErr (WithOptionalTotalCount [OneOffScheduledEvent]))
getCronEvents :: MonadMetadataStorage m => TriggerName -> ScheduledEventPagination -> [ScheduledEventStatus] -> RowsCountOption -> m (Either QErr (WithOptionalTotalCount [CronEvent]))
getScheduledEventInvocations :: MonadMetadataStorage m => GetScheduledEventInvocations -> m (Either QErr (WithOptionalTotalCount [ScheduledEventInvocation]))
deleteScheduledEvent :: MonadMetadataStorage m => ScheduledEventId -> ScheduledEventType -> m (Either QErr ())
insertAction :: MonadMetadataStorage m => ActionName -> SessionVariables -> [Header] -> Value -> m (Either QErr ActionId)
fetchUndeliveredActionEvents :: MonadMetadataStorage m => Int -> m (Either QErr [ActionLogItem])
setActionStatus :: MonadMetadataStorage m => ActionId -> AsyncActionStatus -> m (Either QErr ())
fetchActionResponse :: MonadMetadataStorage m => ActionId -> m (Either QErr ActionLogResponse)
clearActionData :: MonadMetadataStorage m => ActionName -> m (Either QErr ())
setProcessingActionLogsToPending :: MonadMetadataStorage m => LockedActionIdArray -> m (Either QErr ())

-- | Metadata database operations for EE credentials storage.
--   
--   This class is only necessary because we haven't written an
--   implementation for storing EE credentials in Cloud.
class Monad m => MonadEECredentialsStorage (m :: Type -> Type)
getEEClientCredentials :: MonadEECredentialsStorage m => m (Either QErr (Maybe EEClientCredentials))
setEEClientCredentials :: MonadEECredentialsStorage m => EEClientCredentials -> m (Either QErr ())

-- | Record a one-off event
createOneOffScheduledEvent :: MonadMetadataStorage m => OneOffEvent -> m (Either QErr EventId)

-- | Record a cron event
createCronEvents :: MonadMetadataStorage m => [CronEventSeed] -> m (Either QErr ())

-- | Clear cron events
dropFutureCronEvents :: MonadMetadataStorage m => ClearCronEvents -> m (Either QErr ())

-- | Delete async action logs
deleteActionData :: MonadMetadataStorage m => ActionName -> m (Either QErr ())

-- | Fetch cron/oneoff scheduled event invocations
fetchScheduledEventInvocations :: MonadMetadataStorage m => GetScheduledEventInvocations -> m (Either QErr (WithOptionalTotalCount [ScheduledEventInvocation]))

-- | Fetch cron/oneoff scheduled events
fetchScheduledEvents :: MonadMetadataStorage m => GetScheduledEvents -> m (Either QErr Value)

-- | Drop a cron/oneoff scheduled event
dropEvent :: MonadMetadataStorage m => ScheduledEventId -> ScheduledEventType -> m (Either QErr ())

-- | Retrieve the state from metadata storage catalog
fetchCatalogState :: MonadMetadataStorage m => m (Either QErr CatalogState)

-- | Update the state from metadata storage catalog
updateCatalogState :: MonadMetadataStorage m => CatalogStateType -> Value -> m (Either QErr ())
instance Hasura.Metadata.Class.MonadEECredentialsStorage m => Hasura.Metadata.Class.MonadEECredentialsStorage (Control.Monad.Trans.Except.ExceptT e m)
instance Hasura.Metadata.Class.MonadEECredentialsStorage m => Hasura.Metadata.Class.MonadEECredentialsStorage (Control.Monad.Trans.Managed.ManagedT m)
instance Hasura.Metadata.Class.MonadEECredentialsStorage m => Hasura.Metadata.Class.MonadEECredentialsStorage (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Hasura.Metadata.Class.MonadEECredentialsStorage m => Hasura.Metadata.Class.MonadEECredentialsStorage (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.Metadata.Class.MonadEECredentialsStorage m => Hasura.Metadata.Class.MonadEECredentialsStorage (Control.Monad.Trans.State.Strict.StateT s m)
instance (Hasura.Metadata.Class.MonadEECredentialsStorage m, Control.Monad.Trans.Class.MonadTrans t, GHC.Internal.Base.Monad (t m)) => Hasura.Metadata.Class.MonadEECredentialsStorage (Control.Monad.Trans.Extended.TransT t m)
instance Hasura.Metadata.Class.MonadMetadataStorage m => Hasura.Metadata.Class.MonadMetadataStorage (Control.Monad.Trans.Except.ExceptT e m)
instance Hasura.Metadata.Class.MonadMetadataStorage m => Hasura.Metadata.Class.MonadMetadataStorage (Control.Monad.Trans.Managed.ManagedT m)
instance Hasura.Metadata.Class.MonadMetadataStorage m => Hasura.Metadata.Class.MonadMetadataStorage (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Hasura.Metadata.Class.MonadMetadataStorage m => Hasura.Metadata.Class.MonadMetadataStorage (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.Metadata.Class.MonadMetadataStorage m => Hasura.Metadata.Class.MonadMetadataStorage (Control.Monad.Trans.State.Strict.StateT s m)
instance Hasura.Metadata.Class.MonadMetadataStorage m => Hasura.Metadata.Class.MonadMetadataStorage (Hasura.Tracing.Monad.TraceT m)
instance (Hasura.Metadata.Class.MonadMetadataStorage m, Control.Monad.Trans.Class.MonadTrans t, GHC.Internal.Base.Monad (t m)) => Hasura.Metadata.Class.MonadMetadataStorage (Control.Monad.Trans.Extended.TransT t m)

module Hasura.RQL.DDL.OpenTelemetry

-- | Set the OpenTelemetry configuration to the provided value.
runSetOpenTelemetryConfig :: (MonadError QErr m, MetadataM m, CacheRWM m) => OpenTelemetryConfig -> m EncJSON

-- | Set just the "status" field of the OpenTelemetry configuration.
runSetOpenTelemetryStatus :: (MonadError QErr m, MetadataM m, CacheRWM m) => OtelStatus -> m EncJSON

-- | Smart constructor for <a>OtelExporterInfo</a>.
--   
--   Returns a <tt>Left qErr</tt> to signal a validation error. Returns
--   <tt>Right Nothing</tt> to signal that the exporter should be disabled
--   without raising an error.
--   
--   If this is called we assume <a>OtelEnabled</a>
parseOtelExporterConfig :: Environment -> Set OtelDataType -> OtelExporterConfig -> Either QErr OtelExporterInfo
parseOtelBatchSpanProcessorConfig :: OtelBatchSpanProcessorConfig -> Either QErr OtelBatchSpanProcessorInfo

module Hasura.RQL.DDL.Network
checkForHostnameWithSuffixInAllowlistObject :: String -> Maybe String -> TlsAllow -> Bool
dropHostFromAllowList :: String -> Maybe String -> MetadataModifier
runAddHostToTLSAllowlist :: (QErrM m, CacheRWM m, MetadataM m) => TlsAllow -> m EncJSON
runDropHostFromTLSAllowlist :: (QErrM m, CacheRWM m, MetadataM m) => DropHostFromTLSAllowlist -> m EncJSON

module Hasura.RQL.DDL.Action
data CreateAction
CreateAction :: ActionName -> ActionDefinitionInput -> Maybe Text -> CreateAction
[_caName] :: CreateAction -> ActionName
[_caDefinition] :: CreateAction -> ActionDefinitionInput
[_caComment] :: CreateAction -> Maybe Text
runCreateAction :: (QErrM m, CacheRWM m, MetadataM m) => CreateAction -> m EncJSON
resolveAction :: QErrM m => Environment -> AnnotatedCustomTypes -> ActionDefinitionInput -> BackendMap ScalarParsingMap -> m (ResolvedActionDefinition, AnnotatedOutputType)
data UpdateAction
runUpdateAction :: (QErrM m, CacheRWM m, MetadataM m) => UpdateAction -> m EncJSON
data DropAction
runDropAction :: (MonadError QErr m, CacheRWM m, MetadataM m, MonadMetadataStorage m) => DropAction -> m EncJSON
dropActionInMetadata :: ActionName -> MetadataModifier
data CreateActionPermission
CreateActionPermission :: ActionName -> RoleName -> Maybe Value -> Maybe Text -> CreateActionPermission
[_capAction] :: CreateActionPermission -> ActionName
[_capRole] :: CreateActionPermission -> RoleName
[_capDefinition] :: CreateActionPermission -> Maybe Value
[_capComment] :: CreateActionPermission -> Maybe Text
runCreateActionPermission :: (QErrM m, CacheRWM m, MetadataM m) => CreateActionPermission -> m EncJSON
data DropActionPermission
runDropActionPermission :: (QErrM m, CacheRWM m, MetadataM m) => DropActionPermission -> m EncJSON
dropActionPermissionInMetadata :: ActionName -> RoleName -> MetadataModifier
instance GHC.Classes.Eq Hasura.RQL.DDL.Action.ActionMetadataField
instance GHC.Classes.Eq Hasura.RQL.DDL.Action.ClearActionData
instance GHC.Classes.Eq Hasura.RQL.DDL.Action.DropAction
instance GHC.Classes.Eq Hasura.RQL.DDL.Action.DropActionPermission
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Action.ActionMetadataField
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Action.ClearActionData
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Action.CreateAction
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Action.CreateActionPermission
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Action.DropAction
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Action.DropActionPermission
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Action.UpdateAction
instance GHC.Internal.Generics.Generic Hasura.RQL.DDL.Action.CreateAction
instance GHC.Internal.Generics.Generic Hasura.RQL.DDL.Action.CreateActionPermission
instance GHC.Internal.Generics.Generic Hasura.RQL.DDL.Action.DropAction
instance GHC.Internal.Generics.Generic Hasura.RQL.DDL.Action.DropActionPermission
instance GHC.Internal.Generics.Generic Hasura.RQL.DDL.Action.UpdateAction
instance GHC.Internal.Show.Show Hasura.RQL.DDL.Action.ActionMetadataField
instance GHC.Internal.Show.Show Hasura.RQL.DDL.Action.ClearActionData
instance GHC.Internal.Show.Show Hasura.RQL.DDL.Action.DropAction
instance GHC.Internal.Show.Show Hasura.RQL.DDL.Action.DropActionPermission
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Action.ActionMetadataField
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Action.ClearActionData
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Action.CreateAction
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Action.DropAction
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Action.DropActionPermission

module Hasura.RQL.DDL.Action.Lenses
caName :: Lens' CreateAction ActionName
caDefinition :: Lens' CreateAction ActionDefinitionInput
caComment :: Lens' CreateAction (Maybe Text)
uaName :: Lens' UpdateAction ActionName
uaDefinition :: Lens' UpdateAction ActionDefinitionInput
uaComment :: Lens' UpdateAction (Maybe Text)


-- | Define and handle v1/metadata API operations to track, untrack, and
--   get logical models.
module Hasura.LogicalModel.API

-- | API payload for the <tt>get_logical_model</tt> endpoint.
data GetLogicalModel (b :: BackendType)
GetLogicalModel :: SourceName -> GetLogicalModel (b :: BackendType)
[glmSource] :: GetLogicalModel (b :: BackendType) -> SourceName

-- | Default implementation of the <tt>track_logical_model</tt> request
--   payload.
data TrackLogicalModel (b :: BackendType)
TrackLogicalModel :: SourceName -> LogicalModelName -> Maybe Text -> InsOrdHashMap (Column b) (LogicalModelField b) -> TrackLogicalModel (b :: BackendType)
[tlmSource] :: TrackLogicalModel (b :: BackendType) -> SourceName
[tlmName] :: TrackLogicalModel (b :: BackendType) -> LogicalModelName
[tlmDescription] :: TrackLogicalModel (b :: BackendType) -> Maybe Text
[tlmFields] :: TrackLogicalModel (b :: BackendType) -> InsOrdHashMap (Column b) (LogicalModelField b)

-- | API payload for the <tt>untrack_logical_model</tt> endpoint.
data UntrackLogicalModel (b :: BackendType)
UntrackLogicalModel :: SourceName -> LogicalModelName -> UntrackLogicalModel (b :: BackendType)
[utlmSource] :: UntrackLogicalModel (b :: BackendType) -> SourceName
[utlmName] :: UntrackLogicalModel (b :: BackendType) -> LogicalModelName

-- | Handler for the <tt>get_logical_model</tt> endpoint.
runGetLogicalModel :: forall (b :: BackendType) m. (BackendMetadata b, MonadError QErr m, MetadataM m) => GetLogicalModel b -> m EncJSON

-- | Handler for the <tt>track_logical_model</tt> endpoint. The type
--   'TrackLogicalModel b' (appearing here in wrapped as
--   'BackendTrackLogicalModel b' for <tt>AnyBackend</tt> compatibility) is
--   defined in 'class LogicalModelMetadata'.
execTrackLogicalModel :: forall (b :: BackendType) m. (BackendMetadata b, MonadError QErr m) => TrackLogicalModel b -> Metadata -> m (MetadataObjId, MetadataModifier)

-- | Handler for the <tt>untrack_logical_model</tt> endpoint.
execUntrackLogicalModel :: forall (b :: BackendType) m. (BackendMetadata b, MonadError QErr m) => UntrackLogicalModel b -> Metadata -> m (MetadataObjId, MetadataModifier)

-- | TODO: should this cascade and also delete associated permissions?
dropLogicalModelInMetadata :: forall (b :: BackendType). BackendMetadata b => SourceName -> LogicalModelName -> MetadataModifier

-- | A permission for logical models is tied to a specific name and source.
--   This wrapper adds both of those things to the JSON object that
--   describes the permission.
data CreateLogicalModelPermission (a :: BackendType -> Type) (b :: BackendType)
CreateLogicalModelPermission :: SourceName -> LogicalModelLocation -> PermDef b a -> CreateLogicalModelPermission (a :: BackendType -> Type) (b :: BackendType)
[clmpSource] :: CreateLogicalModelPermission (a :: BackendType -> Type) (b :: BackendType) -> SourceName
[clmpLocation] :: CreateLogicalModelPermission (a :: BackendType -> Type) (b :: BackendType) -> LogicalModelLocation
[clmpInfo] :: CreateLogicalModelPermission (a :: BackendType -> Type) (b :: BackendType) -> PermDef b a

-- | To drop a permission, we need to know the source and name of the
--   logical model, as well as the role whose permission we want to drop.
data DropLogicalModelPermission (b :: BackendType)
DropLogicalModelPermission :: SourceName -> LogicalModelLocation -> RoleName -> DropLogicalModelPermission (b :: BackendType)
[dlmpSource] :: DropLogicalModelPermission (b :: BackendType) -> SourceName
[dlmpLocation] :: DropLogicalModelPermission (b :: BackendType) -> LogicalModelLocation
[dlmpRole] :: DropLogicalModelPermission (b :: BackendType) -> RoleName
runCreateSelectLogicalModelPermission :: forall (b :: BackendType) m. (Backend b, CacheRWM m, MetadataM m, MonadError QErr m) => CreateLogicalModelPermission SelPerm b -> m EncJSON
runDropSelectLogicalModelPermission :: forall (b :: BackendType) m. (Backend b, CacheRWM m, MetadataM m, MonadError QErr m) => DropLogicalModelPermission b -> m EncJSON

-- | a single field in a Logical Model
data LogicalModelField (b :: BackendType)
data LogicalModelLocation
LMLLogicalModel :: LogicalModelName -> LogicalModelLocation
LMLNativeQuery :: NativeQueryName -> LogicalModelLocation
data LogicalModelName
logicalModelFieldMapCodec :: forall (b :: BackendType). Backend b => Codec Value (LogicalModelFields b) (LogicalModelFields b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.LogicalModel.API.GetLogicalModel b)
instance GHC.Classes.Eq (Hasura.LogicalModel.API.UntrackLogicalModel b)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Permission.PermDef b a) => Data.Aeson.Types.FromJSON.FromJSON (Hasura.LogicalModel.API.CreateLogicalModelPermission a b)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.LogicalModel.API.DropLogicalModelPermission b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.LogicalModel.API.GetLogicalModel b)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.LogicalModel.API.LogicalModelSource
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.LogicalModel.API.TrackLogicalModel b)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.LogicalModel.API.UntrackLogicalModel b)
instance GHC.Internal.Generics.Generic (Hasura.LogicalModel.API.CreateLogicalModelPermission a b)
instance GHC.Internal.Generics.Generic (Hasura.LogicalModel.API.DropLogicalModelPermission b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.LogicalModel.API.TrackLogicalModel b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.LogicalModel.API.GetLogicalModel b)
instance GHC.Internal.Show.Show (Hasura.LogicalModel.API.UntrackLogicalModel b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.LogicalModel.API.GetLogicalModel b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.LogicalModel.API.TrackLogicalModel b)
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.LogicalModel.API.UntrackLogicalModel b)

module Hasura.Backends.MSSQL.Schema.Introspection

-- | List all tables, tracked or untracked, on a given data source.
listAllTables :: (CacheRM m, MetadataM m, MonadBaseControl IO m, MonadError QErr m, MonadIO m) => SourceName -> m [TableName]

module Hasura.Backends.BigQuery.Schema.Introspection

-- | List all tables, tracked or untracked, on a given BigQuery source. All
--   given datasets' tables will be included.
listAllTables :: (CacheRM m, MetadataM m, MonadError QErr m, MonadIO m) => SourceName -> m [TableName]

module Hasura.Backends.BigQuery.Instances.Metadata
instance Hasura.RQL.Types.Metadata.Backend.BackendMetadata 'Hasura.RQL.Types.BackendType.BigQuery

module Hasura.Metadata.DTO.Metadata

-- | Exported representation of the GraphQL Engine metadata configuration
--   format.
--   
--   The OpenAPI specification for metadata is experimental and incomplete.
--   Please do not incorporate it into essential workflows at this time.
data MetadataDTO
V1 :: MetadataV1 -> MetadataDTO
V2 :: MetadataV2 -> MetadataDTO
V3 :: MetadataV3 -> MetadataDTO
instance GHC.Classes.Eq Hasura.Metadata.DTO.Metadata.MetadataDTO
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Metadata.DTO.Metadata.MetadataDTO
instance GHC.Internal.Generics.Generic Hasura.Metadata.DTO.Metadata.MetadataDTO
instance Autodocodec.Class.HasCodec Hasura.Metadata.DTO.Metadata.MetadataDTO
instance GHC.Internal.Show.Show Hasura.Metadata.DTO.Metadata.MetadataDTO
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Metadata.DTO.Metadata.MetadataDTO
instance Data.OpenApi.Internal.Schema.ToSchema Hasura.Metadata.DTO.Metadata.MetadataDTO


-- | This module exports an OpenAPI specification for the GraphQL Engine
--   metadata API.
--   
--   The OpenAPI specification for metadata is experimental and incomplete.
--   Please do not incorporate it into essential workflows at this time.
module Hasura.Server.MetadataOpenAPI

-- | An OpenApi document includes "schemas" that describe the data that may
--   be produced or consumed by an API. It can also include "paths" which
--   describe REST endpoints, and the document can include other API
--   metadata. This example only includes schemas.
--   
--   The OpenAPI specification for metadata is experimental and incomplete.
--   Please do not incorporate it into essential workflows at this time.
metadataOpenAPI :: OpenApi

module Hasura.RQL.DML.Types
newtype OrderByExp
OrderByExp :: [OrderByItem ('Postgres 'Vanilla)] -> OrderByExp
[getOrderByItems] :: OrderByExp -> [OrderByItem ('Postgres 'Vanilla)]
data DMLQuery a
DMLQuery :: SourceName -> QualifiedTable -> a -> DMLQuery a
getSourceDMLQuery :: DMLQuery a -> SourceName
data SelectG a b c
SelectG :: [a] -> Maybe b -> Maybe OrderByExp -> Maybe c -> Maybe c -> SelectG a b c
[sqColumns] :: SelectG a b c -> [a]
[sqWhere] :: SelectG a b c -> Maybe b
[sqOrderBy] :: SelectG a b c -> Maybe OrderByExp
[sqLimit] :: SelectG a b c -> Maybe c
[sqOffset] :: SelectG a b c -> Maybe c
data Wildcard
Star :: Wildcard
StarDot :: Wildcard -> Wildcard
data SelCol
SCStar :: Wildcard -> SelCol
SCExtSimple :: PGCol -> SelCol
SCExtRel :: RelName -> Maybe RelName -> SelectQ -> SelCol
type SelectQ = SelectG SelCol BoolExp 'Postgres 'Vanilla Int
type SelectQT = SelectG SelCol BoolExp 'Postgres 'Vanilla Value
type SelectQuery = DMLQuery SelectQ
type SelectQueryT = DMLQuery SelectQT
type InsObj (b :: BackendType) = ColumnValues b Value
data InsertQuery
InsertQuery :: QualifiedTable -> SourceName -> Value -> Maybe OnConflict -> Maybe [PGCol] -> InsertQuery
[iqTable] :: InsertQuery -> QualifiedTable
[iqSource] :: InsertQuery -> SourceName
[iqObjects] :: InsertQuery -> Value
[iqOnConflict] :: InsertQuery -> Maybe OnConflict
[iqReturning] :: InsertQuery -> Maybe [PGCol]
data OnConflict
OnConflict :: Maybe ConstraintOn -> Maybe ConstraintName -> ConflictAction -> OnConflict
[ocConstraintOn] :: OnConflict -> Maybe ConstraintOn
[ocConstraint] :: OnConflict -> Maybe ConstraintName
[ocAction] :: OnConflict -> ConflictAction
data ConflictAction
CAIgnore :: ConflictAction
CAUpdate :: ConflictAction
newtype ConstraintOn
ConstraintOn :: [PGCol] -> ConstraintOn
[getPGCols] :: ConstraintOn -> [PGCol]
type UpdVals (b :: BackendType) = ColumnValues b Value
data UpdateQuery
UpdateQuery :: QualifiedTable -> SourceName -> BoolExp ('Postgres 'Vanilla) -> UpdVals ('Postgres 'Vanilla) -> UpdVals ('Postgres 'Vanilla) -> UpdVals ('Postgres 'Vanilla) -> [PGCol] -> Maybe [PGCol] -> UpdateQuery
[uqTable] :: UpdateQuery -> QualifiedTable
[uqSource] :: UpdateQuery -> SourceName
[uqWhere] :: UpdateQuery -> BoolExp ('Postgres 'Vanilla)
[uqSet] :: UpdateQuery -> UpdVals ('Postgres 'Vanilla)
[uqInc] :: UpdateQuery -> UpdVals ('Postgres 'Vanilla)
[uqMul] :: UpdateQuery -> UpdVals ('Postgres 'Vanilla)
[uqDefault] :: UpdateQuery -> [PGCol]
[uqReturning] :: UpdateQuery -> Maybe [PGCol]
data DeleteQuery
DeleteQuery :: QualifiedTable -> SourceName -> BoolExp ('Postgres 'Vanilla) -> Maybe [PGCol] -> DeleteQuery
[doTable] :: DeleteQuery -> QualifiedTable
[doSource] :: DeleteQuery -> SourceName
[doWhere] :: DeleteQuery -> BoolExp ('Postgres 'Vanilla)
[doReturning] :: DeleteQuery -> Maybe [PGCol]
data CountQuery
CountQuery :: QualifiedTable -> SourceName -> Maybe [PGCol] -> Maybe (BoolExp ('Postgres 'Vanilla)) -> CountQuery
[cqTable] :: CountQuery -> QualifiedTable
[cqSource] :: CountQuery -> SourceName
[cqDistinct] :: CountQuery -> Maybe [PGCol]
[cqWhere] :: CountQuery -> Maybe (BoolExp ('Postgres 'Vanilla))
data QueryT
QTInsert :: InsertQuery -> QueryT
QTSelect :: SelectQueryT -> QueryT
QTUpdate :: UpdateQuery -> QueryT
QTDelete :: DeleteQuery -> QueryT
QTCount :: CountQuery -> QueryT
QTBulk :: [QueryT] -> QueryT
instance GHC.Classes.Eq Hasura.RQL.DML.Types.ConflictAction
instance GHC.Classes.Eq Hasura.RQL.DML.Types.ConstraintOn
instance GHC.Classes.Eq Hasura.RQL.DML.Types.CountQuery
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.RQL.DML.Types.DMLQuery a)
instance GHC.Classes.Eq Hasura.RQL.DML.Types.DeleteQuery
instance GHC.Classes.Eq Hasura.RQL.DML.Types.InsertQuery
instance GHC.Classes.Eq Hasura.RQL.DML.Types.OnConflict
instance GHC.Classes.Eq Hasura.RQL.DML.Types.OrderByExp
instance GHC.Classes.Eq Hasura.RQL.DML.Types.QueryT
instance GHC.Classes.Eq Hasura.RQL.DML.Types.SelCol
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c) => GHC.Classes.Eq (Hasura.RQL.DML.Types.SelectG a b c)
instance GHC.Classes.Eq Hasura.RQL.DML.Types.UpdateQuery
instance GHC.Classes.Eq Hasura.RQL.DML.Types.Wildcard
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DML.Types.ConflictAction
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DML.Types.ConstraintOn
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DML.Types.CountQuery
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DML.Types.DMLQuery a)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DML.Types.DeleteQuery
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DML.Types.InsertQuery
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DML.Types.OnConflict
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DML.Types.OrderByExp
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DML.Types.QueryT
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DML.Types.SelCol
instance (Data.Aeson.Types.FromJSON.FromJSON a, Data.Aeson.Types.FromJSON.FromJSON b, Data.Aeson.Types.FromJSON.FromJSON c) => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DML.Types.SelectG a b c)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DML.Types.UpdateQuery
instance GHC.Internal.Generics.Generic Hasura.RQL.DML.Types.OnConflict
instance GHC.Internal.Generics.Generic Hasura.RQL.DML.Types.QueryT
instance GHC.Internal.Generics.Generic (Hasura.RQL.DML.Types.SelectG a b c)
instance GHC.Classes.Ord Hasura.RQL.DML.Types.Wildcard
instance GHC.Internal.Show.Show Hasura.RQL.DML.Types.ConflictAction
instance GHC.Internal.Show.Show Hasura.RQL.DML.Types.ConstraintOn
instance GHC.Internal.Show.Show Hasura.RQL.DML.Types.CountQuery
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (Hasura.RQL.DML.Types.DMLQuery a)
instance GHC.Internal.Show.Show Hasura.RQL.DML.Types.DeleteQuery
instance GHC.Internal.Show.Show Hasura.RQL.DML.Types.InsertQuery
instance GHC.Internal.Show.Show Hasura.RQL.DML.Types.OnConflict
instance GHC.Internal.Show.Show Hasura.RQL.DML.Types.OrderByExp
instance GHC.Internal.Show.Show Hasura.RQL.DML.Types.QueryT
instance GHC.Internal.Show.Show Hasura.RQL.DML.Types.SelCol
instance (GHC.Internal.Show.Show a, GHC.Internal.Show.Show b, GHC.Internal.Show.Show c) => GHC.Internal.Show.Show (Hasura.RQL.DML.Types.SelectG a b c)
instance GHC.Internal.Show.Show Hasura.RQL.DML.Types.UpdateQuery
instance GHC.Internal.Show.Show Hasura.RQL.DML.Types.Wildcard


-- | Postgres Types Column
--   
--   Gets the Postgres type used to represent a column, defaulting to Text
--   when unsure.
module Hasura.Backends.Postgres.Types.Column

-- | Gets the representation type associated with a <a>ColumnType</a>.
--   Avoid using this if possible. Prefer <tt>parsePGScalarValue</tt>,
--   <tt>parsePGScalarValues</tt>, or <a>mkTypedSessionVar</a>.
unsafePGColumnToBackend :: forall (pgKind :: PostgresKind). ColumnType ('Postgres pgKind) -> PGScalarType


-- | Postgres Translate Mutation
--   
--   Provide a combinator for generating a Postgres SQL SELECT statement
--   for the selected columns in mutation queries.
--   
--   See <a>Mutation</a> and note [Prepared statements in Mutations]
module Hasura.Backends.Postgres.Translate.Mutation

-- | Note:- Using sorted columns is necessary to enable casting the rows
--   returned by VALUES expression to table type. For example, let's
--   consider the table, `CREATE TABLE test (id serial primary key, name
--   text not null, age int)`. The generated values expression should be in
--   order of columns; `SELECT ("row"::table).* VALUES (1, <tt>Robert</tt>,
--   23) AS "row"`.
mkSelectExpFromColumnValues :: forall (pgKind :: PostgresKind) m. MonadError QErr m => QualifiedTable -> [ColumnInfo ('Postgres pgKind)] -> [ColumnValues ('Postgres pgKind) TxtEncodedVal] -> m Select


-- | Postgres Translate Column
--   
--   Translate column values to Postgres-specific SQL expressions.
module Hasura.Backends.Postgres.Translate.Column
toTxtValue :: forall (pgKind :: PostgresKind). ColumnValue ('Postgres pgKind) -> SQLExp

-- | Formats each columns to appropriate SQL expression
toJSONableExp :: forall (pgKind :: PostgresKind). StringifyNumbers -> ColumnType ('Postgres pgKind) -> Bool -> Maybe NamingCase -> SQLExp -> SQLExp


-- | This module defines functions that translate from the Postgres IR into
--   Postgres SQL AST.
--   
--   NOTE: These functions <a>processAnnAggregateSelect</a>,
--   <a>processAnnSimpleSelect</a>, <a>processConnectionSelect</a>, are all
--   mutually recursive.
--   
--   These functions are generally called from the top level functions in
--   Translate.Select, and the call stack looks like:
--   
--   <ul>
--   <li><tt>selectQuerySQL</tt> -&gt; <tt>mkSQLSelect</tt> -&gt;
--   <a>processAnnSimpleSelect</a> -&gt;
--   <a>processSelectParams</a>/<a>processAnnFields</a></li>
--   <li><tt>selectAggregateQuerySQL</tt> -&gt; <tt>mkAggregateSelect</tt>
--   -&gt; <a>processAnnAggregateSelect</a> -&gt;
--   <a>processSelectParams</a>/<a>processAnnFields</a></li>
--   <li><tt>connetionSelectQuerySQL</tt> -&gt; <tt>mkConnectionSelect</tt>
--   -&gt; <tt>processConnectionSelection</tt> -&gt;
--   <a>processSelectParams</a></li>
--   </ul>
--   
--   <a>SelectSource</a> consists of a prefix, a source, a boolean
--   conditional expression, and info on whether sorting or slicing is done
--   (needed to handle the LIMIT optimisation)
module Hasura.Backends.Postgres.Translate.Select.Internal.Process
processAnnAggregateSelect :: forall (pgKind :: PostgresKind) m. (MonadReader StringifyNumbers m, MonadWriter SelectWriter m, MonadState NativeQueryFreshIdStore m, Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind, MonadIO m, MonadError QErr m) => UserInfo -> SourcePrefixes -> FieldName -> AnnAggregateSelect ('Postgres pgKind) -> m (SelectSource, InsOrdHashMap ColumnAlias SQLExp, Extractor)
processAnnSimpleSelect :: forall (pgKind :: PostgresKind) m. (MonadReader StringifyNumbers m, MonadState NativeQueryFreshIdStore m, MonadWriter SelectWriter m, Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind, MonadIO m, MonadError QErr m) => UserInfo -> SourcePrefixes -> FieldName -> PermissionLimitSubQuery -> AnnSimpleSelect ('Postgres pgKind) -> m (SelectSource, InsOrdHashMap ColumnAlias SQLExp)
processConnectionSelect :: forall (pgKind :: PostgresKind) m. (MonadReader StringifyNumbers m, MonadWriter SelectWriter m, MonadState NativeQueryFreshIdStore m, Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind, MonadIO m, MonadError QErr m) => UserInfo -> SourcePrefixes -> FieldName -> TableAlias -> HashMap PGCol PGCol -> ConnectionSelect ('Postgres pgKind) Void SQLExp -> m (ArrayConnectionSource, Extractor, InsOrdHashMap ColumnAlias SQLExp)


-- | This module defines the top-level translation functions pertaining to
--   streaming selects into Postgres AST.
--   
--   Streaming subscriptions are subscriptions based on a user-provided
--   cursor column. Unlike live queries, streaming subscriptions can be
--   used to only get the part that has changed in the query's response,
--   although this will be dependent on the user's choice of the cursor
--   column. The streaming starts from the initial value provided by the
--   user.
module Hasura.Backends.Postgres.Translate.Select.Streaming
mkStreamSQLSelect :: forall (pgKind :: PostgresKind) m. (Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind, PostgresGenerateSQLSelect pgKind, MonadWriter CustomSQLCTEs m, MonadIO m, MonadError QErr m) => UserInfo -> AnnSimpleStreamSelect ('Postgres pgKind) -> m Select
selectStreamQuerySQL :: forall (pgKind :: PostgresKind) m. (Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind, PostgresGenerateSQLSelect pgKind, MonadIO m, MonadError QErr m) => UserInfo -> AnnSimpleStreamSelect ('Postgres pgKind) -> m Query


-- | This module defines the top-level translation functions pertaining to
--   queries that are not aggregation queries, i.e. so-called "simple"
--   selects into Postgres AST.
module Hasura.Backends.Postgres.Translate.Select.Simple
mkSQLSelect :: forall (pgKind :: PostgresKind) m. (Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind, PostgresGenerateSQLSelect pgKind, MonadWriter CustomSQLCTEs m, MonadIO m, MonadError QErr m) => UserInfo -> JsonAggSelect -> AnnSimpleSelect ('Postgres pgKind) -> m Select

-- | Translates IR to Postgres queries for simple SELECTs (select queries
--   that are not aggregations, including subscriptions).
--   
--   See <a>mkSQLSelect</a> for the Postgres AST.
selectQuerySQL :: forall (pgKind :: PostgresKind) m. (Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind, PostgresGenerateSQLSelect pgKind, MonadIO m, MonadError QErr m) => UserInfo -> JsonAggSelect -> AnnSimpleSelect ('Postgres pgKind) -> m Query


-- | This module defines the top-level translation functions pertaining to
--   translating Connection (i.e. Relay) queries into Postgres AST.
module Hasura.Backends.Postgres.Translate.Select.Connection

-- | Translates IR to Postgres queries for "connection" queries (used for
--   Relay).
--   
--   See <a>mkConnectionSelect</a> for the Postgres AST.
connectionSelectQuerySQL :: forall (pgKind :: PostgresKind) m. (Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind, PostgresGenerateSQLSelect pgKind, MonadIO m, MonadError QErr m) => UserInfo -> ConnectionSelect ('Postgres pgKind) Void SQLExp -> m Query
mkConnectionSelect :: forall (pgKind :: PostgresKind) m. (Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind, PostgresGenerateSQLSelect pgKind, MonadWriter CustomSQLCTEs m, MonadIO m, MonadError QErr m) => UserInfo -> ConnectionSelect ('Postgres pgKind) Void SQLExp -> m (SelectWithG Select)


-- | This module defines the top-level translation functions pertaining to
--   queries that use aggregation (i.e., <i>not</i> so-called "simple"
--   selects) into Postgres AST.
module Hasura.Backends.Postgres.Translate.Select.Aggregate

-- | We process aggregate queries differently because the types of
--   aggregate queries are different. In the <tt>_asnFields</tt> field of
--   an <a>AnnSelectG</a>, we will have a <tt>TableAggregateFieldG</tt>
--   instead of an <tt>AnnFieldG</tt>.
mkAggregateSelect :: forall (pgKind :: PostgresKind) m. (Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind, PostgresGenerateSQLSelect pgKind, MonadWriter CustomSQLCTEs m, MonadIO m, MonadError QErr m) => UserInfo -> AnnAggregateSelect ('Postgres pgKind) -> m Select

-- | Translates IR to Postgres queries for aggregated SELECTs.
--   
--   See <a>mkAggregateSelect</a> for the Postgres AST.
selectAggregateQuerySQL :: forall (pgKind :: PostgresKind) m. (Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind, PostgresGenerateSQLSelect pgKind, MonadIO m, MonadError QErr m) => UserInfo -> AnnAggregateSelect ('Postgres pgKind) -> m Query


-- | Postgres Translate Select
--   
--   This module is a translation layer between IR and postgres-specific
--   select queries.
--   
--   There are four main types of selects (as distinguished from the IR):
--   
--   <ul>
--   <li>"simple" selects</li>
--   <li>aggregate selects</li>
--   <li>connection selects (used for relay)</li>
--   <li>streaming selects (see
--   Hasura.Backends.Postgres.Translate.Select.Streaming for details)</li>
--   </ul>
module Hasura.Backends.Postgres.Translate.Select
type PostgresTranslateSelect (pgKind :: PostgresKind) = (PostgresAnnotatedFieldJSON pgKind, PostgresGenerateSQLSelect pgKind)


-- | Postgres Translate Returning
--   
--   Combinators and helpers for dealing with GraphQL returning statements.
module Hasura.Backends.Postgres.Translate.Returning

-- | The postgres common table expression (CTE) for mutation queries. This
--   CTE expression is used to generate mutation field output expression,
--   see Note [Mutation output expression].
data MutationCTE

-- | A Mutation with check constraint validation (Insert or Update)
MCCheckConstraint :: TopLevelCTE -> MutationCTE

-- | A Select statement which emits mutated table rows
MCSelectValues :: Select -> MutationCTE

-- | A Delete statement
MCDelete :: SQLDelete -> MutationCTE
getMutationCTE :: MutationCTE -> TopLevelCTE
checkPermissionRequired :: MutationCTE -> Bool
mkMutFldExp :: forall (pgKind :: PostgresKind) m. (Backend ('Postgres pgKind), PostgresTranslateSelect pgKind, MonadWriter CustomSQLCTEs m, MonadIO m, MonadError QErr m) => UserInfo -> TableIdentifier -> Maybe Int -> StringifyNumbers -> Maybe NamingCase -> MutFld ('Postgres pgKind) -> m SQLExp
mkDefaultMutFlds :: forall (pgKind :: PostgresKind). Backend ('Postgres pgKind) => Maybe [ColumnInfo ('Postgres pgKind)] -> MutationOutput ('Postgres pgKind)
mkCheckErrorExp :: TableIdentifier -> SQLExp

-- | Generate mutation output expression with given mutation CTE statement.
--   See Note [Mutation output expression].
mkMutationOutputExp :: forall (pgKind :: PostgresKind) m. (Backend ('Postgres pgKind), PostgresTranslateSelect pgKind, MonadIO m, MonadError QErr m) => UserInfo -> QualifiedTable -> [ColumnInfo ('Postgres pgKind)] -> Maybe Int -> MutationCTE -> MutationOutput ('Postgres pgKind) -> StringifyNumbers -> Maybe NamingCase -> m SelectWith
checkConstraintIdentifier :: Identifier
asCheckErrorExtractor :: SQLExp -> Extractor
instance GHC.Classes.Eq Hasura.Backends.Postgres.Translate.Returning.MutationCTE
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Translate.Returning.MutationCTE


-- | Postgres Translate Insert
--   
--   Translates IR inserts to Postgres-specific SQL INSERT statements.
module Hasura.Backends.Postgres.Translate.Insert
mkInsertCTE :: forall (pgKind :: PostgresKind) m. (Backend ('Postgres pgKind), MonadIO m, MonadError QErr m) => UserInfo -> InsertQueryP1 ('Postgres pgKind) -> m TopLevelCTE
toSQLConflict :: forall (pgKind :: PostgresKind) m. (Backend ('Postgres pgKind), MonadIO m, MonadError QErr m) => UserInfo -> QualifiedTable -> OnConflictClause ('Postgres pgKind) SQLExp -> m SQLConflict

-- | Annotates the check constraint expression with <tt>boolean</tt>
--   (<a>check-condition</a>)::boolean
insertCheckConstraint :: BoolExp -> SQLExp

-- | When inserting data, we might need to also enforce the update check
--   condition, because we might fall back to an update via an <tt>ON
--   CONFLICT</tt> clause.
--   
--   We generate something which looks like
--   
--   <pre>
--   INSERT INTO
--     ...
--   ON CONFLICT DO UPDATE SET
--     ...
--   RETURNING
--     *,
--     CASE WHEN xmax = 0
--       THEN {insert_cond}
--       ELSE {update_cond}
--     END
--       AS "check__constraint"
--   </pre>
--   
--   See <tt><a>https://stackoverflow.com/q/34762732</a></tt> for more
--   information on the use of the <tt>xmax</tt> system column.
insertOrUpdateCheckExpr :: forall (pgKind :: PostgresKind). QualifiedTable -> Maybe (OnConflictClause ('Postgres pgKind) SQLExp) -> BoolExp -> Maybe BoolExp -> Extractor


-- | Postgres Translate Update
--   
--   Translates IR update to Postgres-specific SQL UPDATE statements.
module Hasura.Backends.Postgres.Translate.Update

-- | Create the update CTE.
mkUpdateCTE :: forall (pgKind :: PostgresKind) m. (Backend ('Postgres pgKind), MonadIO m, MonadError QErr m) => UserInfo -> AnnotatedUpdate ('Postgres pgKind) -> m UpdateCTE
data UpdateCTE

-- | Used for <i>update_table</i> and <i>update_table_by_pk</i>.
Update :: TopLevelCTE -> UpdateCTE

-- | Used for <i>update_table_many</i>.
MultiUpdate :: [TopLevelCTE] -> UpdateCTE
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Translate.Update.UpdateCTE


-- | Postgres Execute Mutation
--   
--   Generic combinators for translating and excecuting IR mutation
--   statements. Used by the specific mutation modules, e.g. <a>Insert</a>.
--   
--   See <a>Execute</a>.
module Hasura.Backends.Postgres.Execute.Mutation
data MutateResp (b :: BackendType) a
MutateResp :: Int -> [ColumnValues b a] -> MutateResp (b :: BackendType) a
[_mrAffectedRows] :: MutateResp (b :: BackendType) a -> Int
[_mrReturningColumns] :: MutateResp (b :: BackendType) a -> [ColumnValues b a]
execDeleteQuery :: forall (pgKind :: PostgresKind) m. (MonadTx m, MonadIO m, Backend ('Postgres pgKind), PostgresTranslateSelect pgKind, MonadReader QueryTagsComment m) => StringifyNumbers -> Maybe NamingCase -> UserInfo -> (AnnDel ('Postgres pgKind), Seq PrepArg) -> m EncJSON
execInsertQuery :: forall m (pgKind :: PostgresKind). (MonadTx m, Backend ('Postgres pgKind), PostgresTranslateSelect pgKind, MonadReader QueryTagsComment m, MonadIO m) => StringifyNumbers -> Maybe NamingCase -> UserInfo -> (InsertQueryP1 ('Postgres pgKind), Seq PrepArg) -> m EncJSON
execUpdateQuery :: forall (pgKind :: PostgresKind) m. (MonadTx m, Backend ('Postgres pgKind), PostgresTranslateSelect pgKind, MonadReader QueryTagsComment m, MonadIO m) => StringifyNumbers -> Maybe NamingCase -> UserInfo -> (AnnotatedUpdate ('Postgres pgKind), Seq PrepArg) -> m EncJSON
executeMutationOutputQuery :: forall (pgKind :: PostgresKind) m. (MonadTx m, Backend ('Postgres pgKind), PostgresTranslateSelect pgKind, MonadReader QueryTagsComment m, MonadIO m) => UserInfo -> QualifiedTable -> [ColumnInfo ('Postgres pgKind)] -> Maybe Int -> MutationCTE -> MutationOutput ('Postgres pgKind) -> StringifyNumbers -> Maybe NamingCase -> [PrepArg] -> m EncJSON
mutateAndFetchCols :: forall (pgKind :: PostgresKind). (Backend ('Postgres pgKind), PostgresTranslateSelect pgKind) => UserInfo -> QualifiedTable -> [ColumnInfo ('Postgres pgKind)] -> (MutationCTE, Seq PrepArg) -> StringifyNumbers -> Maybe NamingCase -> TxE QErr (MutateResp ('Postgres pgKind) TxtEncodedVal)
type ValidateInputPayloadVersion = Int
validateInputPayloadVersion :: ValidateInputPayloadVersion
newtype ValidateInputErrorResponse
ValidateInputErrorResponse :: Text -> ValidateInputErrorResponse
[_vierMessage] :: ValidateInputErrorResponse -> Text
data HttpHandlerLog
HttpHandlerLog :: Text -> Value -> [HeaderConf] -> Value -> Int -> HttpHandlerLog
[_hhlUrl] :: HttpHandlerLog -> Text
[_hhlRequest] :: HttpHandlerLog -> Value
[_hhlRequestHeaders] :: HttpHandlerLog -> [HeaderConf]
[_hhlResponse] :: HttpHandlerLog -> Value
[_hhlResponseStatus] :: HttpHandlerLog -> Int
data ValidateInsertInputLog
VIILHttpHandler :: HttpHandlerLog -> ValidateInsertInputLog

-- | Map of table name and the value that is being inserted for that table
--   This map is helpful for collecting all the insert mutation arguments
--   for the nested tables and then sending them all at onve to the input
--   validation webhook.
type InsertValidationPayloadMap (pgKind :: PostgresKind) = InsOrdHashMap TableName 'Postgres pgKind ([AnnotatedInsertRow 'Postgres pgKind UnpreparedValue 'Postgres pgKind], ValidateInput ResolvedWebhook)
validateUpdateMutation :: forall (pgKind :: PostgresKind) m. (MonadError QErr m, MonadIO m, MonadTrace m) => Environment -> Manager -> Logger Hasura -> UserInfo -> ResolvedWebhook -> [HeaderConf] -> Timeout -> Bool -> [Header] -> AnnotatedUpdateG ('Postgres pgKind) Void (UnpreparedValue ('Postgres pgKind)) -> Maybe (HashMap Name (Value Variable)) -> m ()
validateDeleteMutation :: forall m (pgKind :: PostgresKind). (MonadError QErr m, MonadIO m, MonadTrace m) => Environment -> Manager -> Logger Hasura -> UserInfo -> ResolvedWebhook -> [HeaderConf] -> Timeout -> Bool -> [Header] -> AnnDelG ('Postgres pgKind) Void (UnpreparedValue ('Postgres pgKind)) -> Maybe (HashMap Name (Value Variable)) -> m ()
validateMutation :: (MonadError QErr m, MonadIO m, MonadTrace m) => Environment -> Manager -> Logger Hasura -> UserInfo -> ResolvedWebhook -> [HeaderConf] -> Timeout -> Bool -> [Header] -> Value -> m ()
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq a) => GHC.Classes.Eq (Hasura.Backends.Postgres.Execute.Mutation.MutateResp b a)
instance GHC.Classes.Eq Hasura.Backends.Postgres.Execute.Mutation.ValidateInputErrorResponse
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.FromJSON.FromJSON a) => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Backends.Postgres.Execute.Mutation.MutateResp b a)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Execute.Mutation.ValidateInputErrorResponse
instance GHC.Internal.Generics.Generic (Hasura.Backends.Postgres.Execute.Mutation.MutateResp b a)
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Execute.Mutation.HttpHandlerLog
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show a) => GHC.Internal.Show.Show (Hasura.Backends.Postgres.Execute.Mutation.MutateResp b a)
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Execute.Mutation.ValidateInputErrorResponse
instance Hasura.Logging.ToEngineLog Hasura.Backends.Postgres.Execute.Mutation.ValidateInsertInputLog Hasura.Logging.Hasura
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Execute.Mutation.HttpHandlerLog
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.ToJSON.ToJSON a) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Backends.Postgres.Execute.Mutation.MutateResp b a)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Execute.Mutation.ValidateInputErrorResponse
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Execute.Mutation.ValidateInsertInputLog


-- | Postgres Execute Insert
--   
--   Translates and executes IR to Postgres-specific SQL.
--   
--   See <a>Execute</a>.
module Hasura.Backends.Postgres.Execute.Insert
convertToSQLTransaction :: forall (pgKind :: PostgresKind) m. (MonadTx m, MonadIO m, MonadTrace m, Backend ('Postgres pgKind), PostgresTranslateSelect pgKind, MonadReader QueryTagsComment m) => AnnotatedInsert ('Postgres pgKind) Void SQLExp -> UserInfo -> Seq PrepArg -> StringifyNumbers -> Maybe NamingCase -> m EncJSON
validateInsertInput :: forall m (pgKind :: PostgresKind). (MonadError QErr m, MonadIO m, MonadTrace m, MonadState (InsertValidationPayloadMap pgKind) m) => Environment -> Manager -> Logger Hasura -> UserInfo -> MultiObjectInsert ('Postgres pgKind) (UnpreparedValue ('Postgres pgKind)) -> [Header] -> m ()
validateInsertRows :: forall m (pgKind :: PostgresKind). (MonadError QErr m, MonadIO m, MonadTrace m) => Environment -> Manager -> Logger Hasura -> UserInfo -> ResolvedWebhook -> [HeaderConf] -> Timeout -> Bool -> [Header] -> [AnnotatedInsertRow ('Postgres pgKind) (UnpreparedValue ('Postgres pgKind))] -> m ()


-- | Postgres DDL EventTrigger
--   
--   Used for creating event triggers for metadata changes.
--   
--   See <a>Backend</a>.
module Hasura.Backends.Postgres.DDL.EventTrigger
insertManualEvent :: forall m (pgKind :: PostgresKind). (MonadIO m, MonadError QErr m) => SourceConfig ('Postgres pgKind) -> TableName ('Postgres pgKind) -> TriggerName -> Value -> UserInfo -> Maybe TraceContext -> m EventId
redeliverEvent :: forall m (pgKind :: PostgresKind). (MonadIO m, MonadError QErr m) => SourceConfig ('Postgres pgKind) -> EventId -> m ()
dropTriggerAndArchiveEvents :: forall m (pgKind :: PostgresKind). (MonadIO m, MonadError QErr m) => SourceConfig ('Postgres pgKind) -> TriggerName -> QualifiedTable -> m ()
createTableEventTrigger :: forall (pgKind :: PostgresKind) m. (Backend ('Postgres pgKind), MonadIO m, MonadBaseControl IO m) => SQLGenCtx -> PGSourceConfig -> QualifiedTable -> [ColumnInfo ('Postgres pgKind)] -> TriggerName -> TriggerOnReplication -> TriggerOpsDef ('Postgres pgKind) -> Maybe (PrimaryKey ('Postgres pgKind) (ColumnInfo ('Postgres pgKind))) -> m (Either QErr ())
createMissingSQLTriggers :: forall m (pgKind :: PostgresKind). (MonadIO m, MonadError QErr m, MonadBaseControl IO m, Backend ('Postgres pgKind)) => SQLGenCtx -> PGSourceConfig -> TableName ('Postgres pgKind) -> ([ColumnInfo ('Postgres pgKind)], Maybe (PrimaryKey ('Postgres pgKind) (ColumnInfo ('Postgres pgKind)))) -> TriggerName -> TriggerOnReplication -> TriggerOpsDef ('Postgres pgKind) -> m ()
dropTriggerQ :: TriggerName -> TxE QErr ()
dropDanglingSQLTrigger :: forall m (pgKind :: PostgresKind). (MonadIO m, MonadError QErr m) => SourceConfig ('Postgres pgKind) -> TriggerName -> QualifiedTable -> HashSet Ops -> m ()
mkAllTriggersQ :: forall (pgKind :: PostgresKind) m. (Backend ('Postgres pgKind), MonadTx m, MonadReader SQLGenCtx m) => TriggerName -> QualifiedTable -> TriggerOnReplication -> [ColumnInfo ('Postgres pgKind)] -> TriggerOpsDef ('Postgres pgKind) -> m ()
getMaintenanceModeVersion :: forall m (pgKind :: PostgresKind). (MonadIO m, MonadError QErr m) => SourceConfig ('Postgres pgKind) -> m MaintenanceModeVersion
fetchUndeliveredEvents :: forall m (pgKind :: PostgresKind). (MonadIO m, MonadError QErr m) => SourceConfig ('Postgres pgKind) -> SourceName -> [TriggerName] -> MaintenanceMode () -> FetchBatchSize -> m [Event ('Postgres pgKind)]
setRetry :: forall m (pgKind :: PostgresKind). (MonadIO m, MonadError QErr m) => SourceConfig ('Postgres pgKind) -> Event ('Postgres pgKind) -> UTCTime -> MaintenanceMode MaintenanceModeVersion -> m ()
recordSuccess :: forall m (pgKind :: PostgresKind). MonadIO m => SourceConfig ('Postgres pgKind) -> Event ('Postgres pgKind) -> Invocation 'EventType -> MaintenanceMode MaintenanceModeVersion -> m (Either QErr ())
recordError :: forall m (pgKind :: PostgresKind). MonadIO m => SourceConfig ('Postgres pgKind) -> Event ('Postgres pgKind) -> Invocation 'EventType -> ProcessEventError -> MaintenanceMode MaintenanceModeVersion -> m (Either QErr ())
recordError' :: forall m (pgKind :: PostgresKind). MonadIO m => SourceConfig ('Postgres pgKind) -> Event ('Postgres pgKind) -> Maybe (Invocation 'EventType) -> ProcessEventError -> MaintenanceMode MaintenanceModeVersion -> m (Either QErr ())
unlockEventsInSource :: forall m (pgKind :: PostgresKind). MonadIO m => SourceConfig ('Postgres pgKind) -> NESet EventId -> m (Either QErr Int)
updateColumnInEventTrigger :: forall (pgKind :: PostgresKind). QualifiedTable -> PGCol -> PGCol -> QualifiedTable -> EventTriggerConf ('Postgres pgKind) -> EventTriggerConf ('Postgres pgKind)
checkIfTriggerExists :: (MonadIO m, MonadError QErr m) => PGSourceConfig -> TriggerName -> HashSet Ops -> m Bool

-- | Add cleanup logs for given trigger names and cleanup configs. This
--   will perform the following steps:
--   
--   <ol>
--   <li>Get last scheduled cleanup event and count.</li>
--   <li>If count is less than 5, then add add more cleanup logs, else do
--   nothing</li>
--   </ol>
addCleanupSchedules :: (MonadIO m, MonadError QErr m) => PGSourceConfig -> [(TriggerName, AutoTriggerLogCleanupConfig)] -> m ()

-- | <tt>deleteAllScheduledCleanups</tt> deletes all scheduled cleanup logs
--   for a given event trigger
deleteAllScheduledCleanups :: (MonadIO m, MonadError QErr m) => PGSourceConfig -> TriggerName -> m ()

-- | <tt>getCleanupEventsForDeletion</tt> returns the cleanup logs that are
--   to be deleted. This will perform the following steps:
--   
--   <ol>
--   <li>Get the scheduled cleanup events that were scheduled before
--   current time.</li>
--   <li>If there are multiple entries for the same trigger name with
--   different scheduled time, then fetch the latest entry and mark others
--   as dead.</li>
--   </ol>
getCleanupEventsForDeletion :: (MonadIO m, MonadError QErr m) => PGSourceConfig -> m [(Text, TriggerName)]
updateCleanupEventStatusToDead :: (MonadIO m, MonadError QErr m) => PGSourceConfig -> [Text] -> m ()

-- | <tt>updateCleanupEventStatusToPaused</tt> updates the cleanup log
--   status to <tt>paused</tt> if the event trigger configuration is
--   paused.
updateCleanupEventStatusToPaused :: (MonadIO m, MonadError QErr m) => PGSourceConfig -> Text -> m ()

-- | <tt>updateCleanupEventStatusToCompleted</tt> updates the cleanup log
--   status after the event logs are deleted. This will perform the
--   following steps:
--   
--   <ol>
--   <li>Updates the cleanup config status to <tt>completed</tt>.</li>
--   <li>Updates the number of event logs and event invocation logs that
--   were deleted for a trigger name</li>
--   </ol>
updateCleanupEventStatusToCompleted :: (MonadIO m, MonadError QErr m) => PGSourceConfig -> Text -> DeletedEventLogStats -> m ()

-- | <tt>deleteEventTriggerLogs</tt> deletes the event logs (and event
--   invocation logs) based on the cleanup configuration given This will
--   perform the following steps:
--   
--   <ol>
--   <li>Select all the dead events based on criteria set in the cleanup
--   config.</li>
--   <li>Lock the events in the database so that other HGE instances don't
--   pick them up for deletion.</li>
--   <li>Based on the config, perform the delete action.</li>
--   </ol>
deleteEventTriggerLogs :: (MonadIO m, MonadError QErr m) => PGSourceConfig -> TriggerLogCleanupConfig -> IO (Maybe (TriggerLogCleanupConfig, EventTriggerCleanupStatus)) -> m DeletedEventLogStats
fetchEventLogs :: forall m (b :: BackendType). (MonadError QErr m, MonadIO m) => PGSourceConfig -> GetEventLogs b -> m [EventLog]
fetchEventInvocationLogs :: forall m (b :: BackendType). (MonadError QErr m, MonadIO m) => PGSourceConfig -> GetEventInvocations b -> m [EventInvocationLog]
fetchEventById :: forall m (b :: BackendType). (MonadError QErr m, MonadIO m) => PGSourceConfig -> GetEventById b -> m EventLogWithInvocations
instance GHC.Classes.Eq Hasura.Backends.Postgres.DDL.EventTrigger.QualifiedTriggerName
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.DDL.EventTrigger.QualifiedTriggerName
instance Database.PG.Query.Class.ToPrepArg Hasura.Backends.Postgres.DDL.EventTrigger.QualifiedTriggerName


-- | Postgres DDL Source
--   
--   A Source is a connected database. One can have multiple sources of the
--   same kind (e.g. Postgres).
--   
--   This module provides ways to fetch, update, and deal with table and
--   function metadata and hdb_catalog migrations for a Postgres Source.
--   
--   NOTE: Please have a look at the
--   `server<i>documentation</i>migration-guidelines.md` before adding any
--   new migration if you haven't already looked at it.
module Hasura.Backends.Postgres.DDL.Source

-- | We differentiate the handling of metadata between Citus, Cockroach and
--   Vanilla Postgres because Citus imposes limitations on the types of
--   joins that it permits, which then limits the types of relations that
--   we can track.
class ToMetadataFetchQuery (pgKind :: PostgresKind)

-- | We differentiate for CockroachDB and other PG implementations as our
--   CockroachDB table fetching SQL does not require table information, and
--   fails if it receives unused prepared arguments this distinction should
--   no longer be necessary if this issue is resolved:
--   <a>https://github.com/cockroachdb/cockroach/issues/86375</a>
class FetchTableMetadata (pgKind :: PostgresKind)
fetchTableMetadata :: (FetchTableMetadata pgKind, Backend ('Postgres pgKind), ToMetadataFetchQuery pgKind, MonadTx m) => HashSet QualifiedTable -> m (DBTablesMetadata ('Postgres pgKind))
class FetchFunctionMetadata (pgKind :: PostgresKind)
fetchFunctionMetadata :: (FetchFunctionMetadata pgKind, MonadTx m) => HashSet QualifiedFunction -> m (DBFunctionsMetadata ('Postgres pgKind))

-- | Initialise catalog tables for a source, including those required by
--   the event delivery subsystem.
prepareCatalog :: forall (m :: Type -> Type) (pgKind :: PostgresKind). (MonadIO m, MonadBaseControl IO m) => SourceConfig ('Postgres pgKind) -> ExceptT QErr m (RecreateEventTriggers, SourceCatalogMigrationState)

-- | Clean source database after dropping in metadata
postDropSourceHook :: forall m (pgKind :: PostgresKind). (MonadIO m, MonadError QErr m, MonadBaseControl IO m) => SourceConfig ('Postgres pgKind) -> TableEventTriggers ('Postgres pgKind) -> m ()
resolveDatabaseMetadata :: forall (pgKind :: PostgresKind) m. (Backend ('Postgres pgKind), ToMetadataFetchQuery pgKind, FetchFunctionMetadata pgKind, FetchTableMetadata pgKind, MonadIO m, MonadBaseControl IO m, HasFeatureFlagChecker m) => SourceMetadata ('Postgres pgKind) -> SourceConfig ('Postgres pgKind) -> m (Either QErr (DBObjectsIntrospection ('Postgres pgKind)))
resolveSourceConfig :: forall m (pgKind :: PostgresKind) manager. (MonadIO m, MonadResolveSource m) => SourceName -> PostgresConnConfiguration -> BackendSourceKind ('Postgres pgKind) -> BackendConfig ('Postgres pgKind) -> Environment -> manager -> m (Either QErr (SourceConfig ('Postgres pgKind)))

-- | <a>logPGSourceCatalogMigrationLockedQueries</a> as the name suggests
--   logs the queries which are blocking in the database. This function is
--   called asynchronously from <tt>initCatalogIfNeeded</tt> while the
--   source catalog is being migrated. NOTE: When there are no locking
--   queries present in the database, nothing will be logged.
logPGSourceCatalogMigrationLockedQueries :: MonadIO m => Logger Hasura -> PGSourceConfig -> m Void

-- | Fetch Postgres metadata of all user tables
pgFetchTableMetadata :: forall (pgKind :: PostgresKind) m. (Backend ('Postgres pgKind), ToMetadataFetchQuery pgKind, MonadTx m) => HashSet QualifiedTable -> m (DBTablesMetadata ('Postgres pgKind))
instance Hasura.Backends.Postgres.DDL.Source.FetchFunctionMetadata 'Hasura.RQL.Types.BackendType.Citus
instance Hasura.Backends.Postgres.DDL.Source.FetchFunctionMetadata 'Hasura.RQL.Types.BackendType.Cockroach
instance Hasura.Backends.Postgres.DDL.Source.FetchFunctionMetadata 'Hasura.RQL.Types.BackendType.Vanilla
instance Hasura.Backends.Postgres.DDL.Source.FetchTableMetadata 'Hasura.RQL.Types.BackendType.Citus
instance Hasura.Backends.Postgres.DDL.Source.FetchTableMetadata 'Hasura.RQL.Types.BackendType.Cockroach
instance Hasura.Backends.Postgres.DDL.Source.FetchTableMetadata 'Hasura.RQL.Types.BackendType.Vanilla
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.DDL.Source.PGSourceLockQuery
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.DDL.Source.PGSourceLockQuery
instance Hasura.Logging.ToEngineLog [Hasura.Backends.Postgres.DDL.Source.PGSourceLockQuery] Hasura.Logging.Hasura
instance Hasura.Logging.ToEngineLog Hasura.Backends.Postgres.DDL.Source.PGSourceLockQueryError Hasura.Logging.Hasura
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.DDL.Source.PGSourceLockQuery
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.DDL.Source.PGSourceLockQueryError
instance Hasura.Backends.Postgres.DDL.Source.ToMetadataFetchQuery 'Hasura.RQL.Types.BackendType.Citus
instance Hasura.Backends.Postgres.DDL.Source.ToMetadataFetchQuery 'Hasura.RQL.Types.BackendType.Cockroach
instance Hasura.Backends.Postgres.DDL.Source.ToMetadataFetchQuery 'Hasura.RQL.Types.BackendType.Vanilla


-- | Postgres Instances Schema
--   
--   Defines a <a>BackendSchema</a> type class instance for Postgres.
module Hasura.Backends.Postgres.Instances.Schema
instance Hasura.GraphQL.Schema.Backend.BackendSchema ('Hasura.RQL.Types.BackendType.Postgres pgKind) => Hasura.GraphQL.Schema.BoolExp.AggregationPredicatesSchema ('Hasura.RQL.Types.BackendType.Postgres pgKind)
instance (Hasura.Backends.Postgres.Instances.Schema.PostgresSchema pgKind, Hasura.RQL.Types.Backend.Backend ('Hasura.RQL.Types.BackendType.Postgres pgKind)) => Hasura.GraphQL.Schema.Backend.BackendLogicalModelSelectSchema ('Hasura.RQL.Types.BackendType.Postgres pgKind)
instance (Hasura.Backends.Postgres.Instances.Schema.PostgresSchema pgKind, Hasura.RQL.Types.Backend.Backend ('Hasura.RQL.Types.BackendType.Postgres pgKind)) => Hasura.GraphQL.Schema.Backend.BackendNativeQuerySelectSchema ('Hasura.RQL.Types.BackendType.Postgres pgKind)
instance (Hasura.RQL.Types.Backend.Backend ('Hasura.RQL.Types.BackendType.Postgres pgKind), Hasura.Backends.Postgres.Instances.Schema.PostgresSchema pgKind) => Hasura.GraphQL.Schema.Backend.BackendSchema ('Hasura.RQL.Types.BackendType.Postgres pgKind)
instance (Hasura.Backends.Postgres.Instances.Schema.PostgresSchema pgKind, Hasura.RQL.Types.Backend.Backend ('Hasura.RQL.Types.BackendType.Postgres pgKind)) => Hasura.GraphQL.Schema.Backend.BackendTableSelectSchema ('Hasura.RQL.Types.BackendType.Postgres pgKind)
instance Hasura.RQL.Types.Backend.Backend ('Hasura.RQL.Types.BackendType.Postgres pgKind) => Hasura.GraphQL.Schema.Backend.BackendUpdateOperatorsSchema ('Hasura.RQL.Types.BackendType.Postgres pgKind)
instance Hasura.Backends.Postgres.Instances.Schema.PostgresSchema 'Hasura.RQL.Types.BackendType.Citus
instance Hasura.Backends.Postgres.Instances.Schema.PostgresSchema 'Hasura.RQL.Types.BackendType.Cockroach
instance Hasura.Backends.Postgres.Instances.Schema.PostgresSchema 'Hasura.RQL.Types.BackendType.Vanilla

module Hasura.GraphQL.Schema.Instances


-- | This module only exposes one function, <a>nodeField</a>, which is used
--   at the root level of the schema to create the <tt>node</tt> field in
--   the Relay API schema.
module Hasura.GraphQL.Schema.Relay

-- | Constructs the parser for the node interface.
--   
--   As mentioned in Note [Internal Relay HashMap], this function must
--   parse an incoming query for ANY potential matching table. Its
--   resulting parser returns a <a>NodeMap</a>: a container that, to a
--   source name and a table name, associates both the parsed fields and
--   all the relevant table information required to craft a request.
nodeInterface :: SourceCache -> NodeInterfaceParserBuilder

-- | Creates a field parser for the top-level "node" field in the
--   QueryRoot.
--   
--   It exepcts one argument, the node id. It looks for the targeted table
--   in the <a>NodeMap</a> returned by <a>nodeInterface</a>, and, if
--   successful, attempts to craft a corresponding <tt>QueryRootField</tt>
--   that will extract the requested row.
nodeField :: forall m (n :: Type -> Type). (MonadError QErr m, MonadMemoize m, MonadParse n) => SourceCache -> SchemaContext -> SchemaOptions -> m (FieldParser n (QueryRootField UnpreparedValue))

module Hasura.GraphQL.Schema.Action

-- | actionExecute is used to execute either a query action or a
--   synchronous mutation action. A query action or a synchronous mutation
--   action accepts the field name and input arguments and a selectionset.
--   The input argument and selectionset types are defined by the user.
--   
--   <pre>
--   action_name(action_input_arguments) {
--     col1: col1_type
--     col2: col2_type
--   }
--   </pre>
actionExecute :: forall r (m :: Type -> Type) (n :: Type -> Type). MonadBuildActionSchema r m n => AnnotatedCustomTypes -> ActionInfo -> SchemaT r m (Maybe (FieldParser n (AnnActionExecution (RemoteRelationshipField UnpreparedValue))))

-- | actionAsyncMutation is used to execute a asynchronous mutation action.
--   An asynchronous action expects the field name and the input arguments
--   to the action. A selectionset is *not* expected. An action ID (UUID)
--   will be returned after performing the action
--   
--   <pre>
--   action_name(action_input_arguments)
--   </pre>
actionAsyncMutation :: forall r (m :: Type -> Type) (n :: Type -> Type). MonadBuildActionSchema r m n => HashMap Name AnnotatedInputType -> ActionInfo -> SchemaT r m (Maybe (FieldParser n AnnActionMutationAsync))

-- | actionAsyncQuery is used to query/subscribe to the result of an
--   asynchronous mutation action. The only input argument to an
--   asynchronous mutation action is the action ID (UUID) and a selection
--   set is expected, the selection set contains 4 fields namely <a>id</a>,
--   <tt>created_at</tt>,<tt>errors</tt> and <tt>output</tt>. The result of
--   the action can be queried through the <tt>output</tt> field.
--   
--   <pre>
--   action_name (id: UUID!) {
--     id: UUID!
--     created_at: timestampz!
--     errors: JSON
--     output: user_defined_type!
--   }
--   </pre>
actionAsyncQuery :: forall r (m :: Type -> Type) (n :: Type -> Type). MonadBuildActionSchema r m n => HashMap Name AnnotatedObjectType -> ActionInfo -> SchemaT r m (Maybe (FieldParser n (AnnActionAsyncQuery ('Postgres 'Vanilla) (RemoteRelationshipField UnpreparedValue))))


-- | Postgres-specific schema combinators. Those should be moved to the
--   corresponding instance of <tt>BackendSchema</tt>, when actions are
--   generalized.
module Hasura.GraphQL.Schema.Postgres
buildActionQueryFields :: forall r (m :: Type -> Type) (n :: Type -> Type). MonadBuildActionSchema r m n => AnnotatedCustomTypes -> ActionInfo -> SchemaT r m [FieldParser n (QueryRootField UnpreparedValue)]
buildActionSubscriptionFields :: forall r (m :: Type -> Type) (n :: Type -> Type). MonadBuildActionSchema r m n => AnnotatedCustomTypes -> ActionInfo -> SchemaT r m [FieldParser n (QueryRootField UnpreparedValue)]
buildActionMutationFields :: forall r (m :: Type -> Type) (n :: Type -> Type). MonadBuildActionSchema r m n => AnnotatedCustomTypes -> ActionInfo -> SchemaT r m [FieldParser n (MutationRootField UnpreparedValue)]


-- | Postgres Execute subscription
--   
--   Multiplex is an optimization which allows us to group similar queries
--   into a single query, and routing the response rows afterwards. See
--   <a>https://hasura.io/docs/latest/graphql/core/databases/postgres/subscriptions/execution-and-performance.html</a>
--   for more details
--   
--   See <a>Execute</a>.
module Hasura.Backends.Postgres.Execute.Subscription
newtype MultiplexedQuery
MultiplexedQuery :: Query -> MultiplexedQuery
[unMultiplexedQuery] :: MultiplexedQuery -> Query

-- | Internal: Used to collect information about various parameters of a
--   subscription field's AST as we resolve them to SQL expressions.
data QueryParametersInfo (b :: BackendType)
QueryParametersInfo :: HashMap Name (ColumnValue b) -> Seq (ColumnValue b) -> HashSet SessionVariable -> QueryParametersInfo (b :: BackendType)
[_qpiReusableVariableValues] :: QueryParametersInfo (b :: BackendType) -> HashMap Name (ColumnValue b)
[_qpiSyntheticVariableValues] :: QueryParametersInfo (b :: BackendType) -> Seq (ColumnValue b)

-- | The session variables that are referenced in the query root fld's AST.
--   This information is used to determine a cohort's required session
--   variables
[_qpiReferencedSessionVariables] :: QueryParametersInfo (b :: BackendType) -> HashSet SessionVariable
mkMultiplexedQuery :: forall (pgKind :: PostgresKind) m. (Backend ('Postgres pgKind), PostgresTranslateSelect pgKind, MonadIO m, MonadError QErr m) => UserInfo -> InsOrdHashMap Name (QueryDB ('Postgres pgKind) Void SQLExp) -> m MultiplexedQuery
mkStreamingMultiplexedQuery :: forall (pgKind :: PostgresKind) m. (Backend ('Postgres pgKind), PostgresTranslateSelect pgKind, MonadIO m, MonadError QErr m) => UserInfo -> (Name, QueryDB ('Postgres pgKind) Void SQLExp) -> m MultiplexedQuery

-- | Resolves an <a>UnresolvedVal</a> by converting <a>UVPG</a> values to
--   SQL expressions that refer to the <tt>result_vars</tt> input object,
--   collecting information about various parameters of the query along the
--   way.
resolveMultiplexedValue :: forall (pgKind :: PostgresKind) m. (MonadState (QueryParametersInfo ('Postgres pgKind)) m, MonadError QErr m) => SessionVariables -> UnpreparedValue ('Postgres pgKind) -> m SQLExp

-- | Checks if the provided arguments are valid values for their
--   corresponding types. | Generates SQL of the format "select
--   <tt>v1</tt>::t1, <tt>v2</tt>::t2 ..."
validateVariablesTx :: forall (pgKind :: PostgresKind) f m. (Traversable f, MonadTx m, MonadIO m) => f (ColumnValue ('Postgres pgKind)) -> m (ValidatedVariables f)
executeMultiplexedQuery :: MonadTx m => MultiplexedQuery -> [(CohortId, CohortVariables)] -> m [(CohortId, ByteString)]
executeStreamingMultiplexedQuery :: MonadTx m => MultiplexedQuery -> [(CohortId, CohortVariables)] -> m [(CohortId, ByteString, ViaJSON CursorVariableValues)]

-- | Internal; used by both <a>executeMultiplexedQuery</a>,
--   <a>executeStreamingMultiplexedQuery</a> and
--   <tt>pgDBSubscriptionExplain</tt>.
executeQuery :: (MonadTx m, FromRes a) => Query -> [(CohortId, CohortVariables)] -> m a
data SubscriptionType
Streaming :: SubscriptionType
LiveQuery :: SubscriptionType
instance GHC.Classes.Eq Hasura.Backends.Postgres.Execute.Subscription.MultiplexedQuery
instance GHC.Internal.Generics.Generic (Hasura.Backends.Postgres.Execute.Subscription.QueryParametersInfo b)
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Execute.Subscription.MultiplexedQuery
instance GHC.Internal.Base.Monoid (Hasura.Backends.Postgres.Execute.Subscription.QueryParametersInfo b)
instance GHC.Internal.Base.Semigroup (Hasura.Backends.Postgres.Execute.Subscription.QueryParametersInfo b)
instance Data.Text.Extended.ToTxt Hasura.Backends.Postgres.Execute.Subscription.MultiplexedQuery


-- | Postgres DDL
--   
--   Implements the DDL related methods of the <a>BackendMetadata</a> type
--   class for the Postgres backend, which provides an interface for
--   fetching information about the objects in the database, such as
--   tables, relationships, etc.
module Hasura.Backends.Postgres.DDL
parseCollectableType :: forall (pgKind :: PostgresKind) m. (Backend ('Postgres pgKind), MonadError QErr m) => CollectableType (ColumnType ('Postgres pgKind)) -> Value -> m (PartialSQLExp ('Postgres pgKind))


-- | Validate native queries against postgres-like flavors.
module Hasura.Backends.Postgres.Instances.NativeQueries

-- | Prepare a native query query against a postgres-like database to
--   validate it.
validateNativeQuery :: forall m (pgKind :: PostgresKind) sourceConfig. (MonadIO m, MonadError QErr m) => InsOrdHashMap PGScalarType Oid -> Environment -> SourceName -> PostgresConnConfiguration -> sourceConfig -> LogicalModelInfo ('Postgres pgKind) -> NativeQueryMetadata ('Postgres pgKind) -> m (InterpolatedQuery ArgumentName)

-- | Convert a native query to a prepared statement to be validate.
--   
--   Used by <a>validateNativeQuery</a>. Exported for testing.
nativeQueryToPreparedStatement :: forall m (pgKind :: PostgresKind). MonadError QErr m => LogicalModelInfo ('Postgres pgKind) -> NativeQueryMetadata ('Postgres pgKind) -> m (ByteString, Text)


-- | Postgres Instances Metadata
--   
--   Defines a <a>BackendMetadata</a> type class instance for Postgres.
module Hasura.Backends.Postgres.Instances.Metadata
instance (Hasura.RQL.Types.Backend.Backend ('Hasura.RQL.Types.BackendType.Postgres pgKind), Hasura.Backends.Postgres.Instances.Metadata.PostgresMetadata pgKind, Hasura.Backends.Postgres.DDL.Source.FetchTableMetadata pgKind, Hasura.Backends.Postgres.DDL.Source.FetchFunctionMetadata pgKind, Hasura.Backends.Postgres.DDL.Source.ToMetadataFetchQuery pgKind) => Hasura.RQL.Types.Metadata.Backend.BackendMetadata ('Hasura.RQL.Types.BackendType.Postgres pgKind)
instance Hasura.Backends.Postgres.Instances.Metadata.PostgresMetadata 'Hasura.RQL.Types.BackendType.Citus
instance Hasura.Backends.Postgres.Instances.Metadata.PostgresMetadata 'Hasura.RQL.Types.BackendType.Cockroach
instance Hasura.Backends.Postgres.Instances.Metadata.PostgresMetadata 'Hasura.RQL.Types.BackendType.Vanilla

module Hasura.RQL.DML.Internal
data SessionVariableBuilder (m :: Type -> Type)
askDelPermInfo :: (UserInfoM m, QErrM m) => TableInfo ('Postgres 'Vanilla) -> m (DelPermInfo ('Postgres 'Vanilla))
askInsPermInfo :: (UserInfoM m, QErrM m) => TableInfo ('Postgres 'Vanilla) -> m (InsPermInfo ('Postgres 'Vanilla))
askPermInfo :: UserInfoM m => Lens' (RolePermInfo ('Postgres 'Vanilla)) (Maybe c) -> TableInfo ('Postgres 'Vanilla) -> m (Maybe c)
askSelPermInfo :: (UserInfoM m, QErrM m) => TableInfo ('Postgres 'Vanilla) -> m (SelPermInfo ('Postgres 'Vanilla))
askTableInfoSource :: (QErrM m, TableInfoRM ('Postgres 'Vanilla) m) => TableName ('Postgres 'Vanilla) -> m (TableInfo ('Postgres 'Vanilla))
askUpdPermInfo :: (UserInfoM m, QErrM m) => TableInfo ('Postgres 'Vanilla) -> m (UpdPermInfo ('Postgres 'Vanilla))
binRHSBuilder :: forall (m :: Type -> Type). QErrM m => ColumnType ('Postgres 'Vanilla) -> Value -> DMLP1T m SQLExp
checkPermOnCol :: (UserInfoM m, QErrM m) => PermType -> HashSet (Column ('Postgres 'Vanilla)) -> Column ('Postgres 'Vanilla) -> m ()
checkRetCols :: (UserInfoM m, QErrM m) => FieldInfoMap (FieldInfo ('Postgres 'Vanilla)) -> SelPermInfo ('Postgres 'Vanilla) -> [PGCol] -> m [ColumnInfo ('Postgres 'Vanilla)]
checkSelOnCol :: (UserInfoM m, QErrM m) => SelPermInfo ('Postgres 'Vanilla) -> Column ('Postgres 'Vanilla) -> m ()
convAnnBoolExpPartialSQL :: Applicative f => SessionVariableBuilder f -> AnnBoolExpPartialSQL ('Postgres 'Vanilla) -> f (AnnBoolExpSQL ('Postgres 'Vanilla))
convAnnRedactionExpPartialSQL :: Applicative f => SessionVariableBuilder f -> AnnRedactionExpPartialSQL ('Postgres 'Vanilla) -> f (AnnRedactionExp ('Postgres 'Vanilla) (SQLExpression ('Postgres 'Vanilla)))
convBoolExp :: (UserInfoM m, QErrM m, TableInfoRM ('Postgres 'Vanilla) m, LogicalModelFieldsRM ('Postgres 'Vanilla) m) => FieldInfoMap (FieldInfo ('Postgres 'Vanilla)) -> SelPermInfo ('Postgres 'Vanilla) -> BoolExp ('Postgres 'Vanilla) -> SessionVariableBuilder m -> FieldInfoMap (FieldInfo ('Postgres 'Vanilla)) -> ValueParser ('Postgres 'Vanilla) m (SQLExpression ('Postgres 'Vanilla)) -> m (AnnBoolExpSQL ('Postgres 'Vanilla))
convPartialSQLExp :: Applicative f => SessionVariableBuilder f -> PartialSQLExp ('Postgres 'Vanilla) -> f (SQLExpression ('Postgres 'Vanilla))
fetchRelDet :: (UserInfoM m, QErrM m, TableInfoRM ('Postgres 'Vanilla) m) => RelName -> TableName ('Postgres 'Vanilla) -> m (FieldInfoMap (FieldInfo ('Postgres 'Vanilla)), SelPermInfo ('Postgres 'Vanilla))
fetchRelTabInfo :: (QErrM m, TableInfoRM ('Postgres 'Vanilla) m) => TableName ('Postgres 'Vanilla) -> m (TableInfo ('Postgres 'Vanilla))
isTabUpdatable :: RoleName -> TableInfo ('Postgres 'Vanilla) -> Bool
onlyPositiveInt :: MonadError QErr m => Int -> m ()
runDMLP1T :: DMLP1T m a -> m (a, Seq PrepArg)
sessVarFromCurrentSetting :: forall (f :: Type -> Type). Applicative f => SessionVariableBuilder f
validateHeaders :: (UserInfoM m, QErrM m) => HashSet Text -> m ()
valueParserWithCollectableType :: MonadError QErr m => (ColumnType ('Postgres 'Vanilla) -> Value -> m SQLExp) -> CollectableType (ColumnType ('Postgres 'Vanilla)) -> Value -> m SQLExp
verifyAsrns :: MonadError QErr m => [a -> m ()] -> [a] -> m ()
instance GHC.Internal.Base.Monad m => GHC.Internal.Base.Applicative (Hasura.RQL.DML.Internal.DMLP1T m)
instance Hasura.RQL.Types.SchemaCache.CacheRM m => Hasura.RQL.Types.SchemaCache.CacheRM (Hasura.RQL.DML.Internal.DMLP1T m)
instance GHC.Internal.Base.Functor m => GHC.Internal.Base.Functor (Hasura.RQL.DML.Internal.DMLP1T m)
instance Hasura.LogicalModel.Fields.LogicalModelFieldsRM b m => Hasura.LogicalModel.Fields.LogicalModelFieldsRM b (Hasura.RQL.DML.Internal.DMLP1T m)
instance GHC.Internal.Base.Monad m => GHC.Internal.Base.Monad (Hasura.RQL.DML.Internal.DMLP1T m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Hasura.RQL.DML.Internal.DMLP1T m)
instance GHC.Internal.Base.Monad m => Control.Monad.State.Class.MonadState (Data.Sequence.Internal.Seq Database.PG.Query.Connection.PrepArg) (Hasura.RQL.DML.Internal.DMLP1T m)
instance Control.Monad.Trans.Class.MonadTrans Hasura.RQL.DML.Internal.DMLP1T
instance Hasura.RQL.Types.SchemaCache.TableCoreInfoRM b m => Hasura.RQL.Types.SchemaCache.TableCoreInfoRM b (Hasura.RQL.DML.Internal.DMLP1T m)
instance Hasura.RQL.Types.SchemaCache.TableInfoRM b m => Hasura.RQL.Types.SchemaCache.TableInfoRM b (Hasura.RQL.DML.Internal.DMLP1T m)
instance Hasura.Authentication.User.UserInfoM m => Hasura.Authentication.User.UserInfoM (Hasura.RQL.DML.Internal.DMLP1T m)

module Hasura.RQL.DML.Update
runUpdate :: (QErrM m, UserInfoM m, CacheRM m, MonadBaseControl IO m, MonadIO m, MonadTrace m, MetadataM m) => SQLGenCtx -> UpdateQuery -> m EncJSON

module Hasura.RQL.DML.Select
runSelect :: (QErrM m, UserInfoM m, CacheRM m, MonadIO m, MonadBaseControl IO m, MonadTrace m, MetadataM m) => SQLGenCtx -> SelectQuery -> m EncJSON

module Hasura.RQL.DML.Insert
runInsert :: (QErrM m, UserInfoM m, CacheRM m, MonadIO m, MonadTrace m, MonadBaseControl IO m, MetadataM m) => SQLGenCtx -> InsertQuery -> m EncJSON

module Hasura.RQL.DML.Delete
validateDeleteQWith :: (UserInfoM m, QErrM m, TableInfoRM ('Postgres 'Vanilla) m, LogicalModelFieldsRM ('Postgres 'Vanilla) m) => SessionVariableBuilder m -> (ColumnType ('Postgres 'Vanilla) -> Value -> m SQLExp) -> DeleteQuery -> m (AnnDel ('Postgres 'Vanilla))
validateDeleteQ :: (QErrM m, UserInfoM m, CacheRM m) => DeleteQuery -> m (AnnDel ('Postgres 'Vanilla), Seq PrepArg)
data AnnDelG (b :: BackendType) r v
AnnDel :: TableName b -> (AnnBoolExp b v, AnnBoolExp b v) -> MutationOutputG b r v -> [ColumnInfo b] -> Maybe NamingCase -> Maybe (ValidateInput ResolvedWebhook) -> Bool -> AnnDelG (b :: BackendType) r v
[_adTable] :: AnnDelG (b :: BackendType) r v -> TableName b
[_adWhere] :: AnnDelG (b :: BackendType) r v -> (AnnBoolExp b v, AnnBoolExp b v)
[_adOutput] :: AnnDelG (b :: BackendType) r v -> MutationOutputG b r v
[_adAllCols] :: AnnDelG (b :: BackendType) r v -> [ColumnInfo b]
[_adNamingConvention] :: AnnDelG (b :: BackendType) r v -> Maybe NamingCase
[_adValidateInput] :: AnnDelG (b :: BackendType) r v -> Maybe (ValidateInput ResolvedWebhook)
[_adIsDeleteByPk] :: AnnDelG (b :: BackendType) r v -> Bool
type AnnDel (b :: BackendType) = AnnDelG b Void SQLExpression b
execDeleteQuery :: forall (pgKind :: PostgresKind) m. (MonadTx m, MonadIO m, Backend ('Postgres pgKind), PostgresTranslateSelect pgKind, MonadReader QueryTagsComment m) => StringifyNumbers -> Maybe NamingCase -> UserInfo -> (AnnDel ('Postgres pgKind), Seq PrepArg) -> m EncJSON
runDelete :: (QErrM m, UserInfoM m, CacheRM m, MonadIO m, MonadTrace m, MonadBaseControl IO m, MetadataM m) => SQLGenCtx -> DeleteQuery -> m EncJSON

module Hasura.RQL.DML.Count
data CountQueryP1
CountQueryP1 :: QualifiedTable -> (AnnBoolExpSQL ('Postgres 'Vanilla), Maybe (AnnBoolExpSQL ('Postgres 'Vanilla))) -> Maybe [PGCol] -> CountQueryP1
[cqp1Table] :: CountQueryP1 -> QualifiedTable
[cqp1Where] :: CountQueryP1 -> (AnnBoolExpSQL ('Postgres 'Vanilla), Maybe (AnnBoolExpSQL ('Postgres 'Vanilla)))
[cqp1Distinct] :: CountQueryP1 -> Maybe [PGCol]
validateCountQWith :: (UserInfoM m, QErrM m, TableInfoRM ('Postgres 'Vanilla) m, LogicalModelFieldsRM ('Postgres 'Vanilla) m) => SessionVariableBuilder m -> (ColumnType ('Postgres 'Vanilla) -> Value -> m SQLExp) -> CountQuery -> m CountQueryP1
validateCountQ :: (QErrM m, UserInfoM m, CacheRM m) => CountQuery -> m (CountQueryP1, Seq PrepArg)
runCount :: (QErrM m, UserInfoM m, CacheRM m, MonadIO m, MonadBaseControl IO m, MonadTrace m, MetadataM m) => CountQuery -> m EncJSON
countQToTx :: (MonadTx m, MonadIO m) => UserInfo -> (CountQueryP1, Seq PrepArg) -> m EncJSON
instance GHC.Classes.Eq Hasura.RQL.DML.Count.CountQueryP1

module Hasura.Backends.MSSQL.DDL.EventTrigger
createTableEventTrigger :: MonadIO m => SQLGenCtx -> MSSQLSourceConfig -> TableName -> [ColumnInfo 'MSSQL] -> TriggerName -> TriggerOnReplication -> TriggerOpsDef 'MSSQL -> Maybe (PrimaryKey 'MSSQL (ColumnInfo 'MSSQL)) -> m (Either QErr ())
fetchUndeliveredEvents :: (MonadIO m, MonadError QErr m) => MSSQLSourceConfig -> SourceName -> [TriggerName] -> MaintenanceMode () -> FetchBatchSize -> m [Event 'MSSQL]
setRetry :: (MonadIO m, MonadError QErr m) => MSSQLSourceConfig -> Event 'MSSQL -> UTCTime -> MaintenanceMode MaintenanceModeVersion -> m ()
recordSuccess :: MonadIO m => MSSQLSourceConfig -> Event 'MSSQL -> Invocation 'EventType -> MaintenanceMode MaintenanceModeVersion -> m (Either QErr ())
recordError :: MonadIO m => MSSQLSourceConfig -> Event 'MSSQL -> Invocation 'EventType -> ProcessEventError -> MaintenanceMode MaintenanceModeVersion -> m (Either QErr ())
recordError' :: MonadIO m => MSSQLSourceConfig -> Event 'MSSQL -> Maybe (Invocation 'EventType) -> ProcessEventError -> MaintenanceMode MaintenanceModeVersion -> m (Either QErr ())
dropTriggerQ :: TriggerName -> SchemaName -> TxE QErr ()
dropTriggerAndArchiveEvents :: (MonadIO m, MonadError QErr m) => MSSQLSourceConfig -> TriggerName -> TableName -> m ()
dropDanglingSQLTrigger :: (MonadIO m, MonadError QErr m) => MSSQLSourceConfig -> TriggerName -> TableName -> HashSet Ops -> m ()
redeliverEvent :: (MonadIO m, MonadError QErr m) => MSSQLSourceConfig -> EventId -> m ()
insertManualEvent :: (MonadIO m, MonadError QErr m) => MSSQLSourceConfig -> TableName -> TriggerName -> Value -> UserInfo -> Maybe TraceContext -> m EventId
unlockEventsInSource :: MonadIO m => MSSQLSourceConfig -> NESet EventId -> m (Either QErr Int)
getMaintenanceModeVersion :: (MonadIO m, MonadError QErr m) => MSSQLSourceConfig -> m MaintenanceModeVersion
qualifyTableName :: TableName -> Text
createMissingSQLTriggers :: (MonadIO m, MonadError QErr m, MonadBaseControl IO m) => SQLGenCtx -> MSSQLSourceConfig -> TableName -> ([ColumnInfo 'MSSQL], Maybe (PrimaryKey 'MSSQL (ColumnInfo 'MSSQL))) -> TriggerName -> TriggerOnReplication -> TriggerOpsDef 'MSSQL -> m ()
checkIfTriggerExists :: (MonadIO m, MonadError QErr m) => MSSQLSourceConfig -> TriggerName -> HashSet Ops -> m Bool

-- | Add cleanup logs for given trigger names and cleanup configs. This
--   will perform the following steps:
--   
--   <ol>
--   <li>Get last scheduled cleanup event and count.</li>
--   <li>If count is less than 5, then add add more cleanup logs, else do
--   nothing</li>
--   </ol>
addCleanupSchedules :: (MonadIO m, MonadError QErr m) => MSSQLSourceConfig -> [(TriggerName, AutoTriggerLogCleanupConfig)] -> m ()

-- | <tt>deleteAllScheduledCleanups</tt> deletes all scheduled cleanup logs
--   for a given event trigger
deleteAllScheduledCleanups :: (MonadIO m, MonadError QErr m) => MSSQLSourceConfig -> TriggerName -> m ()

-- | <tt>getCleanupEventsForDeletion</tt> returns the cleanup logs that are
--   to be deleted. This will perform the following steps:
--   
--   <ol>
--   <li>Get the scheduled cleanup events that were scheduled before
--   current time.</li>
--   <li>If there are multiple entries for the same trigger name with
--   different scheduled time, then fetch the latest entry and mark others
--   as dead.</li>
--   </ol>
getCleanupEventsForDeletion :: (MonadIO m, MonadError QErr m) => MSSQLSourceConfig -> m [(Text, TriggerName)]
updateCleanupEventStatusToDead :: (MonadIO m, MonadError QErr m) => MSSQLSourceConfig -> [Text] -> m ()

-- | <tt>updateCleanupEventStatusToPaused</tt> updates the cleanup log
--   status to <tt>paused</tt> if the event trigger configuration is
--   paused.
updateCleanupEventStatusToPaused :: (MonadIO m, MonadError QErr m) => MSSQLSourceConfig -> Text -> m ()

-- | <tt>updateCleanupEventStatusToCompleted</tt> updates the cleanup log
--   status after the event logs are deleted. This will perform the
--   following steps:
--   
--   <ol>
--   <li>Updates the cleanup config status to <tt>completed</tt>.</li>
--   <li>Updates the number of event logs and event invocation logs that
--   were deleted for a trigger name</li>
--   </ol>
updateCleanupEventStatusToCompleted :: (MonadIO m, MonadError QErr m) => MSSQLSourceConfig -> Text -> DeletedEventLogStats -> m ()

-- | <tt>deleteEventTriggerLogs</tt> deletes the event logs (and event
--   invocation logs) based on the cleanup configuration given This will
--   perform the following steps:
--   
--   <ol>
--   <li>Select all the dead events based on criteria set in the cleanup
--   config.</li>
--   <li>Lock the events in the database so that other HGE instances don't
--   pick them up for deletion.</li>
--   <li>Based on the config, perform the delete action.</li>
--   </ol>
deleteEventTriggerLogs :: (MonadIO m, MonadError QErr m) => MSSQLSourceConfig -> TriggerLogCleanupConfig -> IO (Maybe (TriggerLogCleanupConfig, EventTriggerCleanupStatus)) -> m DeletedEventLogStats
fetchEventLogs :: forall m (b :: BackendType). (MonadIO m, MonadError QErr m) => MSSQLSourceConfig -> GetEventLogs b -> m [EventLog]
fetchEventInvocationLogs :: forall m (b :: BackendType). (MonadError QErr m, MonadIO m) => MSSQLSourceConfig -> GetEventInvocations b -> m [EventInvocationLog]
fetchEventById :: forall m (b :: BackendType). (MonadError QErr m, MonadIO m) => MSSQLSourceConfig -> GetEventById b -> m EventLogWithInvocations
instance Hasura.SQL.Types.ToSQL Hasura.Backends.MSSQL.DDL.EventTrigger.QualifiedTriggerName
instance Hasura.SQL.Types.ToSQL Hasura.Backends.MSSQL.DDL.EventTrigger.SQLTriggerName

module Hasura.Eventing.Backend

-- | The <tt>BackendEventTrigger</tt> type class contains functions which
--   interacts with the source database to perform event trigger related
--   operations like fetching pending events from the database or inserting
--   a new invocation log after processing an event.
class Backend b => BackendEventTrigger (b :: BackendType)

-- | insertManualEvent inserts the specified event in the event log table,
--   note that this method should also set the trace context and session
--   variables in the source database context (if available).
insertManualEvent :: (BackendEventTrigger b, MonadIO m, MonadError QErr m) => SourceConfig b -> TableName b -> TriggerName -> Value -> UserInfo -> Maybe TraceContext -> m EventId

-- | <tt>fetchUndeliveredEvents</tt> fetches the undelivered events from
--   the source and locks those events for processing. The locking is done
--   so that when there are multiple instances of graphql-engine connected
--   to the same source they don't end up processing the same events
--   concurrently.
--   
--   Also, it's crucial that the SQL query used to fetch events in this
--   function uses something like Postgres's `FOR UPDATE SKIP LOCKED`
--   mechanism so that it skips past the events which are locked by the
--   database and pick newer undelivered events to achieve maximum
--   throughput.
--   
--   The locking mechanism for event triggers is timestamp based i.e. when
--   an event is fetched from the database, the <tt>locked</tt> column will
--   contain the timestamp of when it was fetched from the database.
--   Undelivered events will have <tt>NULL</tt> value as their
--   <tt>locked</tt> column value.
--   
--   The idea behind having a timestamp based locking mechanism is that if
--   the graphql-engine is shutdown abruptly with events being fetched by
--   the events processor, it will be locked and after the shutdown it will
--   remain locked. Now with a timestamp based lock, when the
--   graphql-engine is started again it will also fetch events which have a
--   <tt>locked</tt> value of older than 30 mins along with the undelivered
--   events. So, this way no events remain in a <tt>locked</tt> state.
--   
--   When fetching the events from the event_log table we also include the
--   list of the triggers that exist in the metadata at that point of time,
--   because we have seen in some cases there are events that do not belong
--   to any of the event triggers present in the metadata and those are
--   fetched only to be failed saying the said event trigger doesn't exist.
--   So, to avoid this (atleast, as much as possible) we get only the
--   events of the event triggers we have in the metadata.
fetchUndeliveredEvents :: (BackendEventTrigger b, MonadIO m, MonadError QErr m) => SourceConfig b -> SourceName -> [TriggerName] -> MaintenanceMode () -> FetchBatchSize -> m [Event b]

-- | Ad-hoc function to set a retry for an undelivered event
setRetry :: (BackendEventTrigger b, MonadIO m, MonadError QErr m) => SourceConfig b -> Event b -> UTCTime -> MaintenanceMode MaintenanceModeVersion -> m ()

-- | <tt>getMaintenanceModeVersion</tt> gets the source catalog version
--   from the source
getMaintenanceModeVersion :: (BackendEventTrigger b, MonadIO m, MonadError QErr m) => SourceConfig b -> m MaintenanceModeVersion

-- | <tt>recordSuccess</tt> records a successful event invocation, it does
--   a couple of things,
--   
--   <ol>
--   <li>Insert the invocation in the invocation logs table</li>
--   <li>Mark the event as <tt>delivered</tt> in the event_log table</li>
--   </ol>
recordSuccess :: (BackendEventTrigger b, MonadIO m) => SourceConfig b -> Event b -> Invocation 'EventType -> MaintenanceMode MaintenanceModeVersion -> m (Either QErr ())

-- | <tt>recordError</tt> records an erronous event invocation, it does a
--   couple of things,
--   
--   <ol>
--   <li>Insert the invocation in the invocation logs table</li>
--   <li>Depending on the value of <a>ProcessEventError</a>, it will
--   either, - Set a retry for the given event - Mark the event as
--   <a>error</a></li>
--   </ol>
recordError :: (BackendEventTrigger b, MonadIO m) => SourceConfig b -> Event b -> Invocation 'EventType -> ProcessEventError -> MaintenanceMode MaintenanceModeVersion -> m (Either QErr ())

-- | <tt>recordError'</tt> records an erronous event invocation, it does a
--   couple of things,
--   
--   <ol>
--   <li>If present, insert the invocation in the invocation logs
--   table</li>
--   <li>Depending on the value of <a>ProcessEventError</a>, it will
--   either, - Set a retry for the given event - Mark the event as
--   <a>error</a></li>
--   </ol>
recordError' :: (BackendEventTrigger b, MonadIO m) => SourceConfig b -> Event b -> Maybe (Invocation 'EventType) -> ProcessEventError -> MaintenanceMode MaintenanceModeVersion -> m (Either QErr ())

-- | <tt>dropTriggerAndArchiveEvents</tt> drops the database trigger and
--   marks all the events related to the event trigger as archived. See
--   Note [Cleanup for dropped triggers]
dropTriggerAndArchiveEvents :: (BackendEventTrigger b, MonadIO m, MonadError QErr m) => SourceConfig b -> TriggerName -> TableName b -> m ()

-- | <tt>dropDanglingSQLTriggger</tt> is used to delete the extraneous SQL
--   triggers created by an event trigger. The extraneous SQL triggers can
--   be created when an event trigger's definition is replaced to a new
--   definition. For example, an event trigger <tt>authors_all</tt> had an
--   INSERT and UPDATE trigger defined earlier and after it has UPDATE and
--   DELETE triggers. So, in this case, we need to drop the trigger created
--   by us earlier for the INSERT trigger.
dropDanglingSQLTrigger :: (BackendEventTrigger b, MonadIO m, MonadError QErr m) => SourceConfig b -> TriggerName -> TableName b -> HashSet Ops -> m ()
redeliverEvent :: (BackendEventTrigger b, MonadIO m, MonadError QErr m) => SourceConfig b -> EventId -> m ()

-- | <tt>unlockEventsInSource</tt> unlocks the cached locked events which
--   were captured when a graceful shutdown is initiated, so that when the
--   graphql-engine restarts these events can be fetched to process them
--   immediately.
unlockEventsInSource :: (BackendEventTrigger b, MonadIO m) => SourceConfig b -> NESet EventId -> m (Either QErr Int)

-- | <tt>createMissingSQLTriggers</tt> checks in the source whether all the
--   triggers exist according to the event trigger's specification. If any
--   SQL trigger doesn't exist then it will create it.
createMissingSQLTriggers :: (BackendEventTrigger b, MonadIO m, MonadError QErr m, MonadBaseControl IO m, Backend b) => SQLGenCtx -> SourceConfig b -> TableName b -> ([ColumnInfo b], Maybe (PrimaryKey b (ColumnInfo b))) -> TriggerName -> TriggerOnReplication -> TriggerOpsDef b -> m ()
createTableEventTrigger :: (BackendEventTrigger b, MonadBaseControl IO m, MonadIO m, MonadError QErr m) => SQLGenCtx -> SourceConfig b -> TableName b -> [ColumnInfo b] -> TriggerName -> TriggerOnReplication -> TriggerOpsDef b -> Maybe (PrimaryKey b (ColumnInfo b)) -> m (Either QErr ())
checkIfTriggerExists :: (BackendEventTrigger b, MonadIO m, MonadError QErr m) => SourceConfig b -> TriggerName -> HashSet Ops -> m Bool

-- | <tt>addCleanupSchedules</tt> adds cleanup logs for given trigger names
--   and cleanup configs. This will perform the following steps:
--   
--   <ol>
--   <li>Get last scheduled cleanup event and count.</li>
--   <li>If count is less than 5, then add add more cleanup logs, else do
--   nothing</li>
--   </ol>
addCleanupSchedules :: (BackendEventTrigger b, MonadIO m, MonadError QErr m) => SourceConfig b -> [(TriggerName, AutoTriggerLogCleanupConfig)] -> m ()

-- | <tt>deleteAllScheduledCleanups</tt> deletes all scheduled cleanup logs
--   for a given event trigger
deleteAllScheduledCleanups :: (BackendEventTrigger b, MonadIO m, MonadError QErr m) => SourceConfig b -> TriggerName -> m ()

-- | <tt>getCleanupEventsForDeletion</tt> returns the cleanup logs that are
--   to be deleted. This will perform the following steps:
--   
--   <ol>
--   <li>Get the scheduled cleanup events that were scheduled before
--   current time.</li>
--   <li>If there are multiple entries for the same trigger name with
--   different scheduled time, then fetch the latest entry and mark others
--   as dead.</li>
--   </ol>
getCleanupEventsForDeletion :: (BackendEventTrigger b, MonadIO m, MonadError QErr m) => SourceConfig b -> m [(Text, TriggerName)]

-- | <tt>updateCleanupEventStatusToDead</tt> updates the event trigger
--   cleanup logs as dead
updateCleanupEventStatusToDead :: (BackendEventTrigger b, MonadIO m, MonadError QErr m) => SourceConfig b -> [Text] -> m ()

-- | <tt>updateCleanupEventStatusToPaused</tt> updates the cleanup log
--   status to <tt>paused</tt> if the event trigger configuration is
--   paused.
updateCleanupEventStatusToPaused :: (BackendEventTrigger b, MonadIO m, MonadError QErr m) => SourceConfig b -> Text -> m ()

-- | <tt>updateCleanupEventStatusToCompleted</tt> updates the cleanup log
--   status after the event logs are deleted. This will perform the
--   following steps:
--   
--   <ol>
--   <li>Updates the cleanup config status to <tt>completed</tt>.</li>
--   <li>Updates the number of event logs and event invocation logs that
--   were deleted for a trigger name</li>
--   </ol>
updateCleanupEventStatusToCompleted :: (BackendEventTrigger b, MonadIO m, MonadError QErr m) => SourceConfig b -> Text -> DeletedEventLogStats -> m ()

-- | <tt>deleteEventTriggerLogs</tt> deletes the event logs (and event
--   invocation logs) based on the cleanup configuration given This will
--   perform the following steps:
--   
--   <ol>
--   <li>Select all the dead events based on criteria set in the cleanup
--   config.</li>
--   <li>Lock the events in the database so that other HGE instances don't
--   pick them up for deletion.</li>
--   <li>Based on the config, perform the delete action.</li>
--   </ol>
deleteEventTriggerLogs :: (BackendEventTrigger b, MonadIO m, MonadError QErr m) => SourceConfig b -> TriggerLogCleanupConfig -> IO (Maybe (TriggerLogCleanupConfig, EventTriggerCleanupStatus)) -> m DeletedEventLogStats

-- | @fetchEventLogs fetches event logs from the source for a given event
--   trigger.
fetchEventLogs :: (BackendEventTrigger b, MonadIO m, MonadError QErr m) => SourceConfig b -> GetEventLogs b -> m [EventLog]

-- | @fetchEventInvocationLogs fetches invocation logs from the source for
--   a given event trigger.
fetchEventInvocationLogs :: (BackendEventTrigger b, MonadIO m, MonadError QErr m) => SourceConfig b -> GetEventInvocations b -> m [EventInvocationLog]

-- | @fetchEventById fetches the event and it's invocation logs from the
--   source for a given EventId.
fetchEventById :: (BackendEventTrigger b, MonadIO m, MonadError QErr m) => SourceConfig b -> GetEventById b -> m EventLogWithInvocations
instance Hasura.Eventing.Backend.BackendEventTrigger 'Hasura.RQL.Types.BackendType.BigQuery
instance Hasura.Eventing.Backend.BackendEventTrigger 'Hasura.RQL.Types.BackendType.DataConnector
instance Hasura.Eventing.Backend.BackendEventTrigger 'Hasura.RQL.Types.BackendType.MSSQL
instance Hasura.Eventing.Backend.BackendEventTrigger ('Hasura.RQL.Types.BackendType.Postgres 'Hasura.RQL.Types.BackendType.Vanilla)
instance Hasura.Eventing.Backend.BackendEventTrigger ('Hasura.RQL.Types.BackendType.Postgres 'Hasura.RQL.Types.BackendType.Citus)
instance Hasura.Eventing.Backend.BackendEventTrigger ('Hasura.RQL.Types.BackendType.Postgres 'Hasura.RQL.Types.BackendType.Cockroach)


-- | <h1>Event Triggers</h1>
--   
--   Event triggers are like ordinary SQL triggers, except instead of
--   calling a SQL procedure, they call a webhook. The event delivery
--   mechanism involves coordination between both the database and
--   graphql-engine: only the SQL database knows when the events should
--   fire, but only graphql-engine know how to actually deliver them.
--   
--   Therefore, event triggers are implemented in two parts:
--   
--   <ol>
--   <li>Every event trigger is backed by a bona fide SQL trigger. When the
--   SQL trigger fires, it creates a new record in the
--   hdb_catalog.event_log table.</li>
--   <li>Concurrently, a thread in graphql-engine monitors the
--   hdb_catalog.event_log table for new events. When new event(s) are
--   found, it uses the information (URL,payload and headers) stored in the
--   event to deliver the event to the webhook.</li>
--   </ol>
--   
--   The creation and deletion of SQL trigger itself is managed by the
--   metadata DDL APIs (see Hasura.RQL.DDL.EventTrigger), so this module
--   focuses on event delivery.
--   
--   Most of the subtleties involve guaranteeing reliable delivery of
--   events: we guarantee that every event will be delivered at least once,
--   even if graphql-engine crashes. This means we have to record the state
--   of each event in the database, and we have to retry failed requests at
--   a regular (user-configurable) interval.
module Hasura.Eventing.EventTrigger
initEventEngineCtx :: MonadIO m => Refined Positive Int -> Refined NonNegative Milliseconds -> Refined NonNegative Int -> m EventEngineCtx

-- | Logger to accumulate stats of fetched events over a period of time and
--   log once using <tt>'L.Logger L.Hasura'. See
--   </tt><tt>createStatsLogger</tt> for more details.
createFetchedEventsStatsLogger :: MonadIO m => Logger Hasura -> m FetchedEventsStatsLogger

-- | Close the fetched events stats logger.
closeFetchedEventsStatsLogger :: MonadIO m => Logger Hasura -> FetchedEventsStatsLogger -> m ()

-- | Service events from our in-DB queue.
--   
--   There are a few competing concerns and constraints here; we want to...
--   - fetch events in batches for lower DB pressure - don't fetch more
--   than N at a time (since that can mean: space leak, less effective
--   scale out, possible double sends for events we've checked out on exit
--   (TODO clean shutdown procedure)) - try not to cause webhook workers to
--   stall waiting on DB fetch - limit webhook HTTP concurrency per
--   HASURA_GRAPHQL_EVENTS_HTTP_POOL_SIZE
processEventQueue :: (MonadIO m, MonadBaseControl IO m, Forall (Pure m), MonadMask m, MonadTrace m, MonadGetPolicies m) => Logger Hasura -> FetchedEventsStatsLogger -> Manager -> IO SchemaCache -> IO EventEngineCtx -> TVar Int -> LockedEventsCtx -> ServerMetrics -> EventTriggerMetrics -> MaintenanceMode () -> TriggersErrorLogLevelStatus -> m (Forever m)
defaultMaxEventThreads :: Refined Positive Int
defaultFetchInterval :: DiffTime

-- | Change data for a particular row
--   
--   
--   <a>https://docs.hasura.io/1.0/graphql/manual/event-triggers/payload.html</a>
data Event (b :: BackendType)
Event :: EventId -> SourceName -> TableName b -> TriggerMetadata -> Value -> Int -> LocalTime -> Maybe UTCTime -> UTCTime -> Maybe UTCTime -> Event (b :: BackendType)
[eId] :: Event (b :: BackendType) -> EventId
[eSource] :: Event (b :: BackendType) -> SourceName
[eTable] :: Event (b :: BackendType) -> TableName b
[eTrigger] :: Event (b :: BackendType) -> TriggerMetadata
[eEvent] :: Event (b :: BackendType) -> Value
[eTries] :: Event (b :: BackendType) -> Int
[eCreatedAt] :: Event (b :: BackendType) -> LocalTime
[eRetryAt] :: Event (b :: BackendType) -> Maybe UTCTime

-- | The values <a>eCreatedAtUTC</a> and <a>eRetryAtUTC</a> are only used
--   for calculating the <tt>event_processing_time</tt> metric.
[eCreatedAtUTC] :: Event (b :: BackendType) -> UTCTime
[eRetryAtUTC] :: Event (b :: BackendType) -> Maybe UTCTime

-- | See Note [Maintenance Mode]
data EventEngineCtx
EventEngineCtx :: TVar Int -> DiffTime -> Refined NonNegative Int -> EventEngineCtx
[_eeCtxEventThreadsCapacity] :: EventEngineCtx -> TVar Int
[_eeCtxFetchInterval] :: EventEngineCtx -> DiffTime
[_eeCtxFetchSize] :: EventEngineCtx -> Refined NonNegative Int
saveLockedEventTriggerEvents :: MonadIO m => SourceName -> [EventId] -> TVar (HashMap SourceName (Set EventId)) -> m ()
removeEventTriggerEventFromLockedEvents :: MonadIO m => SourceName -> EventId -> TVar (HashMap SourceName (Set EventId)) -> m ()
logQErr :: (MonadTraceContext m, MonadReader r m, Has (Logger Hasura) r, MonadIO m) => QErr -> m ()
instance GHC.Classes.Eq Hasura.Eventing.EventTrigger.DeliveryInfo
instance GHC.Classes.Eq Hasura.Eventing.EventTrigger.EventInternalErr
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.Eventing.EventTrigger.EventPayload b)
instance GHC.Classes.Eq Hasura.Eventing.EventTrigger.EventsCount
instance GHC.Classes.Eq Hasura.Eventing.EventTrigger.FetchedEventsStats
instance GHC.Classes.Eq Hasura.Eventing.EventTrigger.NumEventsFetchedPerSource
instance GHC.Classes.Eq Hasura.Eventing.EventTrigger.QualifiedTableStrict
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Eventing.EventTrigger.EventsCount
instance GHC.Internal.Generics.Generic Hasura.Eventing.EventTrigger.DeliveryInfo
instance GHC.Internal.Generics.Generic (Hasura.Eventing.EventTrigger.EventPayload b)
instance GHC.Internal.Generics.Generic Hasura.Eventing.EventTrigger.FetchedEventsStats
instance GHC.Internal.Base.Monoid Hasura.Eventing.EventTrigger.FetchedEventsStats
instance GHC.Internal.Base.Monoid Hasura.Eventing.EventTrigger.NumEventsFetchedPerSource
instance GHC.Internal.Num.Num Hasura.Eventing.EventTrigger.EventsCount
instance GHC.Internal.Base.Semigroup Hasura.Eventing.EventTrigger.FetchedEventsStats
instance GHC.Internal.Base.Semigroup Hasura.Eventing.EventTrigger.NumEventsFetchedPerSource
instance GHC.Internal.Show.Show Hasura.Eventing.EventTrigger.DeliveryInfo
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.Eventing.EventTrigger.EventPayload b)
instance GHC.Internal.Show.Show Hasura.Eventing.EventTrigger.EventsCount
instance GHC.Internal.Show.Show Hasura.Eventing.EventTrigger.FetchedEventsStats
instance GHC.Internal.Show.Show Hasura.Eventing.EventTrigger.NumEventsFetchedPerSource
instance GHC.Internal.Show.Show Hasura.Eventing.EventTrigger.QualifiedTableStrict
instance Hasura.Logging.ToEngineLog Hasura.Eventing.EventTrigger.EventInternalErr Hasura.Logging.Hasura
instance Hasura.Logging.ToEngineLog Hasura.Eventing.EventTrigger.FetchedEventsStats Hasura.Logging.Hasura
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Eventing.EventTrigger.DeliveryInfo
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Eventing.EventTrigger.EventPayload b)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Eventing.EventTrigger.EventsCount
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Eventing.EventTrigger.FetchedEventsStats
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Eventing.EventTrigger.NumEventsFetchedPerSource
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Eventing.EventTrigger.QualifiedTableStrict

module Hasura.RQL.DDL.EventTrigger
data CreateEventTriggerQuery (b :: BackendType)
runCreateEventTriggerQuery :: forall (b :: BackendType) m r. (BackendMetadata b, BackendEventTrigger b, QErrM m, UserInfoM m, CacheRWM m, MonadTraceContext m, MetadataM m, MonadIO m, MonadEventLogCleanup m, MonadReader r m, Has (Logger Hasura) r) => CreateEventTriggerQuery b -> m EncJSON
data DeleteEventTriggerQuery (b :: BackendType)
runDeleteEventTriggerQuery :: forall (b :: BackendType) m. (BackendEventTrigger b, MonadError QErr m, CacheRWM m, MonadIO m, MetadataM m) => DeleteEventTriggerQuery b -> m EncJSON
dropEventTriggerInMetadata :: forall (b :: BackendType). TriggerName -> TableMetadata b -> TableMetadata b
data RedeliverEventQuery (b :: BackendType)
runRedeliverEvent :: forall (b :: BackendType) m. (BackendEventTrigger b, MonadIO m, CacheRM m, QErrM m, MetadataM m) => RedeliverEventQuery b -> m EncJSON
data InvokeEventTriggerQuery (b :: BackendType)
runInvokeEventTrigger :: forall (b :: BackendType) m. (MonadIO m, QErrM m, CacheRM m, MetadataM m, MonadTrace m, UserInfoM m, BackendEventTrigger b) => InvokeEventTriggerQuery b -> m EncJSON
newtype ResolveHeaderError
ResolveHeaderError :: [Text] -> ResolveHeaderError
[unResolveHeaderError] :: ResolveHeaderError -> [Text]
getHeaderInfosFromConf :: QErrM m => Environment -> [HeaderConf] -> m [EventHeaderInfo]
getHeaderInfosFromConfEither :: Environment -> [HeaderConf] -> Either ResolveHeaderError [EventHeaderInfo]
getWebhookInfoFromConf :: QErrM m => Environment -> WebhookConf -> m WebhookConfInfo
buildEventTriggerInfo :: forall (b :: BackendType) m. (Backend b, QErrM m) => Environment -> SourceName -> TableName b -> EventTriggerConf b -> m (EventTriggerInfo b, Seq SchemaDependency)
getSourceTableAndTriggers :: forall (b :: BackendType). SourceMetadata b -> [(TableName b, TriggerName)]
getTriggerNames :: forall (b :: BackendType). SourceMetadata b -> HashSet TriggerName
getTriggersMap :: forall (b :: BackendType). SourceMetadata b -> InsOrdHashMap TriggerName (EventTriggerConf b)
getTableNameFromTrigger :: forall (b :: BackendType). Backend b => SchemaCache -> SourceName -> TriggerName -> Maybe (TableName b)
cetqSource :: forall (b :: BackendType) f. Functor f => (SourceName -> f SourceName) -> CreateEventTriggerQuery b -> f (CreateEventTriggerQuery b)
cetqName :: forall (b :: BackendType) f. Functor f => (TriggerName -> f TriggerName) -> CreateEventTriggerQuery b -> f (CreateEventTriggerQuery b)
cetqTable :: forall (b :: BackendType) f. Functor f => (TableName b -> f (TableName b)) -> CreateEventTriggerQuery b -> f (CreateEventTriggerQuery b)
cetqInsert :: forall (b :: BackendType) f. Functor f => (Maybe (SubscribeOpSpec b) -> f (Maybe (SubscribeOpSpec b))) -> CreateEventTriggerQuery b -> f (CreateEventTriggerQuery b)
cetqUpdate :: forall (b :: BackendType) f. Functor f => (Maybe (SubscribeOpSpec b) -> f (Maybe (SubscribeOpSpec b))) -> CreateEventTriggerQuery b -> f (CreateEventTriggerQuery b)
cetqDelete :: forall (b :: BackendType) f. Functor f => (Maybe (SubscribeOpSpec b) -> f (Maybe (SubscribeOpSpec b))) -> CreateEventTriggerQuery b -> f (CreateEventTriggerQuery b)
cetqEnableManual :: forall (b :: BackendType) f. Functor f => (Maybe Bool -> f (Maybe Bool)) -> CreateEventTriggerQuery b -> f (CreateEventTriggerQuery b)
cetqRetryConf :: forall (b :: BackendType) f. Functor f => (Maybe RetryConf -> f (Maybe RetryConf)) -> CreateEventTriggerQuery b -> f (CreateEventTriggerQuery b)
cetqWebhook :: forall (b :: BackendType) f. Functor f => (Maybe InputWebhook -> f (Maybe InputWebhook)) -> CreateEventTriggerQuery b -> f (CreateEventTriggerQuery b)
cetqWebhookFromEnv :: forall (b :: BackendType) f. Functor f => (Maybe Text -> f (Maybe Text)) -> CreateEventTriggerQuery b -> f (CreateEventTriggerQuery b)
cetqHeaders :: forall (b :: BackendType) f. Functor f => (Maybe [HeaderConf] -> f (Maybe [HeaderConf])) -> CreateEventTriggerQuery b -> f (CreateEventTriggerQuery b)
cetqReplace :: forall (b :: BackendType) f. Functor f => (Bool -> f Bool) -> CreateEventTriggerQuery b -> f (CreateEventTriggerQuery b)
cetqRequestTransform :: forall (b :: BackendType) f. Functor f => (Maybe RequestTransform -> f (Maybe RequestTransform)) -> CreateEventTriggerQuery b -> f (CreateEventTriggerQuery b)
cetqResponseTrasnform :: forall (b :: BackendType) f. Functor f => (Maybe MetadataResponseTransform -> f (Maybe MetadataResponseTransform)) -> CreateEventTriggerQuery b -> f (CreateEventTriggerQuery b)
cteqCleanupConfig :: forall (b :: BackendType) f. Functor f => (Maybe AutoTriggerLogCleanupConfig -> f (Maybe AutoTriggerLogCleanupConfig)) -> CreateEventTriggerQuery b -> f (CreateEventTriggerQuery b)
cteqTriggerOnReplication :: forall (b :: BackendType) f. Functor f => (TriggerOnReplication -> f TriggerOnReplication) -> CreateEventTriggerQuery b -> f (CreateEventTriggerQuery b)
runCleanupEventTriggerLog :: (MonadEventLogCleanup m, MonadError QErr m, CacheRWM m) => TriggerLogCleanupConfig -> m EncJSON
runEventTriggerResumeCleanup :: (MonadIO m, QErrM m, CacheRWM m, MetadataM m) => TriggerLogCleanupToggleConfig -> m EncJSON
runEventTriggerPauseCleanup :: (MonadError QErr m, CacheRWM m, MonadIO m, MetadataM m) => TriggerLogCleanupToggleConfig -> m EncJSON

-- | This typeclass have the implementation logic for the event trigger log
--   cleanup.
--   
--   TODO: this doesn't belong here in the DDL folder, but should be part
--   of Hasura.Eventing. It could even be made a Service, since the whole
--   point of it is to implement features differently between OSS and Pro.
class Monad m => MonadEventLogCleanup (m :: Type -> Type)
runLogCleaner :: MonadEventLogCleanup m => SourceCache -> TriggerLogCleanupConfig -> m (Either QErr EncJSON)
generateCleanupSchedules :: MonadEventLogCleanup m => AnyBackend SourceInfo -> TriggerName -> AutoTriggerLogCleanupConfig -> m (Either QErr ())

-- | <a>updateTriggerCleanupSchedules</a> is primarily used to update the
--   cleanup schedules associated with an event trigger in case the cleanup
--   config has changed while replacing the metadata.
--   
--   In case, i. a source has been dropped - We don't need to clear the
--   cleanup schedules because the event log cleanup table is dropped as
--   part of the post drop source hook. ii. a table or an event trigger has
--   been dropped/updated - Older cleanup events will be deleted first and
--   in case of an update, new cleanup events will be generated and
--   inserted into the table. iii. a new event trigger with cleanup config
--   has been added - Generate the cleanup events and insert it. iv. a new
--   source has been added - Generate the cleanup events and insert it. v.
--   the cron schedule for event trigger cleanup config has changed -
--   Delete cleanup events with older cron schedule and generate cleanup
--   events with new cron schedule.
updateTriggerCleanupSchedules :: MonadEventLogCleanup m => Logger Hasura -> InsOrdHashMap SourceName BackendSourceMetadata -> InsOrdHashMap SourceName BackendSourceMetadata -> SchemaCache -> m (Either QErr ())

-- | Collects and returns all the event triggers with cleanup config
getAllEventTriggersWithCleanupConfig :: forall (b :: BackendType). TableInfo b -> [(TriggerName, AutoTriggerLogCleanupConfig)]
getAllETWithCleanupConfigInTableMetadata :: forall (b :: BackendType). TableMetadata b -> [(TriggerName, AutoTriggerLogCleanupConfig)]
runGetEventLogs :: forall (b :: BackendType) m. (MonadIO m, CacheRM m, MonadError QErr m, BackendEventTrigger b, MetadataM m) => GetEventLogs b -> m EncJSON
runGetEventInvocationLogs :: forall (b :: BackendType) m. (MonadIO m, CacheRM m, MonadError QErr m, BackendEventTrigger b, MetadataM m) => GetEventInvocations b -> m EncJSON
runGetEventById :: forall (b :: BackendType) m. (MonadIO m, CacheRM m, MonadError QErr m, BackendEventTrigger b, MetadataM m) => GetEventById b -> m EncJSON
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.EventTrigger.CreateEventTriggerQuery b)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.EventTrigger.DeleteEventTriggerQuery b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.EventTrigger.InvokeEventTriggerQuery b)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.EventTrigger.RedeliverEventQuery b)
instance Hasura.RQL.DDL.EventTrigger.MonadEventLogCleanup m => Hasura.RQL.DDL.EventTrigger.MonadEventLogCleanup (Control.Monad.Trans.Except.ExceptT e m)
instance Hasura.RQL.DDL.EventTrigger.MonadEventLogCleanup m => Hasura.RQL.DDL.EventTrigger.MonadEventLogCleanup (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Hasura.RQL.DDL.EventTrigger.MonadEventLogCleanup m => Hasura.RQL.DDL.EventTrigger.MonadEventLogCleanup (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.RQL.DDL.EventTrigger.MonadEventLogCleanup m => Hasura.RQL.DDL.EventTrigger.MonadEventLogCleanup (Control.Monad.Trans.State.Strict.StateT w m)
instance Hasura.RQL.DDL.EventTrigger.MonadEventLogCleanup m => Hasura.RQL.DDL.EventTrigger.MonadEventLogCleanup (Hasura.Tracing.Monad.TraceT m)
instance GHC.Internal.Show.Show Hasura.RQL.DDL.EventTrigger.ResolveHeaderError
instance Data.Text.Extended.ToTxt Hasura.RQL.DDL.EventTrigger.ResolveHeaderError


-- | <h1>Scheduled Triggers</h1>
--   
--   This module implements the functionality of invoking webhooks during
--   specified time events aka scheduled events. The scheduled events are
--   the events generated by the graphql-engine using the cron triggers
--   or/and a scheduled event can be created by the user at a specified
--   time with the payload, webhook, headers and the retry configuration.
--   Scheduled events are modeled using rows in Postgres with a
--   <tt>timestamp</tt> column.
--   
--   This module implements scheduling and delivery of scheduled events:
--   
--   <ol>
--   <li>Scheduling a cron event involves creating new cron events. New
--   cron events are created based on the cron schedule and the number of
--   scheduled events that are already present in the scheduled events
--   buffer. The graphql-engine computes the new scheduled events and
--   writes them to the database.(Generator)</li>
--   <li>Delivering a scheduled event involves reading undelivered
--   scheduled events from the database and delivering them to the webhook
--   server. (Processor)</li>
--   </ol>
--   
--   The rationale behind separating the event scheduling and event
--   delivery mechanism into two different threads is that the scheduling
--   and delivering of the scheduled events are not directly dependent on
--   each other. The generator will almost always try to create scheduled
--   events which are supposed to be delivered in the future (timestamp
--   &gt; current_timestamp) and the processor will fetch scheduled events
--   of the past (timestamp &lt; current_timestamp). So, the set of the
--   scheduled events generated by the generator and the processor will
--   never be the same. The point here is that they're not correlated to
--   each other. They can be split into different threads for a better
--   performance.
--   
--   <h2>Implementation</h2>
--   
--   The scheduled triggers eventing is being implemented in the metadata
--   storage. All functions that make interaction to storage system are
--   abstracted in the @<a>MonadMetadataStorage</a> class.
--   
--   During the startup, two threads are started:
--   
--   <ol>
--   <li>Generator: Fetches the list of scheduled triggers from cache and
--   generates the scheduled events.<ul><li>Additional events will be
--   generated only if there are fewer than 100 scheduled
--   events.</li><li>The upcoming events timestamp will be generated
--   using:<ul><li>cron schedule of the scheduled trigger</li><li>max
--   timestamp of the scheduled events that already exist or
--   current_timestamp(when no scheduled events exist)</li><li>The
--   timestamp of the scheduled events is stored with timezone because
--   `SELECT NOW()` returns timestamp with timezone, so it's good to
--   compare two things of the same type.</li></ul></li></ul>This
--   effectively corresponds to doing an INSERT with values containing
--   specific timestamp.</li>
--   <li>Processor: Fetches the undelivered cron events and the scheduled
--   events from the database and which have timestamp lesser than the
--   current timestamp and then process them.</li>
--   </ol>
--   
--   TODO - Consider and document ordering guarantees - do we have any in
--   the presence of multiple hasura instances? - If we have nothing useful
--   to say about ordering, then consider processing events asynchronously,
--   so that a slow webhook doesn't cause everything subsequent to be
--   delayed
module Hasura.Eventing.ScheduledTrigger

-- | runCronEventsGenerator makes sure that all the cron triggers have an
--   adequate buffer of cron events.
runCronEventsGenerator :: (MonadIO m, MonadTraceContext m, MonadMetadataStorage m) => Logger Hasura -> FetchedCronTriggerStatsLogger -> IO SchemaCache -> m void
processScheduledTriggers :: (MonadIO m, MonadTrace m, MonadMetadataStorage m, MonadBaseControl IO m) => IO Environment -> Logger Hasura -> FetchedScheduledEventsStatsLogger -> Manager -> ScheduledTriggerMetrics -> IO SchemaCache -> LockedEventsCtx -> TriggersErrorLogLevelStatus -> m (Forever m)

-- | Generates next <tt>n events starting </tt>from according to
--   <a>CronSchedule</a>
generateScheduleTimes :: UTCTime -> Int -> CronSchedule -> [UTCTime]
data CronEventSeed
CronEventSeed :: TriggerName -> UTCTime -> CronEventSeed
[cesName] :: CronEventSeed -> TriggerName
[cesScheduledTime] :: CronEventSeed -> UTCTime
data LockedEventsCtx
LockedEventsCtx :: TVar (Set CronEventId) -> TVar (Set OneOffScheduledEventId) -> TVar (HashMap SourceName (Set EventId)) -> TVar (Set LockedActionEventId) -> LockedEventsCtx
[leCronEvents] :: LockedEventsCtx -> TVar (Set CronEventId)
[leOneOffEvents] :: LockedEventsCtx -> TVar (Set OneOffScheduledEventId)
[leEvents] :: LockedEventsCtx -> TVar (HashMap SourceName (Set EventId))
[leActionEvents] :: LockedEventsCtx -> TVar (Set LockedActionEventId)

-- | Logger to accumulate stats of fetched cron triggers, for generating
--   cron events, over a period of time and log once using <tt>'L.Logger
--   L.Hasura'. See </tt><tt>createStatsLogger</tt> for more details.
createFetchedCronTriggerStatsLogger :: MonadIO m => Logger Hasura -> m FetchedCronTriggerStatsLogger

-- | Close the fetched cron trigger stats logger.
closeFetchedCronTriggersStatsLogger :: MonadIO m => Logger Hasura -> FetchedCronTriggerStatsLogger -> m ()

-- | Logger to accumulate stats of fetched scheduled events over a period
--   of time and log once using <tt>'L.Logger L.Hasura'. See
--   </tt><tt>createStatsLogger</tt> for more details.
createFetchedScheduledEventsStatsLogger :: MonadIO m => Logger Hasura -> m FetchedScheduledEventsStatsLogger

-- | Close the fetched scheduled events stats logger.
closeFetchedScheduledEventsStatsLogger :: MonadIO m => Logger Hasura -> FetchedScheduledEventsStatsLogger -> m ()

-- | Get cron trigger stats for cron jobs with fewer than 100 future
--   reified events in the database
--   
--   The point here is to maintain a certain number of future events so the
--   user can kind of see what's coming up, and obviously to give
--   <a>processCronEvents</a> something to do.
getDeprivedCronTriggerStatsTx :: [TriggerName] -> TxE QErr [CronTriggerStats]
getScheduledEventsForDeliveryTx :: [TriggerName] -> TxE QErr ([CronEvent], [OneOffScheduledEvent])
insertInvocationTx :: Invocation 'ScheduledType -> ScheduledEventType -> TxE QErr ()
setScheduledEventOpTx :: ScheduledEventId -> ScheduledEventOp -> ScheduledEventType -> TxE QErr ()
unlockScheduledEventsTx :: ScheduledEventType -> [ScheduledEventId] -> TxE QErr Int
unlockAllLockedScheduledEventsTx :: TxE QErr ()
insertCronEventsTx :: [CronEventSeed] -> TxE QErr ()
insertOneOffScheduledEventTx :: OneOffEvent -> TxE QErr EventId
dropFutureCronEventsTx :: ClearCronEvents -> TxE QErr ()
getOneOffScheduledEventsTx :: ScheduledEventPagination -> [ScheduledEventStatus] -> RowsCountOption -> TxE QErr (WithOptionalTotalCount [OneOffScheduledEvent])
getCronEventsTx :: TriggerName -> ScheduledEventPagination -> [ScheduledEventStatus] -> RowsCountOption -> TxE QErr (WithOptionalTotalCount [CronEvent])
deleteScheduledEventTx :: ScheduledEventId -> ScheduledEventType -> TxE QErr ()
getScheduledEventInvocationsTx :: GetScheduledEventInvocations -> TxE QErr (WithOptionalTotalCount [ScheduledEventInvocation])
getScheduledEventsInvocationsQuery :: EventTables -> GetScheduledEventInvocations -> Select
getScheduledEventsInvocationsQueryNoPagination :: EventTables -> GetScheduledEventInvocationsBy -> Select
mkScheduledEventStatusFilter :: [ScheduledEventStatus] -> BoolExp
scheduledTimeOrderBy :: OrderByExp
executeWithOptionalTotalCount :: FromJSON a => Query -> RowsCountOption -> TxE QErr (WithOptionalTotalCount a)

-- | Build a select expression which outputs total count and list of json
--   rows with pagination limit and offset applied
mkPaginationSelectExp :: Select -> ScheduledEventPagination -> RowsCountOption -> Select
withCount :: (Int, ViaJSON a) -> WithOptionalTotalCount a
invocationFieldExtractors :: QualifiedTable -> [Extractor]
mkEventIdBoolExp :: QualifiedTable -> EventId -> BoolExp
data EventTables
EventTables :: QualifiedTable -> QualifiedTable -> QualifiedTable -> EventTables
[etOneOffInvocationsTable] :: EventTables -> QualifiedTable
[etCronInvocationsTable] :: EventTables -> QualifiedTable
[etCronEventsTable] :: EventTables -> QualifiedTable

module Hasura.RQL.DDL.ScheduledTrigger

-- | runCreateCronTrigger will update a existing cron trigger when the
--   <tt>replace</tt> value is set to <tt>true</tt> and when replace is
--   <tt>false</tt> a new cron trigger will be created
runCreateCronTrigger :: (MonadError QErr m, CacheRWM m, MonadIO m, MetadataM m, MonadMetadataStorage m) => CreateCronTrigger -> m EncJSON
runDeleteCronTrigger :: (MonadError QErr m, CacheRWM m, MetadataM m, MonadMetadataStorage m) => ScheduledTriggerName -> m EncJSON
dropCronTriggerInMetadata :: TriggerName -> MetadataModifier
resolveCronTrigger :: QErrM m => Environment -> CronTriggerMetadata -> m CronTriggerInfo
runCreateScheduledEvent :: (MonadError QErr m, MonadMetadataStorage m) => CreateScheduledEvent -> m EncJSON
runDeleteScheduledEvent :: (MonadMetadataStorage m, MonadError QErr m) => DeleteScheduledEvent -> m EncJSON
runGetScheduledEvents :: (MonadError QErr m, CacheRM m, MonadMetadataStorage m) => GetScheduledEvents -> m EncJSON
runGetScheduledEventInvocations :: (MonadError QErr m, CacheRM m, MonadMetadataStorage m) => GetScheduledEventInvocations -> m EncJSON
populateInitialCronTriggerEvents :: (MonadIO m, MonadError QErr m, MonadMetadataStorage m) => CronSchedule -> TriggerName -> m ()

-- | Metadata API handler to retrieve all the cron triggers from the
--   metadata
runGetCronTriggers :: MetadataM m => m EncJSON


-- | MSSQL Source
--   
--   Implements the Source related methods of the <a>BackendMetadata</a>
--   type class for the MSSQL backend, which provides an interface for
--   identifying the MSSQL database instance (source) and manipulate it.
--   
--   The actual instance is defined in
--   <a>Hasura.Backends.MSSQL.Instances.Metadata</a>.
module Hasura.Backends.MSSQL.DDL.Source
resolveSourceConfig :: (MonadIO m, MonadResolveSource m) => SourceName -> MSSQLConnConfiguration -> BackendSourceKind 'MSSQL -> BackendConfig 'MSSQL -> Environment -> manager -> m (Either QErr MSSQLSourceConfig)
resolveDatabaseMetadata :: (MonadIO m, MonadBaseControl IO m) => MSSQLSourceConfig -> m (Either QErr (DBObjectsIntrospection 'MSSQL))
postDropSourceHook :: (MonadIO m, MonadBaseControl IO m) => MSSQLSourceConfig -> TableEventTriggers 'MSSQL -> m ()

-- | Initialise catalog tables for a source, including those required by
--   the event delivery subsystem.
prepareCatalog :: forall (m :: Type -> Type). (MonadIO m, MonadBaseControl IO m) => MSSQLSourceConfig -> ExceptT QErr m (RecreateEventTriggers, SourceCatalogMigrationState)


-- | MSSQL DDL
--   
--   Implements the DDL related methods of the <a>BackendMetadata</a> type
--   class for the MSSQL backend, which provides an interface for fetching
--   information about the objects in the database, such as tables,
--   relationships, etc.
--   
--   The actual instance is defined in
--   <a>Hasura.Backends.MSSQL.Instances.Metadata</a>.
module Hasura.Backends.MSSQL.DDL
buildComputedFieldInfo :: MonadError QErr m => HashSet (TableName 'MSSQL) -> TableName 'MSSQL -> HashSet (Column 'MSSQL) -> ComputedFieldName -> ComputedFieldDefinition 'MSSQL -> RawFunctionInfo 'MSSQL -> Comment -> m (ComputedFieldInfo 'MSSQL)
fetchAndValidateEnumValues :: Monad m => SourceConfig 'MSSQL -> TableName 'MSSQL -> Maybe (PrimaryKey 'MSSQL (RawColumnInfo 'MSSQL)) -> [RawColumnInfo 'MSSQL] -> m (Either QErr EnumValues)
buildFunctionInfo :: MonadError QErr m => SourceName -> FunctionName 'MSSQL -> SystemDefined -> FunctionConfig 'MSSQL -> FunctionPermissionsMap -> RawFunctionInfo 'MSSQL -> Maybe Text -> NamingCase -> m (FunctionInfo 'MSSQL, SchemaDependency)
updateColumnInEventTrigger :: TableName 'MSSQL -> Column 'MSSQL -> Column 'MSSQL -> TableName 'MSSQL -> EventTriggerConf 'MSSQL -> EventTriggerConf 'MSSQL
parseCollectableType :: MonadError QErr m => CollectableType (ColumnType 'MSSQL) -> Value -> m (PartialSQLExp 'MSSQL)
getStoredProcedureGraphqlName :: MonadError QErr m => FunctionName -> StoredProcedureConfig -> m Name


-- | MSSQL Instances Metadata
--   
--   Defines a <a>BackendMetadata</a> type class instance for MSSQL.
module Hasura.Backends.MSSQL.Instances.Metadata
instance Hasura.RQL.Types.Metadata.Backend.BackendMetadata 'Hasura.RQL.Types.BackendType.MSSQL

module Hasura.Backends.DataConnector.Logging
logAgentRequest :: (MonadIO m, MonadTrace m) => Logger Hasura -> Request -> Either HttpException (Response ByteString) -> m ()
logClientError :: (MonadIO m, MonadTrace m) => Logger Hasura -> ClientError -> m ()
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Logging.AgentCommunicationLog
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Logging.RequestLogInfo
instance GHC.Internal.Show.Show Hasura.Backends.DataConnector.Logging.AgentCommunicationLog
instance GHC.Internal.Show.Show Hasura.Backends.DataConnector.Logging.RequestLogInfo
instance Hasura.Logging.ToEngineLog Hasura.Backends.DataConnector.Logging.AgentCommunicationLog Hasura.Logging.Hasura

module Hasura.Backends.DataConnector.Agent.Client

-- | Auth Key provided to the GDC Agent in <a>Request</a> headers.
newtype AgentLicenseKey
AgentLicenseKey :: ByteString -> AgentLicenseKey
[unAgentLicenseKey] :: AgentLicenseKey -> ByteString
data AgentClientContext
AgentClientContext :: Logger Hasura -> BaseUrl -> Manager -> Maybe Int -> Maybe AgentLicenseKey -> AgentClientContext
[_accLogger] :: AgentClientContext -> Logger Hasura
[_accBaseUrl] :: AgentClientContext -> BaseUrl
[_accHttpManager] :: AgentClientContext -> Manager
[_accResponseTimeout] :: AgentClientContext -> Maybe Int
[_accAgentLicenseKey] :: AgentClientContext -> Maybe AgentLicenseKey
data AgentClientT (m :: Type -> Type) a
runAgentClientT :: AgentClientT m a -> AgentClientContext -> m a
capabilities :: forall (m :: Type -> Type). (MonadIO m, MonadTrace m, MonadError QErr m) => AgentClientT m CapabilitiesResponse
schemaGet :: forall (m :: Type -> Type). (MonadIO m, MonadTrace m, MonadError QErr m) => SourceName -> Config -> AgentClientT m SchemaResponse
schemaPost :: forall (m :: Type -> Type). (MonadIO m, MonadTrace m, MonadError QErr m) => SourceName -> Config -> SchemaRequest -> AgentClientT m SchemaResponse
query :: forall (m :: Type -> Type). (MonadIO m, MonadTrace m, MonadError QErr m) => SourceName -> Config -> QueryRequest -> AgentClientT m QueryResponse
explain :: forall (m :: Type -> Type). (MonadIO m, MonadTrace m, MonadError QErr m) => SourceName -> Config -> QueryRequest -> AgentClientT m ExplainResponse
mutation :: forall (m :: Type -> Type). (MonadIO m, MonadTrace m, MonadError QErr m) => SourceName -> Config -> MutationRequest -> AgentClientT m MutationResponse
instance GHC.Internal.Base.Applicative m => GHC.Internal.Base.Applicative (Hasura.Backends.DataConnector.Agent.Client.AgentClientT m)
instance GHC.Internal.Base.Functor m => GHC.Internal.Base.Functor (Hasura.Backends.DataConnector.Agent.Client.AgentClientT m)
instance GHC.Internal.Base.Monad m => GHC.Internal.Base.Monad (Hasura.Backends.DataConnector.Agent.Client.AgentClientT m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Hasura.Backends.DataConnector.Agent.Client.AgentClientT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Hasura.Backends.DataConnector.Agent.Client.AgentClientT m)
instance Hasura.Tracing.Class.MonadTrace m => Hasura.Tracing.Class.MonadTrace (Hasura.Backends.DataConnector.Agent.Client.AgentClientT m)
instance Hasura.Tracing.Class.MonadTraceContext m => Hasura.Tracing.Class.MonadTraceContext (Hasura.Backends.DataConnector.Agent.Client.AgentClientT m)
instance (Control.Monad.IO.Class.MonadIO m, Hasura.Tracing.Class.MonadTrace m, Control.Monad.Error.Class.MonadError Hasura.Base.Error.QErr m) => Servant.Client.Core.RunClient.RunClient (Hasura.Backends.DataConnector.Agent.Client.AgentClientT m)


-- | This module provides operations to load and modify metadata relating
--   to GraphQL Data Connectors.
module Hasura.RQL.DDL.DataConnector
data DCAddAgent
DCAddAgent :: DataConnectorName -> BaseUrl -> Maybe Text -> SkipCheck -> DCAddAgent

-- | Source kind, ie., the backend type.
[_gdcaName] :: DCAddAgent -> DataConnectorName

-- | The Agent URL.
[_gdcaUrl] :: DCAddAgent -> BaseUrl

-- | Override the display name provided by the Agent.
[_gdcaDisplayName] :: DCAddAgent -> Maybe Text

-- | Optionally skip the Agent Validation step.
[_gdcaSkipCheck] :: DCAddAgent -> SkipCheck

-- | Insert a new Data Connector Agent into Metadata.
runAddDataConnectorAgent :: (MetadataM m, ProvidesNetwork m, CacheRWM m, Has (Logger Hasura) r, MonadReader r m, MonadError QErr m, MonadIO m, MonadBaseControl IO m) => DCAddAgent -> m EncJSON
newtype DCDeleteAgent
DCDeleteAgent :: DataConnectorName -> DCDeleteAgent
[_dcdaName] :: DCDeleteAgent -> DataConnectorName

-- | Delete a Data Connector Agent from the Metadata.
runDeleteDataConnectorAgent :: (CacheRWM m, MetadataM m, MonadError QErr m) => DCDeleteAgent -> m EncJSON
instance GHC.Classes.Eq Hasura.RQL.DDL.DataConnector.SkipCheck
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.DataConnector.DCAddAgent
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.DataConnector.DCDeleteAgent
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.DataConnector.SkipCheck
instance GHC.Internal.Base.Monoid Hasura.RQL.DDL.DataConnector.SkipCheck
instance GHC.Internal.Base.Semigroup Hasura.RQL.DDL.DataConnector.SkipCheck
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.DataConnector.DCAddAgent
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.DataConnector.DCDeleteAgent
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.DataConnector.SkipCheck

module Hasura.Backends.DataConnector.Adapter.Metadata
instance Hasura.RQL.Types.Metadata.Backend.BackendMetadata 'Hasura.RQL.Types.BackendType.DataConnector

module Hasura.RQL.Types.Metadata.Instances


-- | Telemetry types
--   
--   Define anonymized metrics regarding usage of various features of
--   Hasura.
module Hasura.Server.Telemetry.Types
data RelationshipMetric
RelationshipMetric :: Int -> Int -> RelationshipMetric
[_rmManual] :: RelationshipMetric -> Int
[_rmAuto] :: RelationshipMetric -> Int
data PermissionMetric
PermissionMetric :: Int -> Int -> Int -> Int -> Int -> PermissionMetric
[_pmSelect] :: PermissionMetric -> Int
[_pmInsert] :: PermissionMetric -> Int
[_pmUpdate] :: PermissionMetric -> Int
[_pmDelete] :: PermissionMetric -> Int
[_pmRoles] :: PermissionMetric -> Int
data ActionMetric
ActionMetric :: Int -> Int -> Int -> Int -> Int -> ActionMetric
[_amSynchronous] :: ActionMetric -> Int
[_amAsynchronous] :: ActionMetric -> Int
[_amQueryActions] :: ActionMetric -> Int
[_amTypeRelationships] :: ActionMetric -> Int
[_amCustomTypes] :: ActionMetric -> Int
data NativeQueriesMetrics
NativeQueriesMetrics :: Int -> Int -> NativeQueriesMetrics
[_nqmWithParameters] :: NativeQueriesMetrics -> Int
[_nqmWithoutParameters] :: NativeQueriesMetrics -> Int
data StoredProceduresMetrics
StoredProceduresMetrics :: Int -> Int -> StoredProceduresMetrics
[_spmWithParameters] :: StoredProceduresMetrics -> Int
[_spmWithoutParameters] :: StoredProceduresMetrics -> Int
newtype LogicalModelsMetrics
LogicalModelsMetrics :: Int -> LogicalModelsMetrics
[_lmmCount] :: LogicalModelsMetrics -> Int
data Metrics
Metrics :: Int -> Int -> Int -> RelationshipMetric -> PermissionMetric -> Int -> Int -> Maybe Int -> Maybe ServiceTimingMetrics -> Maybe ActionMetric -> NativeQueriesMetrics -> StoredProceduresMetrics -> LogicalModelsMetrics -> Metrics
[_mtTables] :: Metrics -> Int
[_mtViews] :: Metrics -> Int
[_mtEnumTables] :: Metrics -> Int
[_mtRelationships] :: Metrics -> RelationshipMetric
[_mtPermissions] :: Metrics -> PermissionMetric
[_mtEventTriggers] :: Metrics -> Int
[_mtFunctions] :: Metrics -> Int
[_mtRemoteSchemas] :: Metrics -> Maybe Int
[_mtServiceTimings] :: Metrics -> Maybe ServiceTimingMetrics
[_mtActions] :: Metrics -> Maybe ActionMetric
[_mtNativeQueries] :: Metrics -> NativeQueriesMetrics
[_mtStoredProcedures] :: Metrics -> StoredProceduresMetrics
[_mtLogicalModels] :: Metrics -> LogicalModelsMetrics
data SourceMetadata
SourceMetadata :: Maybe DbUid -> BackendType -> Text -> Maybe DbVersion -> SourceMetadata
[_smDbUid] :: SourceMetadata -> Maybe DbUid
[_smBackendType] :: SourceMetadata -> BackendType
[_smDbKind] :: SourceMetadata -> Text
[_smDbVersion] :: SourceMetadata -> Maybe DbVersion
data HasuraTelemetry
HasuraTelemetry :: MetadataDbId -> InstanceId -> Version -> Maybe CI -> SourceMetadata -> Metrics -> HashSet ExperimentalFeature -> HasuraTelemetry
[_htMetadataDbUid] :: HasuraTelemetry -> MetadataDbId
[_htInstanceUid] :: HasuraTelemetry -> InstanceId
[_htHasuraVersion] :: HasuraTelemetry -> Version
[_htCi] :: HasuraTelemetry -> Maybe CI
[_htSourceMetadata] :: HasuraTelemetry -> SourceMetadata
[_htMetrics] :: HasuraTelemetry -> Metrics
[_htExperimentalFeatures] :: HasuraTelemetry -> HashSet ExperimentalFeature
data TelemetryPayload
TelemetryPayload :: Topic -> HasuraTelemetry -> TelemetryPayload
[_tpTopic] :: TelemetryPayload -> Topic
[_tpData] :: TelemetryPayload -> HasuraTelemetry

-- | The telemetry table to which we'll add telemetry.
newtype Topic
Topic :: Text -> Topic
[getTopic] :: Topic -> Text

-- | The properties that characterize this request. The dimensions over
--   which we collect metrics for each serviced request.
data RequestDimensions
RequestDimensions :: !QueryType -> !Locality -> !Transport -> RequestDimensions
[telemQueryType] :: RequestDimensions -> !QueryType
[telemLocality] :: RequestDimensions -> !Locality
[telemTransport] :: RequestDimensions -> !Transport

-- | Accumulated time metrics.
data RequestTimings
RequestTimings :: !Seconds -> !Seconds -> RequestTimings

-- | Time spent waiting on PG/remote http calls
[telemTimeIO] :: RequestTimings -> !Seconds

-- | Total service time for request (including <a>telemTimeIO</a>)
[telemTimeTot] :: RequestTimings -> !Seconds

-- | Was this request a mutation (involved DB writes)?
data QueryType
Mutation :: QueryType
Query :: QueryType

-- | Was this a PG local query, or did it involve remote execution?
data Locality

-- | No data was fetched
Empty :: Locality

-- | local DB data
Local :: Locality

-- | remote schema
Remote :: Locality

-- | mixed
Heterogeneous :: Locality

-- | Was this a query over http or websockets?
data Transport
HTTP :: Transport
WebSocket :: Transport

-- | The final shape of this part of our metrics data JSON. This should
--   allow reasonably efficient querying using GIN indexes and JSONB
--   containment operations (which treat arrays as sets).
data ServiceTimingMetrics
ServiceTimingMetrics :: Int -> [ServiceTimingMetric] -> ServiceTimingMetrics

-- | This is set to a new unique value when the counters reset (e.g.
--   because of a restart)
[collectionTag] :: ServiceTimingMetrics -> Int
[serviceTimingMetrics] :: ServiceTimingMetrics -> [ServiceTimingMetric]
data ServiceTimingMetric
ServiceTimingMetric :: RequestDimensions -> RunningTimeBucket -> RequestTimingsCount -> ServiceTimingMetric
[dimensions] :: ServiceTimingMetric -> RequestDimensions
[bucket] :: ServiceTimingMetric -> RunningTimeBucket
[metrics] :: ServiceTimingMetric -> RequestTimingsCount

-- | The timings and counts here were from requests with total time longer
--   than <a>bucketGreaterThan</a> (but less than any larger bucket cutoff
--   times).
newtype RunningTimeBucket
RunningTimeBucket :: Seconds -> RunningTimeBucket
[bucketGreaterThan] :: RunningTimeBucket -> Seconds

-- | <a>RequestTimings</a> along with the count
data RequestTimingsCount
RequestTimingsCount :: !Seconds -> !Seconds -> !Word -> RequestTimingsCount
[telemTimeIO] :: RequestTimingsCount -> !Seconds
[telemTimeTot] :: RequestTimingsCount -> !Seconds

-- | The number of requests that have contributed to the accumulated
--   timings above. So e.g. <tt>telemTimeTot / count</tt> would give the
--   mean service time.
[telemCount] :: RequestTimingsCount -> !Word
instance GHC.Classes.Eq Hasura.Server.Telemetry.Types.ActionMetric
instance GHC.Classes.Eq Hasura.Server.Telemetry.Types.LogicalModelsMetrics
instance GHC.Classes.Eq Hasura.Server.Telemetry.Types.Metrics
instance GHC.Classes.Eq Hasura.Server.Telemetry.Types.NativeQueriesMetrics
instance GHC.Classes.Eq Hasura.Server.Telemetry.Types.PermissionMetric
instance GHC.Classes.Eq Hasura.Server.Telemetry.Types.RelationshipMetric
instance GHC.Classes.Eq Hasura.Server.Telemetry.Types.SourceMetadata
instance GHC.Classes.Eq Hasura.Server.Telemetry.Types.StoredProceduresMetrics
instance GHC.Classes.Eq Hasura.Server.Telemetry.Types.Topic
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Telemetry.Types.Topic
instance GHC.Internal.Generics.Generic Hasura.Server.Telemetry.Types.ActionMetric
instance GHC.Internal.Generics.Generic Hasura.Server.Telemetry.Types.HasuraTelemetry
instance GHC.Internal.Generics.Generic Hasura.Server.Telemetry.Types.LogicalModelsMetrics
instance GHC.Internal.Generics.Generic Hasura.Server.Telemetry.Types.Metrics
instance GHC.Internal.Generics.Generic Hasura.Server.Telemetry.Types.NativeQueriesMetrics
instance GHC.Internal.Generics.Generic Hasura.Server.Telemetry.Types.PermissionMetric
instance GHC.Internal.Generics.Generic Hasura.Server.Telemetry.Types.RelationshipMetric
instance GHC.Internal.Generics.Generic Hasura.Server.Telemetry.Types.SourceMetadata
instance GHC.Internal.Generics.Generic Hasura.Server.Telemetry.Types.StoredProceduresMetrics
instance GHC.Internal.Generics.Generic Hasura.Server.Telemetry.Types.TelemetryPayload
instance GHC.Internal.Base.Monoid Hasura.Server.Telemetry.Types.LogicalModelsMetrics
instance GHC.Internal.Base.Monoid Hasura.Server.Telemetry.Types.NativeQueriesMetrics
instance GHC.Internal.Base.Monoid Hasura.Server.Telemetry.Types.StoredProceduresMetrics
instance GHC.Internal.Base.Semigroup Hasura.Server.Telemetry.Types.LogicalModelsMetrics
instance GHC.Internal.Base.Semigroup Hasura.Server.Telemetry.Types.NativeQueriesMetrics
instance GHC.Internal.Base.Semigroup Hasura.Server.Telemetry.Types.StoredProceduresMetrics
instance GHC.Internal.Show.Show Hasura.Server.Telemetry.Types.ActionMetric
instance GHC.Internal.Show.Show Hasura.Server.Telemetry.Types.HasuraTelemetry
instance GHC.Internal.Show.Show Hasura.Server.Telemetry.Types.LogicalModelsMetrics
instance GHC.Internal.Show.Show Hasura.Server.Telemetry.Types.Metrics
instance GHC.Internal.Show.Show Hasura.Server.Telemetry.Types.NativeQueriesMetrics
instance GHC.Internal.Show.Show Hasura.Server.Telemetry.Types.PermissionMetric
instance GHC.Internal.Show.Show Hasura.Server.Telemetry.Types.RelationshipMetric
instance GHC.Internal.Show.Show Hasura.Server.Telemetry.Types.SourceMetadata
instance GHC.Internal.Show.Show Hasura.Server.Telemetry.Types.StoredProceduresMetrics
instance GHC.Internal.Show.Show Hasura.Server.Telemetry.Types.TelemetryPayload
instance GHC.Internal.Show.Show Hasura.Server.Telemetry.Types.Topic
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Types.ActionMetric
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Types.HasuraTelemetry
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Types.LogicalModelsMetrics
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Types.Metrics
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Types.NativeQueriesMetrics
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Types.PermissionMetric
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Types.RelationshipMetric
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Types.SourceMetadata
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Types.StoredProceduresMetrics
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Types.TelemetryPayload
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Types.Topic


-- | <h1>Remote Schema Permissions Validation</h1>
--   
--   This module parses the GraphQL IDL (Schema Document) that's provided
--   by the user for configuring permissions for remote schemas to a schema
--   introspection object, which is then used to construct the remote
--   schema for the particular role.
--   
--   This module does two things essentially:
--   
--   <ol>
--   <li>Checks if the given schema document is a subset of the upstream
--   remote schema document. This is done by checking if all the objects,
--   interfaces, unions, enums, scalars and input objects provided in the
--   schema document exist in the upstream remote schema too. We validate
--   the fields, directives and arguments too, wherever applicable.</li>
--   <li>Parse the <tt>preset</tt> directives (if any) on input object
--   fields or argument fields. A <tt>preset</tt> directive is used to
--   specify any preset argument on a field, it can be either a static
--   value or session variable value. There is some validation done on
--   preset directives. For example: - Preset directives can only be
--   specified at <tt>ARGUMENT_DEFINITION</tt> or
--   <tt>INPUT_FIELD_DEFINITION</tt> - A field expecting object cannot have
--   a scalar/enum preset directive and vice versa.</li>
--   </ol>
--   
--   If a preset directive value is a session variable (like `x-hasura-*`),
--   then it's considered to be a session variable value. In the case, the
--   user wants to treat the session variable value literally, they can add
--   the <tt>static</tt> key to the preset directive to indicate that the
--   value provided should be considered literally. For example:
--   
--   `user(id: Int @preset(value: "x-hasura-user-id", static: true))
--   
--   In this case `x-hasura-user-id` will be considered literally.
--   
--   For validation, we use the <a>MonadValidate</a> monad transformer to
--   collect as many errors as possible and then report all those errors at
--   one go to the user.
module Hasura.RemoteSchema.SchemaCache.Permission
resolveRoleBasedRemoteSchema :: MonadError QErr m => RoleName -> RemoteSchemaName -> IntrospectionResult -> SchemaDocument -> m (IntrospectionResult, SchemaDependency)
instance GHC.Classes.Eq Hasura.RemoteSchema.SchemaCache.Permission.ArgumentDefinitionType
instance GHC.Classes.Eq Hasura.RemoteSchema.SchemaCache.Permission.FieldDefinitionType
instance GHC.Classes.Eq Hasura.RemoteSchema.SchemaCache.Permission.GraphQLType
instance GHC.Classes.Eq Hasura.RemoteSchema.SchemaCache.Permission.PresetInputTypeInfo
instance GHC.Classes.Eq Hasura.RemoteSchema.SchemaCache.Permission.RoleBasedSchemaValidationError
instance GHC.Internal.Generics.Generic Hasura.RemoteSchema.SchemaCache.Permission.PresetInputTypeInfo
instance GHC.Classes.Ord Hasura.RemoteSchema.SchemaCache.Permission.PresetInputTypeInfo
instance GHC.Internal.Show.Show Hasura.RemoteSchema.SchemaCache.Permission.ArgumentDefinitionType
instance GHC.Internal.Show.Show Hasura.RemoteSchema.SchemaCache.Permission.FieldDefinitionType
instance GHC.Internal.Show.Show Hasura.RemoteSchema.SchemaCache.Permission.GraphQLType
instance GHC.Internal.Show.Show Hasura.RemoteSchema.SchemaCache.Permission.PresetInputTypeInfo
instance GHC.Internal.Show.Show Hasura.RemoteSchema.SchemaCache.Permission.RoleBasedSchemaValidationError
instance Data.Text.Extended.ToTxt Hasura.RemoteSchema.SchemaCache.Permission.ArgumentDefinitionType
instance Data.Text.Extended.ToTxt Hasura.RemoteSchema.SchemaCache.Permission.FieldDefinitionType
instance Data.Text.Extended.ToTxt Hasura.RemoteSchema.SchemaCache.Permission.GraphQLType

module Hasura.RemoteSchema.MetadataAPI.Permission
data AddRemoteSchemaPermission
AddRemoteSchemaPermission :: RemoteSchemaName -> RoleName -> RemoteSchemaPermissionDefinition -> Maybe Text -> AddRemoteSchemaPermission
[_arspRemoteSchema] :: AddRemoteSchemaPermission -> RemoteSchemaName
[_arspRole] :: AddRemoteSchemaPermission -> RoleName
[_arspDefinition] :: AddRemoteSchemaPermission -> RemoteSchemaPermissionDefinition
[_arspComment] :: AddRemoteSchemaPermission -> Maybe Text
data DropRemoteSchemaPermissions
DropRemoteSchemaPermissions :: RemoteSchemaName -> RoleName -> DropRemoteSchemaPermissions
[_drspRemoteSchema] :: DropRemoteSchemaPermissions -> RemoteSchemaName
[_drspRole] :: DropRemoteSchemaPermissions -> RoleName
runDropRemoteSchemaPermissions :: (QErrM m, CacheRWM m, MetadataM m) => DropRemoteSchemaPermissions -> m EncJSON
runAddRemoteSchemaPermissions :: (QErrM m, CacheRWM m, MetadataM m) => RemoteSchemaPermissions -> AddRemoteSchemaPermission -> m EncJSON
instance GHC.Classes.Eq Hasura.RemoteSchema.MetadataAPI.Permission.AddRemoteSchemaPermission
instance GHC.Classes.Eq Hasura.RemoteSchema.MetadataAPI.Permission.DropRemoteSchemaPermissions
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RemoteSchema.MetadataAPI.Permission.AddRemoteSchemaPermission
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RemoteSchema.MetadataAPI.Permission.DropRemoteSchemaPermissions
instance GHC.Internal.Generics.Generic Hasura.RemoteSchema.MetadataAPI.Permission.AddRemoteSchemaPermission
instance GHC.Internal.Generics.Generic Hasura.RemoteSchema.MetadataAPI.Permission.DropRemoteSchemaPermissions
instance Control.DeepSeq.NFData Hasura.RemoteSchema.MetadataAPI.Permission.AddRemoteSchemaPermission
instance Control.DeepSeq.NFData Hasura.RemoteSchema.MetadataAPI.Permission.DropRemoteSchemaPermissions
instance GHC.Internal.Show.Show Hasura.RemoteSchema.MetadataAPI.Permission.AddRemoteSchemaPermission
instance GHC.Internal.Show.Show Hasura.RemoteSchema.MetadataAPI.Permission.DropRemoteSchemaPermissions
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RemoteSchema.MetadataAPI.Permission.AddRemoteSchemaPermission
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RemoteSchema.MetadataAPI.Permission.DropRemoteSchemaPermissions

module Hasura.RQL.DDL.Schema.Source
data AddSource (b :: BackendType)
runAddSource :: forall m (b :: BackendType). (MonadIO m, MonadError QErr m, CacheRWM m, MetadataM m, BackendMetadata b) => Environment -> AddSource b -> m EncJSON
data DropSource
DropSource :: SourceName -> Bool -> DropSource
[_dsName] :: DropSource -> SourceName
[_dsCascade] :: DropSource -> Bool
runDropSource :: (MonadError QErr m, CacheRWM m, MonadIO m, MonadBaseControl IO m, MetadataM m, MonadReader r m, Has (Logger Hasura) r) => DropSource -> m EncJSON
runPostDropSourceHook :: forall m r (b :: BackendType). (MonadError QErr m, MonadIO m, MonadBaseControl IO m, MonadReader r m, Has (Logger Hasura) r, BackendMetadata b) => SourceName -> SourceInfo b -> m ()
data RenameSource
runRenameSource :: (MonadError QErr m, CacheRWM m, MetadataM m) => RenameSource -> m EncJSON
data UpdateSource (b :: BackendType)
runUpdateSource :: forall m (b :: BackendType). (MonadError QErr m, CacheRWM m, MetadataM m, BackendMetadata b) => UpdateSource b -> m EncJSON
newtype GetSourceTables (b :: BackendType)
GetSourceTables :: SourceName -> GetSourceTables (b :: BackendType)
[_gstSourceName] :: GetSourceTables (b :: BackendType) -> SourceName

-- | Fetch a list of tables for the request data source.
runGetSourceTables :: forall (b :: BackendType) m r. (BackendMetadata b, CacheRM m, MonadError QErr m, MetadataM m, MonadIO m, MonadBaseControl IO m, MonadReader r m, Has (Logger Hasura) r, ProvidesNetwork m) => GetSourceTables b -> m EncJSON
newtype GetSourceTrackables (b :: BackendType)
GetSourceTrackables :: SourceName -> GetSourceTrackables (b :: BackendType)
[_gstrSourceName] :: GetSourceTrackables (b :: BackendType) -> SourceName

-- | Fetch a list of tables for the request data source.
runGetSourceTrackables :: forall (b :: BackendType) m r. (BackendMetadata b, CacheRM m, MonadError QErr m, MetadataM m, MonadIO m, MonadBaseControl IO m, MonadReader r m, Has (Logger Hasura) r, ProvidesNetwork m) => GetSourceTrackables b -> m EncJSON
data GetTableInfo (b :: BackendType)
GetTableInfo :: SourceName -> TableName b -> GetTableInfo (b :: BackendType)
[_gtiSourceName] :: GetTableInfo (b :: BackendType) -> SourceName
[_gtiTableName] :: GetTableInfo (b :: BackendType) -> TableName b

-- | Get information about the given table.
runGetTableInfo :: forall (b :: BackendType) m. (BackendMetadata b, CacheRM m, MonadError QErr m, MetadataM m, MonadBaseControl IO m, MonadIO m) => GetTableInfo b -> m EncJSON
data GetTableInfo_
GetTableInfo_ :: SourceName -> TableName 'DataConnector -> GetTableInfo_
[_gtiSourceName_] :: GetTableInfo_ -> SourceName
[_gtiTableName_] :: GetTableInfo_ -> TableName 'DataConnector

-- | Legacy data connector command. This doesn't use the DataConnector
--   <a>ScalarType</a> to represent types.
runGetTableInfo_ :: (CacheRM m, MonadError QErr m, MetadataM m, MonadBaseControl IO m, MonadIO m) => GetTableInfo_ -> m EncJSON
instance GHC.Classes.Eq Hasura.RQL.DDL.Schema.Source.DropSource
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Schema.Source.DropSource
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Schema.Source.GetSourceTables b)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Schema.Source.GetSourceTrackables b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Schema.Source.GetTableInfo b)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Schema.Source.GetTableInfo_
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Schema.Source.RenameSource
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Extended.FromJSONWithContext (Hasura.RQL.Types.BackendType.BackendSourceKind b) (Hasura.RQL.DDL.Schema.Source.AddSource b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Extended.FromJSONWithContext (Hasura.RQL.Types.BackendType.BackendSourceKind b) (Hasura.RQL.DDL.Schema.Source.UpdateSource b)
instance GHC.Internal.Generics.Generic Hasura.RQL.DDL.Schema.Source.RenameSource
instance GHC.Internal.Show.Show Hasura.RQL.DDL.Schema.Source.DropSource


-- | Types/functions shared between modules that implement
--   <a>Hasura.RQL.DDL.Schema.Cache</a>. Other modules should not import
--   this module directly.
module Hasura.RQL.DDL.Schema.Cache.Common
data ApolloFederationConfig
ApolloFederationConfig :: ApolloFederationVersion -> ApolloFederationConfig
[enable] :: ApolloFederationConfig -> ApolloFederationVersion
data ApolloFederationVersion
V1 :: ApolloFederationVersion
newtype BackendInvalidationKeysWrapper (b :: BackendType)
BackendInvalidationKeysWrapper :: BackendInvalidationKeys b -> BackendInvalidationKeysWrapper (b :: BackendType)
[unBackendInvalidationKeysWrapper] :: BackendInvalidationKeysWrapper (b :: BackendType) -> BackendInvalidationKeys b

-- | The direct output of <tt>buildSchemaCacheRule</tt>. Contains most of
--   the things necessary to build a schema cache, but dependencies and
--   inconsistent metadata objects are collected via a separate
--   <a>MonadWriter</a> side channel.
--   
--   See also Note [Avoiding GraphQL schema rebuilds when changing
--   irrelevant Metadata]
data BuildOutputs
BuildOutputs :: SourceCache -> ActionCache -> HashMap RemoteSchemaName (RemoteSchemaCtx, MetadataObject) -> AnnotatedCustomTypes -> HashMap RoleName Role -> BackendCache -> BuildOutputs
[_boSources] :: BuildOutputs -> SourceCache
[_boActions] :: BuildOutputs -> ActionCache

-- | We preserve the <a>MetadataObject</a> from the original catalog
--   metadata in the output so we can reuse it later if we need to mark the
--   remote schema inconsistent during GraphQL schema generation (because
--   of field conflicts).
[_boRemoteSchemas] :: BuildOutputs -> HashMap RemoteSchemaName (RemoteSchemaCtx, MetadataObject)
[_boCustomTypes] :: BuildOutputs -> AnnotatedCustomTypes
[_boRoles] :: BuildOutputs -> HashMap RoleName Role
[_boBackendCache] :: BuildOutputs -> BackendCache

-- | The monad in which @<a>RebuildableSchemaCache</a> is being run
data CacheBuild a

-- | Parameters required for schema cache build
data CacheBuildParams
CacheBuildParams :: Manager -> SourceResolver ('Postgres 'Vanilla) -> SourceResolver 'MSSQL -> CacheStaticConfig -> CacheBuildParams

-- | <a>InvalidationKeys</a> used to apply requested
--   <a>CacheInvalidations</a>.
data InvalidationKeys
InvalidationKeys :: InvalidationKey -> HashMap RemoteSchemaName InvalidationKey -> HashMap SourceName InvalidationKey -> BackendMap BackendInvalidationKeysWrapper -> InvalidationKeys
[_ikMetadata] :: InvalidationKeys -> InvalidationKey
[_ikRemoteSchemas] :: InvalidationKeys -> HashMap RemoteSchemaName InvalidationKey
[_ikSources] :: InvalidationKeys -> HashMap SourceName InvalidationKey
[_ikBackends] :: InvalidationKeys -> BackendMap BackendInvalidationKeysWrapper
ikMetadata :: Lens' InvalidationKeys InvalidationKey
ikRemoteSchemas :: Lens' InvalidationKeys (HashMap RemoteSchemaName InvalidationKey)
ikSources :: Lens' InvalidationKeys (HashMap SourceName InvalidationKey)
ikBackends :: Lens' InvalidationKeys (BackendMap BackendInvalidationKeysWrapper)
data NonColumnTableInputs (b :: BackendType)
NonColumnTableInputs :: TableName b -> [ObjRelDef b] -> [ArrRelDef b] -> [ComputedFieldMetadata b] -> [RemoteRelationship] -> NonColumnTableInputs (b :: BackendType)
[_nctiTable] :: NonColumnTableInputs (b :: BackendType) -> TableName b
[_nctiObjectRelationships] :: NonColumnTableInputs (b :: BackendType) -> [ObjRelDef b]
[_nctiArrayRelationships] :: NonColumnTableInputs (b :: BackendType) -> [ArrRelDef b]
[_nctiComputedFields] :: NonColumnTableInputs (b :: BackendType) -> [ComputedFieldMetadata b]
[_nctiRemoteRelationships] :: NonColumnTableInputs (b :: BackendType) -> [RemoteRelationship]
data RebuildableSchemaCache
RebuildableSchemaCache :: SchemaCache -> InvalidationKeys -> Rule (ReaderT BuildReason CacheBuild) (MetadataWithResourceVersion, CacheDynamicConfig, InvalidationKeys, Maybe StoredIntrospection) (SchemaCache, (SourcesIntrospectionStatus, SchemaRegistryAction)) -> RebuildableSchemaCache
data TableBuildInput (b :: BackendType)
TableBuildInput :: TableName b -> Bool -> TableConfig b -> Maybe ApolloFederationConfig -> Maybe LogicalModelName -> TableBuildInput (b :: BackendType)
data TablePermissionInputs (b :: BackendType)
TablePermissionInputs :: TableName b -> [InsPermDef b] -> [SelPermDef b] -> [UpdPermDef b] -> [DelPermDef b] -> TablePermissionInputs (b :: BackendType)
[_tpiTable] :: TablePermissionInputs (b :: BackendType) -> TableName b
[_tpiInsert] :: TablePermissionInputs (b :: BackendType) -> [InsPermDef b]
[_tpiSelect] :: TablePermissionInputs (b :: BackendType) -> [SelPermDef b]
[_tpiUpdate] :: TablePermissionInputs (b :: BackendType) -> [UpdPermDef b]
[_tpiDelete] :: TablePermissionInputs (b :: BackendType) -> [DelPermDef b]
addTableContext :: forall (b :: BackendType). Backend b => TableName b -> Text -> Text
addLogicalModelContext :: LogicalModelLocation -> Text -> Text
boActions :: Lens' BuildOutputs ActionCache
boCustomTypes :: Lens' BuildOutputs AnnotatedCustomTypes
boBackendCache :: Lens' BuildOutputs BackendCache
boRemoteSchemas :: Lens' BuildOutputs (HashMap RemoteSchemaName (RemoteSchemaCtx, MetadataObject))
boRoles :: Lens' BuildOutputs (HashMap RoleName Role)
boSources :: Lens' BuildOutputs SourceCache

-- | Processes a list of catalog metadata into a map of processed
--   information, marking any duplicate entries inconsistent.
buildInfoMap :: (ArrowChoice arr, ArrowDistribute arr, ArrowWriter (Seq CollectItem) arr, Hashable k) => (a -> k) -> (a -> MetadataObject) -> arr (e, a) (Maybe b) -> arr (e, [a]) (HashMap k b)
buildInfoMapM :: (MonadWriter (Seq CollectItem) m, Hashable k) => (a -> k) -> (a -> MetadataObject) -> (a -> m (Maybe b)) -> [a] -> m (HashMap k b)

-- | Like <a>buildInfoMap</a>, but includes each processed info’s
--   associated <a>MetadataObject</a> in the result. This is useful if the
--   results will be further processed, and the <a>MetadataObject</a> is
--   still needed to mark the object inconsistent.
buildInfoMapPreservingMetadata :: (ArrowChoice arr, ArrowDistribute arr, ArrowWriter (Seq CollectItem) arr, Hashable k) => (a -> k) -> (a -> MetadataObject) -> arr (e, a) (Maybe b) -> arr (e, [a]) (HashMap k (b, MetadataObject))
buildInfoMapPreservingMetadataM :: (MonadWriter (Seq CollectItem) m, Hashable k) => (a -> k) -> (a -> MetadataObject) -> (a -> m (Maybe b)) -> [a] -> m (HashMap k (b, MetadataObject))
initialInvalidationKeys :: InvalidationKeys
invalidateKeys :: CacheInvalidations -> InvalidationKeys -> InvalidationKeys
mkTableInputs :: forall (b :: BackendType). TableMetadata b -> (TableBuildInput b, NonColumnTableInputs b, TablePermissionInputs b)
runCacheBuild :: (MonadIO m, MonadError QErr m) => CacheBuildParams -> CacheBuild a -> m a
runCacheBuildM :: (MonadIO m, MonadError QErr m, MonadResolveSource m, ProvidesNetwork m, HasCacheStaticConfig m) => CacheBuild a -> m a
withRecordDependencies :: ArrowWriter (Seq CollectItem) arr => WriterA (Seq SchemaDependency) arr (e, s) a -> arr (e, (MetadataObject, (SchemaObjId, s))) a

-- | The status of collection of stored introspections of remote schemas
--   and data sources.
data SourcesIntrospectionStatus

-- | A full introspection collection of all available remote schemas and
--   data sources.
SourcesIntrospectionChangedFull :: StoredIntrospection -> SourcesIntrospectionStatus

-- | A partial introspection collection. Does not include all configured
--   remote schemas and data sources, because they were not available.
SourcesIntrospectionChangedPartial :: StoredIntrospection -> SourcesIntrospectionStatus

-- | None of remote schemas or data sources introspection is refetched.
SourcesIntrospectionUnchanged :: SourcesIntrospectionStatus
instance GHC.Internal.Base.Applicative Hasura.RQL.DDL.Schema.Cache.Common.CacheBuild
instance GHC.Classes.Eq (Hasura.RQL.Types.Metadata.Backend.BackendInvalidationKeys b) => GHC.Classes.Eq (Hasura.RQL.DDL.Schema.Cache.Common.BackendInvalidationKeysWrapper b)
instance GHC.Classes.Eq Hasura.RQL.DDL.Schema.Cache.Common.InvalidationKeys
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.DDL.Schema.Cache.Common.NonColumnTableInputs b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.DDL.Schema.Cache.Common.TableBuildInput b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.DDL.Schema.Cache.Common.TablePermissionInputs b)
instance GHC.Internal.Base.Functor Hasura.RQL.DDL.Schema.Cache.Common.CacheBuild
instance GHC.Internal.Generics.Generic Hasura.RQL.DDL.Schema.Cache.Common.InvalidationKeys
instance GHC.Internal.Generics.Generic (Hasura.RQL.DDL.Schema.Cache.Common.NonColumnTableInputs b)
instance GHC.Internal.Generics.Generic (Hasura.RQL.DDL.Schema.Cache.Common.TableBuildInput b)
instance GHC.Internal.Generics.Generic (Hasura.RQL.DDL.Schema.Cache.Common.TablePermissionInputs b)
instance Hasura.RQL.DDL.Schema.Cache.Config.HasCacheStaticConfig Hasura.RQL.DDL.Schema.Cache.Common.CacheBuild
instance Control.Monad.Trans.Control.MonadBaseControl GHC.Types.IO Hasura.RQL.DDL.Schema.Cache.Common.CacheBuild
instance Control.Monad.Base.MonadBase GHC.Types.IO Hasura.RQL.DDL.Schema.Cache.Common.CacheBuild
instance GHC.Internal.Base.Monad Hasura.RQL.DDL.Schema.Cache.Common.CacheBuild
instance Control.Monad.Error.Class.MonadError Hasura.Base.Error.QErr Hasura.RQL.DDL.Schema.Cache.Common.CacheBuild
instance Control.Monad.IO.Class.MonadIO Hasura.RQL.DDL.Schema.Cache.Common.CacheBuild
instance Control.Monad.Reader.Class.MonadReader Hasura.RQL.DDL.Schema.Cache.Common.CacheBuildParams Hasura.RQL.DDL.Schema.Cache.Common.CacheBuild
instance Hasura.RQL.Types.Source.MonadResolveSource Hasura.RQL.DDL.Schema.Cache.Common.CacheBuild
instance GHC.Internal.Base.Monoid (Hasura.RQL.Types.Metadata.Backend.BackendInvalidationKeys b) => GHC.Internal.Base.Monoid (Hasura.RQL.DDL.Schema.Cache.Common.BackendInvalidationKeysWrapper b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.DDL.Schema.Cache.Common.TableBuildInput b)
instance GHC.Classes.Ord (Hasura.RQL.Types.Metadata.Backend.BackendInvalidationKeys b) => GHC.Classes.Ord (Hasura.RQL.DDL.Schema.Cache.Common.BackendInvalidationKeysWrapper b)
instance Hasura.Services.Network.ProvidesNetwork Hasura.RQL.DDL.Schema.Cache.Common.CacheBuild
instance Hasura.Incremental.Select.Select (Hasura.RQL.DDL.Schema.Cache.Common.BackendInvalidationKeysWrapper b)
instance Hasura.Incremental.Select.Select Hasura.RQL.DDL.Schema.Cache.Common.InvalidationKeys
instance GHC.Internal.Base.Semigroup (Hasura.RQL.Types.Metadata.Backend.BackendInvalidationKeys b) => GHC.Internal.Base.Semigroup (Hasura.RQL.DDL.Schema.Cache.Common.BackendInvalidationKeysWrapper b)
instance GHC.Internal.Show.Show (Hasura.RQL.Types.Metadata.Backend.BackendInvalidationKeys b) => GHC.Internal.Show.Show (Hasura.RQL.DDL.Schema.Cache.Common.BackendInvalidationKeysWrapper b)
instance GHC.Internal.Show.Show Hasura.RQL.DDL.Schema.Cache.Common.InvalidationKeys
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.DDL.Schema.Cache.Common.NonColumnTableInputs b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.DDL.Schema.Cache.Common.TableBuildInput b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.DDL.Schema.Cache.Common.TablePermissionInputs b)


module Hasura.Table.API
data TrackTable (b :: BackendType)
TrackTable :: SourceName -> TableName b -> Bool -> Maybe ApolloFederationConfig -> Maybe LogicalModelName -> TrackTable (b :: BackendType)
[tSource] :: TrackTable (b :: BackendType) -> SourceName
[tName] :: TrackTable (b :: BackendType) -> TableName b
[tIsEnum] :: TrackTable (b :: BackendType) -> Bool
[tApolloFedConfig] :: TrackTable (b :: BackendType) -> Maybe ApolloFederationConfig
[tLogicalModel] :: TrackTable (b :: BackendType) -> Maybe LogicalModelName
runTrackTableQ :: forall (b :: BackendType) m. (MonadError QErr m, CacheRWM m, MetadataM m, BackendMetadata b) => TrackTable b -> m EncJSON
data TrackTableV2 (b :: BackendType)
TrackTableV2 :: TrackTable b -> TableConfig b -> TrackTableV2 (b :: BackendType)
[ttv2Table] :: TrackTableV2 (b :: BackendType) -> TrackTable b
[ttv2Configuration] :: TrackTableV2 (b :: BackendType) -> TableConfig b
runTrackTableV2Q :: forall (b :: BackendType) m. (MonadError QErr m, CacheRWM m, MetadataM m, BackendMetadata b) => TrackTableV2 b -> m EncJSON
data TrackTables (b :: BackendType)
TrackTables :: [TrackTableV2 b] -> AllowWarnings -> TrackTables (b :: BackendType)
[_ttv2Tables] :: TrackTables (b :: BackendType) -> [TrackTableV2 b]
[_ttv2AllowWarnings] :: TrackTables (b :: BackendType) -> AllowWarnings
runTrackTablesQ :: forall (b :: BackendType) m. (MonadError QErr m, CacheRWM m, MetadataM m, BackendMetadata b) => TrackTables b -> m EncJSON
data UntrackTable (b :: BackendType)
UntrackTable :: SourceName -> TableName b -> Bool -> UntrackTable (b :: BackendType)
[utSource] :: UntrackTable (b :: BackendType) -> SourceName
[utTable] :: UntrackTable (b :: BackendType) -> TableName b
[utCascade] :: UntrackTable (b :: BackendType) -> Bool
runUntrackTableQ :: forall (b :: BackendType) m. (CacheRWM m, QErrM m, MetadataM m, BackendMetadata b, BackendEventTrigger b, MonadIO m) => UntrackTable b -> m EncJSON
data UntrackTables (b :: BackendType)
UntrackTables :: [UntrackTable b] -> AllowWarnings -> UntrackTables (b :: BackendType)
[_utTables] :: UntrackTables (b :: BackendType) -> [UntrackTable b]
[_utAllowWarnings] :: UntrackTables (b :: BackendType) -> AllowWarnings
runUntrackTablesQ :: forall (b :: BackendType) m. (CacheRWM m, QErrM m, MetadataM m, BackendMetadata b, BackendEventTrigger b, MonadIO m) => UntrackTables b -> m EncJSON
dropTableInMetadata :: forall (b :: BackendType). Backend b => SourceName -> TableName b -> MetadataModifier
data SetTableIsEnum (b :: BackendType)
SetTableIsEnum :: SourceName -> TableName b -> Bool -> SetTableIsEnum (b :: BackendType)
[stieSource] :: SetTableIsEnum (b :: BackendType) -> SourceName
[stieTable] :: SetTableIsEnum (b :: BackendType) -> TableName b
[stieIsEnum] :: SetTableIsEnum (b :: BackendType) -> Bool
runSetExistingTableIsEnumQ :: forall (b :: BackendType) m. (MonadError QErr m, CacheRWM m, MetadataM m, BackendMetadata b) => SetTableIsEnum b -> m EncJSON
data SetTableCustomFields
SetTableCustomFields :: SourceName -> QualifiedTable -> TableCustomRootFields -> HashMap (Column ('Postgres 'Vanilla)) Name -> SetTableCustomFields
[_stcfSource] :: SetTableCustomFields -> SourceName
[_stcfTable] :: SetTableCustomFields -> QualifiedTable
[_stcfCustomRootFields] :: SetTableCustomFields -> TableCustomRootFields
[_stcfCustomColumnNames] :: SetTableCustomFields -> HashMap (Column ('Postgres 'Vanilla)) Name
runSetTableCustomFieldsQV2 :: (QErrM m, CacheRWM m, MetadataM m) => SetTableCustomFields -> m EncJSON
data SetTableCustomization (b :: BackendType)
SetTableCustomization :: SourceName -> TableName b -> TableConfig b -> SetTableCustomization (b :: BackendType)
[_stcSource] :: SetTableCustomization (b :: BackendType) -> SourceName
[_stcTable] :: SetTableCustomization (b :: BackendType) -> TableName b
[_stcConfiguration] :: SetTableCustomization (b :: BackendType) -> TableConfig b
runSetTableCustomization :: forall (b :: BackendType) m. (QErrM m, CacheRWM m, MetadataM m, Backend b) => SetTableCustomization b -> m EncJSON

-- | Builds an initial table cache. Does not fill in permissions or event
--   triggers, and the returned <tt>FieldInfoMap</tt>s only contain
--   columns, not relationships; those pieces of information are filled in
--   later.
buildTableCache :: forall arr (m :: Type -> Type) (b :: BackendType). (ArrowChoice arr, ArrowDistribute arr, ArrowWriter (Seq CollectItem) arr, ArrowCache m arr, MonadIO m, MonadBaseControl IO m, BackendMetadata b) => arr (SourceName, SourceConfig b, DBTablesMetadata b, [TableBuildInput b], Dependency InvalidationKey, NamingCase, LogicalModels b) (HashMap (TableName b) (TableCoreInfoG b (StructuredColumnInfo b) (ColumnInfo b)))

-- | Check whether a given name would conflict with the current schema by
--   doing an internal introspection
checkConflictingNode :: MonadError QErr m => SchemaCache -> Text -> m ()
data SetApolloFederationConfig (b :: BackendType)
SetApolloFederationConfig :: SourceName -> TableName b -> Maybe ApolloFederationConfig -> SetApolloFederationConfig (b :: BackendType)
[_safcSource] :: SetApolloFederationConfig (b :: BackendType) -> SourceName
[_safcTable] :: SetApolloFederationConfig (b :: BackendType) -> TableName b

-- | Apollo Federation config for the table, setting <a>Nothing</a> would
--   disable Apollo Federation support on the table.
[_safcApolloFederationConfig] :: SetApolloFederationConfig (b :: BackendType) -> Maybe ApolloFederationConfig
runSetApolloFederationConfig :: forall (b :: BackendType) m. (QErrM m, CacheRWM m, MetadataM m, Backend b) => SetApolloFederationConfig b -> m EncJSON
instance GHC.Classes.Eq Hasura.Table.API.SetTableCustomFields
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.Table.API.SetTableCustomization b)
instance GHC.Classes.Eq (Hasura.RQL.Types.Backend.TableName b) => GHC.Classes.Eq (Hasura.Table.API.SetTableIsEnum b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.Table.API.TrackTable b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.Table.API.TrackTableV2 b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.Table.API.UntrackTable b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Table.API.SetApolloFederationConfig b)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Table.API.SetTableCustomFields
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Table.API.SetTableCustomization b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Table.API.SetTableIsEnum b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Table.API.TrackTable b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Table.API.TrackTableV2 b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Table.API.TrackTables b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Table.API.UntrackTable b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Table.API.UntrackTables b)
instance GHC.Internal.Show.Show Hasura.Table.API.SetTableCustomFields
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.Table.API.SetTableCustomization b)
instance GHC.Internal.Show.Show (Hasura.RQL.Types.Backend.TableName b) => GHC.Internal.Show.Show (Hasura.Table.API.SetTableIsEnum b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.Table.API.TrackTable b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.Table.API.TrackTableV2 b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.Table.API.UntrackTable b)

module Hasura.RQL.DDL.Schema.Diff
data TableMeta (b :: BackendType)
TableMeta :: TableName b -> DBTableMetadata b -> [ComputedFieldMeta b] -> TableMeta (b :: BackendType)
[tmTable] :: TableMeta (b :: BackendType) -> TableName b
[tmInfo] :: TableMeta (b :: BackendType) -> DBTableMetadata b
[tmComputedFields] :: TableMeta (b :: BackendType) -> [ComputedFieldMeta b]
data FunctionMeta (b :: BackendType)
FunctionMeta :: OID -> FunctionName b -> FunctionVolatility -> FunctionMeta (b :: BackendType)
[fmOid] :: FunctionMeta (b :: BackendType) -> OID
[fmFunction] :: FunctionMeta (b :: BackendType) -> FunctionName b
[fmType] :: FunctionMeta (b :: BackendType) -> FunctionVolatility
data TablesDiff (b :: BackendType)
TablesDiff :: [TableName b] -> [(TableName b, TableDiff b)] -> TablesDiff (b :: BackendType)
[_sdDroppedTables] :: TablesDiff (b :: BackendType) -> [TableName b]
[_sdAlteredTables] :: TablesDiff (b :: BackendType) -> [(TableName b, TableDiff b)]
data FunctionsDiff (b :: BackendType)
FunctionsDiff :: [FunctionName b] -> [(FunctionName b, FunctionVolatility)] -> FunctionsDiff (b :: BackendType)
[fdDropped] :: FunctionsDiff (b :: BackendType) -> [FunctionName b]
[fdAltered] :: FunctionsDiff (b :: BackendType) -> [(FunctionName b, FunctionVolatility)]
data ComputedFieldMeta (b :: BackendType)
ComputedFieldMeta :: ComputedFieldName -> FunctionMeta b -> ComputedFieldMeta (b :: BackendType)
[ccmName] :: ComputedFieldMeta (b :: BackendType) -> ComputedFieldName
[ccmFunctionMeta] :: ComputedFieldMeta (b :: BackendType) -> FunctionMeta b
getTablesDiff :: forall (b :: BackendType). Backend b => [TableMeta b] -> [TableMeta b] -> TablesDiff b
processTablesDiff :: forall (b :: BackendType) m. (MonadError QErr m, CacheRM m, MonadWriter MetadataModifier m, BackendMetadata b, Column b ~ ColumnPath b) => SourceName -> TableCache b -> TablesDiff b -> m ()
getIndirectDependenciesFromTableDiff :: forall (b :: BackendType) m. (QErrM m, CacheRM m, Backend b) => SourceName -> TablesDiff b -> m [SchemaObjId]
getFunctionsDiff :: forall (b :: BackendType). [FunctionMeta b] -> [FunctionMeta b] -> FunctionsDiff b
getOverloadedFunctions :: forall (b :: BackendType). Backend b => [FunctionName b] -> [FunctionMeta b] -> [FunctionName b]
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.DDL.Schema.Diff.ComputedFieldDiff b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.DDL.Schema.Diff.ComputedFieldMeta b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.DDL.Schema.Diff.FunctionMeta b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.DDL.Schema.Diff.FunctionsDiff b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.DDL.Schema.Diff.TableMeta b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Schema.Diff.ComputedFieldMeta b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Schema.Diff.FunctionMeta b)
instance GHC.Internal.Generics.Generic (Hasura.RQL.DDL.Schema.Diff.ComputedFieldMeta b)
instance GHC.Internal.Generics.Generic (Hasura.RQL.DDL.Schema.Diff.FunctionMeta b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.DDL.Schema.Diff.ComputedFieldDiff b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.DDL.Schema.Diff.ComputedFieldMeta b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.DDL.Schema.Diff.FunctionMeta b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.DDL.Schema.Diff.FunctionsDiff b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.DDL.Schema.Diff.TableMeta b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.DDL.Schema.Diff.ComputedFieldMeta b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.DDL.Schema.Diff.FunctionMeta b)

module Hasura.RQL.DDL.Schema.Cache.Permission
buildTablePermissions :: forall (b :: BackendType) m. (MonadError QErr m, MonadWriter (Seq CollectItem) m, BackendMetadata b, GetAggregationPredicatesDeps b) => Environment -> SourceName -> SourceConfig b -> TableCoreCache b -> TableName b -> FieldInfoMap (FieldInfo b) -> TablePermissionInputs b -> OrderedRoles -> HashMap LogicalModelName (LogicalModelMetadata b) -> m (RolePermInfoMap b)

-- | <a>orderRoles</a> is used to order the roles, in such a way that given
--   a role R with n parent roles - PR1, PR2 .. PRn, then the
--   <a>orderRoles</a> function will order the roles in such a way that all
--   the parent roles precede the role R. Note that the order of the parent
--   roles itself doesn't matter as long as they precede the roles on which
--   they are dependent on.
--   
--   For example, the orderRoles may return `[PR1, PR3, PR2, ... PRn, R]`
--   or `[PR5, PR3, PR1 ... R]`, both of them are correct because all the
--   parent roles precede the inherited role R, assuming the parent roles
--   themselves don't have any parents for the sake of this example.
orderRoles :: MonadError QErr m => [Role] -> m OrderedRoles

-- | <a>OrderedRoles</a> is a data type to hold topologically sorted roles
--   according to each role's parent roles, see <a>orderRoles</a> for more
--   details.
data OrderedRoles
_unOrderedRoles :: OrderedRoles -> [Role]
mkBooleanPermissionMap :: (RoleName -> a) -> HashMap RoleName a -> OrderedRoles -> HashMap RoleName a

-- | <a>resolveCheckPermission</a> is a helper function which will convert
--   the indermediate type <a>CheckPermission</a> to its original type. It
--   will record any metadata inconsistencies, if exists.
resolveCheckPermission :: MonadWriter (Seq CollectItem) m => CheckPermission p -> RoleName -> InconsistentRoleEntity -> m (Maybe p)

-- | Create the permission map for a native query based on the select
--   permissions given in metadata. Compare with
--   <a>buildTablePermissions</a>.
buildLogicalModelPermissions :: forall (b :: BackendType) m. (MonadError QErr m, MonadWriter (Seq CollectItem) m, BackendMetadata b, GetAggregationPredicatesDeps b, LogicalModelFieldsRM b m) => SourceName -> SourceConfig b -> TableCoreCache b -> LogicalModelLocation -> InsOrdHashMap (Column b) (LogicalModelField b) -> InsOrdHashMap RoleName (SelPermDef b) -> OrderedRoles -> m (RolePermInfoMap b)
instance GHC.Classes.Eq Hasura.RQL.DDL.Schema.Cache.Permission.OrderedRoles
instance GHC.Internal.Generics.Generic Hasura.RQL.DDL.Schema.Cache.Permission.OrderedRoles
instance Hasura.RQL.Types.Backend.Backend b => Data.Text.Extended.ToTxt (Hasura.RQL.DDL.Schema.Cache.Permission.SelectPermissionSource b)

module Hasura.RemoteSchema.SchemaCache.Build
buildRemoteSchemas :: forall arr (m :: Type -> Type) remoteRelationshipDefinition. (ArrowChoice arr, ArrowDistribute arr, ArrowWriter (Seq CollectItem) arr, ArrowCache m arr, MonadIO m, MonadBaseControl IO m, Eq remoteRelationshipDefinition, ToJSON remoteRelationshipDefinition, MonadError QErr m, ProvidesNetwork m) => Logger Hasura -> Environment -> arr ((Dependency (HashMap RemoteSchemaName InvalidationKey), OrderedRoles, Maybe (HashMap RemoteSchemaName ByteString), SchemaSampledFeatureFlags), [RemoteSchemaMetadataG remoteRelationshipDefinition]) (HashMap RemoteSchemaName (PartiallyResolvedRemoteSchemaCtxG remoteRelationshipDefinition, MetadataObject))
addRemoteSchemaP2Setup :: (QErrM m, MonadIO m, ProvidesNetwork m, MonadTrace m) => RemoteSchemaName -> Environment -> SchemaSampledFeatureFlags -> RemoteSchemaDef -> m (IntrospectionResult, ByteString, RemoteSchemaInfo)

module Hasura.RemoteSchema.SchemaCache

module Hasura.RQL.DDL.RemoteRelationship

-- | Argument to the <tt>_create_remote_relationship</tt> and
--   <tt>_update_remote_relationship</tt> families of metadata commands.
--   
--   For historical reason, this type is also used to represent a db-to-rs
--   schema in the metadata.
data CreateFromSourceRelationship (b :: BackendType)
CreateFromSourceRelationship :: SourceName -> TableName b -> RelName -> RemoteRelationshipDefinition -> CreateFromSourceRelationship (b :: BackendType)
[_crrSource] :: CreateFromSourceRelationship (b :: BackendType) -> SourceName
[_crrTable] :: CreateFromSourceRelationship (b :: BackendType) -> TableName b
[_crrName] :: CreateFromSourceRelationship (b :: BackendType) -> RelName
[_crrDefinition] :: CreateFromSourceRelationship (b :: BackendType) -> RemoteRelationshipDefinition
runCreateRemoteRelationship :: forall (b :: BackendType) m. (MonadError QErr m, CacheRWM m, MetadataM m, BackendMetadata b) => CreateFromSourceRelationship b -> m EncJSON
execDeleteRemoteRelationship :: forall (b :: BackendType) m. (BackendMetadata b, MonadError QErr m, CacheRWM m) => DeleteFromSourceRelationship b -> m (MetadataObjId, MetadataModifier)
runDeleteRemoteRelationship :: forall (b :: BackendType) m. (BackendMetadata b, MonadError QErr m, CacheRWM m, MetadataM m) => DeleteFromSourceRelationship b -> m EncJSON
runUpdateRemoteRelationship :: forall (b :: BackendType) m. (MonadError QErr m, CacheRWM m, MetadataM m, BackendMetadata b) => CreateFromSourceRelationship b -> m EncJSON

-- | Argument to the <tt>_drop_remote_relationship</tt> family of metadata
--   commands.
data DeleteFromSourceRelationship (b :: BackendType)
DeleteFromSourceRelationship :: SourceName -> TableName b -> RelName -> DeleteFromSourceRelationship (b :: BackendType)
[_drrSource] :: DeleteFromSourceRelationship (b :: BackendType) -> SourceName
[_drrTable] :: DeleteFromSourceRelationship (b :: BackendType) -> TableName b
[_drrName] :: DeleteFromSourceRelationship (b :: BackendType) -> RelName
dropRemoteRelationshipInMetadata :: forall (b :: BackendType). RelName -> TableMetadata b -> TableMetadata b

-- | Internal intermediary step.
--   
--   We build the output of sources in two steps: 1. we first resolve
--   sources, and collect the core info of their tables 2. we then build
--   the entire output from the collection of partially resolved sources
--   
--   We need this split to be able to resolve cross-source relationships:
--   to process one source's remote relationship, we need to know about the
--   target source's tables core info.
--   
--   This data structure is used as an argument to <tt>AnyBackend</tt> in
--   the backend-agnostic intermediary collection, and used here to build
--   remote field info.
data PartiallyResolvedSource (b :: BackendType)
PartiallyResolvedSource :: SourceMetadata b -> SourceConfig b -> DBObjectsIntrospection b -> HashMap (TableName b) (TableCoreInfoG b (StructuredColumnInfo b) (ColumnInfo b)) -> HashMap (TableName b) (EventTriggerInfoMap b) -> PartiallyResolvedSource (b :: BackendType)
[_prsSourceMetadata] :: PartiallyResolvedSource (b :: BackendType) -> SourceMetadata b
[_prsConfig] :: PartiallyResolvedSource (b :: BackendType) -> SourceConfig b
[_prsIntrospection] :: PartiallyResolvedSource (b :: BackendType) -> DBObjectsIntrospection b
[_tableCoreInfoMap] :: PartiallyResolvedSource (b :: BackendType) -> HashMap (TableName b) (TableCoreInfoG b (StructuredColumnInfo b) (ColumnInfo b))
[_eventTriggerInfoMap] :: PartiallyResolvedSource (b :: BackendType) -> HashMap (TableName b) (EventTriggerInfoMap b)

-- | Builds the schema cache representation of a remote relationship TODO:
--   this is not actually called by the remote relationship DDL API and is
--   only used as part of the schema cache process. Should this be moved
--   elsewhere?
buildRemoteFieldInfo :: QErrM m => LHSIdentifier -> HashMap FieldName lhsJoinField -> RemoteRelationship -> HashMap SourceName (AnyBackend PartiallyResolvedSource) -> PartiallyResolvedRemoteSchemaMap -> m (RemoteFieldInfo lhsJoinField, Seq SchemaDependency)
data CreateRemoteSchemaRemoteRelationship
CreateRemoteSchemaRemoteRelationship :: RemoteSchemaName -> Name -> RelName -> RemoteRelationshipDefinition -> CreateRemoteSchemaRemoteRelationship
[_crsrrRemoteSchema] :: CreateRemoteSchemaRemoteRelationship -> RemoteSchemaName
[_crsrrType] :: CreateRemoteSchemaRemoteRelationship -> Name
[_crsrrName] :: CreateRemoteSchemaRemoteRelationship -> RelName
[_crsrrDefinition] :: CreateRemoteSchemaRemoteRelationship -> RemoteRelationshipDefinition
runCreateRemoteSchemaRemoteRelationship :: (MonadError QErr m, CacheRWM m, MetadataM m) => CreateRemoteSchemaRemoteRelationship -> m EncJSON
runUpdateRemoteSchemaRemoteRelationship :: (MonadError QErr m, CacheRWM m, MetadataM m) => CreateRemoteSchemaRemoteRelationship -> m EncJSON

-- | Argument to the <tt>_drop_remote_relationship</tt> family of metadata
--   commands.
data DeleteRemoteSchemaRemoteRelationship
DeleteRemoteSchemaRemoteRelationship :: RemoteSchemaName -> Name -> RelName -> DeleteRemoteSchemaRemoteRelationship
[_drsrrRemoteSchema] :: DeleteRemoteSchemaRemoteRelationship -> RemoteSchemaName
[_drsrrTypeName] :: DeleteRemoteSchemaRemoteRelationship -> Name
[_drsrrName] :: DeleteRemoteSchemaRemoteRelationship -> RelName
runDeleteRemoteSchemaRemoteRelationship :: (MonadError QErr m, CacheRWM m, MetadataM m) => DeleteRemoteSchemaRemoteRelationship -> m EncJSON
getRemoteSchemaEntityJoinColumns :: MonadError QErr m => RemoteSchemaName -> RemoteSchemaIntrospection -> Name -> m (HashMap FieldName Name)
instance GHC.Classes.Eq (Hasura.RQL.Types.Backend.TableName b) => GHC.Classes.Eq (Hasura.RQL.DDL.RemoteRelationship.CreateFromSourceRelationship b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.DDL.RemoteRelationship.PartiallyResolvedSource b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.RemoteRelationship.CreateFromSourceRelationship b)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.RemoteRelationship.CreateRemoteSchemaRemoteRelationship
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.RemoteRelationship.DeleteFromSourceRelationship b)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.RemoteRelationship.DeleteRemoteSchemaRemoteRelationship
instance GHC.Internal.Generics.Generic Hasura.RQL.DDL.RemoteRelationship.CreateRemoteSchemaRemoteRelationship
instance GHC.Internal.Show.Show (Hasura.RQL.Types.Backend.TableName b) => GHC.Internal.Show.Show (Hasura.RQL.DDL.RemoteRelationship.CreateFromSourceRelationship b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.DDL.RemoteRelationship.CreateFromSourceRelationship b)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.RemoteRelationship.CreateRemoteSchemaRemoteRelationship


-- | Funtions related to <tt>hdb_catalog</tt> schema prior to metadata
--   separation (catalog version &lt; 43).
module Hasura.RQL.DDL.Schema.LegacyCatalog
saveMetadataToHdbTables :: (MonadTx m, MonadReader SystemDefined m) => MetadataNoSources -> m ()
fetchMetadataFromHdbTables :: MonadTx m => m MetadataNoSources

-- | Drops and recreates all “system-defined” metadata, aka metadata for
--   tables and views in the <tt>information_schema</tt> and
--   <tt>hdb_catalog</tt> schemas. These tables and views are tracked to
--   expose them to the console, which allows us to reuse the same
--   functionality we use to implement user-defined APIs to expose the
--   catalog.
--   
--   This process has a long and storied history.
--   
--   In the past, we reused the same machinery we use for CLI migrations to
--   define our own internal metadata migrations. This caused trouble,
--   however, as we’d have to run those migrations in lockstep with our SQL
--   migrations to ensure the two didn’t get out of sync. This in turn
--   caused trouble because those migrations would hit code paths inside
--   <tt>graphql-engine</tt> to add or remove things from the
--   <tt>pg_catalog</tt> tables, and <i>that</i> in turn would fail because
--   we hadn’t finished running the SQL migrations, so we were running a
--   new version of the code against an old version of the schema! That
--   caused #2826.
--   
--   To fix that, #2379 switched to the approach of just dropping and
--   recreating all system metadata every time we run any SQL migrations.
--   But <i>that</i> in turn caused trouble due to the way we were
--   constantly rebuilding the schema cache (#3354), causing us to switch
--   to incremental schema cache construction (#3394). However, although
--   that mostly resolved the problem, we still weren’t totally out of the
--   woods, as the incremental construction was still too slow on slow
--   Postgres instances (#3654).
--   
--   To sidestep the whole issue, as of #3686 we now just create all the
--   system metadata in code here, and we only rebuild the schema cache
--   once, at the very end. This is a little unsatisfying, since it means
--   our internal migrations are “blessed” compared to user-defined CLI
--   migrations. If we improve CLI migrations further in the future, maybe
--   we can switch back to using that approach, instead.
recreateSystemMetadata :: MonadTx m => m ()
addCronTriggerForeignKeyConstraint :: MonadTx m => m ()
parseLegacyRemoteRelationshipDefinition :: MonadError QErr m => Value -> m RemoteRelationshipDefinition

module Hasura.GraphQL.Schema.RemoteRelationship

-- | Remote relationship field parsers
remoteRelationshipField :: SchemaContext -> SchemaOptions -> SourceCache -> RemoteSchemaMap -> RemoteSchemaPermissions -> RemoteSourceRelationshipBuilder -> RemoteRelationshipParserBuilder

module Hasura.GraphQL.Schema

-- | Builds the full GraphQL context for a given query type.
--   
--   A <a>GQLContext</a> stores how an incoming request should be
--   processed: how to translate each incoming field of a request into a
--   corresponding semantic representation. There is a different one per
--   <tt>Role</tt>, as each role might have different permissions, and
--   therefore not access to the same set of objects in the schema.
--   
--   This function takes all necessary information from the metadata, and
--   the <tt>GraphQLQueryType</tt>, and builds all relevant contexts: a
--   hash map from <a>RoleName</a> to their <a>GQLContext</a> and the
--   "default" context for unauthenticated users.
--   
--   When building the schema for each role, we treat the remote schemas as
--   "second-class citizens" compared to sources; more specifically, we
--   attempt to detect whether the inclusion of a given remote schema would
--   result in root fields conflict, and only keep schemas that don't
--   generate any. This results in a partial schema being available to the
--   users, and a better error message than would arise from
--   <a>safeSelectionSet</a>.
buildGQLContext :: (MonadError QErr m, MonadIO m) => SchemaSampledFeatureFlags -> InferFunctionPermissions -> RemoteSchemaPermissions -> HashSet ExperimentalFeature -> SQLGenCtx -> ApolloFederationStatus -> SourceCache -> HashMap RemoteSchemaName (RemoteSchemaCtx, MetadataObject) -> ActionCache -> AnnotatedCustomTypes -> Maybe SchemaRegistryContext -> Logger Hasura -> m ((SchemaIntrospection, HashMap RoleName (RoleContext GQLContext), GQLContext, HashSet InconsistentMetadata), (HashMap RoleName (RoleContext GQLContext), GQLContext), SchemaRegistryAction)

module Hasura.GraphQL.Execute.RemoteJoin.Types

-- | A JoinTree represents the set of operations that need to be executed
--   to enrich the response of a source with data from remote sources. A
--   tree structure is used to capture the locations in the response where
--   the join has to happpen as it offers an efficient traversal mechanism.
--   
--   For a query such as this:
--   
--   { city { name code # weather is a remote relationship weather {
--   forecast } state { # weather is a remote relationship weather {
--   forecast } } } }
--   
--   the join tree would look like [ , ("weather", Leaf
--   RemoteJoinInfoOfWeather), , ("state", [ ("weather", Leaf
--   RemoteJoinInfoOfWeather) ]) ]
--   
--   Note that the same join tree will be emitted even if <tt>city</tt> is
--   of type '[City]' and <a>state</a> is of type [State], we currently do
--   not capture any information if any of the fields in the path expect
--   json arrays. It is similar in spirit to a GraphQL selection set in
--   this regard.
--   
--   This structure is somewhat similar to a prefix tree such as
--   <a>Trie</a>, but has two additional guarantees: - a <a>JoinTree</a> is
--   never empty, - there cannot exist a pair of values for which one's
--   prefix key is a subset of the other: every value is effectively a
--   leaf.
newtype JoinTree a
JoinTree :: NEHashMap QualifiedFieldName (JoinNode a) -> JoinTree a
[unJoinTree] :: JoinTree a -> NEHashMap QualifiedFieldName (JoinNode a)

-- | Each leaf associates a mapping from typename to actual join info. This
--   allows to disambiguate between different remote joins with the same
--   name in a given selection set, which might happen with union or
--   interface fragments.
data JoinNode a
Leaf :: a -> JoinNode a
Tree :: JoinTree a -> JoinNode a
type RemoteJoins = JoinTree RemoteJoin

-- | A field name annotated with an optional type name.
--   
--   To deal with ambiguous join paths, such as those that emerge from
--   GraphQL interfaces or GraphQL unions, we do not just keep track of the
--   fields' name, but also, optionally, of their type. Whenever a
--   selection set is deemed ambiguous, we insert a reserved field in the
--   query to retrieve the typename, <tt>__hasura_internal_typename</tt>;
--   when traversing the join tree, if that key is present, then we use it
--   alongside the field name when querying the join tree (see
--   <tt>traverseObject</tt> in the <tt>Join</tt> module).
--   
--   We use <a>Text</a> for the representation of the field name instead of
--   <a>FieldName</a>, for simplicity: the join tree is only meant to be
--   queried using the values we get in the reponse, which will be
--   unrestricted text.
data QualifiedFieldName
QualifiedFieldName :: Maybe Text -> Text -> QualifiedFieldName
[_qfTypeName] :: QualifiedFieldName -> Maybe Text
[_qfFieldName] :: QualifiedFieldName -> Text

-- | Collect all the remote joins to a remote schema from a join tree.
getRemoteSchemaJoins :: RemoteJoins -> [RemoteSchemaJoin]

-- | An individual join entry point in a <a>JoinTree</a>.
--   
--   Either a join against a source, or against a remote schema. In either
--   case, the constructor will contain that particular join's information
--   (a <a>RemoteSourceJoin</a> or <a>RemoteSchemaJoin</a> respectively)
--   and, recursively, the set of follow-up <a>RemoteJoins</a> from that
--   target, if any.
data RemoteJoin
RemoteJoinSource :: AnyBackend RemoteSourceJoin -> Maybe RemoteJoins -> RemoteJoin
RemoteJoinRemoteSchema :: RemoteSchemaJoin -> Maybe RemoteJoins -> RemoteJoin

-- | A unique id that gets assigned to each <a>RemoteJoin</a> (this is to
--   avoid the requirement of Ord/Hashable implementation for RemoteJoin)
type JoinCallId = Int

-- | Disambiguates between <a>FieldName</a>s which are provided as part of
--   the GraphQL selection provided by the user (i.e. <a>JCSelected</a>)
--   and those which we need to retreive data but which are not expressly
--   requested (i.e. <a>JCPhantom</a>).
--   
--   After processing the remote join, we remove all phantom
--   <a>FieldName</a>s and only return those which fall under the
--   <a>JCSelected</a> branch of this type.
data JoinColumnAlias

-- | This fieldname is already part of the response.
JCSelected :: !FieldName -> JoinColumnAlias

-- | This is explicitly added for the join.
--   
--   Such keys will have to be removed from the response eventually.
JCPhantom :: !FieldName -> JoinColumnAlias

-- | Extracts the field name from the <a>JoinColumnAlias</a>, regardless of
--   whether the field is requested by the user of a "phantom" field.
getAliasFieldName :: JoinColumnAlias -> FieldName

-- | Extracts the list of phantom field names out of a given
--   <a>RemoteJoin</a>, i.e. the name of the fields that must be part of
--   the query but were not requested by the user.
getPhantomFields :: RemoteJoin -> [FieldName]

-- | Extracts an abstracted field mapping for a particular
--   <a>RemoteJoin</a>, using a common representation.
--   
--   The RHS of the mapping uses <a>JoinColumnAlias</a> instead of
--   <a>FieldName</a> to differentiate between selected fields and phantom
--   fields (see <a>JoinColumnAlias</a>).
getJoinColumnMapping :: RemoteJoin -> HashMap FieldName JoinColumnAlias

-- | A <a>RemoteSourceJoin</a> contains all the contextual information
--   required for the execution of a join against a source, translated from
--   the IR's representation of a selection (see <tt>AnnFieldG</tt>).
data RemoteSourceJoin (b :: BackendType)
RemoteSourceJoin :: !SourceName -> !SourceConfig b -> !SourceRelationshipSelection b Void UnpreparedValue -> !HashMap FieldName (JoinColumnAlias, (Column b, ScalarType b)) -> StringifyNumbers -> RemoteSourceJoin (b :: BackendType)
[_rsjSource] :: RemoteSourceJoin (b :: BackendType) -> !SourceName
[_rsjSourceConfig] :: RemoteSourceJoin (b :: BackendType) -> !SourceConfig b
[_rsjRelationship] :: RemoteSourceJoin (b :: BackendType) -> !SourceRelationshipSelection b Void UnpreparedValue
[_rsjJoinColumns] :: RemoteSourceJoin (b :: BackendType) -> !HashMap FieldName (JoinColumnAlias, (Column b, ScalarType b))
[_rsjStringifyNum] :: RemoteSourceJoin (b :: BackendType) -> StringifyNumbers

-- | A <a>RemoteSchemaJoin</a> contains all the contextual information
--   required for the execution of a join against a remote schema,
--   translated from the IR's representation of a selection (see
--   <tt>AnnFieldG</tt>).
data RemoteSchemaJoin
RemoteSchemaJoin :: !HashMap Name (InputValue RemoteSchemaVariable) -> !ResultCustomizer -> !SelectionSet Void RemoteSchemaVariable -> !HashMap FieldName JoinColumnAlias -> !NonEmpty FieldCall -> !RemoteSchemaInfo -> RemoteSchemaJoin

-- | User-provided arguments with variables.
[_rsjArgs] :: RemoteSchemaJoin -> !HashMap Name (InputValue RemoteSchemaVariable)

-- | Customizer for JSON result from the remote server.
[_rsjResultCustomizer] :: RemoteSchemaJoin -> !ResultCustomizer

-- | User-provided selection set of remote field.
[_rsjSelSet] :: RemoteSchemaJoin -> !SelectionSet Void RemoteSchemaVariable

-- | A map of the join column to its alias in the response
[_rsjJoinColumnAliases] :: RemoteSchemaJoin -> !HashMap FieldName JoinColumnAlias

-- | Remote server fields.
[_rsjFieldCall] :: RemoteSchemaJoin -> !NonEmpty FieldCall

-- | The remote schema server info.
[_rsjRemoteSchema] :: RemoteSchemaJoin -> !RemoteSchemaInfo

-- | A unique id assigned to each join argument
type JoinArgumentId = Int

-- | A map of fieldname to values extracted from each LHS row/object
--   
--   For example, if a remote relationship <tt>weather</tt> on
--   <tt>city</tt> table is defined as follows: city.weather =
--   get_weather(city: city.code, cityState: city.state_code) a join
--   argument for this join would have the values of columns <tt>code</tt>
--   and <tt>state_code</tt> for each <tt>city</tt> row that participates
--   in the join
newtype JoinArgument
JoinArgument :: HashMap FieldName Value -> JoinArgument
[unJoinArgument] :: JoinArgument -> HashMap FieldName Value
data JoinArguments
JoinArguments :: !RemoteJoin -> !HashMap JoinArgument JoinArgumentId -> !FieldName -> JoinArguments

-- | The <a>RemoteJoin</a> associated with the join arguments within this
--   structure.
[_jalJoin] :: JoinArguments -> !RemoteJoin

-- | Arguments for which we must fetch a response from the remote, along
--   with the identifiers that are used to stitch the final response
--   together.
--   
--   NOTE: <a>HashMap</a> is used to deduplicate multiple
--   <a>JoinArgument</a>s so that we avoid fetching more data from a remote
--   than is necessary (i.e. in the case of duplicate arguments).
[_jalArguments] :: JoinArguments -> !HashMap JoinArgument JoinArgumentId

-- | The <a>FieldName</a> associated with the "replacement token" for this
--   join argument.
--   
--   NOTE: We need this for query logging; ideally we would use the full
--   path for the GraphQL query associated with this remote join, but we
--   don't have access to that here so this is the next best thing to do.
[_jalFieldName] :: JoinArguments -> !FieldName
instance GHC.Classes.Eq Hasura.GraphQL.Execute.RemoteJoin.Types.JoinArgument
instance GHC.Classes.Eq Hasura.GraphQL.Execute.RemoteJoin.Types.JoinColumnAlias
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.GraphQL.Execute.RemoteJoin.Types.JoinNode a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.GraphQL.Execute.RemoteJoin.Types.JoinTree a)
instance GHC.Classes.Eq Hasura.GraphQL.Execute.RemoteJoin.Types.QualifiedFieldName
instance GHC.Classes.Eq Hasura.GraphQL.Execute.RemoteJoin.Types.RemoteJoin
instance GHC.Classes.Eq Hasura.GraphQL.Execute.RemoteJoin.Types.RemoteSchemaJoin
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.Select.SourceRelationshipSelection b GHC.Internal.Base.Void Hasura.RQL.IR.Value.UnpreparedValue)) => GHC.Classes.Eq (Hasura.GraphQL.Execute.RemoteJoin.Types.RemoteSourceJoin b)
instance GHC.Internal.Data.Foldable.Foldable Hasura.GraphQL.Execute.RemoteJoin.Types.JoinNode
instance GHC.Internal.Data.Foldable.Foldable Hasura.GraphQL.Execute.RemoteJoin.Types.JoinTree
instance GHC.Internal.Base.Functor Hasura.GraphQL.Execute.RemoteJoin.Types.JoinNode
instance GHC.Internal.Base.Functor Hasura.GraphQL.Execute.RemoteJoin.Types.JoinTree
instance GHC.Internal.Generics.Generic Hasura.GraphQL.Execute.RemoteJoin.Types.JoinArgument
instance GHC.Internal.Generics.Generic Hasura.GraphQL.Execute.RemoteJoin.Types.JoinArguments
instance GHC.Internal.Generics.Generic Hasura.GraphQL.Execute.RemoteJoin.Types.JoinColumnAlias
instance GHC.Internal.Generics.Generic (Hasura.GraphQL.Execute.RemoteJoin.Types.JoinNode a)
instance GHC.Internal.Generics.Generic (Hasura.GraphQL.Execute.RemoteJoin.Types.JoinTree a)
instance GHC.Internal.Generics.Generic Hasura.GraphQL.Execute.RemoteJoin.Types.QualifiedFieldName
instance GHC.Internal.Generics.Generic Hasura.GraphQL.Execute.RemoteJoin.Types.RemoteJoin
instance GHC.Internal.Generics.Generic Hasura.GraphQL.Execute.RemoteJoin.Types.RemoteSchemaJoin
instance GHC.Internal.Generics.Generic (Hasura.GraphQL.Execute.RemoteJoin.Types.RemoteSourceJoin b)
instance Data.Hashable.Class.Hashable Hasura.GraphQL.Execute.RemoteJoin.Types.JoinArgument
instance Data.Hashable.Class.Hashable Hasura.GraphQL.Execute.RemoteJoin.Types.JoinColumnAlias
instance Data.Hashable.Class.Hashable Hasura.GraphQL.Execute.RemoteJoin.Types.QualifiedFieldName
instance GHC.Internal.Base.Semigroup (Hasura.GraphQL.Execute.RemoteJoin.Types.JoinTree a)
instance GHC.Internal.Show.Show Hasura.GraphQL.Execute.RemoteJoin.Types.JoinArgument
instance GHC.Internal.Show.Show Hasura.GraphQL.Execute.RemoteJoin.Types.JoinColumnAlias
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (Hasura.GraphQL.Execute.RemoteJoin.Types.JoinNode a)
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (Hasura.GraphQL.Execute.RemoteJoin.Types.JoinTree a)
instance GHC.Internal.Show.Show Hasura.GraphQL.Execute.RemoteJoin.Types.QualifiedFieldName
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Internal.Show.Show (Hasura.RQL.IR.Select.SourceRelationshipSelection b GHC.Internal.Base.Void Hasura.RQL.IR.Value.UnpreparedValue), GHC.Internal.Show.Show (Hasura.RQL.Types.SourceConfiguration.SourceConfig b)) => GHC.Internal.Show.Show (Hasura.GraphQL.Execute.RemoteJoin.Types.RemoteSourceJoin b)
instance GHC.Internal.Data.Traversable.Traversable Hasura.GraphQL.Execute.RemoteJoin.Types.JoinNode
instance GHC.Internal.Data.Traversable.Traversable Hasura.GraphQL.Execute.RemoteJoin.Types.JoinTree

module Hasura.GraphQL.Execute.RemoteJoin.Collect

-- | Collects remote joins from the a <a>QueryDB</a> if any, and transforms
--   the selection to add new join fields where those occured.
--   
--   Returns the transformed selection set, in which remote fields have
--   been inserted, and for which the <tt>r</tt> type is now <a>Void</a>.
getRemoteJoinsQueryDB :: forall (b :: BackendType). Backend b => QueryDB b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b) -> (QueryDB b Void (UnpreparedValue b), Maybe RemoteJoins)

-- | Collects remote joins from the a <a>MutationDB</a> if any, and
--   transforms the selection to add new join fields where those occured.
--   
--   Returns the transformed selection set, in which remote fields have
--   been inserted, and for which the <tt>r</tt> type is now <a>Void</a>.
getRemoteJoinsMutationDB :: forall (b :: BackendType). Backend b => MutationDB b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b) -> (MutationDB b Void (UnpreparedValue b), Maybe RemoteJoins)
getRemoteJoinsActionQuery :: ActionQuery (RemoteRelationshipField UnpreparedValue) -> (ActionQuery Void, Maybe RemoteJoins)
getRemoteJoinsActionMutation :: ActionMutation (RemoteRelationshipField UnpreparedValue) -> (ActionMutation Void, Maybe RemoteJoins)
getRemoteJoinsGraphQLField :: GraphQLField (RemoteRelationshipField UnpreparedValue) var -> (GraphQLField Void var, Maybe RemoteJoins)
instance GHC.Internal.Base.Applicative Hasura.GraphQL.Execute.RemoteJoin.Collect.Collector
instance GHC.Internal.Base.Functor Hasura.GraphQL.Execute.RemoteJoin.Collect.Collector
instance GHC.Internal.Base.Monad Hasura.GraphQL.Execute.RemoteJoin.Collect.Collector
instance Control.Monad.Writer.Class.MonadWriter (GHC.Internal.Maybe.Maybe Hasura.GraphQL.Execute.RemoteJoin.Types.RemoteJoins) Hasura.GraphQL.Execute.RemoteJoin.Collect.Collector

module Hasura.GraphQL.Execute.Backend

-- | This typeclass enacapsulates how a given backend translates a root
--   field into an execution plan. For now, each root field maps to one
--   execution step, but in the future, when we have a client-side
--   dataloader, each root field might translate into a multi-step plan.
class (Backend b, ToTxt MultiplexedQuery b, Show ResolvedConnectionTemplate b, Eq ResolvedConnectionTemplate b, Hashable ResolvedConnectionTemplate b) => BackendExecute (b :: BackendType) where {
    type PreparedQuery (b :: BackendType);
    type MultiplexedQuery (b :: BackendType);
    type ExecutionMonad (b :: BackendType) :: Type -> Type -> Type -> Type;
}
mkDBQueryPlan :: (BackendExecute b, MonadError QErr m, MonadQueryTags m, MonadReader QueryTagsComment m, MonadIO m, MonadGetPolicies m) => UserInfo -> SourceName -> SourceConfig b -> QueryDB b Void (UnpreparedValue b) -> [Header] -> Maybe Name -> TraceQueryStatus -> m (DBStepInfo b, [ModelInfoPart])
mkDBMutationPlan :: (BackendExecute b, MonadError QErr m, MonadIO m, MonadQueryTags m, MonadReader QueryTagsComment m, MonadTrace m) => Environment -> Manager -> Logger Hasura -> UserInfo -> StringifyNumbers -> SourceName -> SourceConfig b -> MutationDB b Void (UnpreparedValue b) -> [Header] -> Maybe Name -> Maybe (HashMap Name (Value Variable)) -> TraceQueryStatus -> m (DBStepInfo b, [ModelInfoPart])
mkLiveQuerySubscriptionPlan :: (BackendExecute b, MonadError QErr m, MonadIO m, MonadBaseControl IO m, MonadReader QueryTagsComment m) => UserInfo -> SourceName -> SourceConfig b -> Maybe Name -> RootFieldMap (QueryDB b Void (UnpreparedValue b)) -> [Header] -> Maybe Name -> m (SubscriptionQueryPlan b (MultiplexedQuery b), [ModelInfoPart])
mkDBStreamingSubscriptionPlan :: (BackendExecute b, MonadError QErr m, MonadIO m, MonadBaseControl IO m, MonadReader QueryTagsComment m) => UserInfo -> SourceName -> SourceConfig b -> (RootFieldAlias, QueryDB b Void (UnpreparedValue b)) -> [Header] -> Maybe Name -> m (SubscriptionQueryPlan b (MultiplexedQuery b), [ModelInfoPart])
mkDBQueryExplain :: (BackendExecute b, MonadError QErr m, MonadIO m) => RootFieldAlias -> UserInfo -> SourceName -> SourceConfig b -> QueryDB b Void (UnpreparedValue b) -> [Header] -> Maybe Name -> m (AnyBackend DBStepInfo)
mkSubscriptionExplain :: (BackendExecute b, MonadError QErr m, MonadIO m, MonadBaseControl IO m) => SubscriptionQueryPlan b (MultiplexedQuery b) -> m SubscriptionQueryPlanExplanation
mkDBRemoteRelationshipPlan :: (BackendExecute b, MonadError QErr m, MonadQueryTags m, MonadIO m, MonadGetPolicies m) => UserInfo -> SourceName -> SourceConfig b -> NonEmpty Object -> HashMap FieldName (Column b, ScalarType b) -> FieldName -> (FieldName, SourceRelationshipSelection b Void UnpreparedValue) -> [Header] -> Maybe Name -> StringifyNumbers -> TraceQueryStatus -> m (DBStepInfo b, [ModelInfoPart])
data DBStepInfo (b :: BackendType)
DBStepInfo :: SourceName -> SourceConfig b -> Maybe (PreparedQuery b) -> OnBaseMonad (ExecutionMonad b) (ActionResult b) -> ResolvedConnectionTemplate b -> DBStepInfo (b :: BackendType)
[dbsiSourceName] :: DBStepInfo (b :: BackendType) -> SourceName
[dbsiSourceConfig] :: DBStepInfo (b :: BackendType) -> SourceConfig b
[dbsiPreparedQuery] :: DBStepInfo (b :: BackendType) -> Maybe (PreparedQuery b)
[dbsiAction] :: DBStepInfo (b :: BackendType) -> OnBaseMonad (ExecutionMonad b) (ActionResult b)
[dbsiResolvedConnectionTemplate] :: DBStepInfo (b :: BackendType) -> ResolvedConnectionTemplate b
data ActionResult (b :: BackendType)
ActionResult :: Maybe (ExecutionStatistics b) -> EncJSON -> ActionResult (b :: BackendType)
[arStatistics] :: ActionResult (b :: BackendType) -> Maybe (ExecutionStatistics b)
[arResult] :: ActionResult (b :: BackendType) -> EncJSON

-- | Lift a result from the database into an <a>ActionResult</a>.
withNoStatistics :: forall (b :: BackendType). EncJSON -> ActionResult b

-- | The series of steps that need to be executed for a given query. For
--   now, those steps are all independent. In the future, when we implement
--   a client-side dataloader and generalized joins, this will need to be
--   changed into an annotated tree.
type ExecutionPlan = RootFieldMap ExecutionStep

-- | One execution step to processing a GraphQL query (e.g. one root
--   field).
data ExecutionStep

-- | A query to execute against the database
[ExecStepDB] :: ResponseHeaders -> AnyBackend DBStepInfo -> Maybe RemoteJoins -> ExecutionStep

-- | Execute an action
[ExecStepAction] :: ActionExecutionPlan -> ActionsInfo -> Maybe RemoteJoins -> ExecutionStep

-- | A graphql query to execute against a remote schema
[ExecStepRemote] :: !RemoteSchemaInfo -> !ResultCustomizer -> !GQLReqOutgoing -> Maybe RemoteJoins -> ExecutionStep

-- | Output a plain JSON object
[ExecStepRaw] :: Value -> ExecutionStep
[ExecStepMulti] :: [ExecutionStep] -> ExecutionStep

-- | The result of an explain query: for a given root field (denoted by its
--   name): the generated SQL query, and the detailed explanation obtained
--   from the database (if any). We mostly use this type as an intermediary
--   step, and immediately tranform any value we obtain into an equivalent
--   JSON representation.
data ExplainPlan
ExplainPlan :: !RootFieldAlias -> !Maybe Text -> !Maybe [Text] -> ExplainPlan
[_fpField] :: ExplainPlan -> !RootFieldAlias
[_fpSql] :: ExplainPlan -> !Maybe Text
[_fpPlan] :: ExplainPlan -> !Maybe [Text]

-- | Provides an abstraction over the base monad in which a computation
--   runs.
--   
--   Given a transformer <tt>t</tt> and a type <tt>a</tt>, <tt>OnBaseMonad
--   t a</tt> represents a computation of type <tt>t m a</tt>, for any base
--   monad <tt>m</tt>. This allows <a>DBStepInfo</a> to store a
--   backend-specific computation, using a backend-specific monad
--   transformer, on top of the base app monad, without <a>DBStepInfo</a>
--   needing to know about the base monad <tt>m</tt>.
--   
--   However, this kind of type erasure forces us to bundle all of the
--   constraints on the base monad <tt>m</tt> here. The constraints here
--   are the union of the constraints required across all backends. If it
--   were possible to express constraint functions of the form <tt>(Type
--   -&gt; Type) -&gt; Constraint</tt> at the type level, we could make the
--   list of constraints a type family in <a>BackendExecute</a>, allowing
--   each backend to specify its own specific constraints; and we could
--   then provide the list of constraints as an additional argument to
--   <tt>OnBaseMonad</tt>, pushing the requirement to implement the union
--   of all constraints to the base execution functions.
--   
--   All backends require <tt>MonadError QErr</tt> to report errors, and
--   <a>MonadIO</a> to be able to communicate over the network. Most of
--   them require <a>MonadTrace</a> to be able to create new spans as part
--   of the execution, and several use <tt>MonadBaseControl IO</tt> to use
--   <tt>try</tt> in their error handling.
newtype OnBaseMonad (t :: Type -> Type -> Type -> Type) a
OnBaseMonad :: (forall (m :: Type -> Type). (Functor (t m), MonadIO m, MonadBaseControl IO m, MonadTrace m, MonadError QErr m) => t m a) -> OnBaseMonad (t :: (Type -> Type) -> Type -> Type) a
[runOnBaseMonad] :: OnBaseMonad (t :: (Type -> Type) -> Type -> Type) a -> forall (m :: Type -> Type). (Functor (t m), MonadIO m, MonadBaseControl IO m, MonadTrace m, MonadError QErr m) => t m a

-- | This is a helper function to convert a remote source's relationship to
--   a normal relationship to a temporary table. This function can be used
--   to implement executeRemoteRelationship function in databases which
--   support constructing a temporary table for a list of json objects.
convertRemoteSourceRelationship :: forall (b :: BackendType). Backend b => HashMap (ColumnPath b) (ColumnPath b) -> SelectFromG b (UnpreparedValue b) -> Column b -> ColumnType b -> (FieldName, SourceRelationshipSelection b Void UnpreparedValue) -> StringifyNumbers -> QueryDB b Void (UnpreparedValue b)
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Backend.ExplainPlan
instance GHC.Internal.Base.Functor (Hasura.GraphQL.Execute.Backend.OnBaseMonad t)
instance GHC.Internal.Generics.Generic Hasura.GraphQL.Execute.Backend.ExplainPlan
instance GHC.Internal.Show.Show Hasura.GraphQL.Execute.Backend.ExplainPlan
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Backend.ExplainPlan


-- | This module holds functions and data types used for logging at the
--   GraphQL layer. Unlike QueryLog, these are fired after queries are
--   finished so could include things like execution time in future.
module Hasura.GraphQL.Logging.ExecutionLog

-- | A GraphQL query, optionally generated SQL, and the request id makes up
--   the | <a>ExecutionLog</a>
data ExecutionLog
ExecutionLog :: !RequestId -> !Maybe (AnyBackend ExecutionStats) -> ExecutionLog
[_elRequestId] :: ExecutionLog -> !RequestId
[_elStatistics] :: ExecutionLog -> !Maybe (AnyBackend ExecutionStats)

-- | <a>ExecutionStatistics</a> is a type family, which means we can't
--   partially apply it (in <a>AnyBackend</a>, for example). To get round
--   this, we have a newtype that really just wraps the type family.
newtype ExecutionStats (b :: BackendType)
ExecutionStats :: ExecutionStatistics b -> ExecutionStats (b :: BackendType)

-- | When we want to log anything from <tt>DBStepInfo</tt>, we first need
--   to transform the backend-specific execution statistics into
--   <a>AnyBackend</a> statistics. This is fine in practice because all we
--   do with it is log it as JSON.
statsToAnyBackend :: forall (b :: BackendType). HasTag b => ActionResult b -> (Maybe (AnyBackend ExecutionStats), EncJSON)
class Monad m => MonadExecutionLog (m :: Type -> Type)
logExecutionLog :: MonadExecutionLog m => Logger Hasura -> ExecutionLog -> m ()
instance Hasura.GraphQL.Logging.ExecutionLog.MonadExecutionLog m => Hasura.GraphQL.Logging.ExecutionLog.MonadExecutionLog (Control.Monad.Trans.Except.ExceptT e m)
instance Hasura.GraphQL.Logging.ExecutionLog.MonadExecutionLog m => Hasura.GraphQL.Logging.ExecutionLog.MonadExecutionLog (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.GraphQL.Logging.ExecutionLog.MonadExecutionLog m => Hasura.GraphQL.Logging.ExecutionLog.MonadExecutionLog (Hasura.Tracing.Monad.TraceT m)
instance Hasura.Logging.ToEngineLog Hasura.GraphQL.Logging.ExecutionLog.ExecutionLog Hasura.Logging.Hasura
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Logging.ExecutionLog.ExecutionLog
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.GraphQL.Logging.ExecutionLog.ExecutionStats b)


-- | This module holds functions and data types used for logging at the
--   GraphQL layer. In contrast with, logging at the HTTP server layer.
module Hasura.GraphQL.Logging

module Hasura.GraphQL.Transport.Backend

-- | This typeclass enacapsulates how a given backend sends queries and
--   mutations over the network. Each backend is currently responsible for
--   both logging and tracing, for now.
class BackendExecute b => BackendTransport (b :: BackendType)
runDBQuery :: (BackendTransport b, MonadIO m, MonadBaseControl IO m, MonadError QErr m, MonadQueryLog m, MonadExecutionLog m, MonadTrace m) => RequestId -> GQLReqUnparsed -> RootFieldAlias -> UserInfo -> Logger Hasura -> Maybe (CredentialCache AgentLicenseKey) -> SourceConfig b -> OnBaseMonad (ExecutionMonad b) (Maybe (AnyBackend ExecutionStats), EncJSON) -> Maybe (PreparedQuery b) -> ResolvedConnectionTemplate b -> m (DiffTime, EncJSON)
runDBMutation :: (BackendTransport b, MonadIO m, MonadBaseControl IO m, MonadError QErr m, MonadQueryLog m, MonadTrace m) => RequestId -> GQLReqUnparsed -> RootFieldAlias -> UserInfo -> Logger Hasura -> Maybe (CredentialCache AgentLicenseKey) -> SourceConfig b -> OnBaseMonad (ExecutionMonad b) EncJSON -> Maybe (PreparedQuery b) -> ResolvedConnectionTemplate b -> m (DiffTime, EncJSON)
runDBSubscription :: (BackendTransport b, MonadIO m, MonadBaseControl IO m) => SourceConfig b -> MultiplexedQuery b -> [(CohortId, CohortVariables)] -> ResolvedConnectionTemplate b -> m (DiffTime, Either QErr [(CohortId, ByteString)])
runDBStreamingSubscription :: (BackendTransport b, MonadIO m, MonadBaseControl IO m) => SourceConfig b -> MultiplexedQuery b -> [(CohortId, CohortVariables)] -> ResolvedConnectionTemplate b -> m (DiffTime, Either QErr [(CohortId, ByteString, CursorVariableValues)])
runDBQueryExplain :: (BackendTransport b, MonadIO m, MonadError QErr m, MonadBaseControl IO m, MonadTrace m) => Maybe (CredentialCache AgentLicenseKey) -> DBStepInfo b -> m EncJSON

module Hasura.GraphQL.Execute.Subscription.Poll.StreamingQuery

-- | A single iteration of the streaming query polling loop. Invocations on
--   the same mutable objects may race.
pollStreamingQuery :: forall (b :: BackendType). BackendTransport b => PollerId -> TVar PollerResponseState -> SubscriptionsOptions -> (SourceName, SourceConfig b) -> RoleName -> ParameterizedQueryHash -> MultiplexedQuery b -> CohortMap 'Streaming -> Name -> SubscriptionPostPollHook -> Maybe (IO ()) -> PrometheusMetrics -> IO GranularPrometheusMetricsState -> TMap (Maybe OperationName) Int -> ResolvedConnectionTemplate b -> Maybe (Endo Value) -> Logger Hasura -> [ModelInfoPart] -> IO ModelInfoLogState -> IO ()


-- | Multiplexed subscription poller threads; see
--   <a>Hasura.GraphQL.Execute.Subscription</a> for details.
module Hasura.GraphQL.Execute.Subscription.Poll.LiveQuery

-- | Where the magic happens: the top-level action run periodically by each
--   active <a>Poller</a>. This needs to be async exception safe.
pollLiveQuery :: forall (b :: BackendType). BackendTransport b => PollerId -> TVar PollerResponseState -> SubscriptionsOptions -> (SourceName, SourceConfig b) -> RoleName -> ParameterizedQueryHash -> MultiplexedQuery b -> CohortMap 'LiveQuery -> SubscriptionPostPollHook -> PrometheusMetrics -> IO GranularPrometheusMetricsState -> TMap (Maybe OperationName) Int -> ResolvedConnectionTemplate b -> Maybe (Endo Value) -> Logger Hasura -> [ModelInfoPart] -> IO ModelInfoLogState -> IO ()


-- | Multiplexed subscription poller threads; see
--   <a>Hasura.GraphQL.Execute.Subscription</a> for details.
module Hasura.GraphQL.Execute.Subscription.Poll

-- | A unique, multiplexed query. Each <a>Poller</a> has its own polling
--   thread that periodically polls Postgres and pushes results to each of
--   its listening <a>Cohort</a>s.
--   
--   In SQL, an <a>Poller</a> corresponds to a single, multiplexed query,
--   though in practice, <a>Poller</a>s with large numbers of
--   <a>Cohort</a>s are batched into multiple concurrent queries for
--   performance reasons.
data Poller streamCursor
Poller :: CohortMap streamCursor -> TVar PollerResponseState -> TMVar PollerIOState -> ParameterizedQueryHash -> TMap (Maybe OperationName) Int -> Poller streamCursor
[_pCohorts] :: Poller streamCursor -> CohortMap streamCursor
[_pPollerState] :: Poller streamCursor -> TVar PollerResponseState

-- | This is in a separate <a>TMVar</a> because it’s important that we are
--   able to construct <a>Poller</a> values in <a>STM</a> --- we need the
--   insertion into the <a>PollerMap</a> to be atomic to ensure that we
--   don’t accidentally create two for the same query due to a race.
--   However, we can’t spawn the worker thread or create the metrics store
--   in <a>STM</a>, so we insert it into the <a>Poller</a> only after we’re
--   certain we won’t create any duplicates.
--   
--   This var is "write once", moving monotonically from empty to full.
--   TODO this could probably be tightened up to something like 'STM
--   PollerIOState'
[_pIOState] :: Poller streamCursor -> TMVar PollerIOState
[_pParameterizedQueryHash] :: Poller streamCursor -> ParameterizedQueryHash
[_pOperationNamesMap] :: Poller streamCursor -> TMap (Maybe OperationName) Int

-- | An ID to track unique <a>Poller</a>s, so that we can gather metrics
--   about each poller
newtype PollerId
PollerId :: UUID -> PollerId
[unPollerId] :: PollerId -> UUID
data PollerIOState
PollerIOState :: !Thread -> !PollerId -> PollerIOState

-- | a handle on the poller’s worker thread that can be used to <a>stop</a>
--   it if all its cohorts stop listening
[_pThread] :: PollerIOState -> !Thread
[_pId] :: PollerIOState -> !PollerId

-- | Where the magic happens: the top-level action run periodically by each
--   active <a>Poller</a>. This needs to be async exception safe.
pollLiveQuery :: forall (b :: BackendType). BackendTransport b => PollerId -> TVar PollerResponseState -> SubscriptionsOptions -> (SourceName, SourceConfig b) -> RoleName -> ParameterizedQueryHash -> MultiplexedQuery b -> CohortMap 'LiveQuery -> SubscriptionPostPollHook -> PrometheusMetrics -> IO GranularPrometheusMetricsState -> TMap (Maybe OperationName) Int -> ResolvedConnectionTemplate b -> Maybe (Endo Value) -> Logger Hasura -> [ModelInfoPart] -> IO ModelInfoLogState -> IO ()

-- | A single iteration of the streaming query polling loop. Invocations on
--   the same mutable objects may race.
pollStreamingQuery :: forall (b :: BackendType). BackendTransport b => PollerId -> TVar PollerResponseState -> SubscriptionsOptions -> (SourceName, SourceConfig b) -> RoleName -> ParameterizedQueryHash -> MultiplexedQuery b -> CohortMap 'Streaming -> Name -> SubscriptionPostPollHook -> Maybe (IO ()) -> PrometheusMetrics -> IO GranularPrometheusMetricsState -> TMap (Maybe OperationName) Int -> ResolvedConnectionTemplate b -> Maybe (Endo Value) -> Logger Hasura -> [ModelInfoPart] -> IO ModelInfoLogState -> IO ()
data PollerKey (b :: BackendType)
PollerKey :: SourceName -> RoleName -> Text -> ResolvedConnectionTemplate b -> ParameterizedQueryHash -> PollerKey (b :: BackendType)
[_lgSource] :: PollerKey (b :: BackendType) -> SourceName
[_lgRole] :: PollerKey (b :: BackendType) -> RoleName
[_lgQuery] :: PollerKey (b :: BackendType) -> Text
[_lgConnectionKey] :: PollerKey (b :: BackendType) -> ResolvedConnectionTemplate b
[_lgParameterizedQueryHash] :: PollerKey (b :: BackendType) -> ParameterizedQueryHash
newtype BackendPollerKey
BackendPollerKey :: AnyBackend PollerKey -> BackendPollerKey
[unBackendPollerKey] :: BackendPollerKey -> AnyBackend PollerKey
type PollerMap streamCursor = Map BackendPollerKey Poller streamCursor

-- | For dev debugging, output subject to change.
dumpPollerMap :: Bool -> PollerMap streamCursor -> IO Value
data PollDetails
PollDetails :: PollerId -> SubscriptionType -> Text -> DiffTime -> [BatchExecutionDetails] -> DiffTime -> SubscriptionsOptions -> SourceName -> RoleName -> ParameterizedQueryHash -> LogLevel -> Maybe [PollDetailsError] -> PollDetails

-- | the unique ID (basically a thread that run as a <a>Poller</a>) for the
--   <a>Poller</a>
[_pdPollerId] :: PollDetails -> PollerId

-- | distinguish between the subscription type (i.e. live-query or
--   streaming subscription)
[_pdKind] :: PollDetails -> SubscriptionType

-- | the multiplexed SQL query to be run against the database with all the
--   variables together
[_pdGeneratedSql] :: PollDetails -> Text

-- | the time taken to get a snapshot of cohorts from our
--   <tt>SubscriptionsState</tt> data structure
[_pdSnapshotTime] :: PollDetails -> DiffTime

-- | list of execution batches and their details
[_pdBatches] :: PollDetails -> [BatchExecutionDetails]

-- | total time spent on a poll cycle
[_pdTotalTime] :: PollDetails -> DiffTime
[_pdLiveQueryOptions] :: PollDetails -> SubscriptionsOptions
[_pdSource] :: PollDetails -> SourceName
[_pdRole] :: PollDetails -> RoleName
[_pdParameterizedQueryHash] :: PollDetails -> ParameterizedQueryHash
[_pdLogLevel] :: PollDetails -> LogLevel
[_pdErrors] :: PollDetails -> Maybe [PollDetailsError]

-- | Execution information related to a single batched execution
data BatchExecutionDetails
BatchExecutionDetails :: Maybe DiffTime -> DiffTime -> DiffTime -> BatchId -> [CohortExecutionDetails] -> Maybe Int -> BatchExecutionDetails

-- | postgres execution time of each batch (<a>Nothing</a> in case of
--   non-PG dbs)
[_bedPgExecutionTime] :: BatchExecutionDetails -> Maybe DiffTime

-- | database execution time of each batch
[_bedDbExecutionTime] :: BatchExecutionDetails -> DiffTime

-- | time to taken to push to all cohorts belonging to this batch
[_bedPushTime] :: BatchExecutionDetails -> DiffTime

-- | id of the batch
[_bedBatchId] :: BatchExecutionDetails -> BatchId

-- | execution details of the cohorts belonging to this batch
[_bedCohorts] :: BatchExecutionDetails -> [CohortExecutionDetails]
[_bedBatchResponseSizeBytes] :: BatchExecutionDetails -> Maybe Int

-- | Execution information related to a cohort on a poll cycle
data CohortExecutionDetails
CohortExecutionDetails :: !CohortId -> !CohortVariables -> !Maybe Int -> ![SubscriberExecutionDetails] -> ![SubscriberExecutionDetails] -> !BatchId -> CohortExecutionDetails
[_cedCohortId] :: CohortExecutionDetails -> !CohortId
[_cedVariables] :: CohortExecutionDetails -> !CohortVariables

-- | Nothing in case of an error
[_cedResponseSize] :: CohortExecutionDetails -> !Maybe Int

-- | The response on this cycle has been pushed to these above subscribers
--   New subscribers (those which haven't been around during the previous
--   poll cycle) will always be part of this
[_cedPushedTo] :: CohortExecutionDetails -> ![SubscriberExecutionDetails]

-- | The response on this cycle has *not* been pushed to these above
--   subscribers. This would when the response hasn't changed from the
--   previous polled cycle
[_cedIgnored] :: CohortExecutionDetails -> ![SubscriberExecutionDetails]
[_cedBatchId] :: CohortExecutionDetails -> !BatchId
type SubscriptionPostPollHook = PollDetails -> IO ()
defaultSubscriptionPostPollHook :: Logger Hasura -> SubscriptionPostPollHook

-- | A batched group of <a>Subscriber</a>s who are not only listening to
--   the same query but also have identical session and query variables.
--   Each result pushed to a <a>Cohort</a> is forwarded along to each of
--   its <a>Subscriber</a>s.
--   
--   In SQL, each <a>Cohort</a> corresponds to a single row in the
--   laterally-joined <tt>_subs</tt> table (and therefore a single row in
--   the query result).
--   
--   See also <a>CohortMap</a>.
data Cohort streamCursorVars
Cohort :: CohortId -> TVar (Maybe ResponseHash) -> SubscriberMap -> SubscriberMap -> streamCursorVars -> Cohort streamCursorVars

-- | a unique identifier used to identify the cohort in the generated query
[_cCohortId] :: Cohort streamCursorVars -> CohortId

-- | Contains a hash of the previous poll's DB query result, if any, used
--   to determine if we need to push an updated result to the subscribers
--   or not.
[_cPreviousResponse] :: Cohort streamCursorVars -> TVar (Maybe ResponseHash)

-- | the subscribers we’ve already pushed a result to; we push new results
--   to them if the response changes
[_cExistingSubscribers] :: Cohort streamCursorVars -> SubscriberMap

-- | subscribers we haven’t yet pushed any results to; we push results to
--   them regardless if the result changed, then merge them in the map of
--   existing subscribers
[_cNewSubscribers] :: Cohort streamCursorVars -> SubscriberMap

-- | a mutable type which holds the latest value of the subscription stream
--   cursor. In case of live query subscription, this field is ignored by
--   setting <tt>streamCursorVars</tt> to <tt>()</tt>
[_cStreamCursorVariables] :: Cohort streamCursorVars -> streamCursorVars
data CohortId
newCohortId :: MonadIO m => m CohortId
data CohortVariables

-- | A key we use to determine if two <a>Subscriber</a>s belong in the same
--   <a>Cohort</a> (assuming they already meet the criteria to be in the
--   same <a>Poller</a>). Note the distinction between this and
--   <a>CohortId</a>; the latter is a completely synthetic key used only to
--   identify the cohort in the generated SQL query.
type CohortKey = CohortVariables

-- | This has the invariant, maintained in <tt>removeLiveQuery</tt>, that
--   it contains no <a>Cohort</a> with zero total (existing + new)
--   subscribers.
type CohortMap streamCursor = TMap CohortKey Cohort streamCursor
data Subscriber
Subscriber :: !SubscriberId -> !SubscriberMetadata -> !RequestId -> !Maybe OperationName -> !OnChange -> Subscriber
[_sId] :: Subscriber -> !SubscriberId
[_sMetadata] :: Subscriber -> !SubscriberMetadata
[_sRequestId] :: Subscriber -> !RequestId
[_sOperationName] :: Subscriber -> !Maybe OperationName
[_sOnChangeCallback] :: Subscriber -> !OnChange
data SubscriberId
newSubscriberId :: IO SubscriberId

-- | Allows a user of the live query subsystem (currently websocket
--   transport) to attach arbitrary metadata about a subscriber. This
--   information is available as part of Subscriber in
--   CohortExecutionDetails and can be logged by customizing in pollerlog
data SubscriberMetadata
mkSubscriberMetadata :: WSId -> OperationId -> Maybe OperationName -> RequestId -> SubscriberMetadata
unSubscriberMetadata :: SubscriberMetadata -> Value
type SubscriberMap = TMap SubscriberId Subscriber
type OnChange = SubscriptionGQResponse -> IO ()
type SubscriptionGQResponse = GQResult SubscriptionResponse
data SubscriptionResponse
SubscriptionResponse :: !ByteString -> !DiffTime -> SubscriptionResponse
[_lqrPayload] :: SubscriptionResponse -> !ByteString
[_lqrExecutionTime] :: SubscriptionResponse -> !DiffTime

-- | Subscription onChange metadata, used for adding more extra analytics
--   data
data SubscriptionMetadata
SubscriptionMetadata :: !DiffTime -> SubscriptionMetadata
[_sqmExecutionTime] :: SubscriptionMetadata -> !DiffTime
data SubscriberExecutionDetails
SubscriberExecutionDetails :: !SubscriberId -> !SubscriberMetadata -> SubscriberExecutionDetails
[_sedSubscriberId] :: SubscriberExecutionDetails -> !SubscriberId
[_sedSubscriberMetadata] :: SubscriberExecutionDetails -> !SubscriberMetadata

-- | The <tt>BatchId</tt> is a number based ID to uniquely identify a batch
--   in a single poll and it's used to identify the batch to which a cohort
--   belongs to.
newtype BatchId
BatchId :: Int -> BatchId
[_unBatchId] :: BatchId -> Int


-- | Top-level management of subscription poller threads. The
--   implementation of the polling itself is in
--   <a>Hasura.GraphQL.Execute.Subscription.Poll</a>. See
--   <a>Hasura.GraphQL.Execute.Subscription</a> for high-level details.
module Hasura.GraphQL.Execute.Subscription.State

-- | The top-level datatype that holds the state for all active
--   subscriptions.
--   
--   NOTE!: This must be kept consistent with a websocket connection's
--   <tt>OperationMap</tt>, in <tt>onClose</tt> and <tt>onStart</tt>.
data SubscriptionsState
SubscriptionsState :: PollerMap () -> PollerMap (TVar CursorVariableValues) -> SubscriptionPostPollHook -> AsyncActionSubscriptionState -> SubscriptionsState
[_ssLiveQueryMap] :: SubscriptionsState -> PollerMap ()
[_ssStreamQueryMap] :: SubscriptionsState -> PollerMap (TVar CursorVariableValues)

-- | A hook function which is run after each fetch cycle
[_ssPostPollHook] :: SubscriptionsState -> SubscriptionPostPollHook
[_ssAsyncActions] :: SubscriptionsState -> AsyncActionSubscriptionState
initSubscriptionsState :: SubscriptionPostPollHook -> IO SubscriptionsState

-- | For dev debugging, output subject to change.
dumpSubscriptionsState :: Bool -> LiveQueriesOptions -> StreamQueriesOptions -> SubscriptionsState -> IO Value

-- | SubscriberDetails contains the data required to locate a subscriber in
--   the correct cohort within the correct poller in the operation map.
data SubscriberDetails a
type SubscriptionPostPollHook = PollDetails -> IO ()

-- | Fork a thread handling a regular (live query) subscription
addLiveQuery :: forall (b :: BackendType). BackendTransport b => Logger Hasura -> ServerMetrics -> PrometheusMetrics -> SubscriberMetadata -> SubscriptionsState -> IO (LiveQueriesOptions, StreamQueriesOptions) -> SourceName -> ParameterizedQueryHash -> Maybe OperationName -> RequestId -> SubscriptionQueryPlan b (MultiplexedQuery b) -> IO GranularPrometheusMetricsState -> OnChange -> Maybe (Endo Value) -> [ModelInfoPart] -> IO ModelInfoLogState -> IO LiveQuerySubscriberDetails

-- | Fork a thread handling a streaming subscription
addStreamSubscriptionQuery :: forall (b :: BackendType). BackendTransport b => Logger Hasura -> ServerMetrics -> PrometheusMetrics -> SubscriberMetadata -> SubscriptionsState -> IO (LiveQueriesOptions, StreamQueriesOptions) -> SourceName -> ParameterizedQueryHash -> Maybe OperationName -> RequestId -> Name -> SubscriptionQueryPlan b (MultiplexedQuery b) -> IO GranularPrometheusMetricsState -> OnChange -> Maybe (Endo Value) -> [ModelInfoPart] -> IO ModelInfoLogState -> IO StreamingSubscriberDetails
removeLiveQuery :: Logger Hasura -> ServerMetrics -> PrometheusMetrics -> SubscriptionsState -> LiveQuerySubscriberDetails -> IO GranularPrometheusMetricsState -> Maybe OperationName -> IO ()
removeStreamingQuery :: Logger Hasura -> ServerMetrics -> PrometheusMetrics -> SubscriptionsState -> StreamingSubscriberDetails -> IO GranularPrometheusMetricsState -> Maybe OperationName -> IO ()

-- | An async action query whose relationships are referred to table in a
--   source. We need to generate an SQL statement with the action response
--   and execute it in the source database so as to fetch response joined
--   with relationship rows. For more details see Note [Resolving async
--   action query]
data LiveAsyncActionQueryOnSource
LiveAsyncActionQueryOnSource :: !LiveQuerySubscriberDetails -> !ActionLogResponseMap -> !LiveQuerySubscriberDetails -> ActionLogResponseMap -> IO (Maybe LiveQuerySubscriberDetails) -> LiveAsyncActionQueryOnSource
[_laaqpCurrentLqId] :: LiveAsyncActionQueryOnSource -> !LiveQuerySubscriberDetails
[_laaqpPrevActionLogMap] :: LiveAsyncActionQueryOnSource -> !ActionLogResponseMap

-- | An IO action to restart the live query poller with updated action log
--   responses fetched from metadata storage Restarting a live query
--   re-generates the SQL statement with new action log responses to send
--   latest action response to the client.
[_laaqpRestartLq] :: LiveAsyncActionQueryOnSource -> !LiveQuerySubscriberDetails -> ActionLogResponseMap -> IO (Maybe LiveQuerySubscriberDetails)
data LiveAsyncActionQueryWithNoRelationships
LiveAsyncActionQueryWithNoRelationships :: !ActionLogResponseMap -> IO () -> !IO () -> LiveAsyncActionQueryWithNoRelationships

-- | An IO action to send response to the websocket client
[_laaqwnrSendResponse] :: LiveAsyncActionQueryWithNoRelationships -> !ActionLogResponseMap -> IO ()

-- | An IO action to send "completed" message to the websocket client
[_laaqwnrSendCompleted] :: LiveAsyncActionQueryWithNoRelationships -> !IO ()
data LiveAsyncActionQuery
LAAQNoRelationships :: LiveAsyncActionQueryWithNoRelationships -> LiveAsyncActionQuery
LAAQOnSourceDB :: LiveAsyncActionQueryOnSource -> LiveAsyncActionQuery
data AsyncActionQueryLive
AsyncActionQueryLive :: NonEmpty ActionId -> (QErr -> IO ()) -> LiveAsyncActionQuery -> AsyncActionQueryLive
[_aaqlActionIds] :: AsyncActionQueryLive -> NonEmpty ActionId

-- | An IO action to send error message (in case of any exception) to the
--   websocket client
[_aaqlOnException] :: AsyncActionQueryLive -> QErr -> IO ()
[_aaqlLiveExecution] :: AsyncActionQueryLive -> LiveAsyncActionQuery

-- | A share-able state map which stores an async action live query with
--   it's subscription operation id
type AsyncActionSubscriptionState = TMap OperationId AsyncActionQueryLive
addAsyncActionLiveQuery :: AsyncActionSubscriptionState -> OperationId -> NonEmpty ActionId -> (QErr -> IO ()) -> LiveAsyncActionQuery -> IO ()
removeAsyncActionLiveQuery :: AsyncActionSubscriptionState -> OperationId -> IO ()
type LiveQuerySubscriberDetails = SubscriberDetails CohortKey

-- | The <a>CohortKey</a> contains the variables with which the
--   subscription was started and which will remain unchanged. The second
--   type contains the mutable reference through which we can get the
--   latest value of the cursor and using both the <a>CohortKey</a> and the
--   latest cursor value, we locate the subscriber in the operation map to
--   find its details and then stop it.
type StreamingSubscriberDetails = SubscriberDetails (CohortKey, TVar CursorVariableValues)
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (Hasura.GraphQL.Execute.Subscription.State.SubscriberDetails a)

module Hasura.GraphQL.Execute.Remote
buildExecStepRemote :: RemoteSchemaInfo -> ResultCustomizer -> OperationType -> GraphQLField Void Variable -> Maybe RemoteJoins -> Maybe OperationName -> ExecutionStep
getVariableDefinitionAndValue :: Variable -> (VariableDefinition, (Name, Value))

-- | Resolves a <a>RemoteSchemaVariable</a> into a GraphQL <a>Variable</a>.
--   
--   A <a>RemoteSchemaVariable</a> can either be a query variable (i.e. a
--   variable provided in the query) or it can be a
--   <a>SessionPresetVariable</a> (in which case we look up the value of
--   the session variable and coerce it into the appropriate type and then
--   construct the GraphQL <a>Variable</a>).
--   
--   NOTE: The session variable preset is a hard preset (i.e. if the
--   session variable doesn't exist, an error will be thrown).
--   
--   The name of the GraphQL variable generated will be a GraphQL-ized
--   version of the session variable (i.e. <a>-</a> will be replaced with
--   '_'), since session variables are not valid GraphQL names.
--   
--   Additionally, we need to handle partially traversed JSON values;
--   likewise, we create a new variable out of thin air.
--   
--   For example, considering the following schema for a role:
--   
--   input UserName { firstName : String! @preset(value:<a>Foo</a>)
--   lastName : String! }
--   
--   type Query { user( user_id: Int! @preset(value:"x-hasura-user-id")
--   user_name: UserName! ): User }
--   
--   and the incoming query to the graphql-engine is:
--   
--   query($foo: UserName!) { user(user_name: $foo) { id name } }
--   
--   with variables:
--   
--   { "foo": {"lastName": <a>Bar</a>} }
--   
--   After resolving the session argument presets, the query that will be
--   sent to the remote server will be:
--   
--   query ($x_hasura_user_id: Int!, $hasura_json_var_1: String!) { user
--   (user_id: $x_hasura_user_id, user_name: {firstName: <a>Foo</a>,
--   lastName: $hasura_json_var_1}) { id name } }
resolveRemoteVariable :: forall (m :: Type -> Type). MonadError QErr m => UserInfo -> RemoteSchemaVariable -> StateT RemoteJSONVariableMap m Variable

-- | TODO: Documentation.
resolveRemoteField :: forall (m :: Type -> Type) r. MonadError QErr m => UserInfo -> RemoteSchemaRootField r RemoteSchemaVariable -> StateT RemoteJSONVariableMap m (RemoteSchemaRootField r Variable)

-- | TODO: Documentation.
runVariableCache :: Monad m => StateT RemoteJSONVariableMap m a -> m a
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Remote.RemoteJSONVariableKey
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Remote.RemoteJSONVariableMap
instance GHC.Internal.Generics.Generic Hasura.GraphQL.Execute.Remote.RemoteJSONVariableKey
instance Data.Hashable.Class.Hashable Hasura.GraphQL.Execute.Remote.RemoteJSONVariableKey
instance GHC.Internal.Base.Monoid Hasura.GraphQL.Execute.Remote.RemoteJSONVariableMap
instance GHC.Internal.Base.Semigroup Hasura.GraphQL.Execute.Remote.RemoteJSONVariableMap


-- | How to construct and execute a call to a remote schema for a remote
--   join.
--   
--   There are three steps required to do this: 1. construct the call:
--   given the requested fields, the phantom fields, the values extracted
--   by the LHS, construct a GraphQL query 2. execute that GraphQL query
--   over the network 3. build a index of the variables out of the response
--   
--   This can be done as one function, but we also export the individual
--   steps for debugging / test purposes. We congregate all intermediary
--   state in the opaque <a>RemoteSchemaCall</a> type.
module Hasura.GraphQL.Execute.RemoteJoin.RemoteSchema

-- | Construct and execute a call to a remote schema for a remote join.
makeRemoteSchemaJoinCall :: (MonadError QErr m, MonadTrace m, MonadIO m) => (GQLReqOutgoing -> m ByteString) -> UserInfo -> RemoteSchemaJoin -> FieldName -> IntMap JoinArgument -> m (Maybe (IntMap Value))

-- | Intermediate type containing all of the information required to
--   perform a remote schema call, constructed from the static join
--   information.
data RemoteSchemaCall

-- | Constructs a <a>RemoteSchemaCall</a> from some static information,
--   such as the definition of the join, and dynamic information such as
--   the user's information and the map of join arguments.
buildRemoteSchemaCall :: MonadError QErr m => RemoteSchemaJoin -> IntMap JoinArgument -> UserInfo -> m (Maybe RemoteSchemaCall)

-- | Sends the call over the network, and parse the resulting ByteString.
executeRemoteSchemaCall :: MonadError QErr m => (GQLReqOutgoing -> m ByteString) -> RemoteSchemaCall -> m Object

-- | Construct a join index from the remote source's <a>Value</a> response.
--   
--   This function extracts from the <tt>RemoteJoinCall</tt> a mapping from
--   <a>JoinArgumentId</a> to <a>ResponsePath</a>: from an integer that
--   uniquely identifies a join argument to the "path" at which we expect
--   that value in the response. With it, and with the actual reponse JSON
--   value obtained from the remote server, it constructs a corresponding
--   mapping of, for each argument, its extracted value.
--   
--   If the response does not have value at any of the provided
--   <a>ResponsePath</a>s, throw a generic <a>QErr</a>.
--   
--   NOTE(jkachmar): If we switch to an <a>Applicative</a> validator, we
--   can collect more than one missing <a>ResponsePath</a>s (rather than
--   short-circuiting on the first missing value).
buildJoinIndex :: MonadError QErr m => RemoteSchemaCall -> Object -> m (IntMap Value)
instance GHC.Classes.Eq Hasura.GraphQL.Execute.RemoteJoin.RemoteSchema.ResponsePath
instance GHC.Internal.Show.Show Hasura.GraphQL.Execute.RemoteJoin.RemoteSchema.ResponsePath

module Hasura.GraphQL.Execute.Common

-- | Typeclass representing safety checks (if any) that need to be
--   performed before a GraphQL query should be allowed to be executed. In
--   OSS, the safety check is to check in the query is in the allow list.
--   
--   the <a>executeIntrospection</a> function has different implementations
--   in OSS and Pro. In Pro, the GraphQL schema introspection can be
--   disabled for specified roles and in OSS there is no restrictions.
--   
--   | TODO (from master): Limitation: This parses the query, which is not
--   ideal if we already have the query cached. The parsing happens
--   unnecessary. But getting this to either return a plan or parse was
--   tricky and complicated.
class Monad m => MonadGQLExecutionCheck (m :: Type -> Type)
checkGQLExecution :: MonadGQLExecutionCheck m => UserInfo -> ([Header], IpAddress) -> AllowListStatus -> SchemaCache -> GQLReqUnparsed -> RequestId -> m (Either QErr GQLReqParsed)
executeIntrospection :: MonadGQLExecutionCheck m => UserInfo -> Value -> SetGraphqlIntrospectionOptions -> m (Either QErr ExecutionStep)
checkGQLBatchedReqs :: MonadGQLExecutionCheck m => UserInfo -> RequestId -> [GQLReq GQLQueryText] -> SchemaCache -> m (Either QErr ())
instance Hasura.GraphQL.Execute.Common.MonadGQLExecutionCheck m => Hasura.GraphQL.Execute.Common.MonadGQLExecutionCheck (Control.Monad.Trans.Except.ExceptT e m)
instance Hasura.GraphQL.Execute.Common.MonadGQLExecutionCheck m => Hasura.GraphQL.Execute.Common.MonadGQLExecutionCheck (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.GraphQL.Execute.Common.MonadGQLExecutionCheck m => Hasura.GraphQL.Execute.Common.MonadGQLExecutionCheck (Hasura.Tracing.Monad.TraceT m)


-- | Postgres Execute Prepare
--   
--   Deals with translating (session) variables to SQL expressions. Uses a
--   state monad to keep track of things like variables and generating
--   fresh variable names.
--   
--   See <a>Execute</a>.
module Hasura.Backends.Postgres.Execute.Prepare
type PlanVariables = HashMap PlanVariable Int

-- | The value is (PG.PrepArg, PGScalarValue) because we want to log the
--   human-readable value of the prepared argument and not the binary
--   encoding in PG format
type PrepArgMap = IntMap (PrepArg, PGScalarValue)
data PlanningSt
PlanningSt :: Int -> PlanVariables -> PrepArgMap -> PlanningSt
[_psArgNumber] :: PlanningSt -> Int
[_psVariables] :: PlanningSt -> PlanVariables
[_psPrepped] :: PlanningSt -> PrepArgMap

-- | The series of steps that need to be executed for a given query. For
--   now, those steps are all independent. In the future, when we implement
--   a client-side dataloader and generalized joins, this will need to be
--   changed into an annotated tree.
type ExecutionPlan = RootFieldMap ExecutionStep

-- | One execution step to processing a GraphQL query (e.g. one root
--   field).
data ExecutionStep

-- | A query to execute against the database
[ExecStepDB] :: ResponseHeaders -> AnyBackend DBStepInfo -> Maybe RemoteJoins -> ExecutionStep

-- | Execute an action
[ExecStepAction] :: ActionExecutionPlan -> ActionsInfo -> Maybe RemoteJoins -> ExecutionStep

-- | A graphql query to execute against a remote schema
[ExecStepRemote] :: !RemoteSchemaInfo -> !ResultCustomizer -> !GQLReqOutgoing -> Maybe RemoteJoins -> ExecutionStep

-- | Output a plain JSON object
[ExecStepRaw] :: Value -> ExecutionStep
[ExecStepMulti] :: [ExecutionStep] -> ExecutionStep
initPlanningSt :: PlanningSt

-- | If we're preparing a value with planning state, we favour referring to
--   values by their prepared argument index. If the value refers to a
--   session value, we look for it in prepared value (1) and access the
--   particular keys using the JSONB <tt>-&gt;&gt;</tt> accessor.
prepareWithPlan :: forall m (pgKind :: PostgresKind). (MonadState PlanningSt m, MonadError QErr m) => UserInfo -> UnpreparedValue ('Postgres pgKind) -> m SQLExp

-- | If we're <i>not</i> using a prepared statement, substitution is pretty
--   naïve: we resolve session variable names, ignore parameter names, and
--   substitute into the <a>SQLExp</a>.
prepareWithoutPlan :: forall m (pgKind :: PostgresKind). MonadError QErr m => UserInfo -> UnpreparedValue ('Postgres pgKind) -> m SQLExp

-- | The map of user session variables is always given the number (1) as
--   its variable argument number (see <a>getVarArgNum</a>). If we want to
--   refer to a particular variable in this map, we use JSONB functions to
--   interrogate variable (1).
withUserVars :: SessionVariables -> PrepArgMap -> PrepArgMap
instance GHC.Classes.Eq Hasura.Backends.Postgres.Execute.Prepare.PlanVariable
instance GHC.Classes.Eq Hasura.Backends.Postgres.Execute.Prepare.PlanningSt
instance GHC.Internal.Generics.Generic Hasura.Backends.Postgres.Execute.Prepare.PlanVariable
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Execute.Prepare.PlanVariable
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Execute.Prepare.PlanVariable
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Execute.Prepare.PlanningSt


-- | Postgres Instances Execute
--   
--   This module implements the needed functionality for implementing a
--   <a>BackendExecute</a> instance for Postgres, which defines an
--   interface for translating a root field into an execution plan and
--   interacting with a database.
--   
--   This module includes the Postgres implementation of queries,
--   mutations, and more.
module Hasura.Backends.Postgres.Instances.Execute
data PreparedSql
PreparedSql :: Query -> PrepArgMap -> PreparedSql
[_psQuery] :: PreparedSql -> Query
[_psPrepArgs] :: PreparedSql -> PrepArgMap
instance (Hasura.RQL.Types.Backend.Backend ('Hasura.RQL.Types.BackendType.Postgres pgKind), Hasura.Backends.Postgres.Translate.Select.PostgresTranslateSelect pgKind) => Hasura.GraphQL.Execute.Backend.BackendExecute ('Hasura.RQL.Types.BackendType.Postgres pgKind)
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.Instances.Execute.PreparedSql


-- | Postgres Instances Transport
--   
--   Defines the MSSQL instance of <a>BackendTransport</a> and how to
--   interact with the database for running queries, mutations,
--   subscriptions, and so on.
module Hasura.Backends.Postgres.Instances.Transport
runPGMutationTransaction :: forall (pgKind :: PostgresKind) m. (HasTag ('Postgres pgKind), MonadIO m, MonadBaseControl IO m, MonadError QErr m, MonadQueryLog m, MonadTrace m) => RequestId -> GQLReqUnparsed -> UserInfo -> Logger Hasura -> SourceConfig ('Postgres pgKind) -> ResolvedConnectionTemplate ('Postgres pgKind) -> RootFieldMap (DBStepInfo ('Postgres pgKind)) -> m (DiffTime, RootFieldMap EncJSON)
instance (Hasura.RQL.Types.Backend.Backend ('Hasura.RQL.Types.BackendType.Postgres pgKind), Hasura.Backends.Postgres.Translate.Select.PostgresTranslateSelect pgKind) => Hasura.GraphQL.Transport.Backend.BackendTransport ('Hasura.RQL.Types.BackendType.Postgres pgKind)


-- | Responsible for translating and building an MSSQL execution plan for
--   update mutations.
--   
--   This module is used by <a>Hasura.Backends.MSSQL.Instances.Execute</a>.
module Hasura.Backends.MSSQL.Execute.Update

-- | Executes an Update IR AST and return results as JSON.
executeUpdate :: (MonadError QErr m, MonadReader QueryTagsComment m) => UserInfo -> StringifyNumbers -> SourceName -> ModelSourceType -> SourceConfig 'MSSQL -> AnnotatedUpdateG 'MSSQL Void (UnpreparedValue 'MSSQL) -> m (OnBaseMonad (ExceptT QErr) EncJSON, [ModelNameInfo])


-- | Responsible for translating and building an MSSQL execution plan for
--   delete mutations.
--   
--   This module is used by <a>Hasura.Backends.MSSQL.Instances.Execute</a>.
module Hasura.Backends.MSSQL.Execute.Insert

-- | Execute and insert/upsert mutation against MS SQL Server. See the
--   documentation for <a>buildInsertTx</a> to see how it's done.
executeInsert :: (MonadError QErr m, MonadReader QueryTagsComment m) => UserInfo -> StringifyNumbers -> SourceName -> ModelSourceType -> SourceConfig 'MSSQL -> AnnotatedInsert 'MSSQL Void (UnpreparedValue 'MSSQL) -> m (OnBaseMonad (ExceptT QErr) EncJSON, [ModelNameInfo])


-- | Responsible for translating and building an MSSQL execution plan for
--   delete mutations.
--   
--   This module is used by <a>Hasura.Backends.MSSQL.Instances.Execute</a>.
module Hasura.Backends.MSSQL.Execute.Delete

-- | Executes a Delete IR AST and return results as JSON.
executeDelete :: (MonadError QErr m, MonadReader QueryTagsComment m) => UserInfo -> StringifyNumbers -> SourceName -> ModelSourceType -> SourceConfig 'MSSQL -> AnnDelG 'MSSQL Void (UnpreparedValue 'MSSQL) -> m (OnBaseMonad (ExceptT QErr) EncJSON, [ModelNameInfo])

module Hasura.Backends.BigQuery.Instances.Execute
instance Hasura.GraphQL.Execute.Backend.BackendExecute 'Hasura.RQL.Types.BackendType.BigQuery

module Hasura.RemoteSchema.MetadataAPI.Core

-- | The payload for <tt>add_remote_schema</tt>, and a component of
--   <a>Metadata</a>.
data AddRemoteSchemaQuery
AddRemoteSchemaQuery :: RemoteSchemaName -> RemoteSchemaDef -> Maybe Text -> AddRemoteSchemaQuery

-- | An internal identifier for this remote schema.
[_arsqName] :: AddRemoteSchemaQuery -> RemoteSchemaName
[_arsqDefinition] :: AddRemoteSchemaQuery -> RemoteSchemaDef

-- | An opaque description or comment. We might display this in the UI, for
--   instance.
[_arsqComment] :: AddRemoteSchemaQuery -> Maybe Text
newtype RemoteSchemaNameQuery
RemoteSchemaNameQuery :: RemoteSchemaName -> RemoteSchemaNameQuery
[_rsnqName] :: RemoteSchemaNameQuery -> RemoteSchemaName
runAddRemoteSchema :: (QErrM m, CacheRWM m, MonadIO m, ProvidesNetwork m, MetadataM m, MonadTrace m) => Environment -> SchemaSampledFeatureFlags -> AddRemoteSchemaQuery -> m EncJSON
runRemoveRemoteSchema :: (QErrM m, UserInfoM m, CacheRWM m, MetadataM m) => RemoteSchemaNameQuery -> m EncJSON
dropRemoteSchemaInMetadata :: RemoteSchemaName -> MetadataModifier
runReloadRemoteSchema :: (QErrM m, CacheRWM m, MetadataM m) => RemoteSchemaNameQuery -> m EncJSON
runIntrospectRemoteSchema :: (CacheRM m, QErrM m) => RemoteSchemaNameQuery -> m EncJSON
dropRemoteSchemaPermissionInMetadata :: RemoteSchemaName -> RoleName -> MetadataModifier
dropRemoteSchemaRemoteRelationshipInMetadata :: RemoteSchemaName -> Name -> RelName -> MetadataModifier
runUpdateRemoteSchema :: (QErrM m, CacheRWM m, MonadIO m, ProvidesNetwork m, MetadataM m, MonadTrace m) => Environment -> SchemaSampledFeatureFlags -> AddRemoteSchemaQuery -> m EncJSON
instance GHC.Classes.Eq Hasura.RemoteSchema.MetadataAPI.Core.AddRemoteSchemaQuery
instance GHC.Classes.Eq Hasura.RemoteSchema.MetadataAPI.Core.RemoteSchemaNameQuery
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RemoteSchema.MetadataAPI.Core.AddRemoteSchemaQuery
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RemoteSchema.MetadataAPI.Core.RemoteSchemaNameQuery
instance GHC.Internal.Generics.Generic Hasura.RemoteSchema.MetadataAPI.Core.AddRemoteSchemaQuery
instance GHC.Internal.Generics.Generic Hasura.RemoteSchema.MetadataAPI.Core.RemoteSchemaNameQuery
instance Control.DeepSeq.NFData Hasura.RemoteSchema.MetadataAPI.Core.AddRemoteSchemaQuery
instance GHC.Internal.Show.Show Hasura.RemoteSchema.MetadataAPI.Core.AddRemoteSchemaQuery
instance GHC.Internal.Show.Show Hasura.RemoteSchema.MetadataAPI.Core.RemoteSchemaNameQuery
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RemoteSchema.MetadataAPI.Core.AddRemoteSchemaQuery
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RemoteSchema.MetadataAPI.Core.RemoteSchemaNameQuery

module Hasura.RemoteSchema.MetadataAPI

module Hasura.RQL.DDL.Schema.Cache.Dependencies

-- | Processes collected <tt>CIDependency</tt> values into a <a>DepMap</a>,
--   performing integrity checking to ensure the dependencies actually
--   exist. If a dependency is missing, its transitive dependents are
--   removed from the cache, and <a>InconsistentMetadata</a>s are returned.
resolveDependencies :: forall (m :: Type -> Type) arr. (ArrowKleisli m arr, QErrM m) => arr (BuildOutputs, [MetadataDependency]) (BuildOutputs, [InconsistentMetadata], DepMap)

module Hasura.RQL.DDL.GraphqlSchemaIntrospection
runSetGraphqlSchemaIntrospectionOptions :: (MonadError QErr m, MetadataM m, CacheRWM m) => SetGraphqlIntrospectionOptions -> m EncJSON


module Hasura.Function.API
data FunctionPermissionArgument (b :: BackendType)
FunctionPermissionArgument :: FunctionName b -> SourceName -> RoleName -> FunctionPermissionArgument (b :: BackendType)
[_afpFunction] :: FunctionPermissionArgument (b :: BackendType) -> FunctionName b
[_afpSource] :: FunctionPermissionArgument (b :: BackendType) -> SourceName
[_afpRole] :: FunctionPermissionArgument (b :: BackendType) -> RoleName

-- | Represents the payload of the API command
--   <tt>pg_set_function_customization</tt>.
--   
--   See the Hasura API reference for a detailed description.
data SetFunctionCustomization (b :: BackendType)
SetFunctionCustomization :: SourceName -> FunctionName b -> FunctionConfig b -> SetFunctionCustomization (b :: BackendType)
[_sfcSource] :: SetFunctionCustomization (b :: BackendType) -> SourceName
[_sfcFunction] :: SetFunctionCustomization (b :: BackendType) -> FunctionName b
[_sfcConfiguration] :: SetFunctionCustomization (b :: BackendType) -> FunctionConfig b
newtype TrackFunction (b :: BackendType)
TrackFunction :: FunctionName b -> TrackFunction (b :: BackendType)
[tfName] :: TrackFunction (b :: BackendType) -> FunctionName b

-- | JSON API payload for v2 of <tt>track_function</tt>:
--   
--   
--   <a>https://hasura.io/docs/latest/graphql/core/api-reference/schema-metadata-api/custom-functions.html#track-function-v2</a>
data TrackFunctionV2 (b :: BackendType)
TrackFunctionV2 :: SourceName -> FunctionName b -> FunctionConfig b -> Maybe Text -> TrackFunctionV2 (b :: BackendType)
[_tfv2Source] :: TrackFunctionV2 (b :: BackendType) -> SourceName
[_tfv2Function] :: TrackFunctionV2 (b :: BackendType) -> FunctionName b
[_tfv2Configuration] :: TrackFunctionV2 (b :: BackendType) -> FunctionConfig b
[_tfv2Comment] :: TrackFunctionV2 (b :: BackendType) -> Maybe Text

-- | JSON API payload for <tt>untrack_function</tt>:
--   
--   
--   <a>https://hasura.io/docs/latest/graphql/core/api-reference/schema-metadata-api/custom-functions.html#untrack-function</a>
data UnTrackFunction (b :: BackendType)
UnTrackFunction :: FunctionName b -> SourceName -> UnTrackFunction (b :: BackendType)
[_utfFunction] :: UnTrackFunction (b :: BackendType) -> FunctionName b
[_utfSource] :: UnTrackFunction (b :: BackendType) -> SourceName
doesFunctionPermissionExist :: forall (b :: BackendType). BackendMetadata b => Metadata -> SourceName -> FunctionName b -> RoleName -> Bool
dropFunctionInMetadata :: forall (b :: BackendType). Backend b => SourceName -> FunctionName b -> MetadataModifier
dropFunctionPermissionInMetadata :: forall (b :: BackendType). BackendMetadata b => SourceName -> FunctionName b -> RoleName -> MetadataModifier
getSingleUniqueFunctionOverload :: forall (b :: BackendType) m. (QErrM m, Backend b) => FunctionName b -> FunctionOverloads b -> m (RawFunctionInfo b)
runCreateFunctionPermission :: forall (b :: BackendType) m. (CacheRWM m, MonadError QErr m, MetadataM m, BackendMetadata b) => FunctionPermissionArgument b -> m EncJSON
runDropFunctionPermission :: forall m (b :: BackendType). (CacheRWM m, MonadError QErr m, MetadataM m, BackendMetadata b) => FunctionPermissionArgument b -> m EncJSON

-- | Changes the custom names of a function. Used in the API command
--   <tt>pg_set_function_customization</tt>.
runSetFunctionCustomization :: forall (b :: BackendType) m. (QErrM m, CacheRWM m, MetadataM m, Backend b) => SetFunctionCustomization b -> m EncJSON
runTrackFunc :: forall (b :: BackendType) m. (MonadError QErr m, CacheRWM m, MetadataM m, BackendMetadata b) => TrackFunction b -> m EncJSON
runTrackFunctionV2 :: forall (b :: BackendType) m. (BackendMetadata b, QErrM m, CacheRWM m, MetadataM m) => TrackFunctionV2 b -> m EncJSON
runUntrackFunc :: forall (b :: BackendType) m. (CacheRWM m, MonadError QErr m, MetadataM m, BackendMetadata b) => UnTrackFunction b -> m EncJSON

-- | Track function, Phase 1: Validate function tracking operation. Fails
--   if function is already being tracked, or if a table with the same name
--   is being tracked.
trackFunctionP1 :: forall (b :: BackendType) m. (CacheRM m, QErrM m, Backend b) => SourceName -> FunctionName b -> m ()
trackFunctionP2 :: forall (b :: BackendType) m. (MonadError QErr m, CacheRWM m, MetadataM m, BackendMetadata b) => SourceName -> FunctionName b -> FunctionConfig b -> Maybe Text -> m EncJSON
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.Function.API.SetFunctionCustomization b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Function.API.FunctionPermissionArgument b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Function.API.SetFunctionCustomization b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Function.API.TrackFunction b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Function.API.TrackFunctionV2 b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Function.API.UnTrackFunction b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.Function.API.SetFunctionCustomization b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Function.API.TrackFunction b)

module Hasura.RQL.DDL.Schema.Cache.Fields
addNonColumnFields :: forall (b :: BackendType) m. (MonadWriter (Seq CollectItem) m, BackendMetadata b) => HashMap SourceName (AnyBackend PartiallyResolvedSource) -> SourceName -> SourceConfig b -> HashMap (TableName b) (TableCoreInfoG b (StructuredColumnInfo b) (ColumnInfo b)) -> FieldInfoMap (StructuredColumnInfo b) -> PartiallyResolvedRemoteSchemaMap -> DBFunctionsMetadata b -> NonColumnTableInputs b -> m (FieldInfoMap (FieldInfo b))


-- | Top-level functions concerned specifically with operations on the
--   schema cache, such as rebuilding it from the catalog and incorporating
--   schema changes. See the module documentation for
--   <a>Hasura.RQL.DDL.Schema</a> for more details.
--   
--   <b>Note</b>: this module is <b>mutually recursive</b> with other
--   <tt>Hasura.RQL.DDL.Schema.*</tt> modules, which both define pieces of
--   the implementation of building the schema cache and define handlers
--   that trigger schema cache rebuilds.
module Hasura.RQL.DDL.Schema.Cache
data RebuildableSchemaCache
lastBuiltSchemaCache :: RebuildableSchemaCache -> SchemaCache
buildRebuildableSchemaCache :: Logger Hasura -> Environment -> MetadataWithResourceVersion -> CacheDynamicConfig -> Maybe SchemaRegistryContext -> CacheBuild RebuildableSchemaCache
data CacheRWT (m :: Type -> Type) a
runCacheRWT :: Monad m => CacheDynamicConfig -> RebuildableSchemaCache -> CacheRWT m a -> m (a, RebuildableSchemaCache, CacheInvalidations, SourcesIntrospectionStatus, SchemaRegistryAction)
mkBooleanPermissionMap :: (RoleName -> a) -> HashMap RoleName a -> OrderedRoles -> HashMap RoleName a
saveSourcesIntrospection :: (MonadTraceContext m, MonadIO m, MonadMetadataStorage m) => Logger Hasura -> SourcesIntrospectionStatus -> MetadataResourceVersion -> m ()
instance GHC.Internal.Base.Monad m => GHC.Internal.Base.Applicative (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)
instance GHC.Internal.Base.Monad m => Hasura.RQL.Types.SchemaCache.CacheRM (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)
instance (Hasura.Tracing.Class.MonadTraceContext m, Control.Monad.IO.Class.MonadIO m, Control.Monad.Error.Class.MonadError Hasura.Base.Error.QErr m, Hasura.Services.Network.ProvidesNetwork m, Hasura.RQL.Types.Source.MonadResolveSource m, Hasura.RQL.DDL.Schema.Cache.Config.HasCacheStaticConfig m, Hasura.Metadata.Class.MonadMetadataStorage m) => Hasura.RQL.Types.SchemaCache.Build.CacheRWM (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.DDL.Schema.Cache.BackendInfoAndSourceMetadata b)
instance GHC.Internal.Base.Functor m => GHC.Internal.Base.Functor (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)
instance GHC.Internal.Generics.Generic (Hasura.RQL.DDL.Schema.Cache.BackendInfoAndSourceMetadata b)
instance GHC.Internal.Base.Monad m => Hasura.Server.Init.FeatureFlag.HasFeatureFlagChecker (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)
instance Control.Monad.Trans.Control.MonadBaseControl b m => Control.Monad.Trans.Control.MonadBaseControl b (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)
instance Control.Monad.Base.MonadBase b m => Control.Monad.Base.MonadBase b (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)
instance GHC.Internal.Base.Monad m => GHC.Internal.Base.Monad (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)
instance Hasura.RQL.DDL.EventTrigger.MonadEventLogCleanup m => Hasura.RQL.DDL.EventTrigger.MonadEventLogCleanup (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)
instance Hasura.Server.Types.MonadGetPolicies m => Hasura.Server.Types.MonadGetPolicies (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)
instance Hasura.Metadata.Class.MonadMetadataStorage m => Hasura.Metadata.Class.MonadMetadataStorage (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)
instance Hasura.QueryTags.MonadQueryTags m => Hasura.QueryTags.MonadQueryTags (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)
instance Hasura.Tracing.Class.MonadTrace m => Hasura.Tracing.Class.MonadTrace (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)
instance Hasura.Tracing.Class.MonadTraceContext m => Hasura.Tracing.Class.MonadTraceContext (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)
instance Control.Monad.Trans.Class.MonadTrans Hasura.RQL.DDL.Schema.Cache.CacheRWT
instance Hasura.Services.Network.ProvidesNetwork m => Hasura.Services.Network.ProvidesNetwork (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Internal.Show.Show (Hasura.RQL.DDL.Schema.Cache.BackendInfoAndSourceMetadata b)
instance Hasura.Authentication.User.UserInfoM m => Hasura.Authentication.User.UserInfoM (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)


-- | This module (along with the various <tt>Hasura.RQL.DDL.Schema.*</tt>
--   modules) provides operations to load and modify the Hasura catalog and
--   schema cache.
--   
--   <ul>
--   <li>The <i>catalog</i> refers to the set of PostgreSQL tables and
--   views that store all schema information known by Hasura. This includes
--   any tracked Postgres tables, views, and functions, all remote schemas,
--   and any additionaly Hasura-specific information such as permissions
--   and relationships.</li>
--   </ul>
--   
--   Primitive functions for loading and modifying the catalog are defined
--   in <a>Hasura.RQL.DDL.Schema.Catalog</a>, but most uses are wrapped by
--   other functions to synchronize catalog information with the
--   information in the schema cache.
--   
--   <ul>
--   <li>The <i>schema cache</i> is a process-global value of type
--   <tt>SchemaCache</tt> that stores an in-memory representation of the
--   data stored in the catalog. The in-memory representation is not
--   identical to the data in the catalog, since it has some
--   post-processing applied to it in order to make it easier to consume
--   for other parts of the system, such as GraphQL schema generation. For
--   example, although column information is represented by
--   <tt>RawColumnInfo</tt>, the schema cache contains “processed”
--   <tt>ColumnInfo</tt> values, instead.</li>
--   </ul>
--   
--   Ultimately, the catalog is the source of truth for all information
--   contained in the schema cache, but to avoid rebuilding the entire
--   schema cache on every change to the catalog, various functions
--   incrementally update the cache when they modify the catalog.
module Hasura.RQL.DDL.Schema
data RunSQLRes
RunSQLRes :: Text -> Value -> RunSQLRes
[rrResultType] :: RunSQLRes -> Text
[rrResult] :: RunSQLRes -> Value
instance GHC.Classes.Eq Hasura.RQL.DDL.Schema.RunSQLRes
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Schema.RunSQLRes
instance Database.PG.Query.Class.FromRes Hasura.RQL.DDL.Schema.RunSQLRes
instance GHC.Internal.Generics.Generic Hasura.RQL.DDL.Schema.RunSQLRes
instance GHC.Internal.Show.Show Hasura.RQL.DDL.Schema.RunSQLRes
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Schema.RunSQLRes


-- | Migrations for the Hasura catalog.
--   
--   To add a new migration:
--   
--   <ol>
--   <li>Bump the catalog version number in
--   <tt>src-rsr/catalog_version.txt</tt>.</li>
--   <li>Add a migration script in the <tt>src-rsr<i>migrations</i></tt>
--   directory with the name
--   <tt><a>version</a>_to_<a>version</a>.sql</tt>.</li>
--   <li>Create a downgrade script in the <tt>src-rsr<i>migrations</i></tt>
--   directory with the name
--   <tt><a>version</a>_to_<a>version</a>.sql</tt>.</li>
--   <li>If making a new release, add the mapping from application version
--   to catalog schema version in
--   <tt>src-rsr/catalog_versions.txt</tt>.</li>
--   <li>If appropriate, add the change to
--   <tt>server<i>src-rsr</i>initialise.sql</tt> for fresh installations of
--   hasura.</li>
--   </ol>
--   
--   The Template Haskell code in this module will automatically compile
--   the new migration script into the <tt>graphql-engine</tt> executable.
--   
--   NOTE: Please have a look at the
--   `server<i>documentation</i>migration-guidelines.md` before adding any
--   new migration if you haven't already looked at it
module Hasura.Server.Migrate
data MigrationResult
MRNothingToDo :: MigrationResult
MRInitialized :: MigrationResult

-- | old catalog version
MRMigrated :: Text -> MigrationResult
MRMaintanenceMode :: MigrationResult
migrateCatalog :: (MonadTx m, MonadIO m, MonadBaseControl IO m) => Maybe (SourceConnConfiguration ('Postgres 'Vanilla)) -> ExtensionsSchema -> MaintenanceMode () -> UTCTime -> m (MigrationResult, MetadataWithResourceVersion)

-- | The current catalog schema version. We store this in a file because we
--   want to append the current verson to the catalog_versions file when
--   tagging a new release, in <tt>tag-release.sh</tt>.
latestCatalogVersion :: MetadataCatalogVersion
downgradeCatalog :: (MonadIO m, MonadTx m) => Maybe (SourceConnConfiguration ('Postgres 'Vanilla)) -> DowngradeOptions -> UTCTime -> m MigrationResult
instance GHC.Classes.Eq Hasura.Server.Migrate.MigrationResult
instance GHC.Internal.Show.Show Hasura.Server.Migrate.MigrationResult
instance Hasura.Logging.ToEngineLog Hasura.Server.Migrate.MigrationResult Hasura.Logging.Hasura

module Hasura.RQL.DDL.Relationship.Rename
data RenameRel (b :: BackendType)
runRenameRel :: forall (b :: BackendType) m. (MonadError QErr m, CacheRWM m, MetadataM m, BackendMetadata b) => RenameRel b -> m EncJSON
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Relationship.Rename.RenameRel b)


-- | Postgres DDL RunSQL
--   
--   Escape hatch for running raw SQL against a postgres database.
--   
--   <a>runRunSQL</a> executes the provided raw SQL.
--   
--   <a>isSchemaCacheBuildRequiredRunSQL</a> checks for known
--   schema-mutating keywords in the raw SQL text.
--   
--   See <a>V2Query</a> and <a>Query</a>.
module Hasura.Backends.Postgres.DDL.RunSQL

-- | Used as an escape hatch to run raw SQL against a database.
runRunSQL :: forall (pgKind :: PostgresKind) m. (BackendMetadata ('Postgres pgKind), ToMetadataFetchQuery pgKind, FetchTableMetadata pgKind, FetchFunctionMetadata pgKind, CacheRWM m, MetadataM m, MonadBaseControl IO m, MonadError QErr m, MonadIO m, MonadTrace m, UserInfoM m) => SQLGenCtx -> RunSQL -> m EncJSON
data RunSQL
RunSQL :: Text -> SourceName -> Bool -> Maybe Bool -> TxAccess -> RunSQL
[rSql] :: RunSQL -> Text
[rSource] :: RunSQL -> SourceName
[rCascade] :: RunSQL -> Bool
[rCheckMetadataConsistency] :: RunSQL -> Maybe Bool
[rTxAccessMode] :: RunSQL -> TxAccess
isReadOnly :: RunSQL -> Bool

-- | Check for known schema-mutating keywords in the raw SQL text.
--   
--   See Note [Checking metadata consistency in run_sql].
isSchemaCacheBuildRequiredRunSQL :: RunSQL -> Bool
instance GHC.Classes.Eq Hasura.Backends.Postgres.DDL.RunSQL.RunSQL
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.DDL.RunSQL.RunSQL
instance GHC.Internal.Show.Show Hasura.Backends.Postgres.DDL.RunSQL.RunSQL
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.DDL.RunSQL.RunSQL


-- | MSSQL DDL RunSQL
--   
--   Provides primitives for running raw text SQL on MSSQL backends.
module Hasura.Backends.MSSQL.DDL.RunSQL
runSQL :: (MonadIO m, MonadBaseControl IO m, CacheRWM m, MonadError QErr m, MetadataM m) => MSSQLRunSQL -> m EncJSON
data MSSQLRunSQL
MSSQLRunSQL :: Text -> SourceName -> Bool -> Maybe Bool -> MSSQLRunSQL
[_mrsSql] :: MSSQLRunSQL -> Text
[_mrsSource] :: MSSQLRunSQL -> SourceName
[_mrsCascade] :: MSSQLRunSQL -> Bool
[_mrsCheckMetadataConsistency] :: MSSQLRunSQL -> Maybe Bool
isSchemaCacheBuildRequiredRunSQL :: MSSQLRunSQL -> Bool
instance GHC.Classes.Eq Hasura.Backends.MSSQL.DDL.RunSQL.MSSQLRunSQL
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.DDL.RunSQL.MSSQLRunSQL
instance GHC.Internal.Show.Show Hasura.Backends.MSSQL.DDL.RunSQL.MSSQLRunSQL
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MSSQL.DDL.RunSQL.MSSQLRunSQL

module Hasura.Backends.DataConnector.Adapter.RunSQL
data DataConnectorRunSQL
DataConnectorRunSQL :: SourceName -> Text -> DataConnectorRunSQL
[_dcSource] :: DataConnectorRunSQL -> SourceName
[_dcSql] :: DataConnectorRunSQL -> Text
runSQL :: (MonadIO m, CacheRWM m, MonadError QErr m, MetadataM m) => DataConnectorName -> DataConnectorRunSQL -> m EncJSON
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Adapter.RunSQL.DataConnectorRunSQL
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.DataConnector.Adapter.RunSQL.DataConnectorRunSQL
instance GHC.Internal.Show.Show Hasura.Backends.DataConnector.Adapter.RunSQL.DataConnectorRunSQL
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.Adapter.RunSQL.DataConnectorRunSQL


-- | Working example:
--   
--   $ curl -XPOST <a>http://localhost:8080/v2/query</a> -d @- &lt;&lt;EOF
--   { "type":"bigquery_run_sql", "args": { "sql":"select 3 * 4 as foo,
--   "Hello, World!" as bar", "source":"chinook" } } EOF
--   {"result_type":<a>TuplesOk</a>,"result":[["foo","bar"],["12","Hello,
--   World!"]]}
module Hasura.Backends.BigQuery.DDL.RunSQL
runSQL :: (MonadIO m, CacheRWM m, MonadError QErr m, MetadataM m) => BigQueryRunSQL -> m EncJSON

-- | The SQL query in the request is ignored
runDatabaseInspection :: (MonadIO m, CacheRWM m, MonadError QErr m, MetadataM m) => BigQueryRunSQL -> m EncJSON
data BigQueryRunSQL
instance GHC.Classes.Eq Hasura.Backends.BigQuery.DDL.RunSQL.BigQueryRunSQL
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.DDL.RunSQL.BigQueryRunSQL
instance GHC.Internal.Generics.Generic Hasura.Backends.BigQuery.DDL.RunSQL.BigQueryRunSQL
instance GHC.Internal.Show.Show Hasura.Backends.BigQuery.DDL.RunSQL.BigQueryRunSQL
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.DDL.RunSQL.BigQueryRunSQL

module Hasura.RQL.DDL.Metadata

-- | Replace the 'current metadata' with the 'new metadata' The 'new
--   metadata' might come via the 'Import Metadata' in console
runReplaceMetadata :: (CacheRWM m, MetadataM m, MonadIO m, MonadBaseControl IO m, MonadMetadataStorage m, MonadReader r m, MonadError QErr m, Has (Logger Hasura) r, MonadEventLogCleanup m, MonadGetPolicies m) => ReplaceMetadata -> m EncJSON
runReplaceMetadataV2 :: (CacheRWM m, MetadataM m, MonadIO m, MonadBaseControl IO m, MonadMetadataStorage m, MonadReader r m, MonadError QErr m, Has (Logger Hasura) r, MonadEventLogCleanup m, MonadGetPolicies m) => ReplaceMetadataV2 -> m EncJSON
runExportMetadata :: (QErrM m, MetadataM m) => ExportMetadata -> m EncJSON
runExportMetadataV2 :: (QErrM m, MetadataM m) => MetadataResourceVersion -> ExportMetadata -> m EncJSON
runClearMetadata :: (MonadIO m, CacheRWM m, MetadataM m, MonadMetadataStorage m, MonadBaseControl IO m, MonadReader r m, MonadError QErr m, Has (Logger Hasura) r, MonadEventLogCleanup m, MonadGetPolicies m) => ClearMetadata -> m EncJSON
runReloadMetadata :: (QErrM m, CacheRWM m, MetadataM m) => ReloadMetadata -> m EncJSON
runDumpInternalState :: (QErrM m, CacheRM m) => DumpInternalState -> m EncJSON
runGetInconsistentMetadata :: (QErrM m, CacheRM m) => GetInconsistentMetadata -> m EncJSON
runDropInconsistentMetadata :: (QErrM m, CacheRWM m, MetadataM m) => DropInconsistentMetadata -> m EncJSON
runGetCatalogState :: (MonadMetadataStorage m, MonadError QErr m) => GetCatalogState -> m EncJSON
runSetCatalogState :: (MonadMetadataStorage m, MonadError QErr m) => SetCatalogState -> m EncJSON
runTestWebhookTransform :: QErrM m => TestWebhookTransform -> m EncJSON
runSetMetricsConfig :: (MonadIO m, CacheRWM m, MetadataM m, MonadError QErr m) => MetricsConfig -> m EncJSON
runRemoveMetricsConfig :: (MonadIO m, CacheRWM m, MetadataM m, MonadError QErr m) => m EncJSON


-- | The RQL metadata query ('<i>v1</i>metadata')
module Hasura.Server.API.Metadata.Types
data RQLMetadataV1
RMAddSource :: !AnyBackend AddSource -> RQLMetadataV1
RMDropSource :: DropSource -> RQLMetadataV1
RMRenameSource :: !RenameSource -> RQLMetadataV1
RMUpdateSource :: !AnyBackend UpdateSource -> RQLMetadataV1
RMListSourceKinds :: !ListSourceKinds -> RQLMetadataV1
RMGetSourceKindCapabilities :: !GetSourceKindCapabilities -> RQLMetadataV1
RMGetSourceTables :: !AnyBackend GetSourceTables -> RQLMetadataV1
RMGetSourceTrackables :: !AnyBackend GetSourceTrackables -> RQLMetadataV1
RMGetTableInfo :: !AnyBackend GetTableInfo -> RQLMetadataV1
RMGetTableInfo_ :: !GetTableInfo_ -> RQLMetadataV1
RMTrackTable :: !AnyBackend TrackTableV2 -> RQLMetadataV1
RMTrackTables :: !AnyBackend TrackTables -> RQLMetadataV1
RMUntrackTable :: !AnyBackend UntrackTable -> RQLMetadataV1
RMUntrackTables :: !AnyBackend UntrackTables -> RQLMetadataV1
RMSetTableCustomization :: !AnyBackend SetTableCustomization -> RQLMetadataV1
RMSetApolloFederationConfig :: AnyBackend SetApolloFederationConfig -> RQLMetadataV1
RMPgSetTableIsEnum :: !AnyBackend SetTableIsEnum -> RQLMetadataV1
RMCreateInsertPermission :: !AnyBackend (CreatePerm InsPerm) -> RQLMetadataV1
RMCreateSelectPermission :: !AnyBackend (CreatePerm SelPerm) -> RQLMetadataV1
RMCreateUpdatePermission :: !AnyBackend (CreatePerm UpdPerm) -> RQLMetadataV1
RMCreateDeletePermission :: !AnyBackend (CreatePerm DelPerm) -> RQLMetadataV1
RMDropInsertPermission :: !AnyBackend DropPerm -> RQLMetadataV1
RMDropSelectPermission :: !AnyBackend DropPerm -> RQLMetadataV1
RMDropUpdatePermission :: !AnyBackend DropPerm -> RQLMetadataV1
RMDropDeletePermission :: !AnyBackend DropPerm -> RQLMetadataV1
RMSetPermissionComment :: !AnyBackend SetPermComment -> RQLMetadataV1
RMCreateObjectRelationship :: !AnyBackend CreateObjRel -> RQLMetadataV1
RMCreateArrayRelationship :: !AnyBackend CreateArrRel -> RQLMetadataV1
RMDropRelationship :: !AnyBackend DropRel -> RQLMetadataV1
RMSetRelationshipComment :: !AnyBackend SetRelComment -> RQLMetadataV1
RMRenameRelationship :: !AnyBackend RenameRel -> RQLMetadataV1
RMSuggestRelationships :: !AnyBackend SuggestRels -> RQLMetadataV1
RMCreateRemoteRelationship :: !AnyBackend CreateFromSourceRelationship -> RQLMetadataV1
RMUpdateRemoteRelationship :: !AnyBackend CreateFromSourceRelationship -> RQLMetadataV1
RMDeleteRemoteRelationship :: !AnyBackend DeleteFromSourceRelationship -> RQLMetadataV1
RMTrackFunction :: !AnyBackend TrackFunctionV2 -> RQLMetadataV1
RMUntrackFunction :: !AnyBackend UnTrackFunction -> RQLMetadataV1
RMSetFunctionCustomization :: AnyBackend SetFunctionCustomization -> RQLMetadataV1
RMCreateFunctionPermission :: !AnyBackend FunctionPermissionArgument -> RQLMetadataV1
RMDropFunctionPermission :: !AnyBackend FunctionPermissionArgument -> RQLMetadataV1
RMAddComputedField :: !AnyBackend AddComputedField -> RQLMetadataV1
RMDropComputedField :: !AnyBackend DropComputedField -> RQLMetadataV1
RMTestConnectionTemplate :: !AnyBackend TestConnectionTemplate -> RQLMetadataV1
RMGetNativeQuery :: !AnyBackend GetNativeQuery -> RQLMetadataV1
RMTrackNativeQuery :: !AnyBackend TrackNativeQuery -> RQLMetadataV1
RMUntrackNativeQuery :: !AnyBackend UntrackNativeQuery -> RQLMetadataV1
RMGetStoredProcedure :: !AnyBackend GetStoredProcedure -> RQLMetadataV1
RMTrackStoredProcedure :: !AnyBackend TrackStoredProcedure -> RQLMetadataV1
RMUntrackStoredProcedure :: !AnyBackend UntrackStoredProcedure -> RQLMetadataV1
RMGetLogicalModel :: !AnyBackend GetLogicalModel -> RQLMetadataV1
RMTrackLogicalModel :: !AnyBackend TrackLogicalModel -> RQLMetadataV1
RMUntrackLogicalModel :: !AnyBackend UntrackLogicalModel -> RQLMetadataV1
RMCreateSelectLogicalModelPermission :: !AnyBackend (CreateLogicalModelPermission SelPerm) -> RQLMetadataV1
RMDropSelectLogicalModelPermission :: !AnyBackend DropLogicalModelPermission -> RQLMetadataV1
RMCreateEventTrigger :: !AnyBackend (Unvalidated1 CreateEventTriggerQuery) -> RQLMetadataV1
RMDeleteEventTrigger :: !AnyBackend DeleteEventTriggerQuery -> RQLMetadataV1
RMRedeliverEvent :: !AnyBackend RedeliverEventQuery -> RQLMetadataV1
RMInvokeEventTrigger :: !AnyBackend InvokeEventTriggerQuery -> RQLMetadataV1
RMCleanupEventTriggerLog :: !TriggerLogCleanupConfig -> RQLMetadataV1
RMResumeEventTriggerCleanup :: !TriggerLogCleanupToggleConfig -> RQLMetadataV1
RMPauseEventTriggerCleanup :: !TriggerLogCleanupToggleConfig -> RQLMetadataV1
RMGetEventLogs :: !AnyBackend GetEventLogs -> RQLMetadataV1
RMGetEventInvocationLogs :: !AnyBackend GetEventInvocations -> RQLMetadataV1
RMGetEventById :: !AnyBackend GetEventById -> RQLMetadataV1
RMAddRemoteSchema :: !AddRemoteSchemaQuery -> RQLMetadataV1
RMUpdateRemoteSchema :: !AddRemoteSchemaQuery -> RQLMetadataV1
RMRemoveRemoteSchema :: !RemoteSchemaNameQuery -> RQLMetadataV1
RMReloadRemoteSchema :: !RemoteSchemaNameQuery -> RQLMetadataV1
RMIntrospectRemoteSchema :: !RemoteSchemaNameQuery -> RQLMetadataV1
RMAddRemoteSchemaPermissions :: !AddRemoteSchemaPermission -> RQLMetadataV1
RMDropRemoteSchemaPermissions :: !DropRemoteSchemaPermissions -> RQLMetadataV1
RMCreateRemoteSchemaRemoteRelationship :: CreateRemoteSchemaRemoteRelationship -> RQLMetadataV1
RMUpdateRemoteSchemaRemoteRelationship :: CreateRemoteSchemaRemoteRelationship -> RQLMetadataV1
RMDeleteRemoteSchemaRemoteRelationship :: DeleteRemoteSchemaRemoteRelationship -> RQLMetadataV1
RMCreateCronTrigger :: !Unvalidated CreateCronTrigger -> RQLMetadataV1
RMDeleteCronTrigger :: !ScheduledTriggerName -> RQLMetadataV1
RMCreateScheduledEvent :: !CreateScheduledEvent -> RQLMetadataV1
RMDeleteScheduledEvent :: !DeleteScheduledEvent -> RQLMetadataV1
RMGetScheduledEvents :: !GetScheduledEvents -> RQLMetadataV1
RMGetScheduledEventInvocations :: !GetScheduledEventInvocations -> RQLMetadataV1
RMGetCronTriggers :: RQLMetadataV1
RMCreateAction :: !Unvalidated CreateAction -> RQLMetadataV1
RMDropAction :: !DropAction -> RQLMetadataV1
RMUpdateAction :: !Unvalidated UpdateAction -> RQLMetadataV1
RMCreateActionPermission :: !CreateActionPermission -> RQLMetadataV1
RMDropActionPermission :: !DropActionPermission -> RQLMetadataV1
RMCreateQueryCollection :: !CreateCollection -> RQLMetadataV1
RMRenameQueryCollection :: !RenameCollection -> RQLMetadataV1
RMDropQueryCollection :: !DropCollection -> RQLMetadataV1
RMAddQueryToCollection :: !AddQueryToCollection -> RQLMetadataV1
RMDropQueryFromCollection :: !DropQueryFromCollection -> RQLMetadataV1
RMAddCollectionToAllowlist :: !AllowlistEntry -> RQLMetadataV1
RMDropCollectionFromAllowlist :: !DropCollectionFromAllowlist -> RQLMetadataV1
RMUpdateScopeOfCollectionInAllowlist :: !UpdateScopeOfCollectionInAllowlist -> RQLMetadataV1
RMCreateRestEndpoint :: !CreateEndpoint -> RQLMetadataV1
RMDropRestEndpoint :: !DropEndpoint -> RQLMetadataV1
RMDCAddAgent :: !DCAddAgent -> RQLMetadataV1
RMDCDeleteAgent :: !DCDeleteAgent -> RQLMetadataV1
RMSetCustomTypes :: !CustomTypes -> RQLMetadataV1
RMSetApiLimits :: !ApiLimit -> RQLMetadataV1
RMRemoveApiLimits :: RQLMetadataV1
RMSetMetricsConfig :: !MetricsConfig -> RQLMetadataV1
RMRemoveMetricsConfig :: RQLMetadataV1
RMAddInheritedRole :: !InheritedRole -> RQLMetadataV1
RMDropInheritedRole :: !DropInheritedRole -> RQLMetadataV1
RMReplaceMetadata :: !ReplaceMetadata -> RQLMetadataV1
RMExportMetadata :: !ExportMetadata -> RQLMetadataV1
RMClearMetadata :: !ClearMetadata -> RQLMetadataV1
RMReloadMetadata :: !ReloadMetadata -> RQLMetadataV1
RMGetInconsistentMetadata :: !GetInconsistentMetadata -> RQLMetadataV1
RMDropInconsistentMetadata :: !DropInconsistentMetadata -> RQLMetadataV1
RMSetGraphqlSchemaIntrospectionOptions :: !SetGraphqlIntrospectionOptions -> RQLMetadataV1
RMAddHostToTLSAllowlist :: !AddHostToTLSAllowlist -> RQLMetadataV1
RMDropHostFromTLSAllowlist :: !DropHostFromTLSAllowlist -> RQLMetadataV1
RMSetQueryTagsConfig :: !SetQueryTagsConfig -> RQLMetadataV1
RMSetOpenTelemetryConfig :: !OpenTelemetryConfig -> RQLMetadataV1
RMSetOpenTelemetryStatus :: !OtelStatus -> RQLMetadataV1
RMDumpInternalState :: !DumpInternalState -> RQLMetadataV1
RMGetCatalogState :: !GetCatalogState -> RQLMetadataV1
RMSetCatalogState :: !SetCatalogState -> RQLMetadataV1
RMTestWebhookTransform :: !Unvalidated TestWebhookTransform -> RQLMetadataV1
RMBulk :: [RQLMetadataRequest] -> RQLMetadataV1
RMBulkKeepGoing :: [RQLMetadataRequest] -> RQLMetadataV1

-- | Bulk metadata queries, running a single schema cache resolve at the
--   end. Only works for a subset of commands.
RMBulkAtomic :: [RQLMetadataRequest] -> RQLMetadataV1
data RQLMetadataV2
RMV2ReplaceMetadata :: !ReplaceMetadataV2 -> RQLMetadataV2
RMV2ExportMetadata :: !ExportMetadata -> RQLMetadataV2
data RQLMetadataRequest
RMV1 :: !RQLMetadataV1 -> RQLMetadataRequest
RMV2 :: !RQLMetadataV2 -> RQLMetadataRequest
instance GHC.Internal.Generics.Generic Hasura.Server.API.Metadata.Types.RQLMetadataV1
instance GHC.Internal.Generics.Generic Hasura.Server.API.Metadata.Types.RQLMetadataV2


-- | BackendAPI
--   
--   This module defines the <a>BackendAPI</a> class, alongside a few
--   helpers. Its goal is to delegate to backends the responsibility of
--   creating the parsers for the metadata API. Each backend is expected to
--   provide a list of <a>CommandParser</a>, which in turn is a simple
--   function from command name and command arguments to a corresponding
--   parser. Command parsers can easily be created using the
--   <a>commandParser</a> function.
--   
--   Furthermore, for each set of related features, such as table tracking
--   commands, or permission commands, a helper function is provided, that
--   allows a backend to write its instance by simply listing the set of
--   features it supports.
module Hasura.Server.API.Backend
class BackendAPI (b :: BackendType)
metadataV1CommandParsers :: BackendAPI b => [CommandParser b]
commandParser :: forall a (b :: BackendType). FromJSON a => Text -> (a -> RQLMetadataV1) -> CommandParser b
eventTriggerCommands :: forall (b :: BackendType). Backend b => [CommandParser b]
functionCommands :: forall (b :: BackendType). Backend b => [CommandParser b]
trackableCommands :: forall (b :: BackendType). Backend b => [CommandParser b]
functionPermissionsCommands :: forall (b :: BackendType). Backend b => [CommandParser b]
relationshipCommands :: forall (b :: BackendType). Backend b => [CommandParser b]
remoteRelationshipCommands :: forall (b :: BackendType). Backend b => [CommandParser b]
sourceCommands :: forall (b :: BackendType). Backend b => [CommandParser b]
tableCommands :: forall (b :: BackendType). Backend b => [CommandParser b]
tablePermissionsCommands :: forall (b :: BackendType). Backend b => [CommandParser b]
computedFieldCommands :: forall (b :: BackendType). Backend b => [CommandParser b]
connectionTemplateCommands :: forall (b :: BackendType). Backend b => [CommandParser b]
nativeQueriesCommands :: forall (b :: BackendType). Backend b => [CommandParser b]
storedProceduresCommands :: forall (b :: BackendType). Backend b => [CommandParser b]
logicalModelsCommands :: forall (b :: BackendType). Backend b => [CommandParser b]


-- | MSSQL Instances API
--   
--   Defines a <a>BackendAPI</a> type class instance for MSSQL.
module Hasura.Backends.MSSQL.Instances.API
instance Hasura.Server.API.Backend.BackendAPI 'Hasura.RQL.Types.BackendType.MSSQL

module Hasura.Backends.DataConnector.Adapter.API
instance Hasura.Server.API.Backend.BackendAPI 'Hasura.RQL.Types.BackendType.DataConnector

module Hasura.Backends.BigQuery.Instances.API
instance Hasura.Server.API.Backend.BackendAPI 'Hasura.RQL.Types.BackendType.BigQuery


-- | Postgres Instances API
--   
--   Defines a <a>BackendAPI</a> type class instance for Postgres.
module Hasura.Backends.Postgres.Instances.API
instance Hasura.Server.API.Backend.BackendAPI ('Hasura.RQL.Types.BackendType.Postgres 'Hasura.RQL.Types.BackendType.Vanilla)
instance Hasura.Server.API.Backend.BackendAPI ('Hasura.RQL.Types.BackendType.Postgres 'Hasura.RQL.Types.BackendType.Citus)
instance Hasura.Server.API.Backend.BackendAPI ('Hasura.RQL.Types.BackendType.Postgres 'Hasura.RQL.Types.BackendType.Cockroach)

module Hasura.Server.API.Instances


-- | <a>FromJSON</a> instances for API.Metadata. Kept separately to
--   discourage becoming a dumping ground for orphan instances
module Hasura.Server.API.Metadata.Instances
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.API.Metadata.Types.RQLMetadataRequest
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.API.Metadata.Types.RQLMetadataV1
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.API.Metadata.Types.RQLMetadataV2


-- | This module contains Data Connector request/response planning code and
--   utility functions and types that are common across the different
--   categories of requests (ie queries, mutations, etc). It contains code
--   and concepts that are independent of these different categories.
--   
--   Both <a>QueryPlan</a> and <a>MutationPlan</a> use the contents of this
--   module, for example <a>mkQueryPlan</a>.
module Hasura.Backends.DataConnector.Plan.Common

-- | Represents a <tt>request</tt> to be sent to a data connector agent
--   (<a>_pRequest</a>) and a function that is capable of reshaping the
--   response to that request into the final JSON form expected to be
--   returned by the GraphQL endpoint (<a>_pResponseReshaper</a>).
data Plan request response
Plan :: request -> (forall (m :: Type -> Type). MonadError QErr m => response -> m Encoding) -> Plan request response
[_pRequest] :: Plan request response -> request
[_pResponseReshaper] :: Plan request response -> forall (m :: Type -> Type). MonadError QErr m => response -> m Encoding

-- | Writes some output to state, like one might do if one was using a
--   Writer monad. The output is combined with the existing output using
--   <a>&lt;&gt;</a> from <a>Semigroup</a>
writeOutput :: (Semigroup output, MonadState state m, Has output state) => output -> m ()

-- | Replaces some output in the state with a new version of the output.
--   Also, a value can be returned from the replacement function.
--   
--   This is useful if you need to inspect the existing state, make a
--   decision, and update it based on that decision. The result of the
--   decision can be returned from the transformation as your <tt>a</tt>
--   value.
replaceOutput :: (MonadState state m, Has output state) => (output -> (output, a)) -> m a

-- | A monoidal data structure used to record Table Relationships
--   encountered during request translation. Used with
--   <tt>recordTableRelationship</tt>.
newtype TableRelationships
TableRelationships :: HashMap TargetName (HashMap RelationshipName Relationship) -> TableRelationships
[unTableRelationships] :: TableRelationships -> HashMap TargetName (HashMap RelationshipName Relationship)

-- | Records a relationship encountered during request translation into the
--   output of the current <a>WriterT</a>
recordRelationship :: (MonadState state m, Has TableRelationships state) => TargetName -> RelationshipName -> Relationship -> m ()
recordTableRelationshipFromRelInfo :: (MonadState state m, Has TableRelationships state) => TargetName -> RelInfo 'DataConnector -> m (RelationshipName, Relationship)

-- | Represents a potential prefix that can be applied to a field name,
--   useful for namespacing field names that may be otherwise duplicated.
data FieldPrefix
noPrefix :: FieldPrefix
prefixWith :: FieldName -> FieldPrefix
applyPrefix :: FieldPrefix -> FieldName -> FieldName
data Cardinality
Single :: Cardinality
Many :: Cardinality

-- | Collects encountered redaction expressions on a per table/function
--   basis. Expressions are deduplicated and assigned a unique name (within
--   that table/function) that is then used to reference the expression
--   inside the query.
newtype RedactionExpressionState
RedactionExpressionState :: HashMap TargetName (HashMap RedactionExpression RedactionExpressionName) -> RedactionExpressionState
[unRedactionExpressionState] :: RedactionExpressionState -> HashMap TargetName (HashMap RedactionExpression RedactionExpressionName)
recordRedactionExpression :: (MonadState state m, Has TableRelationships state, Has RedactionExpressionState state, Has InterpolatedQueries state, MonadError QErr m, MonadReader r m, Has ScalarTypesCapabilities r, Has SessionVariables r, MonadIO m) => TargetName -> AnnRedactionExp 'DataConnector (UnpreparedValue 'DataConnector) -> m (Maybe RedactionExpressionName)
translateRedactionExpressions :: RedactionExpressionState -> Set TargetRedactionExpressions
prepareLiteral :: (MonadError QErr m, MonadReader r m, Has ScalarTypesCapabilities r, Has SessionVariables r) => UnpreparedValue 'DataConnector -> m Literal
translateBoolExpToExpression :: (MonadState state m, Has TableRelationships state, Has InterpolatedQueries state, Has RedactionExpressionState state, MonadError QErr m, MonadReader r m, Has ScalarTypesCapabilities r, Has SessionVariables r, MonadIO m) => TargetName -> AnnBoolExp 'DataConnector (UnpreparedValue 'DataConnector) -> m (Maybe Expression)
mkRelationshipName :: RelName -> RelationshipName
mapFieldNameHashMap :: HashMap FieldName v -> HashMap FieldName v
encodeAssocListAsObject :: [(Text, Encoding)] -> Encoding

-- | Helper function to convert targets into Keys
targetToTargetName :: Target -> TargetName

-- | Records a Native Query encountered during request translation into the
--   output of the current <a>WriterT</a>
recordNativeQuery :: (Has InterpolatedQueries state, Has ScalarTypesCapabilities r, MonadReader r m, MonadState state m, MonadError QErr m, Has SessionVariables r) => NativeQuery 'DataConnector (UnpreparedValue 'DataConnector) -> m InterpolatedQueryId
data ColumnStack
emptyColumnStack :: ColumnStack
pushColumn :: ColumnStack -> ColumnName -> ColumnStack
toColumnSelector :: ColumnStack -> ColumnName -> ColumnSelector
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Plan.Common.FieldPrefix
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Plan.Common.RedactionExpressionState
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Plan.Common.TableRelationships
instance GHC.Internal.Base.Monoid Hasura.Backends.DataConnector.Plan.Common.FieldPrefix
instance GHC.Internal.Base.Monoid Hasura.Backends.DataConnector.Plan.Common.TableRelationships
instance GHC.Internal.Base.Semigroup Hasura.Backends.DataConnector.Plan.Common.FieldPrefix
instance GHC.Internal.Base.Semigroup Hasura.Backends.DataConnector.Plan.Common.TableRelationships
instance GHC.Internal.Show.Show Hasura.Backends.DataConnector.Plan.Common.FieldPrefix
instance GHC.Internal.Show.Show Hasura.Backends.DataConnector.Plan.Common.RedactionExpressionState
instance GHC.Internal.Show.Show Hasura.Backends.DataConnector.Plan.Common.TableRelationships

module Hasura.Backends.DataConnector.Plan.QueryPlan

-- | Map a 'QueryDB <a>DataConnector</a> term into a <a>Plan</a>
mkQueryPlan :: (MonadError QErr m, MonadReader r m, Has ScalarTypesCapabilities r, MonadIO m, Has SessionVariables r) => QueryDB 'DataConnector Void (UnpreparedValue 'DataConnector) -> m (Plan QueryRequest QueryResponse)
translateAnnSimpleSelectToQueryRequest :: (MonadError QErr m, MonadReader r m, Has ScalarTypesCapabilities r, MonadIO m, Has SessionVariables r) => AnnSimpleSelectG 'DataConnector Void (UnpreparedValue 'DataConnector) -> m QueryRequest
translateAnnAggregateSelectToQueryRequest :: (MonadError QErr m, MonadReader r m, Has ScalarTypesCapabilities r, MonadIO m, Has SessionVariables r) => AnnAggregateSelectG 'DataConnector Void (UnpreparedValue 'DataConnector) -> m QueryRequest
translateAnnFields :: (MonadState state m, Has TableRelationships state, Has RedactionExpressionState state, Has InterpolatedQueries state, MonadError QErr m, MonadReader r m, Has ScalarTypesCapabilities r, Has SessionVariables r, MonadIO m) => FieldPrefix -> TargetName -> AnnFieldsG 'DataConnector Void (UnpreparedValue 'DataConnector) -> m (HashMap FieldName Field)
reshapeSimpleSelectRows :: MonadError QErr m => Cardinality -> AnnFieldsG 'DataConnector Void v -> QueryResponse -> m Encoding
reshapeTableAggregateFields :: MonadError QErr m => TableAggregateFieldsG 'DataConnector Void v -> QueryResponse -> m Encoding
reshapeAnnFields :: MonadError QErr m => FieldPrefix -> AnnFieldsG 'DataConnector Void v -> HashMap FieldName FieldValue -> m Encoding
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Plan.QueryPlan.FieldsAndAggregates
instance GHC.Internal.Base.Monoid Hasura.Backends.DataConnector.Plan.QueryPlan.FieldsAndAggregates
instance GHC.Internal.Base.Semigroup Hasura.Backends.DataConnector.Plan.QueryPlan.FieldsAndAggregates
instance GHC.Internal.Show.Show Hasura.Backends.DataConnector.Plan.QueryPlan.FieldsAndAggregates

module Hasura.Backends.DataConnector.Plan.RemoteRelationshipPlan
mkRemoteRelationshipPlan :: (MonadError QErr m, MonadReader r m, Has ScalarTypesCapabilities r, MonadIO m, Has SessionVariables r) => SourceName -> SourceConfig -> NonEmpty Object -> HashMap FieldName (ColumnName, ScalarType) -> FieldName -> FieldName -> SourceRelationshipSelection 'DataConnector Void UnpreparedValue -> m (Plan QueryRequest QueryResponse, [ModelInfoPart])

module Hasura.Backends.DataConnector.Plan.MutationPlan
mkMutationPlan :: (MonadError QErr m, MonadReader r m, Has ScalarTypesCapabilities r, Has SessionVariables r, MonadIO m) => SourceName -> ModelSourceType -> MutationDB 'DataConnector Void (UnpreparedValue 'DataConnector) -> m (Plan MutationRequest MutationResponse, [ModelNameInfo])
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Plan.MutationPlan.TableInsertSchema
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Plan.MutationPlan.TableInsertSchemas
instance GHC.Internal.Base.Monoid Hasura.Backends.DataConnector.Plan.MutationPlan.TableInsertSchemas
instance GHC.Internal.Base.Semigroup Hasura.Backends.DataConnector.Plan.MutationPlan.TableInsertSchema
instance GHC.Internal.Base.Semigroup Hasura.Backends.DataConnector.Plan.MutationPlan.TableInsertSchemas
instance GHC.Internal.Show.Show Hasura.Backends.DataConnector.Plan.MutationPlan.TableInsertSchema
instance GHC.Internal.Show.Show Hasura.Backends.DataConnector.Plan.MutationPlan.TableInsertSchemas


-- | MSSQL SQL Value
--   
--   Provide a function to translate from a column value to its literal
--   (textual) value specific to MSSQL. Used in the <tt>BackendExecute</tt>
--   instance.
module Hasura.Backends.MSSQL.SQL.Value
txtEncodedColVal :: ColumnValue 'MSSQL -> TxtEncodedVal


-- | MSSQL Instances Execute
--   
--   Defines a <a>BackendExecute</a> type class instance for MSSQL.
--   
--   This module implements the needed functionality for implementing a
--   <a>BackendExecute</a> instance for MSSQL, which defines an interface
--   for translating a root field into an execution plan and interacting
--   with a database.
--   
--   This module includes the MSSQL implementation of queries, mutations,
--   and more.
module Hasura.Backends.MSSQL.Instances.Execute
data MultiplexedQuery'
MultiplexedQuery' :: Reselect -> QueryTagsComment -> MultiplexedQuery'
[reselect] :: MultiplexedQuery' -> Reselect
[subscriptionQueryTagsComment] :: MultiplexedQuery' -> QueryTagsComment

-- | Producing the correct SQL-level list comprehension to multiplex a
--   query Problem description:
--   
--   Generate a query that repeats the same query N times but with certain
--   slots replaced:
--   
--   <ul>
--   <li><i> Select x y | (x,y) &lt;- [..</i> ]</li>
--   </ul>
--   
--   Caution: Be aware that this query has a <tt>FOR JSON</tt> clause at
--   the top-level and hence its results may be split up across multiple
--   rows. Use <a>forJsonQueryE</a> to handle this.
multiplexRootReselect :: [(CohortId, CohortVariables)] -> Reselect -> Select
instance Hasura.GraphQL.Execute.Backend.BackendExecute 'Hasura.RQL.Types.BackendType.MSSQL
instance Data.Text.Extended.ToTxt Hasura.Backends.MSSQL.Instances.Execute.MultiplexedQuery'


-- | MSSQL Instances Transport
--   
--   Defines the MSSQL instance of <a>BackendTransport</a> and how to
--   interact with the database for running queries, mutations,
--   subscriptions, and so on.
module Hasura.Backends.MSSQL.Instances.Transport
instance Hasura.GraphQL.Transport.Backend.BackendTransport 'Hasura.RQL.Types.BackendType.MSSQL
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Instances.Transport.CohortResult

module Hasura.Backends.DataConnector.Adapter.Execute
data DataConnectorPreparedQuery
QueryRequest :: QueryRequest -> DataConnectorPreparedQuery
MutationRequest :: MutationRequest -> DataConnectorPreparedQuery
encodePreparedQueryToJsonText :: DataConnectorPreparedQuery -> Text
instance Hasura.GraphQL.Execute.Backend.BackendExecute 'Hasura.RQL.Types.BackendType.DataConnector

module Hasura.GraphQL.Execute.Instances

module Hasura.Backends.DataConnector.Adapter.Transport
instance Hasura.GraphQL.Transport.Backend.BackendTransport 'Hasura.RQL.Types.BackendType.DataConnector

module Hasura.Backends.BigQuery.Instances.Transport
instance Hasura.GraphQL.Transport.Backend.BackendTransport 'Hasura.RQL.Types.BackendType.BigQuery

module Hasura.GraphQL.Transport.Instances


-- | How to construct and execute a call to a source for a remote join.
--   
--   There are three steps required to do this: - construct the execution
--   step for that source join - execute that GraphQL query over the
--   network - build a join index of the variables out of the response
--   
--   This can be done as one function, but we also export the individual
--   steps for debugging / test purposes. We congregate all intermediary
--   state in the opaque <a>SourceJoinCall</a> type.
module Hasura.GraphQL.Execute.RemoteJoin.Source

-- | Construct and execute a call to a source for a remote join.
makeSourceJoinCall :: (MonadQueryTags m, MonadError QErr m, MonadTrace m, MonadIO m, MonadGetPolicies m) => (AnyBackend SourceJoinCall -> m ByteString) -> UserInfo -> AnyBackend RemoteSourceJoin -> FieldName -> IntMap JoinArgument -> [Header] -> Maybe Name -> TraceQueryStatus -> m (Maybe (IntMap Value, [ModelInfoPart]))

-- | Intermediate type that contains all the necessary information to
--   perform a call to a database to perform a join.
data SourceJoinCall (b :: BackendType)
SourceJoinCall :: RootFieldAlias -> SourceConfig b -> DBStepInfo b -> SourceJoinCall (b :: BackendType)
[_sjcRootFieldAlias] :: SourceJoinCall (b :: BackendType) -> RootFieldAlias
[_sjcSourceConfig] :: SourceJoinCall (b :: BackendType) -> SourceConfig b
[_sjcStepInfo] :: SourceJoinCall (b :: BackendType) -> DBStepInfo b
buildSourceJoinCall :: forall (b :: BackendType) m. (BackendExecute b, MonadQueryTags m, MonadError QErr m, MonadTrace m, MonadIO m, MonadGetPolicies m) => UserInfo -> FieldName -> IntMap JoinArgument -> [Header] -> Maybe Name -> TraceQueryStatus -> RemoteSourceJoin b -> m (Maybe (AnyBackend SourceJoinCall, [ModelInfoPart]))

-- | Construct a join index from the <tt>EncJSON</tt> response from the
--   source.
--   
--   Unlike with remote schemas, we can make assumptions about the shape of
--   the result, instead of having to keep track of the path within the
--   answer. This function therefore enforces that the answer has the shape
--   we expect, and throws a <a>QErr</a> if it doesn't.
buildJoinIndex :: MonadError QErr m => ByteString -> m (IntMap Value)

module Hasura.GraphQL.Execute.RemoteJoin.Join

-- | Process all remote joins, recursively.
--   
--   Given the result of the first step of an execution and its associated
--   remote joins, process all joins recursively to build the resulting
--   JSON object.
--   
--   This function is a thin wrapper around
--   <tt>processRemoteJoinsWith</tt>, and starts the join tree traversal
--   process by re-parsing the <a>EncJSON</a> value into an introspectable
--   JSON <tt>Value</tt>, and "injects" the required functions to process
--   each join over the network.
processRemoteJoins :: (MonadError QErr m, MonadIO m, MonadBaseControl IO m, MonadQueryTags m, MonadQueryLog m, MonadExecutionLog m, MonadTrace m, ProvidesNetwork m, MonadGetPolicies m) => RequestId -> Logger Hasura -> Maybe (CredentialCache AgentLicenseKey) -> Environment -> [Header] -> UserInfo -> EncJSON -> Maybe RemoteJoins -> GQLReqUnparsed -> HttpPropagator -> TraceQueryStatus -> m (EncJSON, [ModelInfoPart])

-- | Fold the join tree.
--   
--   This function takes as an argument the functions that will be used to
--   do the actual network calls; this allows this function not to require
--   <a>MonadIO</a>, allowing it to be used in tests.
foldJoinTreeWith :: (MonadError QErr m, MonadQueryTags m, Traversable f, MonadTrace m, MonadIO m, MonadGetPolicies m) => (AnyBackend SourceJoinCall -> m ByteString) -> (ValidatedRemoteSchemaDef -> GQLReqOutgoing -> m ByteString) -> UserInfo -> f Value -> RemoteJoins -> [Header] -> Maybe Name -> TraceQueryStatus -> m (f Value, [ModelInfoPart])
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.GraphQL.Execute.RemoteJoin.Join.CompositeValue a)
instance GHC.Internal.Data.Foldable.Foldable Hasura.GraphQL.Execute.RemoteJoin.Join.CompositeValue
instance GHC.Internal.Base.Functor Hasura.GraphQL.Execute.RemoteJoin.Join.CompositeValue
instance GHC.Internal.Show.Show a => GHC.Internal.Show.Show (Hasura.GraphQL.Execute.RemoteJoin.Join.CompositeValue a)
instance GHC.Internal.Data.Traversable.Traversable Hasura.GraphQL.Execute.RemoteJoin.Join.CompositeValue

module Hasura.GraphQL.Execute.RemoteJoin

module Hasura.App.State
data RebuildableAppContext impl
RebuildableAppContext :: AppContext -> InvalidationKeys -> Rule (ReaderT (Logger Hasura, Manager) (ExceptT QErr IO)) (ServeOptions impl, Environment, InvalidationKeys, CheckFeatureFlag) AppContext -> RebuildableAppContext impl
[lastBuiltAppContext] :: RebuildableAppContext impl -> AppContext
[_racInvalidationMap] :: RebuildableAppContext impl -> InvalidationKeys
[_racRebuild] :: RebuildableAppContext impl -> Rule (ReaderT (Logger Hasura, Manager) (ExceptT QErr IO)) (ServeOptions impl, Environment, InvalidationKeys, CheckFeatureFlag) AppContext

-- | Represents the Read-Only Hasura State, these fields are immutable and
--   the state cannot be changed during runtime.
data AppEnv
AppEnv :: Port -> HostPreference -> PGPool -> Maybe PGPool -> Manager -> Loggers -> TMVar MetadataResourceVersion -> InstanceId -> MaintenanceMode () -> LoggingSettings -> EventingMode -> ReadOnlyMode -> ServerMetrics -> ShutdownLatch -> TMVar MetadataResourceVersion -> PrometheusMetrics -> SamplingPolicy -> SubscriptionsState -> LockedEventsCtx -> ConnParams -> TxIsolation -> Maybe Text -> Maybe Text -> ConnectionOptions -> KeepAliveDelay -> WSConnectionInitTimeout -> Refined NonNegative Seconds -> OptionalInterval -> CheckFeatureFlag -> Maybe (CredentialCache AgentLicenseKey) -> Int -> TriggersErrorLogLevelStatus -> Int -> PersistedQueriesState -> Int -> AppEnv
[appEnvPort] :: AppEnv -> Port
[appEnvHost] :: AppEnv -> HostPreference
[appEnvMetadataDbPool] :: AppEnv -> PGPool
[appEnvIntrospectionDbPool] :: AppEnv -> Maybe PGPool
[appEnvManager] :: AppEnv -> Manager
[appEnvLoggers] :: AppEnv -> Loggers
[appEnvMetadataVersionRef] :: AppEnv -> TMVar MetadataResourceVersion
[appEnvInstanceId] :: AppEnv -> InstanceId
[appEnvEnableMaintenanceMode] :: AppEnv -> MaintenanceMode ()
[appEnvLoggingSettings] :: AppEnv -> LoggingSettings
[appEnvEventingMode] :: AppEnv -> EventingMode
[appEnvEnableReadOnlyMode] :: AppEnv -> ReadOnlyMode
[appEnvServerMetrics] :: AppEnv -> ServerMetrics
[appEnvShutdownLatch] :: AppEnv -> ShutdownLatch
[appEnvMetaVersionRef] :: AppEnv -> TMVar MetadataResourceVersion
[appEnvPrometheusMetrics] :: AppEnv -> PrometheusMetrics
[appEnvTraceSamplingPolicy] :: AppEnv -> SamplingPolicy
[appEnvSubscriptionState] :: AppEnv -> SubscriptionsState
[appEnvLockedEventsCtx] :: AppEnv -> LockedEventsCtx
[appEnvConnParams] :: AppEnv -> ConnParams
[appEnvTxIso] :: AppEnv -> TxIsolation
[appEnvConsoleAssetsDir] :: AppEnv -> Maybe Text
[appEnvConsoleSentryDsn] :: AppEnv -> Maybe Text
[appEnvConnectionOptions] :: AppEnv -> ConnectionOptions
[appEnvWebSocketKeepAlive] :: AppEnv -> KeepAliveDelay
[appEnvWebSocketConnectionInitTimeout] :: AppEnv -> WSConnectionInitTimeout
[appEnvGracefulShutdownTimeout] :: AppEnv -> Refined NonNegative Seconds
[appEnvSchemaPollInterval] :: AppEnv -> OptionalInterval
[appEnvCheckFeatureFlag] :: AppEnv -> CheckFeatureFlag
[appEnvLicenseKeyCache] :: AppEnv -> Maybe (CredentialCache AgentLicenseKey)
[appEnvMaxTotalHeaderLength] :: AppEnv -> Int
[appEnvTriggersErrorLogLevelStatus] :: AppEnv -> TriggersErrorLogLevelStatus
[appEnvAsyncActionsFetchBatchSize] :: AppEnv -> Int
[appEnvPersistedQueries] :: AppEnv -> PersistedQueriesState
[appEnvPersistedQueriesTtl] :: AppEnv -> Int

-- | Represents the Dynamic Hasura State, these field are mutable and can
--   be changed during runtime.
data AppContext
AppContext :: AuthMode -> SQLGenCtx -> HashSet API -> AllowListStatus -> ResponseInternalErrorsConfig -> Environment -> RemoteSchemaPermissions -> InferFunctionPermissions -> HashSet ExperimentalFeature -> NamingCase -> MetadataDefaults -> LiveQueriesOptions -> StreamQueriesOptions -> CorsPolicy -> ConsoleStatus -> TelemetryStatus -> EventEngineCtx -> OptionalInterval -> ApolloFederationStatus -> CloseWebsocketsOnMetadataChangeStatus -> SchemaSampledFeatureFlags -> TraceQueryStatus -> AppContext
[acAuthMode] :: AppContext -> AuthMode
[acSQLGenCtx] :: AppContext -> SQLGenCtx
[acEnabledAPIs] :: AppContext -> HashSet API
[acEnableAllowlist] :: AppContext -> AllowListStatus
[acResponseInternalErrorsConfig] :: AppContext -> ResponseInternalErrorsConfig
[acEnvironment] :: AppContext -> Environment
[acRemoteSchemaPermsCtx] :: AppContext -> RemoteSchemaPermissions
[acFunctionPermsCtx] :: AppContext -> InferFunctionPermissions
[acExperimentalFeatures] :: AppContext -> HashSet ExperimentalFeature
[acDefaultNamingConvention] :: AppContext -> NamingCase
[acMetadataDefaults] :: AppContext -> MetadataDefaults
[acLiveQueryOptions] :: AppContext -> LiveQueriesOptions
[acStreamQueryOptions] :: AppContext -> StreamQueriesOptions
[acCorsPolicy] :: AppContext -> CorsPolicy
[acConsoleStatus] :: AppContext -> ConsoleStatus
[acEnableTelemetry] :: AppContext -> TelemetryStatus
[acEventEngineCtx] :: AppContext -> EventEngineCtx
[acAsyncActionsFetchInterval] :: AppContext -> OptionalInterval
[acApolloFederationStatus] :: AppContext -> ApolloFederationStatus
[acCloseWebsocketsOnMetadataChangeStatus] :: AppContext -> CloseWebsocketsOnMetadataChangeStatus
[acSchemaSampledFeatureFlags] :: AppContext -> SchemaSampledFeatureFlags
[acTraceQueryStatus] :: AppContext -> TraceQueryStatus

-- | Collection of the LoggerCtx, the regular Logger and the PGLogger
data Loggers
Loggers :: LoggerCtx Hasura -> Logger Hasura -> PGLogger -> Loggers
[_lsLoggerCtx] :: Loggers -> LoggerCtx Hasura
[_lsLogger] :: Loggers -> Logger Hasura
[_lsPgLogger] :: Loggers -> PGLogger

-- | Provides access to the <a>AppEnv</a>.
--   
--   This class is nothing more than an equivalent of <tt>MonadReader
--   AppEnv m</tt>, but it abstracts it, so that application code can be
--   written without explicitly relying on an explicit implementation of
--   the app monad. It allows for the app env to be passed implicitly
--   instead of explictly in all of the app init code.
--   
--   This class is not meant to be used across the entirety of the
--   codebase, as using it brings in scope the types of all fields,
--   creating dependencies between unrelated parts of the codebase. It is
--   only meant to be used at the top level; more specific parts of the
--   code should only rely on the relevant subset of the environment,
--   exposed by small, local typeclasses. For instance, at time of writing,
--   this can be used to implement <tt>HasServerConfigCtx</tt>, as a first
--   step towards breaking it down.
class Monad m => HasAppEnv (m :: Type -> Type)
askAppEnv :: HasAppEnv m => m AppEnv

-- | Function to build the <a>AppContext</a> (given the
--   <a>ServeOptions</a>) for the first time
buildRebuildableAppContext :: (Logger Hasura, Manager) -> ServeOptions impl -> CheckFeatureFlag -> Environment -> ExceptT QErr IO (RebuildableAppContext impl)

-- | Function to rebuild the <a>AppContext</a> from a given
--   <a>RebuildableAppContext</a> and a new <a>ServeOptions</a>
rebuildRebuildableAppContext :: (MonadIO m, MonadError QErr m) => (Logger Hasura, Manager) -> RebuildableAppContext impl -> ServeOptions impl -> CheckFeatureFlag -> Environment -> m (RebuildableAppContext impl)
initSQLGenCtx :: HashSet ExperimentalFeature -> StringifyNumbers -> DangerouslyCollapseBooleans -> BackwardsCompatibleNullInNonNullableVariables -> RemoteNullForwardingPolicy -> SQLGenCtx
buildCacheStaticConfig :: AppEnv -> CacheStaticConfig
buildCacheDynamicConfig :: AppContext -> CacheDynamicConfig
instance Hasura.App.State.HasAppEnv m => Hasura.App.State.HasAppEnv (Control.Monad.Trans.Except.ExceptT e m)
instance Hasura.App.State.HasAppEnv m => Hasura.App.State.HasAppEnv (Control.Monad.Trans.Reader.ReaderT r m)

module Hasura.Server.AppStateRef

-- | A mutable reference to a <a>AppState</a>, plus
--   
--   <ul>
--   <li>a write lock,</li>
--   <li>update version tracking, and</li>
--   <li>a gauge metric that tracks the metadata version of the
--   <a>SchemaCache</a>.</li>
--   </ul>
data AppStateRef impl

-- | Build a new <a>AppStateRef</a>.
--   
--   This function also updates the <a>TLSAllowListRef</a> to make it point
--   to the newly minted <tt>SchemaCacheRef</tt>.
initialiseAppStateRef :: MonadIO m => TLSAllowListRef -> Maybe MetricsConfigRef -> ServerMetrics -> RebuildableSchemaCache -> RebuildableAppContext impl -> m (AppStateRef impl)
withSchemaCacheUpdate :: (MonadIO m, MonadBaseControl IO m, MonadError QErr m) => AppStateRef impl -> Logger Hasura -> Maybe (TVar Bool) -> m (a, RebuildableSchemaCache) -> m a

-- | Set the <a>RebuildableAppContext</a> to the <a>AppStateRef</a>
--   produced by the given action.
--   
--   An internal lock ensures that at most one update to the
--   <a>AppStateRef</a> may proceed at a time.
withAppContextUpdate :: (MonadIO m, MonadBaseControl IO m) => AppStateRef impl -> m (a, RebuildableAppContext impl) -> m a

-- | Set the <a>AppStateRef</a>, atomically, to the
--   (<a>RebuildableSchemaCache</a>, <a>RebuildableAppContext</a>) produced
--   by the given action.
--   
--   An internal lock ensures that at most one update to the
--   <a>AppStateRef</a> may proceed at a time.
updateAppStateRef :: (MonadIO m, MonadBaseControl IO m) => AppStateRef impl -> Logger Hasura -> (RebuildableAppContext impl -> m (RebuildableAppContext impl, RebuildableSchemaCache)) -> m ()

-- | Reference to a TLS AllowList, used for dynamic TLS settings in the
--   app's HTTP Manager.
--   
--   This exists to break a chicken-and-egg problem in the initialisation
--   of the engine: the IO action that dynamically reads the TLS settings
--   reads it from the schema cache; but to build the schema cache we need
--   a HTTP manager that has access to the TLS settings... In the past, we
--   were using a temporary HTTP Manager to create the first schema cache,
--   to then create the *real* Manager that would refer to the list in the
--   schema cache. Now, instead, we only create one Manager, which uses a
--   <a>TLSAllowListRef</a> to dynamically access the Allow List.
data TLSAllowListRef

-- | Creates a new <a>TLSAllowListRef</a> that points to the given list.
createTLSAllowListRef :: [TlsAllow] -> IO TLSAllowListRef

-- | Reads the TLS AllowList by attempting to read from the schema cache,
--   and defaulting to the list given when the ref was created.
readTLSAllowList :: TLSAllowListRef -> IO [TlsAllow]

-- | Reference to the metadata's <a>MetricsConfig</a>.
--   
--   Similarly to the <a>TLSAllowListRef</a>, this exists to break a
--   chicken-and-egg problem in the initialisation of the engine: the
--   implementation of several behaviour classes requires access to said
--   config, but those classes are implemented on the app monad, that
--   doesn't have access to the schema cache. This small type allows the
--   app monad to have access to the config, even before we build the first
--   schema cache.
data MetricsConfigRef

-- | Creates a new <a>MetricsConfigRef</a> that points to the given config.
createMetricsConfigRef :: MetricsConfig -> IO MetricsConfigRef

-- | Reads the TLS AllowList by attempting to read from the schema cache,
--   and defaulting to the list given when the ref was created.
readMetricsConfig :: MetricsConfigRef -> IO MetricsConfig

-- | Read the latest <a>SchemaCache</a> from the <a>AppStateRef</a>.
getSchemaCache :: AppStateRef impl -> IO SchemaCache

-- | Read the latest <a>SchemaCache</a> and its version from the
--   <a>AppStateRef</a>.
getSchemaCacheWithVersion :: AppStateRef impl -> IO SchemaCache

-- | Read the contents of the <a>AppStateRef</a> to get the latest
--   <a>RebuildableSchemaCache</a> and <tt>SchemaCacheVer</tt>
getRebuildableSchemaCacheWithVersion :: AppStateRef impl -> IO RebuildableSchemaCache

-- | Read the contents of the <a>AppStateRef</a> to get the latest
--   <a>RebuildableAppContext</a>
readAppContextRef :: AppStateRef impl -> IO (RebuildableAppContext impl)

-- | Read the latest <a>AppContext</a> from the <a>AppStateRef</a>.
getAppContext :: AppStateRef impl -> IO AppContext

-- | Formats and logs a list of inconsistent metadata objects.
logInconsistentMetadata :: Logger Hasura -> [InconsistentMetadata] -> IO ()

-- | Set the <a>AppStateRef</a> to the <a>RebuildableSchemaCache</a>
--   produced by the given action.
--   
--   An internal lock ensures that at most one update to the
--   <a>AppStateRef</a> may proceed at a time.
withSchemaCacheReadUpdate :: (MonadIO m, MonadBaseControl IO m, MonadError QErr m) => AppStateRef impl -> Logger Hasura -> Maybe (TVar Bool) -> (RebuildableSchemaCache -> m (a, RebuildableSchemaCache)) -> m a


-- | Send anonymized metrics to the telemetry server regarding usage of
--   various features of Hasura.
--   
--   The general workflow for telemetry is as follows:
--   
--   <ol>
--   <li>We generate metrics for each backend in the graphql-engine code
--   and send it to <a>telemetryUrl</a>. The relevant types can be found in
--   <a>Hasura.Server.Telemetry.Types</a>.</li>
--   <li>The <a>telemetryUrl</a> endpoint is handled by code in:
--   <a>https://github.com/hasura/hasura-analytics/tree/hge-upgrade</a>,
--   specifically <a>manager/main.go</a> and <a>manager/analytics.go</a>.
--   This server endpoint receives the telemetry payload and sends it to
--   another graphql-engine which runs locally and is backed by a postgres
--   database. The database schema for the telemetry endpoint can also be
--   found in the same repo under <a>hge/migrations/</a>.</li>
--   <li>The information from the postgres db can be viewed in Metabase:
--   <a>https://metabase.telemetry.hasura.io/browse/2/schema/public</a>.</li>
--   </ol>
--   
--   For more information about telemetry in general, visit the user-facing
--   docs on the topic:
--   <a>https://hasura.io/docs/latest/graphql/core/guides/telemetry</a>.
module Hasura.Server.Telemetry

-- | An infinite loop that sends updated telemetry data (<a>Metrics</a>)
--   every 24 hours. The send time depends on when the server was started
--   and will naturally drift.
runTelemetry :: (MonadIO m, HasAppEnv m) => Logger Hasura -> AppStateRef impl -> MetadataDbId -> PGVersion -> ComputeResourcesResponse -> m Void
mkTelemetryLog :: Text -> Text -> Maybe TelemetryHttpError -> TelemetryLog
instance GHC.Internal.Generics.Generic Hasura.Server.Telemetry.ServerTelemetry
instance GHC.Internal.Generics.Generic Hasura.Server.Telemetry.ServerTelemetryRow
instance GHC.Internal.Show.Show Hasura.Server.Telemetry.TelemetryHttpError
instance GHC.Internal.Show.Show Hasura.Server.Telemetry.TelemetryLog
instance Hasura.Logging.ToEngineLog Hasura.Server.Telemetry.TelemetryLog Hasura.Logging.Hasura
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.ServerTelemetry
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.ServerTelemetryRow
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.TelemetryHttpError
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.TelemetryLog

module Hasura.Server.SchemaUpdate

-- | An async thread which listen to Postgres notify to enable schema
--   syncing See Note [Schema Cache Sync]
startSchemaSyncListenerThread :: forall (m :: Type -> Type). ForkableMonadIO m => Logger Hasura -> PGPool -> InstanceId -> Refined NonNegative Milliseconds -> TMVar MetadataResourceVersion -> ManagedT m Thread

-- | An async thread which processes the schema sync events See Note
--   [Schema Cache Sync]
startSchemaSyncProcessorThread :: forall (m :: Type -> Type) impl. (MonadTraceContext m, ForkableMonadIO m, HasAppEnv m, HasCacheStaticConfig m, MonadMetadataStorage m, MonadResolveSource m, ProvidesNetwork m) => AppStateRef impl -> TVar Bool -> ManagedT m Thread
data SchemaSyncThreadType
TTListener :: SchemaSyncThreadType
TTProcessor :: SchemaSyncThreadType
TTMetadataApi :: SchemaSyncThreadType
instance GHC.Classes.Eq Hasura.Server.SchemaUpdate.ErrorState
instance GHC.Internal.Generics.Generic Hasura.Server.SchemaUpdate.ThreadError
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.SchemaUpdate.ThreadError


-- | The RQL query ('<i>v2</i>query')
module Hasura.Server.API.V2Query
data RQLQuery
queryModifiesSchema :: RQLQuery -> Bool
runQuery :: (MonadIO m, MonadBaseControl IO m, MonadError QErr m, HasAppEnv m, HasCacheStaticConfig m, MonadTrace m, MonadMetadataStorage m, MonadResolveSource m, MonadQueryTags m, ProvidesHasuraServices m, UserInfoM m) => AppContext -> RebuildableSchemaCache -> RQLQuery -> m (EncJSON, RebuildableSchemaCache)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.API.V2Query.RQLQuery
instance GHC.Internal.Generics.Generic Hasura.Server.API.V2Query.RQLQuery


-- | The RQL query ('<i>v1</i>query')
module Hasura.Server.API.Query
data RQLQuery

-- | A predicate that determines whether the given query might
--   modify/rebuild the schema cache. If so, it needs to acquire the global
--   lock on the schema cache so that other queries do not modify it
--   concurrently.
--   
--   Ideally, we would enforce this using the type system — queries for
--   which this function returns <a>False</a> should not be allowed to
--   modify the schema cache. But for now we just ensure consistency by
--   hand.
queryModifiesSchemaCache :: RQLQuery -> Bool
requiresAdmin :: RQLQuery -> Bool
runQuery :: (MonadIO m, MonadError QErr m, HasAppEnv m, HasCacheStaticConfig m, MonadTrace m, MonadBaseControl IO m, MonadMetadataStorage m, MonadResolveSource m, MonadQueryTags m, MonadEventLogCleanup m, ProvidesHasuraServices m, MonadGetPolicies m, UserInfoM m) => AppContext -> RebuildableSchemaCache -> RQLQuery -> m (EncJSON, RebuildableSchemaCache)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.API.Query.RQLQuery
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.API.Query.RQLQueryV1
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.API.Query.RQLQueryV2
instance GHC.Internal.Generics.Generic Hasura.Server.API.Query.RQLQueryV1
instance GHC.Internal.Generics.Generic Hasura.Server.API.Query.RQLQueryV2

module Hasura.GraphQL.Execute.Action
fetchActionLogResponses :: (MonadError QErr m, MonadMetadataStorage m, Foldable t) => t ActionId -> m (ActionLogResponseMap, Bool)
runActionExecution :: (MonadIO m, MonadBaseControl IO m, MonadError QErr m, MonadTrace m, MonadMetadataStorage m) => UserInfo -> ActionExecutionPlan -> m (DiffTime, (EncJSON, Maybe ResponseHeaders))

-- | Process async actions from hdb_catalog.hdb_action_log table. This
--   functions is executed in a background thread. See Note [Async action
--   architecture] above
asyncActionsProcessor :: (HasAppEnv m, MonadIO m, MonadBaseControl IO m, Forall (Pure m), MonadMetadataStorage m, MonadTrace m) => IO Environment -> Logger Hasura -> IO SchemaCache -> IO OptionalInterval -> TVar (Set LockedActionEventId) -> Maybe GQLQueryText -> Int -> m (Forever m)

-- | Synchronously execute webhook handler and resolve response to action
--   "output"
resolveActionExecution :: Manager -> Environment -> Logger Hasura -> HttpPropagator -> PrometheusMetrics -> AnnActionExecution Void -> ActionExecContext -> Maybe GQLQueryText -> ActionExecution

-- | Resolve asynchronous action mutation which returns only the action
--   uuid
resolveActionMutationAsync :: (MonadMetadataStorage m, MonadError QErr m) => AnnActionMutationAsync -> [Header] -> SessionVariables -> m ActionId

-- | See Note: [Resolving async action query]
resolveAsyncActionQuery :: UserInfo -> AnnActionAsyncQuery ('Postgres 'Vanilla) Void -> AsyncActionQueryExecution (UnpreparedValue ('Postgres 'Vanilla))
insertActionTx :: ActionName -> SessionVariables -> [Header] -> Value -> TxE QErr ActionId
fetchUndeliveredActionEventsTx :: Int -> TxE QErr [ActionLogItem]
setActionStatusTx :: ActionId -> AsyncActionStatus -> TxE QErr ()
fetchActionResponseTx :: ActionId -> TxE QErr ActionLogResponse
clearActionDataTx :: ActionName -> TxE QErr ()
setProcessingActionLogsToPendingTx :: LockedActionIdArray -> TxE QErr ()
newtype LockedActionIdArray
LockedActionIdArray :: [LockedActionEventId] -> LockedActionIdArray
[unCohortIdArray] :: LockedActionIdArray -> [LockedActionEventId]

module Hasura.GraphQL.Execute.Query

-- | Construct an <a>ExecutionPlan</a> from a <a>SelectionSet</a>.
convertQuerySelSet :: (MonadError QErr m, MonadTrace m, MonadIO m, MonadGQLExecutionCheck m, MonadQueryTags m, ProvidesNetwork m, MonadGetPolicies m) => Environment -> Logger Hasura -> HttpPropagator -> PrometheusMetrics -> GQLContext -> SQLGenCtx -> UserInfo -> RequestHeaders -> [Directive Name] -> SelectionSet NoFragments Name -> [VariableDefinition] -> GQLReqUnparsed -> SetGraphqlIntrospectionOptions -> RequestId -> Maybe Name -> TraceQueryStatus -> m (ExecutionPlan, [QueryRootField UnpreparedValue], DirectiveMap, ParameterizedQueryHash, [ModelInfoPart])
parseGraphQLQuery :: MonadError QErr m => BackwardsCompatibleNullInNonNullableVariables -> GQLContext -> [VariableDefinition] -> Maybe (HashMap Name Value) -> [Directive Name] -> SelectionSet NoFragments Name -> m (RootFieldMap (QueryRootField UnpreparedValue), [Directive Variable], SelectionSet NoFragments Variable)

module Hasura.GraphQL.Execute.Mutation
convertMutationSelectionSet :: (MonadTrace m, MonadIO m, MonadError QErr m, MonadMetadataStorage m, MonadGQLExecutionCheck m, MonadQueryTags m, ProvidesNetwork m) => Environment -> Logger Hasura -> HttpPropagator -> PrometheusMetrics -> GQLContext -> SQLGenCtx -> UserInfo -> RequestHeaders -> [Directive Name] -> SelectionSet NoFragments Name -> [VariableDefinition] -> GQLReqUnparsed -> SetGraphqlIntrospectionOptions -> RequestId -> Maybe Name -> TraceQueryStatus -> m (ExecutionPlan, ParameterizedQueryHash, [ModelInfoPart])


-- | Module related to async action query subscriptions
module Hasura.GraphQL.Execute.Action.Subscription

-- | A forever running thread which processes async action subscriptions.
--   See Note [Async action subscriptions]
asyncActionSubscriptionsProcessor :: (MonadIO m, MonadMetadataStorage m) => AsyncActionSubscriptionState -> m void

module Hasura.GraphQL.Execute

-- | One execution step to processing a GraphQL query (e.g. one root
--   field).
data ExecutionStep

-- | A query to execute against the database
[ExecStepDB] :: ResponseHeaders -> AnyBackend DBStepInfo -> Maybe RemoteJoins -> ExecutionStep

-- | Execute an action
[ExecStepAction] :: ActionExecutionPlan -> ActionsInfo -> Maybe RemoteJoins -> ExecutionStep

-- | A graphql query to execute against a remote schema
[ExecStepRemote] :: !RemoteSchemaInfo -> !ResultCustomizer -> !GQLReqOutgoing -> Maybe RemoteJoins -> ExecutionStep

-- | Output a plain JSON object
[ExecStepRaw] :: Value -> ExecutionStep
[ExecStepMulti] :: [ExecutionStep] -> ExecutionStep
data ResolvedExecutionPlan

-- | query execution; remote schemas and introspection possible
QueryExecutionPlan :: ExecutionPlan -> [QueryRootField UnpreparedValue] -> DirectiveMap -> ResolvedExecutionPlan

-- | mutation execution; only __typename introspection supported
MutationExecutionPlan :: ExecutionPlan -> ResolvedExecutionPlan

-- | either action query or live query execution; remote schemas and
--   introspection not supported
SubscriptionExecutionPlan :: (SubscriptionExecution, Maybe (Endo Value)) -> ResolvedExecutionPlan
data GraphQLQueryType
QueryHasura :: GraphQLQueryType
QueryRelay :: GraphQLQueryType

-- | Construct a <a>ResolvedExecutionPlan</a> from a <a>GQLReqParsed</a>
--   and a bunch of metadata.
--   
--   Labelling it as inlineable fixed a performance regression on GHC
--   8.10.7.
getResolvedExecPlan :: (MonadError QErr m, MonadMetadataStorage m, MonadIO m, MonadBaseControl IO m, MonadTrace m, MonadGQLExecutionCheck m, MonadQueryTags m, ProvidesNetwork m, MonadGetPolicies m) => Environment -> Logger Hasura -> PrometheusMetrics -> UserInfo -> SQLGenCtx -> ReadOnlyMode -> SchemaCache -> GraphQLQueryType -> [Header] -> GQLReqUnparsed -> SingleOperation -> Maybe Name -> RequestId -> TraceQueryStatus -> m (ParameterizedQueryHash, ResolvedExecutionPlan, [ModelInfoPart])

-- | Construct a single step of an execution plan.
makeGQLContext :: UserInfo -> SchemaCache -> GraphQLQueryType -> GQLContext

-- | Sends a GraphQL query to the given server.
execRemoteGQ :: (MonadIO m, MonadError QErr m, MonadTrace m, ProvidesNetwork m) => Environment -> HttpPropagator -> UserInfo -> [Header] -> ValidatedRemoteSchemaDef -> GQLReqOutgoing -> m (DiffTime, [Header], ByteString)

-- | The comprehensive subscription plan. We only support either 1. Fields
--   with only async action queries with no associated relationships or 2.
--   Source database query fields from same source and also can be mixed
--   with async action query fields whose relationships are defined to
--   tables in the source
data SubscriptionExecution
SEAsyncActionsWithNoRelationships :: !RootFieldMap (ActionId, ActionLogResponse -> Either QErr EncJSON) -> SubscriptionExecution
SEOnSourceDB :: !SourceSubscription -> SubscriptionExecution
buildSubscriptionPlan :: (MonadError QErr m, MonadQueryTags m, MonadIO m, MonadBaseControl IO m) => UserInfo -> RootFieldMap (QueryRootField UnpreparedValue) -> ParameterizedQueryHash -> [Header] -> Maybe Name -> m ((SubscriptionExecution, Maybe (Endo Value)), [ModelInfoPart])

-- | Typeclass representing safety checks (if any) that need to be
--   performed before a GraphQL query should be allowed to be executed. In
--   OSS, the safety check is to check in the query is in the allow list.
--   
--   the <a>executeIntrospection</a> function has different implementations
--   in OSS and Pro. In Pro, the GraphQL schema introspection can be
--   disabled for specified roles and in OSS there is no restrictions.
--   
--   | TODO (from master): Limitation: This parses the query, which is not
--   ideal if we already have the query cached. The parsing happens
--   unnecessary. But getting this to either return a plan or parse was
--   tricky and complicated.
class Monad m => MonadGQLExecutionCheck (m :: Type -> Type)
checkGQLExecution :: MonadGQLExecutionCheck m => UserInfo -> ([Header], IpAddress) -> AllowListStatus -> SchemaCache -> GQLReqUnparsed -> RequestId -> m (Either QErr GQLReqParsed)
executeIntrospection :: MonadGQLExecutionCheck m => UserInfo -> Value -> SetGraphqlIntrospectionOptions -> m (Either QErr ExecutionStep)
checkGQLBatchedReqs :: MonadGQLExecutionCheck m => UserInfo -> RequestId -> [GQLReq GQLQueryText] -> SchemaCache -> m (Either QErr ())
checkQueryInAllowlist :: MonadError QErr m => AllowListStatus -> AllowlistMode -> UserInfo -> GQLReqParsed -> SchemaCache -> m ()
newtype MultiplexedSubscriptionQueryPlan (b :: BackendType)
MultiplexedSubscriptionQueryPlan :: SubscriptionQueryPlan b (MultiplexedQuery b) -> MultiplexedSubscriptionQueryPlan (b :: BackendType)
newtype SubscriptionQueryPlan
SubscriptionQueryPlan :: AnyBackend MultiplexedSubscriptionQueryPlan -> SubscriptionQueryPlan
data SourceSubscription
SSLivequery :: !HashSet ActionId -> !ActionLogResponseMap -> ExceptT QErr IO ((SourceName, SubscriptionQueryPlan), [ModelInfoPart]) -> SourceSubscription
SSStreaming :: !RootFieldAlias -> !((SourceName, SubscriptionQueryPlan), [ModelInfoPart]) -> SourceSubscription

module Hasura.GraphQL.Transport.WebSocket.Types
data ErrRespType
ERTLegacy :: ErrRespType
ERTGraphqlCompliant :: ErrRespType
type WSConn = WSConn WSConnData
data WSConnData
WSConnData :: !TVar WSConnState -> !OperationMap -> !ErrRespType -> !GraphQLQueryType -> WSConnData
data WSConnState

-- | headers and IP address from the client for websockets
CSNotInitialised :: !WsHeaders -> !IpAddress -> WSConnState
CSInitError :: !Text -> WSConnState
CSInitialised :: !WsClientState -> WSConnState
data WSServerEnv impl
WSServerEnv :: !Logger Hasura -> !SubscriptionsState -> AppStateRef impl -> !Manager -> IO CorsPolicy -> ReadOnlyMode -> !WSServer -> !KeepAliveDelay -> !ServerMetrics -> !PrometheusMetrics -> !SamplingPolicy -> WSServerEnv impl
[_wseLogger] :: WSServerEnv impl -> !Logger Hasura
[_wseSubscriptionState] :: WSServerEnv impl -> !SubscriptionsState
[_wseAppStateRef] :: WSServerEnv impl -> AppStateRef impl
[_wseHManager] :: WSServerEnv impl -> !Manager
[_wseCorsPolicy] :: WSServerEnv impl -> IO CorsPolicy
[_wseReadOnlyMode] :: WSServerEnv impl -> ReadOnlyMode
[_wseServer] :: WSServerEnv impl -> !WSServer
[_wseKeepAliveDelay] :: WSServerEnv impl -> !KeepAliveDelay
[_wseServerMetrics] :: WSServerEnv impl -> !ServerMetrics
[_wsePrometheusMetrics] :: WSServerEnv impl -> !PrometheusMetrics
[_wseTraceSamplingPolicy] :: WSServerEnv impl -> !SamplingPolicy
data WsClientState
WsClientState :: !UserInfo -> !Maybe UTCTime -> ![Header] -> !IpAddress -> WsClientState

-- | the <a>UserInfo</a> required to execute the GraphQL query
[wscsUserInfo] :: WsClientState -> !UserInfo

-- | the JWT/token expiry time, if any
[wscsTokenExpTime] :: WsClientState -> !Maybe UTCTime

-- | headers from the client (in conn params) to forward to the remote
--   schema
[wscsReqHeaders] :: WsClientState -> ![Header]

-- | IP address required for <tt>MonadGQLAuthorization</tt>
[wscsIpAddress] :: WsClientState -> !IpAddress
newtype WsHeaders
WsHeaders :: [Header] -> WsHeaders
[unWsHeaders] :: WsHeaders -> [Header]
data SubscriberType
LiveQuerySubscriber :: !LiveQuerySubscriberDetails -> SubscriberType
StreamingQuerySubscriber :: !StreamingSubscriberDetails -> SubscriberType
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.Types.WsHeaders
instance GHC.Internal.Show.Show Hasura.GraphQL.Transport.WebSocket.Types.ErrRespType
instance GHC.Internal.Show.Show Hasura.GraphQL.Transport.WebSocket.Types.WSConnState
instance GHC.Internal.Show.Show Hasura.GraphQL.Transport.WebSocket.Types.WsClientState
instance GHC.Internal.Show.Show Hasura.GraphQL.Transport.WebSocket.Types.WsHeaders


-- | Execution of GraphQL queries over HTTP transport
module Hasura.GraphQL.Transport.HTTP
class Monad m => MonadExecuteQuery (m :: Type -> Type)

-- | This method does two things: it looks up a query result in the
--   server-side cache, if a cache is used, and it additionally returns
--   HTTP headers that can instruct a client how long a response can be
--   cached locally (i.e. client-side).
cacheLookup :: MonadExecuteQuery m => ExecutionPlan -> [QueryRootField UnpreparedValue] -> Maybe CachedDirective -> GQLReqParsed -> UserInfo -> [Header] -> m (Either QErr (ResponseHeaders, CacheResult))
($dmcacheLookup) :: forall (t :: (Type -> Type) -> Type -> Type) (n :: Type -> Type). (MonadExecuteQuery m, m ~ t n, MonadTrans t, MonadExecuteQuery n) => ExecutionPlan -> [QueryRootField UnpreparedValue] -> Maybe CachedDirective -> GQLReqParsed -> UserInfo -> [Header] -> m (Either QErr (ResponseHeaders, CacheResult))
data CacheResult

-- | We have a cached response for this query
ResponseCached :: EncJSON -> CacheResult

-- | We don't have a cached response. The <a>ResponseCacher</a> can be used
--   to store the response in the cache after a fresh execution.
ResponseUncached :: Maybe ResponseCacher -> CacheResult
data CachedDirective
CachedDirective :: Int -> Bool -> CachedDirective
[cdTtl] :: CachedDirective -> Int
[cdRefresh] :: CachedDirective -> Bool

-- | Encapsulates a function that stores a query response in the cache.
--   <a>cacheLookup</a> decides when such an invitation to store is
--   generated.
newtype ResponseCacher
ResponseCacher :: (forall (m :: Type -> Type). (MonadTrace m, MonadIO m) => EncJSON -> m (Either QErr CacheStoreResponse)) -> ResponseCacher
[runStoreResponse] :: ResponseCacher -> forall (m :: Type -> Type). (MonadTrace m, MonadIO m) => EncJSON -> m (Either QErr CacheStoreResponse)

-- | Run (execute) a single GraphQL query
runGQ :: (MonadIO m, MonadBaseControl IO m, MonadError QErr m, MonadGQLExecutionCheck m, MonadQueryLog m, MonadExecutionLog m, MonadTrace m, MonadExecuteQuery m, MonadMetadataStorage m, MonadQueryTags m, HasResourceLimits m, ProvidesNetwork m, MonadGetPolicies m) => Environment -> SQLGenCtx -> SchemaCache -> AllowListStatus -> ReadOnlyMode -> TraceQueryStatus -> PrometheusMetrics -> Logger Hasura -> Maybe (CredentialCache AgentLicenseKey) -> RequestId -> UserInfo -> IpAddress -> [Header] -> GraphQLQueryType -> GQLReqUnparsed -> m (GQLQueryOperationSuccessLog, HttpResponse (Maybe GQResponse, EncJSON))

-- | Run (execute) a batched GraphQL query (see <a>GQLBatchedReqs</a>).
runGQBatched :: (MonadIO m, MonadBaseControl IO m, MonadError QErr m, MonadGQLExecutionCheck m, MonadQueryLog m, MonadExecutionLog m, MonadTrace m, MonadExecuteQuery m, MonadMetadataStorage m, MonadQueryTags m, HasResourceLimits m, ProvidesNetwork m, MonadGetPolicies m) => Environment -> SQLGenCtx -> SchemaCache -> AllowListStatus -> ReadOnlyMode -> PrometheusMetrics -> Logger Hasura -> Maybe (CredentialCache AgentLicenseKey) -> RequestId -> ResponseInternalErrorsConfig -> TraceQueryStatus -> UserInfo -> IpAddress -> [Header] -> GraphQLQueryType -> GQLBatchedReqs (GQLReq GQLQueryText) -> m (HttpLogGraphQLInfo, HttpResponse EncJSON)
coalescePostgresMutations :: ExecutionPlan -> Maybe (SourceConfig ('Postgres 'Vanilla), ResolvedConnectionTemplate ('Postgres 'Vanilla), InsOrdHashMap RootFieldAlias (DBStepInfo ('Postgres 'Vanilla)))
extractFieldFromResponse :: forall (m :: Type -> Type). Monad m => RootFieldAlias -> ResultCustomizer -> ByteString -> ExceptT (Either GQExecError QErr) m Value
buildRaw :: Applicative m => Value -> m AnnotatedResponsePart
encodeAnnotatedResponseParts :: RootFieldMap AnnotatedResponsePart -> EncJSON
encodeEncJSONResults :: RootFieldMap EncJSON -> EncJSON

-- | <a>https://graphql.org/learn/serving-over-http/#post-request</a>
--   
--   See <a>GQLReqParsed</a> for invariants.
data GQLReq a
GQLReq :: !Maybe OperationName -> !a -> !Maybe VariableValues -> GQLReq a
[_grOperationName] :: GQLReq a -> !Maybe OperationName
[_grQuery] :: GQLReq a -> !a
[_grVariables] :: GQLReq a -> !Maybe VariableValues

-- | We've not yet parsed the graphql query string parameter of the POST.
type GQLReqUnparsed = GQLReq GQLQueryText

-- | Invariants:
--   
--   <ul>
--   <li>when <a>_grOperationName</a> is <tt>Nothing</tt>, <a>_grQuery</a>
--   contains exactly one <tt>ExecutableDefinitionOperation</tt> (and zero
--   or more <tt>ExecutableDefinitionFragment</tt>)</li>
--   <li>when <a>_grOperationName</a> is present, there is a corresponding
--   <tt>ExecutableDefinitionOperation</tt> in <a>_grQuery</a></li>
--   </ul>
type GQLReqParsed = GQLReq GQLExecDoc
newtype GQLExecDoc
GQLExecDoc :: [ExecutableDefinition Name] -> GQLExecDoc
[unGQLExecDoc] :: GQLExecDoc -> [ExecutableDefinition Name]
newtype OperationName
OperationName :: Name -> OperationName
[_unOperationName] :: OperationName -> Name
newtype GQLQueryText
GQLQueryText :: Text -> GQLQueryText
[_unGQLQueryText] :: GQLQueryText -> Text

-- | A partial response, e.g. from a remote schema call or postgres
--   postgres query, which we'll assemble into the final response for the
--   client. It is annotated with timing metadata.
data AnnotatedResponsePart
AnnotatedResponsePart :: DiffTime -> Locality -> EncJSON -> ResponseHeaders -> AnnotatedResponsePart
[arpTimeIO] :: AnnotatedResponsePart -> DiffTime
[arpLocality] :: AnnotatedResponsePart -> Locality
[arpResponse] :: AnnotatedResponsePart -> EncJSON
[arpHeaders] :: AnnotatedResponsePart -> ResponseHeaders
data CacheStoreResponse

-- | Cache storage is unconditional, just not always available.
CacheStoreSuccess :: CacheStoreResponse
CacheStoreLimitReached :: CacheStoreResponse
CacheStoreNotEnoughCapacity :: CacheStoreResponse
CacheStoreBackendError :: String -> CacheStoreResponse

-- | A predicate on session variables. The <a>Monoid</a> instance makes it
--   simple to combine several predicates disjunctively. | The definition
--   includes <a>Maybe</a> which allows us to short-circuit calls like
--   <tt>mempty &lt;&gt; m</tt> and <tt>m &lt;&gt; mempty</tt>, which
--   otherwise might build up long repeated chains of calls to <tt>_ _
--   -&gt; False</tt>.
data SessVarPred

-- | Filter out only those session variables used by the query AST provided
filterVariablesFromQuery :: [RootField (QueryDBRoot (RemoteRelationshipField UnpreparedValue) UnpreparedValue) (RemoteSchemaRootField (RemoteRelationshipField UnpreparedValue) RemoteSchemaVariable) (ActionQuery (RemoteRelationshipField UnpreparedValue)) d] -> SessVarPred
filterSessionVariableByName :: (SessionVariable -> Bool) -> SessVarPred
runSessVarPred :: SessVarPred -> SessionVariables -> SessionVariables
instance Hasura.GraphQL.Transport.HTTP.MonadExecuteQuery m => Hasura.GraphQL.Transport.HTTP.MonadExecuteQuery (Control.Monad.Trans.Except.ExceptT e m)
instance Hasura.GraphQL.Transport.HTTP.MonadExecuteQuery m => Hasura.GraphQL.Transport.HTTP.MonadExecuteQuery (Control.Monad.Trans.Reader.ReaderT r m)
instance GHC.Internal.Base.Monoid Hasura.GraphQL.Transport.HTTP.SessVarPred
instance GHC.Internal.Base.Semigroup Hasura.GraphQL.Transport.HTTP.SessVarPred

module Hasura.Server.Rest

-- | Implements all the custom endpoints by looking up the path/methods in
--   the endpoint trie and delegating to the graphql handler.
runCustomEndpoint :: (MonadIO m, MonadError QErr m, MonadTrace m, MonadBaseControl IO m, MonadGQLExecutionCheck m, MonadQueryLog m, MonadExecutionLog m, MonadExecuteQuery m, MonadMetadataStorage m, MonadQueryTags m, HasResourceLimits m, ProvidesNetwork m, MonadGetPolicies m) => Environment -> SQLGenCtx -> SchemaCache -> AllowListStatus -> ReadOnlyMode -> TraceQueryStatus -> PrometheusMetrics -> Logger Hasura -> Maybe (CredentialCache AgentLicenseKey) -> RequestId -> UserInfo -> [Header] -> IpAddress -> RestRequest EndpointMethod -> EndpointTrie GQLQueryWithText -> m (HttpLogGraphQLInfo, HttpResponse EncJSON)
data RestRequest method
RestRequest :: Text -> method -> [(Text, Either Text Value)] -> RestRequest method

-- | Remainder of the url path after `api/rest`
[reqPath] :: RestRequest method -> Text
[reqMethod] :: RestRequest method -> method

-- | URL Query/Request Body Arguments
[reqArgs] :: RestRequest method -> [(Text, Either Text Value)]
instance GHC.Internal.Data.Foldable.Foldable Hasura.Server.Rest.RestRequest
instance GHC.Internal.Base.Functor Hasura.Server.Rest.RestRequest
instance GHC.Internal.Data.Traversable.Traversable Hasura.Server.Rest.RestRequest


-- | This file contains the handlers that are used within websocket server.
--   
--   This module export three main handlers for the websocket server
--   (<a>onConn</a>, <a>onMessage</a>, <a>onClose</a>), and two helpers for
--   sending messages to the client (<a>sendMsg</a>,
--   <a>sendCloseWithMsg</a>).
--   
--   NOTE! The handler functions <a>onClose</a>, <a>onMessage</a>, etc.
--   depend for correctness on two properties: - they run with async
--   exceptions masked - they do not race on the same connection
module Hasura.GraphQL.Transport.WebSocket
onConn :: (MonadFail m, MonadIO m, MonadReader (WSServerEnv impl) m) => OnConnH m WSConnData
onMessage :: (MonadIO m, UserAuthentication m, MonadGQLExecutionCheck m, MonadQueryLog m, MonadExecutionLog m, MonadExecuteQuery m, MonadBaseControl IO m, MonadMetadataStorage m, MonadQueryTags m, HasResourceLimits m, ProvidesNetwork m, MonadTrace m, MonadGetPolicies m) => HashSet (EngineLogType Hasura) -> IO AuthMode -> WSServerEnv impl -> WSConn -> ByteString -> WSActions WSConnData -> Maybe (CredentialCache AgentLicenseKey) -> TraceQueryStatus -> m ()
onClose :: MonadIO m => Logger Hasura -> ServerMetrics -> PrometheusMetrics -> SubscriptionsState -> WSConn -> IO GranularPrometheusMetricsState -> m ()
sendMsg :: MonadIO m => WSConn -> ServerMsg -> m ()
sendCloseWithMsg :: MonadIO m => Logger Hasura -> WSConn -> ServerErrorCode -> Maybe ServerMsg -> Maybe Word16 -> m ()

-- | By default, we close all the websocket connections when the metadata
--   changes. This function is used to create the action that will be run
--   when the metadata changes.
mkCloseWebsocketsOnMetadataChangeAction :: WSServer WSConnData -> WebsocketCloseOnMetadataChangeAction
runWebsocketCloseOnMetadataChangeAction :: WebsocketCloseOnMetadataChangeAction -> IO ()
data WebsocketCloseOnMetadataChangeAction
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.OpDetail
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.OperationDetails
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.WSEvent
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.WSLogInfo
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.WsConnInfo
instance Hasura.Logging.ToEngineLog Hasura.GraphQL.Transport.WebSocket.WSLog Hasura.Logging.Hasura
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.OpDetail
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.OperationDetails
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.WSEvent
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.WSLogInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.WsConnInfo


-- | The RQL metadata query ('<i>v1</i>metadata')
module Hasura.Server.API.Metadata

-- | The payload for the <tt><i>v1</i>metadata</tt> endpoint. See:
--   
--   
--   <a>https://hasura.io/docs/latest/graphql/core/api-reference/metadata-api/index/</a>
data RQLMetadata
data RQLMetadataV1
RMAddSource :: !AnyBackend AddSource -> RQLMetadataV1
RMDropSource :: DropSource -> RQLMetadataV1
RMRenameSource :: !RenameSource -> RQLMetadataV1
RMUpdateSource :: !AnyBackend UpdateSource -> RQLMetadataV1
RMListSourceKinds :: !ListSourceKinds -> RQLMetadataV1
RMGetSourceKindCapabilities :: !GetSourceKindCapabilities -> RQLMetadataV1
RMGetSourceTables :: !AnyBackend GetSourceTables -> RQLMetadataV1
RMGetSourceTrackables :: !AnyBackend GetSourceTrackables -> RQLMetadataV1
RMGetTableInfo :: !AnyBackend GetTableInfo -> RQLMetadataV1
RMGetTableInfo_ :: !GetTableInfo_ -> RQLMetadataV1
RMTrackTable :: !AnyBackend TrackTableV2 -> RQLMetadataV1
RMTrackTables :: !AnyBackend TrackTables -> RQLMetadataV1
RMUntrackTable :: !AnyBackend UntrackTable -> RQLMetadataV1
RMUntrackTables :: !AnyBackend UntrackTables -> RQLMetadataV1
RMSetTableCustomization :: !AnyBackend SetTableCustomization -> RQLMetadataV1
RMSetApolloFederationConfig :: AnyBackend SetApolloFederationConfig -> RQLMetadataV1
RMPgSetTableIsEnum :: !AnyBackend SetTableIsEnum -> RQLMetadataV1
RMCreateInsertPermission :: !AnyBackend (CreatePerm InsPerm) -> RQLMetadataV1
RMCreateSelectPermission :: !AnyBackend (CreatePerm SelPerm) -> RQLMetadataV1
RMCreateUpdatePermission :: !AnyBackend (CreatePerm UpdPerm) -> RQLMetadataV1
RMCreateDeletePermission :: !AnyBackend (CreatePerm DelPerm) -> RQLMetadataV1
RMDropInsertPermission :: !AnyBackend DropPerm -> RQLMetadataV1
RMDropSelectPermission :: !AnyBackend DropPerm -> RQLMetadataV1
RMDropUpdatePermission :: !AnyBackend DropPerm -> RQLMetadataV1
RMDropDeletePermission :: !AnyBackend DropPerm -> RQLMetadataV1
RMSetPermissionComment :: !AnyBackend SetPermComment -> RQLMetadataV1
RMCreateObjectRelationship :: !AnyBackend CreateObjRel -> RQLMetadataV1
RMCreateArrayRelationship :: !AnyBackend CreateArrRel -> RQLMetadataV1
RMDropRelationship :: !AnyBackend DropRel -> RQLMetadataV1
RMSetRelationshipComment :: !AnyBackend SetRelComment -> RQLMetadataV1
RMRenameRelationship :: !AnyBackend RenameRel -> RQLMetadataV1
RMSuggestRelationships :: !AnyBackend SuggestRels -> RQLMetadataV1
RMCreateRemoteRelationship :: !AnyBackend CreateFromSourceRelationship -> RQLMetadataV1
RMUpdateRemoteRelationship :: !AnyBackend CreateFromSourceRelationship -> RQLMetadataV1
RMDeleteRemoteRelationship :: !AnyBackend DeleteFromSourceRelationship -> RQLMetadataV1
RMTrackFunction :: !AnyBackend TrackFunctionV2 -> RQLMetadataV1
RMUntrackFunction :: !AnyBackend UnTrackFunction -> RQLMetadataV1
RMSetFunctionCustomization :: AnyBackend SetFunctionCustomization -> RQLMetadataV1
RMCreateFunctionPermission :: !AnyBackend FunctionPermissionArgument -> RQLMetadataV1
RMDropFunctionPermission :: !AnyBackend FunctionPermissionArgument -> RQLMetadataV1
RMAddComputedField :: !AnyBackend AddComputedField -> RQLMetadataV1
RMDropComputedField :: !AnyBackend DropComputedField -> RQLMetadataV1
RMTestConnectionTemplate :: !AnyBackend TestConnectionTemplate -> RQLMetadataV1
RMGetNativeQuery :: !AnyBackend GetNativeQuery -> RQLMetadataV1
RMTrackNativeQuery :: !AnyBackend TrackNativeQuery -> RQLMetadataV1
RMUntrackNativeQuery :: !AnyBackend UntrackNativeQuery -> RQLMetadataV1
RMGetStoredProcedure :: !AnyBackend GetStoredProcedure -> RQLMetadataV1
RMTrackStoredProcedure :: !AnyBackend TrackStoredProcedure -> RQLMetadataV1
RMUntrackStoredProcedure :: !AnyBackend UntrackStoredProcedure -> RQLMetadataV1
RMGetLogicalModel :: !AnyBackend GetLogicalModel -> RQLMetadataV1
RMTrackLogicalModel :: !AnyBackend TrackLogicalModel -> RQLMetadataV1
RMUntrackLogicalModel :: !AnyBackend UntrackLogicalModel -> RQLMetadataV1
RMCreateSelectLogicalModelPermission :: !AnyBackend (CreateLogicalModelPermission SelPerm) -> RQLMetadataV1
RMDropSelectLogicalModelPermission :: !AnyBackend DropLogicalModelPermission -> RQLMetadataV1
RMCreateEventTrigger :: !AnyBackend (Unvalidated1 CreateEventTriggerQuery) -> RQLMetadataV1
RMDeleteEventTrigger :: !AnyBackend DeleteEventTriggerQuery -> RQLMetadataV1
RMRedeliverEvent :: !AnyBackend RedeliverEventQuery -> RQLMetadataV1
RMInvokeEventTrigger :: !AnyBackend InvokeEventTriggerQuery -> RQLMetadataV1
RMCleanupEventTriggerLog :: !TriggerLogCleanupConfig -> RQLMetadataV1
RMResumeEventTriggerCleanup :: !TriggerLogCleanupToggleConfig -> RQLMetadataV1
RMPauseEventTriggerCleanup :: !TriggerLogCleanupToggleConfig -> RQLMetadataV1
RMGetEventLogs :: !AnyBackend GetEventLogs -> RQLMetadataV1
RMGetEventInvocationLogs :: !AnyBackend GetEventInvocations -> RQLMetadataV1
RMGetEventById :: !AnyBackend GetEventById -> RQLMetadataV1
RMAddRemoteSchema :: !AddRemoteSchemaQuery -> RQLMetadataV1
RMUpdateRemoteSchema :: !AddRemoteSchemaQuery -> RQLMetadataV1
RMRemoveRemoteSchema :: !RemoteSchemaNameQuery -> RQLMetadataV1
RMReloadRemoteSchema :: !RemoteSchemaNameQuery -> RQLMetadataV1
RMIntrospectRemoteSchema :: !RemoteSchemaNameQuery -> RQLMetadataV1
RMAddRemoteSchemaPermissions :: !AddRemoteSchemaPermission -> RQLMetadataV1
RMDropRemoteSchemaPermissions :: !DropRemoteSchemaPermissions -> RQLMetadataV1
RMCreateRemoteSchemaRemoteRelationship :: CreateRemoteSchemaRemoteRelationship -> RQLMetadataV1
RMUpdateRemoteSchemaRemoteRelationship :: CreateRemoteSchemaRemoteRelationship -> RQLMetadataV1
RMDeleteRemoteSchemaRemoteRelationship :: DeleteRemoteSchemaRemoteRelationship -> RQLMetadataV1
RMCreateCronTrigger :: !Unvalidated CreateCronTrigger -> RQLMetadataV1
RMDeleteCronTrigger :: !ScheduledTriggerName -> RQLMetadataV1
RMCreateScheduledEvent :: !CreateScheduledEvent -> RQLMetadataV1
RMDeleteScheduledEvent :: !DeleteScheduledEvent -> RQLMetadataV1
RMGetScheduledEvents :: !GetScheduledEvents -> RQLMetadataV1
RMGetScheduledEventInvocations :: !GetScheduledEventInvocations -> RQLMetadataV1
RMGetCronTriggers :: RQLMetadataV1
RMCreateAction :: !Unvalidated CreateAction -> RQLMetadataV1
RMDropAction :: !DropAction -> RQLMetadataV1
RMUpdateAction :: !Unvalidated UpdateAction -> RQLMetadataV1
RMCreateActionPermission :: !CreateActionPermission -> RQLMetadataV1
RMDropActionPermission :: !DropActionPermission -> RQLMetadataV1
RMCreateQueryCollection :: !CreateCollection -> RQLMetadataV1
RMRenameQueryCollection :: !RenameCollection -> RQLMetadataV1
RMDropQueryCollection :: !DropCollection -> RQLMetadataV1
RMAddQueryToCollection :: !AddQueryToCollection -> RQLMetadataV1
RMDropQueryFromCollection :: !DropQueryFromCollection -> RQLMetadataV1
RMAddCollectionToAllowlist :: !AllowlistEntry -> RQLMetadataV1
RMDropCollectionFromAllowlist :: !DropCollectionFromAllowlist -> RQLMetadataV1
RMUpdateScopeOfCollectionInAllowlist :: !UpdateScopeOfCollectionInAllowlist -> RQLMetadataV1
RMCreateRestEndpoint :: !CreateEndpoint -> RQLMetadataV1
RMDropRestEndpoint :: !DropEndpoint -> RQLMetadataV1
RMDCAddAgent :: !DCAddAgent -> RQLMetadataV1
RMDCDeleteAgent :: !DCDeleteAgent -> RQLMetadataV1
RMSetCustomTypes :: !CustomTypes -> RQLMetadataV1
RMSetApiLimits :: !ApiLimit -> RQLMetadataV1
RMRemoveApiLimits :: RQLMetadataV1
RMSetMetricsConfig :: !MetricsConfig -> RQLMetadataV1
RMRemoveMetricsConfig :: RQLMetadataV1
RMAddInheritedRole :: !InheritedRole -> RQLMetadataV1
RMDropInheritedRole :: !DropInheritedRole -> RQLMetadataV1
RMReplaceMetadata :: !ReplaceMetadata -> RQLMetadataV1
RMExportMetadata :: !ExportMetadata -> RQLMetadataV1
RMClearMetadata :: !ClearMetadata -> RQLMetadataV1
RMReloadMetadata :: !ReloadMetadata -> RQLMetadataV1
RMGetInconsistentMetadata :: !GetInconsistentMetadata -> RQLMetadataV1
RMDropInconsistentMetadata :: !DropInconsistentMetadata -> RQLMetadataV1
RMSetGraphqlSchemaIntrospectionOptions :: !SetGraphqlIntrospectionOptions -> RQLMetadataV1
RMAddHostToTLSAllowlist :: !AddHostToTLSAllowlist -> RQLMetadataV1
RMDropHostFromTLSAllowlist :: !DropHostFromTLSAllowlist -> RQLMetadataV1
RMSetQueryTagsConfig :: !SetQueryTagsConfig -> RQLMetadataV1
RMSetOpenTelemetryConfig :: !OpenTelemetryConfig -> RQLMetadataV1
RMSetOpenTelemetryStatus :: !OtelStatus -> RQLMetadataV1
RMDumpInternalState :: !DumpInternalState -> RQLMetadataV1
RMGetCatalogState :: !GetCatalogState -> RQLMetadataV1
RMSetCatalogState :: !SetCatalogState -> RQLMetadataV1
RMTestWebhookTransform :: !Unvalidated TestWebhookTransform -> RQLMetadataV1
RMBulk :: [RQLMetadataRequest] -> RQLMetadataV1
RMBulkKeepGoing :: [RQLMetadataRequest] -> RQLMetadataV1

-- | Bulk metadata queries, running a single schema cache resolve at the
--   end. Only works for a subset of commands.
RMBulkAtomic :: [RQLMetadataRequest] -> RQLMetadataV1
runMetadataQuery :: (MonadIO m, MonadError QErr m, MonadBaseControl IO m, HasAppEnv m, HasCacheStaticConfig m, MonadTrace m, MonadMetadataStorage m, MonadResolveSource m, MonadEventLogCleanup m, ProvidesHasuraServices m, MonadGetPolicies m, UserInfoM m) => AppContext -> RebuildableSchemaCache -> WebsocketCloseOnMetadataChangeAction -> RQLMetadata -> m (EncJSON, RebuildableSchemaCache)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.API.Metadata.RQLMetadata

module Hasura.GraphQL.Transport.WSServerApp
createWSServerApp :: (MonadIO m, MonadFail m, MonadBaseControl IO m, Forall (Pure m), UserAuthentication m, MonadGQLExecutionCheck m, MonadWSLog m, MonadQueryLog m, MonadExecutionLog m, MonadExecuteQuery m, MonadMetadataStorage m, MonadQueryTags m, HasResourceLimits m, ProvidesNetwork m, MonadTrace m, MonadGetPolicies m) => HashSet (EngineLogType Hasura) -> WSServerEnv impl -> WSConnectionInitTimeout -> Maybe (CredentialCache AgentLicenseKey) -> HasuraServerApp m
stopWSServerApp :: WSServerEnv impl -> IO ()
createWSServerEnv :: (HasAppEnv m, MonadIO m) => AppStateRef impl -> m (WSServerEnv impl)

module Hasura.GraphQL.Explain
explainGQLQuery :: (MonadError QErr m, MonadIO m, MonadBaseControl IO m, MonadMetadataStorage m, MonadQueryTags m, MonadTrace m) => BackwardsCompatibleNullInNonNullableVariables -> SchemaCache -> Maybe (CredentialCache AgentLicenseKey) -> [Header] -> GQLExplain -> m EncJSON
data GQLExplain
instance GHC.Classes.Eq Hasura.GraphQL.Explain.GQLExplain
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Explain.GQLExplain
instance GHC.Internal.Generics.Generic Hasura.GraphQL.Explain.GQLExplain
instance GHC.Internal.Show.Show Hasura.GraphQL.Explain.GQLExplain
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Explain.GQLExplain

module Hasura.Server.App
data APIResp
JSONResp :: !HttpResponse EncJSON -> APIResp
RawResp :: !HttpResponse ByteString -> APIResp
data CEConsoleType
OSSConsole :: CEConsoleType
ProLiteConsole :: CEConsoleType
class Monad m => ConsoleRenderer (m :: Type -> Type) where {
    type ConsoleType (m :: Type -> Type);
}
renderConsole :: ConsoleRenderer m => Text -> AuthMode -> TelemetryStatus -> Maybe Text -> Maybe Text -> ConsoleType m -> m (Either String Text)
class Monad m => MonadVersionAPIWithExtraData (m :: Type -> Type)
getExtraDataForVersionAPI :: MonadVersionAPIWithExtraData m => m [Pair]
data Handler (m :: Type -> Type) a
data HandlerCtx
data HasuraApp
HasuraApp :: !Application -> !AsyncActionSubscriptionState -> !IO () -> HasuraApp

-- | The config API (<i>v1alpha1</i>config) handler
class Monad m => MonadConfigApiHandler (m :: Type -> Type)
runConfigApiHandler :: MonadConfigApiHandler m => AppStateRef impl -> SpockCtxT () m ()
class Monad m => MonadGQLApiHandler (m :: Type -> Type)
runPersistedQueriesGetHandler :: MonadGQLApiHandler m => PersistedQueriesState -> Int -> [(Text, Text)] -> Handler m (HttpLogGraphQLInfo, APIResp)
runPersistedQueriesPostHandler :: MonadGQLApiHandler m => PersistedQueriesState -> Int -> ExtQueryReqs -> Handler m (HttpLogGraphQLInfo, HttpResponse EncJSON)

-- | Typeclass representing the metadata API authorization effect
class Monad m => MonadMetadataApiAuthorization (m :: Type -> Type)
authorizeV1QueryApi :: MonadMetadataApiAuthorization m => RQLQuery -> HandlerCtx -> m (Either QErr ())
authorizeV1MetadataApi :: MonadMetadataApiAuthorization m => RQLMetadata -> HandlerCtx -> m (Either QErr ())
authorizeV2QueryApi :: MonadMetadataApiAuthorization m => RQLQuery -> HandlerCtx -> m (Either QErr ())

-- | Represents the Dynamic Hasura State, these field are mutable and can
--   be changed during runtime.
data AppContext
AppContext :: AuthMode -> SQLGenCtx -> HashSet API -> AllowListStatus -> ResponseInternalErrorsConfig -> Environment -> RemoteSchemaPermissions -> InferFunctionPermissions -> HashSet ExperimentalFeature -> NamingCase -> MetadataDefaults -> LiveQueriesOptions -> StreamQueriesOptions -> CorsPolicy -> ConsoleStatus -> TelemetryStatus -> EventEngineCtx -> OptionalInterval -> ApolloFederationStatus -> CloseWebsocketsOnMetadataChangeStatus -> SchemaSampledFeatureFlags -> TraceQueryStatus -> AppContext
[acAuthMode] :: AppContext -> AuthMode
[acSQLGenCtx] :: AppContext -> SQLGenCtx
[acEnabledAPIs] :: AppContext -> HashSet API
[acEnableAllowlist] :: AppContext -> AllowListStatus
[acResponseInternalErrorsConfig] :: AppContext -> ResponseInternalErrorsConfig
[acEnvironment] :: AppContext -> Environment
[acRemoteSchemaPermsCtx] :: AppContext -> RemoteSchemaPermissions
[acFunctionPermsCtx] :: AppContext -> InferFunctionPermissions
[acExperimentalFeatures] :: AppContext -> HashSet ExperimentalFeature
[acDefaultNamingConvention] :: AppContext -> NamingCase
[acMetadataDefaults] :: AppContext -> MetadataDefaults
[acLiveQueryOptions] :: AppContext -> LiveQueriesOptions
[acStreamQueryOptions] :: AppContext -> StreamQueriesOptions
[acCorsPolicy] :: AppContext -> CorsPolicy
[acConsoleStatus] :: AppContext -> ConsoleStatus
[acEnableTelemetry] :: AppContext -> TelemetryStatus
[acEventEngineCtx] :: AppContext -> EventEngineCtx
[acAsyncActionsFetchInterval] :: AppContext -> OptionalInterval
[acApolloFederationStatus] :: AppContext -> ApolloFederationStatus
[acCloseWebsocketsOnMetadataChangeStatus] :: AppContext -> CloseWebsocketsOnMetadataChangeStatus
[acSchemaSampledFeatureFlags] :: AppContext -> SchemaSampledFeatureFlags
[acTraceQueryStatus] :: AppContext -> TraceQueryStatus
boolToText :: Bool -> Text
ceConsoleTypeIdentifier :: CEConsoleType -> String

-- | Default implementation of the <a>MonadConfigApiHandler</a>
configApiGetHandler :: forall (m :: Type -> Type) impl. (MonadIO m, MonadBaseControl IO m, HasAppEnv m, UserAuthentication m, HttpLog m, HasResourceLimits m, MonadTrace m) => AppStateRef impl -> SpockCtxT () m ()
isAdminSecretSet :: AuthMode -> Text
mkGetHandler :: forall (m :: Type -> Type). Handler m (HttpLogGraphQLInfo, APIResp) -> APIHandler m ()
mkSpockAction :: forall (m :: Type -> Type) a impl. (MonadIO m, MonadBaseControl IO m, HasAppEnv m, FromJSON a, UserAuthentication m, HttpLog m, HasResourceLimits m, MonadTrace m) => AppStateRef impl -> (Bool -> QErr -> Encoding) -> (QErr -> QErr) -> APIHandler m a -> ActionT m ()
mkWaiApp :: (MonadIO m, MonadFail m, MonadFix m, MonadStateless IO m, Forall (Pure m), ConsoleRenderer m, MonadVersionAPIWithExtraData m, HttpLog m, HasAppEnv m, HasCacheStaticConfig m, UserAuthentication m, MonadMetadataApiAuthorization m, MonadGQLExecutionCheck m, MonadConfigApiHandler m, MonadQueryLog m, MonadExecutionLog m, MonadWSLog m, MonadTrace m, MonadExecuteQuery m, HasResourceLimits m, MonadMetadataStorage m, MonadResolveSource m, MonadQueryTags m, MonadEventLogCleanup m, ProvidesNetwork m, MonadGetPolicies m, MonadGQLApiHandler m) => (AppStateRef impl -> SpockT m ()) -> AppStateRef impl -> ConsoleType m -> Store EmptyMetrics -> WSServerEnv impl -> m HasuraApp
onlyAdmin :: (MonadError QErr m, MonadReader HandlerCtx m) => m ()
renderHtmlTemplate :: Template -> Value -> Either String Text
onlyWhenApiEnabled :: forall (m :: Type -> Type) impl ctx b. MonadIO m => (AppContext -> Bool) -> AppStateRef impl -> ActionCtxT ctx m b -> ActionCtxT ctx m b
v1GQHandler :: (MonadIO m, MonadBaseControl IO m, MonadGQLExecutionCheck m, MonadQueryLog m, MonadExecutionLog m, MonadTrace m, HasAppEnv m, MonadExecuteQuery m, MonadError QErr m, MonadReader HandlerCtx m, MonadMetadataStorage m, MonadQueryTags m, HasResourceLimits m, ProvidesNetwork m, MonadGetPolicies m) => GQLBatchedReqs (GQLReq GQLQueryText) -> m (HttpLogGraphQLInfo, HttpResponse EncJSON)
instance GHC.Internal.Base.Monad m => GHC.Internal.Base.Applicative (Hasura.Server.App.Handler m)
instance Hasura.Server.App.ConsoleRenderer m => Hasura.Server.App.ConsoleRenderer (Hasura.Tracing.Monad.TraceT m)
instance GHC.Internal.Base.Functor m => GHC.Internal.Base.Functor (Hasura.Server.App.Handler m)
instance Hasura.App.State.HasAppEnv m => Hasura.App.State.HasAppEnv (Hasura.Server.App.Handler m)
instance Hasura.RQL.DDL.Schema.Cache.Config.HasCacheStaticConfig m => Hasura.RQL.DDL.Schema.Cache.Config.HasCacheStaticConfig (Hasura.Server.App.Handler m)
instance Hasura.Server.Init.FeatureFlag.HasFeatureFlagChecker m => Hasura.Server.Init.FeatureFlag.HasFeatureFlagChecker (Hasura.Server.App.Handler m)
instance Hasura.Server.Limits.HasResourceLimits m => Hasura.Server.Limits.HasResourceLimits (Hasura.Server.App.Handler m)
instance Control.Monad.Trans.Control.MonadBaseControl b m => Control.Monad.Trans.Control.MonadBaseControl b (Hasura.Server.App.Handler m)
instance Control.Monad.Base.MonadBase b m => Control.Monad.Base.MonadBase b (Hasura.Server.App.Handler m)
instance GHC.Internal.Base.Monad m => Control.Monad.Error.Class.MonadError Hasura.Base.Error.QErr (Hasura.Server.App.Handler m)
instance Hasura.RQL.DDL.EventTrigger.MonadEventLogCleanup m => Hasura.RQL.DDL.EventTrigger.MonadEventLogCleanup (Hasura.Server.App.Handler m)
instance Hasura.GraphQL.Transport.HTTP.MonadExecuteQuery m => Hasura.GraphQL.Transport.HTTP.MonadExecuteQuery (Hasura.Server.App.Handler m)
instance Hasura.GraphQL.Logging.ExecutionLog.MonadExecutionLog m => Hasura.GraphQL.Logging.ExecutionLog.MonadExecutionLog (Hasura.Server.App.Handler m)
instance GHC.Internal.Control.Monad.Fix.MonadFix m => GHC.Internal.Control.Monad.Fix.MonadFix (Hasura.Server.App.Handler m)
instance Hasura.GraphQL.Execute.Common.MonadGQLExecutionCheck m => Hasura.GraphQL.Execute.Common.MonadGQLExecutionCheck (Hasura.Server.App.Handler m)
instance Hasura.Server.Types.MonadGetPolicies m => Hasura.Server.Types.MonadGetPolicies (Hasura.Server.App.Handler m)
instance GHC.Internal.Base.Monad m => GHC.Internal.Base.Monad (Hasura.Server.App.Handler m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Hasura.Server.App.Handler m)
instance Hasura.Server.App.MonadMetadataApiAuthorization m => Hasura.Server.App.MonadMetadataApiAuthorization (Control.Monad.Trans.Except.ExceptT e m)
instance Hasura.Server.App.MonadMetadataApiAuthorization m => Hasura.Server.App.MonadMetadataApiAuthorization (Hasura.Server.App.Handler m)
instance Hasura.Server.App.MonadMetadataApiAuthorization m => Hasura.Server.App.MonadMetadataApiAuthorization (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.Server.App.MonadMetadataApiAuthorization m => Hasura.Server.App.MonadMetadataApiAuthorization (Hasura.Tracing.Monad.TraceT m)
instance Hasura.Metadata.Class.MonadMetadataStorage m => Hasura.Metadata.Class.MonadMetadataStorage (Hasura.Server.App.Handler m)
instance Hasura.GraphQL.Logging.QueryLog.MonadQueryLog m => Hasura.GraphQL.Logging.QueryLog.MonadQueryLog (Hasura.Server.App.Handler m)
instance Hasura.QueryTags.MonadQueryTags m => Hasura.QueryTags.MonadQueryTags (Hasura.Server.App.Handler m)
instance GHC.Internal.Base.Monad m => Control.Monad.Reader.Class.MonadReader Hasura.Server.App.HandlerCtx (Hasura.Server.App.Handler m)
instance Hasura.RQL.Types.Source.MonadResolveSource m => Hasura.RQL.Types.Source.MonadResolveSource (Hasura.Server.App.Handler m)
instance Hasura.Tracing.Class.MonadTraceContext m => Hasura.Tracing.Class.MonadTraceContext (Hasura.Server.App.Handler m)
instance Hasura.Tracing.Class.MonadTrace m => Hasura.Tracing.Class.MonadTrace (Hasura.Server.App.Handler m)
instance Control.Monad.Trans.Class.MonadTrans Hasura.Server.App.Handler
instance Hasura.Services.Network.ProvidesNetwork m => Hasura.Services.Network.ProvidesNetwork (Hasura.Server.App.Handler m)
instance GHC.Internal.Base.Monad m => Hasura.Authentication.User.UserInfoM (Hasura.Server.App.Handler m)


-- | Defines the CE version of the engine.
--   
--   This module contains everything that is required to run the community
--   edition of the engine: the base application monad and the
--   implementation of all its behaviour classes.
module Hasura.App
data ExitCode
InvalidEnvironmentVariableOptionsError :: ExitCode
InvalidDatabaseConnectionParamsError :: ExitCode
AuthConfigurationError :: ExitCode
DatabaseMigrationError :: ExitCode

-- | used by MT because it initialises the schema cache only these are used
--   in app/Main.hs:
SchemaCacheInitError :: ExitCode
MetadataExportError :: ExitCode
MetadataCleanError :: ExitCode
DowngradeProcessError :: ExitCode
data ExitException
ExitException :: !ExitCode -> !ByteString -> ExitException
[eeCode] :: ExitException -> !ExitCode
[eeMessage] :: ExitException -> !ByteString
throwErrExit :: MonadIO m => forall a. () => ExitCode -> String -> m a
throwErrJExit :: (ToJSON a, MonadIO m) => forall b. () => ExitCode -> a -> m b
accessDeniedErrMsg :: Text
printJSON :: (ToJSON a, MonadIO m) => a -> m ()

-- | Create all loggers based on the set of enabled logs and chosen log
--   level.
mkLoggers :: forall (m :: Type -> Type). (MonadIO m, MonadBaseControl IO m) => HashSet (EngineLogType Hasura) -> LogLevel -> ManagedT m Loggers
mkPGLogger :: Logger Hasura -> PGLogger

-- | Basic information required to connect to the metadata DB, and to the
--   default Postgres DB if any.
data BasicConnectionInfo
BasicConnectionInfo :: ConnInfo -> Maybe PostgresConnConfiguration -> BasicConnectionInfo

-- | metadata db connection info
[bciMetadataConnInfo] :: BasicConnectionInfo -> ConnInfo

-- | default postgres connection info, if any
[bciDefaultPostgres] :: BasicConnectionInfo -> Maybe PostgresConnConfiguration

-- | Only create the metadata connection info.
--   
--   Like <a>initBasicConnectionInfo</a>, it prioritizes
--   <tt>--metadata-database-url</tt>, and falls back to
--   <tt>--database-url</tt> otherwise.
--   
--   !!! This function throws a fatal error if the <tt>--database-url</tt>
--   cannot be !!! resolved.
initMetadataConnectionInfo :: MonadIO m => Environment -> Maybe String -> PostgresConnInfo (Maybe UrlConf) -> m ConnInfo

-- | Create a <a>BasicConnectionInfo</a> based on the given options.
--   
--   The default postgres connection is only created when the
--   <tt>--database-url</tt> option is given. If the
--   <tt>--metadata-database-url</tt> isn't given, the
--   <tt>--database-url</tt> will be used for the metadata connection.
--   
--   All arguments related to the default postgres connection are ignored
--   if the <tt>--database-url</tt> is missing.
--   
--   !!! This function throws a fatal error if the <tt>--database-url</tt>
--   cannot be !!! resolved.
initBasicConnectionInfo :: MonadIO m => Environment -> Maybe String -> PostgresConnInfo (Maybe UrlConf) -> Maybe PostgresPoolSettings -> Bool -> TxIsolation -> m BasicConnectionInfo

-- | Creates a <a>ConnInfo</a> from a <a>UrlConf</a> parameter.
--   
--   !!! throws a fatal error if the configuration is invalid
resolvePostgresConnInfo :: MonadIO m => Environment -> UrlConf -> Maybe Int -> m ConnInfo

-- | Initializes or migrates the catalog and creates the <a>AppEnv</a>
--   required to start the server, and also create the <a>AppInit</a> that
--   needs to be threaded along the init code.
--   
--   For historical reasons, this function performs a few additional
--   startup tasks that are not required to create the <a>AppEnv</a>, such
--   as starting background processes and logging startup information. All
--   of those are flagged with a comment marking them as a side-effect.
--   
--   NOTE: this is invoked in pro, but only for OSS mode (no license key)
initialiseAppEnv :: forall (m :: Type -> Type). ForkableMonadIO m => Environment -> BasicConnectionInfo -> ServeOptions Hasura -> Maybe SubscriptionPostPollHook -> ServerMetrics -> PrometheusMetrics -> SamplingPolicy -> ManagedT m (AppInit, AppEnv)

-- | Initializes the <a>AppContext</a> and returns a corresponding
--   <a>AppStateRef</a>.
--   
--   This function is meant to be run in the app monad, which provides the
--   <a>AppEnv</a>.
initialiseAppContext :: (ForkableMonadIO m, HasAppEnv m) => Environment -> ServeOptions Hasura -> AppInit -> m (AppStateRef Hasura)

-- | Runs catalogue migration, and returns the metadata that was fetched.
--   
--   On success, this function logs the result of the migration, on failure
--   it logs a <tt>catalog_migrate</tt> error and throws a fatal error.
migrateCatalogAndFetchMetadata :: (MonadIO m, MonadBaseControl IO m) => Logger Hasura -> PGPool -> Maybe (SourceConnConfiguration ('Postgres 'Vanilla)) -> MaintenanceMode () -> ExtensionsSchema -> m MetadataWithResourceVersion

-- | Build the original <a>RebuildableSchemaCache</a>.
--   
--   On error, it logs a <tt>catalog_migrate</tt> error and throws a fatal
--   error. This misnomer is intentional: it is to preserve a previous
--   behaviour of the code and avoid a breaking change.
buildFirstSchemaCache :: MonadIO m => Environment -> Logger Hasura -> SourceResolver ('Postgres 'Vanilla) -> SourceResolver 'MSSQL -> MetadataWithResourceVersion -> CacheStaticConfig -> CacheDynamicConfig -> Manager -> Maybe SchemaRegistryContext -> m RebuildableSchemaCache
initSubscriptionsState :: Logger Hasura -> Maybe SubscriptionPostPollHook -> IO SubscriptionsState
initLockedEventsCtx :: IO LockedEventsCtx

-- | The base app monad of the CE engine.
data AppM a
runAppM :: AppEnv -> AppM a -> IO a
getCatalogStateTx :: TxE QErr CatalogState

-- | Core logic to fork a poller thread to update the JWK based on the
--   expiry time specified in <tt>Expires</tt> header or
--   <tt>Cache-Control</tt> header
updateJwkCtxThread :: ForkableMonadIO m => IO AppContext -> Manager -> Logger Hasura -> m Void
notifySchemaCacheSyncTx :: MetadataResourceVersion -> InstanceId -> CacheInvalidations -> TxE QErr ()

-- | Parse cli arguments to graphql-engine executable.
parseArgs :: EnabledLogTypes impl => Environment -> IO (HGEOptions (ServeOptions impl))

-- | This function acts as the entrypoint for the graphql-engine webserver.
--   
--   Note: at the exit of this function, or in case of a graceful server
--   shutdown (SIGTERM, or more generally, whenever the shutdown latch is
--   set), we need to make absolutely sure that we clean up any resources
--   which were allocated during server setup. In the case of a multitenant
--   process, failure to do so can lead to resource leaks.
--   
--   To track these resources, we use the ManagedT monad, and attach
--   finalizers at the same point in the code where we allocate resources.
--   If you fork a new long-lived thread, or create a connection pool, or
--   allocate any other long-lived resource, make sure to pair the
--   allocator with its finalizer. There are plenty of examples throughout
--   the code. For example, see <a>forkManagedT</a>.
--   
--   Note also: the order in which the finalizers run can be important.
--   Specifically, we want the finalizers for the logger threads to run
--   last, so that we retain as many "thread stopping" log messages as
--   possible. The order in which the finalizers is run is determined by
--   the order in which they are introduced in the code.
runHGEServer :: forall (m :: Type -> Type) impl. (MonadIO m, MonadFail m, MonadFix m, MonadMask m, MonadStateless IO m, Forall (Pure m), UserAuthentication m, HttpLog m, HasAppEnv m, HasCacheStaticConfig m, ConsoleRenderer m, MonadVersionAPIWithExtraData m, MonadMetadataApiAuthorization m, MonadGQLExecutionCheck m, MonadConfigApiHandler m, MonadQueryLog m, MonadExecutionLog m, MonadWSLog m, MonadExecuteQuery m, HasResourceLimits m, MonadMetadataStorage m, MonadResolveSource m, MonadQueryTags m, MonadEventLogCleanup m, ProvidesHasuraServices m, MonadTrace m, MonadGetPolicies m, MonadGQLApiHandler m) => (AppStateRef impl -> SpockT m ()) -> AppStateRef impl -> UTCTime -> Maybe (IO ()) -> ConsoleType m -> Store EmptyMetrics -> ManagedT m ()
setCatalogStateTx :: CatalogStateType -> Value -> TxE QErr ()

-- | Part of a factorization of <a>runHGEServer</a> to expose the
--   constructed WAI application for testing purposes. See
--   <a>runHGEServer</a> for documentation.
mkHGEServer :: forall (m :: Type -> Type) impl. (MonadIO m, MonadFail m, MonadFix m, MonadMask m, MonadStateless IO m, Forall (Pure m), UserAuthentication m, HttpLog m, HasAppEnv m, HasCacheStaticConfig m, ConsoleRenderer m, MonadVersionAPIWithExtraData m, MonadMetadataApiAuthorization m, MonadGQLExecutionCheck m, MonadConfigApiHandler m, MonadQueryLog m, MonadExecutionLog m, MonadWSLog m, MonadExecuteQuery m, HasResourceLimits m, MonadMetadataStorage m, MonadResolveSource m, MonadQueryTags m, MonadEventLogCleanup m, ProvidesHasuraServices m, MonadTrace m, MonadGetPolicies m, MonadGQLApiHandler m) => (AppStateRef impl -> SpockT m ()) -> AppStateRef impl -> ConsoleType m -> Store EmptyMetrics -> ManagedT m Application
mkPgSourceResolver :: PGLogger -> SourceResolver ('Postgres 'Vanilla)
mkMSSQLSourceResolver :: SourceResolver 'MSSQL
instance GHC.Internal.Base.Applicative Hasura.App.AppM
instance Hasura.Server.App.ConsoleRenderer Hasura.App.AppM
instance GHC.Internal.Exception.Type.Exception Hasura.App.ExitException
instance GHC.Internal.Base.Functor Hasura.App.AppM
instance Hasura.App.State.HasAppEnv Hasura.App.AppM
instance Hasura.RQL.DDL.Schema.Cache.Config.HasCacheStaticConfig Hasura.App.AppM
instance Hasura.Server.Init.FeatureFlag.HasFeatureFlagChecker Hasura.App.AppM
instance Hasura.Server.Limits.HasResourceLimits Hasura.App.AppM
instance Hasura.Server.Logging.HttpLog Hasura.App.AppM
instance GHC.Internal.Base.Monad Hasura.App.AppM
instance Control.Monad.Trans.Control.MonadBaseControl GHC.Types.IO Hasura.App.AppM
instance Control.Monad.Base.MonadBase GHC.Types.IO Hasura.App.AppM
instance Control.Monad.Catch.MonadCatch Hasura.App.AppM
instance Hasura.Server.App.MonadConfigApiHandler Hasura.App.AppM
instance Hasura.Metadata.Class.MonadEECredentialsStorage Hasura.App.AppM
instance Hasura.RQL.DDL.EventTrigger.MonadEventLogCleanup Hasura.App.AppM
instance Hasura.GraphQL.Transport.HTTP.MonadExecuteQuery Hasura.App.AppM
instance Hasura.GraphQL.Logging.ExecutionLog.MonadExecutionLog Hasura.App.AppM
instance GHC.Internal.Control.Monad.Fail.MonadFail Hasura.App.AppM
instance GHC.Internal.Control.Monad.Fix.MonadFix Hasura.App.AppM
instance Hasura.Server.App.MonadGQLApiHandler Hasura.App.AppM
instance Hasura.GraphQL.Execute.Common.MonadGQLExecutionCheck Hasura.App.AppM
instance Hasura.Server.Types.MonadGetPolicies Hasura.App.AppM
instance Control.Monad.IO.Class.MonadIO Hasura.App.AppM
instance Control.Monad.Catch.MonadMask Hasura.App.AppM
instance Hasura.Server.App.MonadMetadataApiAuthorization Hasura.App.AppM
instance Hasura.Metadata.Class.MonadMetadataStorage Hasura.App.AppM
instance Hasura.GraphQL.Logging.QueryLog.MonadQueryLog Hasura.App.AppM
instance Hasura.QueryTags.MonadQueryTags Hasura.App.AppM
instance Control.Monad.Reader.Class.MonadReader Hasura.App.State.AppEnv Hasura.App.AppM
instance Hasura.RQL.Types.Source.MonadResolveSource Hasura.App.AppM
instance Control.Monad.Catch.MonadThrow Hasura.App.AppM
instance Hasura.Tracing.Class.MonadTrace Hasura.App.AppM
instance Hasura.Tracing.Class.MonadTraceContext Hasura.App.AppM
instance Hasura.Server.App.MonadVersionAPIWithExtraData Hasura.App.AppM
instance Hasura.GraphQL.Transport.WebSocket.Server.MonadWSLog Hasura.App.AppM
instance Hasura.Services.Network.ProvidesNetwork Hasura.App.AppM
instance GHC.Internal.Show.Show Hasura.App.ExitCode
instance GHC.Internal.Show.Show Hasura.App.ExitException
instance Hasura.Server.Auth.UserAuthentication Hasura.App.AppM
